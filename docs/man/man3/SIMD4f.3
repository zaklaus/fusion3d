.TH "SIMD4f" 3 "Tue Nov 24 2015" "Version 0.0.0.1" "Fusion3D" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SIMD4f \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <simdemulator\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSIMD4f\fP ()"
.br
.ti -1c
.RI "\fBSIMD4f\fP (float a, float b, float c, float d)"
.br
.ti -1c
.RI "\fBSIMD4f\fP (float a)"
.br
.ti -1c
.RI "\fBSIMD4f\fP (const float *data)"
.br
.ti -1c
.RI "void \fBGet\fP (float *result) const "
.br
.ti -1c
.RI "void \fBSet\fP (const float *data)"
.br
.ti -1c
.RI "void \fBGetBytes\fP (\fBint8_t\fP *result) const "
.br
.ti -1c
.RI "void \fBSetBytes\fP (const \fBint8_t\fP *data)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBAndNot\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBMax\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBMin\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBPick\fP (const \fBSIMD4f\fP &sourceIfTrue, const \fBSIMD4f\fP &sourceIfFalse)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBConditionalAdd\fP (const \fBSIMD4f\fP &num1, const \fBSIMD4f\fP &num2)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBShuffle\fP (\fBint8_t\fP shuffleByte)"
.br
.ti -1c
.RI "float \fBHorizontalAdd\fP () const "
.br
.ti -1c
.RI "\fBSIMD4i\fP \fBRoundToInt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4i\fP \fBTruncateToInt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBRound\fP (int roundingMode=0) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFloor\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBCeil\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBTruncate\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBAbs\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBSqrt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFastRSqrt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFastReciprocal\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator+\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator+=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator\-\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator*\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator*=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator/\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator/=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator&\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator&=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator|\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator|=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator^\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator^=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator==\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator!=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator>\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator<\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator>=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator<=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator!\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP ()"
.br
.ti -1c
.RI "\fBSIMD4f\fP (float a, float b, float c, float d)"
.br
.ti -1c
.RI "\fBSIMD4f\fP (float a)"
.br
.ti -1c
.RI "\fBSIMD4f\fP (const __m128 &data)"
.br
.ti -1c
.RI "void \fBGet\fP (float *result) const "
.br
.ti -1c
.RI "void \fBSet\fP (const float *data)"
.br
.ti -1c
.RI "void \fBGetBytes\fP (\fBint8_t\fP *result) const "
.br
.ti -1c
.RI "void \fBSetBytes\fP (const \fBint8_t\fP *data)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBAndNot\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBMax\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBMin\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBPick\fP (const \fBSIMD4f\fP &sourceIfTrue, const \fBSIMD4f\fP &sourceIfFalse)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBConditionalAdd\fP (const \fBSIMD4f\fP &num1, const \fBSIMD4f\fP &num2)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBShuffle\fP (\fBint8_t\fP shuffleByte)"
.br
.ti -1c
.RI "float \fBHorizontalAdd\fP () const "
.br
.ti -1c
.RI "\fBSIMD4i\fP \fBRoundToInt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4i\fP \fBTruncateToInt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBRound\fP (int roundingMode=0) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFloor\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBCeil\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBTruncate\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBAbs\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBSqrt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFastRSqrt\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBFastReciprocal\fP () const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator+\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator+=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator\-\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator*\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator*=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator/\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator/=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator&\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator&=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator|\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator|=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator^\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "void \fBoperator^=\fP (const \fBSIMD4f\fP &other)"
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator==\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator!=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator>\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator<\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator>=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator<=\fP (const \fBSIMD4f\fP &other) const "
.br
.ti -1c
.RI "\fBSIMD4f\fP \fBoperator!\fP () const "
.br
.ti -1c
.RI "\fBoperator __m128\fP () const "
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SIMD4f::SIMD4f ()\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (float a, float b, float c, float d)\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (float a)\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (const float * data)\fC [inline]\fP"

.SS "SIMD4f::SIMD4f ()\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (float a, float b, float c, float d)\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (float a)\fC [inline]\fP"

.SS "SIMD4f::SIMD4f (const __m128 & data)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBSIMD4f\fP SIMD4f::Abs () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Abs () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::AndNot (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::AndNot (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Ceil () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Ceil () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::ConditionalAdd (const \fBSIMD4f\fP & num1, const \fBSIMD4f\fP & num2)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::ConditionalAdd (const \fBSIMD4f\fP & num1, const \fBSIMD4f\fP & num2)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::FastReciprocal () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::FastReciprocal () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::FastRSqrt () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::FastRSqrt () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Floor () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Floor () const\fC [inline]\fP"

.SS "void SIMD4f::Get (float * result) const\fC [inline]\fP"

.SS "void SIMD4f::Get (float * result) const\fC [inline]\fP"

.SS "void SIMD4f::GetBytes (\fBint8_t\fP * result) const\fC [inline]\fP"

.SS "void SIMD4f::GetBytes (\fBint8_t\fP * result) const\fC [inline]\fP"

.SS "float SIMD4f::HorizontalAdd () const\fC [inline]\fP"

.SS "float SIMD4f::HorizontalAdd () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Max (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Max (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Min (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Min (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "SIMD4f::operator __m128 () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator! () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator! () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP \fBSIMD4f::operator!\fP= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP \fBSIMD4f::operator!\fP= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator& (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator& (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator&= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator&= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator* (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator* (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator*= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator*= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator+ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator+ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator+= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator+= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator\- (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator\- (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator\-= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator\-= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator/ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator/ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator/= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator/= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator< (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator< (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator<= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator<= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator== (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator== (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator> (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator> (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator>= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator>= (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator^ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator^ (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator^= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator^= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator| (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::operator| (const \fBSIMD4f\fP & other) const\fC [inline]\fP"

.SS "void SIMD4f::operator|= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "void SIMD4f::operator|= (const \fBSIMD4f\fP & other)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Pick (const \fBSIMD4f\fP & sourceIfTrue, const \fBSIMD4f\fP & sourceIfFalse)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Pick (const \fBSIMD4f\fP & sourceIfTrue, const \fBSIMD4f\fP & sourceIfFalse)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Round (int roundingMode = \fC0\fP) const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Round (int roundingMode = \fC0\fP) const\fC [inline]\fP"

.SS "\fBSIMD4i\fP SIMD4f::RoundToInt () const\fC [inline]\fP"

.SS "\fBSIMD4i\fP SIMD4f::RoundToInt () const\fC [inline]\fP"

.SS "void SIMD4f::Set (const float * data)\fC [inline]\fP"

.SS "void SIMD4f::Set (const float * data)\fC [inline]\fP"

.SS "void SIMD4f::SetBytes (const \fBint8_t\fP * data)\fC [inline]\fP"

.SS "void SIMD4f::SetBytes (const \fBint8_t\fP * data)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Shuffle (\fBint8_t\fP shuffleByte)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Shuffle (\fBint8_t\fP shuffleByte)\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Sqrt () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Sqrt () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Truncate () const\fC [inline]\fP"

.SS "\fBSIMD4f\fP SIMD4f::Truncate () const\fC [inline]\fP"

.SS "\fBSIMD4i\fP SIMD4f::TruncateToInt () const\fC [inline]\fP"

.SS "\fBSIMD4i\fP SIMD4f::TruncateToInt () const\fC [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Fusion3D from the source code\&.
