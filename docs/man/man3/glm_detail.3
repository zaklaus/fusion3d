.TH "glm::detail" 3 "Tue Nov 24 2015" "Version 0.0.0.1" "Fusion3D" \" -*- nroff -*-
.ad l
.nh
.SH NAME
glm::detail \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBcompute_areCollinear\fP"
.br
.ti -1c
.RI "struct \fBcompute_areCollinear< T, P, tvec2 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_areCollinear< T, P, tvec3 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_areCollinear< T, P, tvec4 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilMultiple\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilMultiple< false, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilMultiple< false, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilMultiple< true, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilPowerOfTwo\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilPowerOfTwo< T, P, vecType, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilShift\fP"
.br
.ti -1c
.RI "struct \fBcompute_ceilShift< T, P, vecType, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_dot< tquat, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_floorMultiple\fP"
.br
.ti -1c
.RI "struct \fBcompute_floorMultiple< false, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_floorMultiple< false, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_floorMultiple< true, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_fmod\fP"
.br
.ti -1c
.RI "struct \fBcompute_fmod< T, P, vecType, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_isCompNull\fP"
.br
.ti -1c
.RI "struct \fBcompute_isCompNull< T, P, tvec2 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_isCompNull< T, P, tvec3 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_isCompNull< T, P, tvec4 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< double, highp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< double, lowp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< double, mediump, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< float, highp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< float, lowp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< float, mediump, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< int16, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< int32, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< int64, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< int8, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< long double, highp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< long double, lowp, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< long double, mediump, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< uint16, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< uint32, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< uint64, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_linearRand< uint8, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_log2< T, P, vecType, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint16, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint32, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint64, P, vecType >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint8, P, tvec1 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint8, P, tvec2 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint8, P, tvec3 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rand< uint8, P, tvec4 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_rgbToSrgb\fP"
.br
.ti -1c
.RI "struct \fBcompute_rgbToSrgb< T, P, tvec4 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_roundMultiple\fP"
.br
.ti -1c
.RI "struct \fBcompute_roundMultiple< false, false >\fP"
.br
.ti -1c
.RI "struct \fBcompute_roundMultiple< false, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_roundMultiple< true, true >\fP"
.br
.ti -1c
.RI "struct \fBcompute_srgbToRgb\fP"
.br
.ti -1c
.RI "struct \fBcompute_srgbToRgb< T, P, tvec4 >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tdualquat, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat2x2, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat2x3, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat2x4, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat3x2, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat3x3, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat3x4, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat4x2, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat4x3, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tmat4x4, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tquat, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec1, bool, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec1, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec2, bool, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec2, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec3, bool, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec3, T, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec4, bool, P >\fP"
.br
.ti -1c
.RI "struct \fBcompute_to_string< tvec4, T, P >\fP"
.br
.ti -1c
.RI "union \fBi10i10i10i2\fP"
.br
.ti -1c
.RI "struct \fBliteral\fP"
.br
.ti -1c
.RI "struct \fBliteral< T, true >\fP"
.br
.ti -1c
.RI "struct \fBprefix\fP"
.br
.ti -1c
.RI "struct \fBprefix< bool >\fP"
.br
.ti -1c
.RI "struct \fBprefix< double >\fP"
.br
.ti -1c
.RI "struct \fBprefix< float >\fP"
.br
.ti -1c
.RI "struct \fBprefix< int16_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< int32_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< int64_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< int8_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< uint16_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< uint32_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< uint64_t >\fP"
.br
.ti -1c
.RI "struct \fBprefix< uint8_t >\fP"
.br
.ti -1c
.RI "struct \fBshuffle_mask\fP"
.br
.ti -1c
.RI "union \fBu10u10u10u2\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename PARAM , typename RET > GLM_FUNC_DECL RET \fBbitfieldInterleave\fP (PARAM x, PARAM y)"
.br
.ti -1c
.RI "template<typename PARAM , typename RET > GLM_FUNC_DECL RET \fBbitfieldInterleave\fP (PARAM x, PARAM y, PARAM z)"
.br
.ti -1c
.RI "template<typename PARAM , typename RET > GLM_FUNC_DECL RET \fBbitfieldInterleave\fP (PARAM x, PARAM y, PARAM z, PARAM w)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint16\fP \fBbitfieldInterleave\fP (\fBglm::uint8\fP x, \fBglm::uint8\fP y)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBbitfieldInterleave\fP (\fBglm::uint16\fP x, \fBglm::uint16\fP y)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP \fBbitfieldInterleave\fP (\fBglm::uint32\fP x, \fBglm::uint32\fP y)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBbitfieldInterleave\fP (\fBglm::uint8\fP x, \fBglm::uint8\fP y, \fBglm::uint8\fP z)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP \fBbitfieldInterleave\fP (\fBglm::uint16\fP x, \fBglm::uint16\fP y, \fBglm::uint16\fP z)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP \fBbitfieldInterleave\fP (\fBglm::uint32\fP x, \fBglm::uint32\fP y, \fBglm::uint32\fP z)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBbitfieldInterleave\fP (\fBglm::uint8\fP x, \fBglm::uint8\fP y, \fBglm::uint8\fP z, \fBglm::uint8\fP w)"
.br
.ti -1c
.RI "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP \fBbitfieldInterleave\fP (\fBglm::uint16\fP x, \fBglm::uint16\fP y, \fBglm::uint16\fP z, \fBglm::uint16\fP w)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint16\fP \fBfloat2half\fP (\fBglm::uint32\fP f)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBfloat2packed11\fP (\fBglm::uint32\fP f)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBpacked11ToFloat\fP (\fBglm::uint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBfloat2packed10\fP (\fBglm::uint32\fP f)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint32\fP \fBpacked10ToFloat\fP (\fBglm::uint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint\fP \fBhalf2float\fP (\fBglm::uint\fP h)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint\fP \fBfloatTo11bit\fP (float x)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER float \fBpacked11bitToFloat\fP (\fBglm::uint\fP x)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER \fBglm::uint\fP \fBfloatTo10bit\fP (float x)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER float \fBpacked10bitToFloat\fP (\fBglm::uint\fP x)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER float \fBnextafterf\fP (float x, float y)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER double \fBnextafter\fP (double x, double y)"
.br
.ti -1c
.RI "template<typename T , precision P, template< typename, precision > class vecType> GLM_FUNC_QUALIFIER vecType< T, P > \fBtaylorCos\fP (vecType< T, P > const &x)"
.br
.ti -1c
.RI "template<typename T > GLM_FUNC_QUALIFIER T \fBcos_52s\fP (T x)"
.br
.ti -1c
.RI "template<typename T , precision P, template< typename, precision > class vecType> GLM_FUNC_QUALIFIER vecType< T, P > \fBcos_52s\fP (vecType< T, P > const &x)"
.br
.ti -1c
.RI "GLM_INLINE void \fBhash_combine\fP (size_t &seed, size_t hash)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER unsigned int \fBones32\fP (unsigned int x)"
.br
.ti -1c
.RI "template<typename T , precision P> detail::component_count_t \fBnumber_of_elements_\fP (tvec2< T, P > const &v)"
.br
.ti -1c
.RI "template<typename T , precision P> detail::component_count_t \fBnumber_of_elements_\fP (tvec3< T, P > const &v)"
.br
.ti -1c
.RI "template<typename T , precision P> detail::component_count_t \fBnumber_of_elements_\fP (tvec4< T, P > const &v)"
.br
.ti -1c
.RI "template<typename genType > detail::component_count_t \fBnumber_of_elements_\fP (genType const &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator+\fP (const fmat4x4SIMD &m, float const &s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator+\fP (float const &s, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator+\fP (const fmat4x4SIMD &m1, const fmat4x4SIMD &m2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator\-\fP (const fmat4x4SIMD &m, float const &s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator\-\fP (float const &s, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator\-\fP (const fmat4x4SIMD &m1, const fmat4x4SIMD &m2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator*\fP (const fmat4x4SIMD &m, float const &s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator*\fP (float const &s, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (const fmat4x4SIMD &m, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (fvec4SIMD const &v, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator*\fP (const fmat4x4SIMD &m1, const fmat4x4SIMD &m2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator/\fP (const fmat4x4SIMD &m, float const &s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator/\fP (float const &s, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER detail::fmat4x4SIMD \fBinverse\fP (detail::fmat4x4SIMD const &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator/\fP (const fmat4x4SIMD &m, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator/\fP (fvec4SIMD const &v, const fmat4x4SIMD &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD \fBoperator/\fP (const fmat4x4SIMD &m1, const fmat4x4SIMD &m2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD const \fBoperator\-\fP (fmat4x4SIMD const &m)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD const \fBoperator\-\-\fP (fmat4x4SIMD const &m, int)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fmat4x4SIMD const \fBoperator++\fP (fmat4x4SIMD const &m, int)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator\-\fP (fquatSIMD const &q)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator+\fP (fquatSIMD const &q1, fquatSIMD const &q2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator*\fP (fquatSIMD const &q1, fquatSIMD const &q2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (fquatSIMD const &q, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (fvec4SIMD const &v, fquatSIMD const &q)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator*\fP (fquatSIMD const &q, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator*\fP (float s, fquatSIMD const &q)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fquatSIMD \fBoperator/\fP (fquatSIMD const &q, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator+\fP (fvec4SIMD const &v, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator+\fP (float s, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator+\fP (fvec4SIMD const &v1, fvec4SIMD const &v2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator\-\fP (fvec4SIMD const &v, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator\-\fP (float s, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator\-\fP (fvec4SIMD const &v1, fvec4SIMD const &v2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (fvec4SIMD const &v, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (float s, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator*\fP (fvec4SIMD const &v1, fvec4SIMD const &v2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator/\fP (fvec4SIMD const &v, float s)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator/\fP (float s, fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator/\fP (fvec4SIMD const &v1, fvec4SIMD const &v2)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator\-\fP (fvec4SIMD const &v)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator++\fP (fvec4SIMD const &v, int)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER fvec4SIMD \fBoperator\-\-\fP (fvec4SIMD const &v, int)"
.br
.ti -1c
.RI "GLM_FUNC_QUALIFIER std::string \fBformat\fP (const char *msg,\&.\&.\&.)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename PARAM , typename RET > GLM_FUNC_DECL RET glm::detail::bitfieldInterleave (PARAM x, PARAM y)"

.SS "template<typename PARAM , typename RET > GLM_FUNC_DECL RET glm::detail::bitfieldInterleave (PARAM x, PARAM y, PARAM z)"

.SS "template<typename PARAM , typename RET > GLM_FUNC_DECL RET glm::detail::bitfieldInterleave (PARAM x, PARAM y, PARAM z, PARAM w)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint16\fP glm::detail::bitfieldInterleave (\fBglm::uint8\fP x, \fBglm::uint8\fP y)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::bitfieldInterleave (\fBglm::uint16\fP x, \fBglm::uint16\fP y)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP glm::detail::bitfieldInterleave (\fBglm::uint32\fP x, \fBglm::uint32\fP y)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::bitfieldInterleave (\fBglm::uint8\fP x, \fBglm::uint8\fP y, \fBglm::uint8\fP z)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP glm::detail::bitfieldInterleave (\fBglm::uint16\fP x, \fBglm::uint16\fP y, \fBglm::uint16\fP z)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP glm::detail::bitfieldInterleave (\fBglm::uint32\fP x, \fBglm::uint32\fP y, \fBglm::uint32\fP z)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::bitfieldInterleave (\fBglm::uint8\fP x, \fBglm::uint8\fP y, \fBglm::uint8\fP z, \fBglm::uint8\fP w)"

.SS "template<> GLM_FUNC_QUALIFIER \fBglm::uint64\fP glm::detail::bitfieldInterleave (\fBglm::uint16\fP x, \fBglm::uint16\fP y, \fBglm::uint16\fP z, \fBglm::uint16\fP w)"

.SS "template<typename T > GLM_FUNC_QUALIFIER T glm::detail::cos_52s (T x)"

.SS "template<typename T , precision P, template< typename, precision > class vecType> GLM_FUNC_QUALIFIER vecType<T, P> glm::detail::cos_52s (vecType< T, P > const & x)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint16\fP glm::detail::float2half (\fBglm::uint32\fP f)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::float2packed10 (\fBglm::uint32\fP f)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::float2packed11 (\fBglm::uint32\fP f)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint\fP glm::detail::floatTo10bit (float x)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint\fP glm::detail::floatTo11bit (float x)"

.SS "GLM_FUNC_QUALIFIER std::string glm::detail::format (const char * msg,  \&.\&.\&.)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint\fP glm::detail::half2float (\fBglm::uint\fP h)"

.SS "GLM_INLINE void glm::detail::hash_combine (size_t & seed, size_t hash)"

.SS "GLM_FUNC_QUALIFIER detail::fmat4x4SIMD glm::detail::inverse (detail::fmat4x4SIMD const & m)"

.SS "GLM_FUNC_QUALIFIER double glm::detail::nextafter (double x, double y)"

.SS "GLM_FUNC_QUALIFIER float glm::detail::nextafterf (float x, float y)"

.SS "template<typename T , precision P> detail::component_count_t glm::detail::number_of_elements_ (tvec2< T, P > const & v)"

.SS "template<typename T , precision P> detail::component_count_t glm::detail::number_of_elements_ (tvec3< T, P > const & v)"

.SS "template<typename T , precision P> detail::component_count_t glm::detail::number_of_elements_ (tvec4< T, P > const & v)"

.SS "template<typename genType > detail::component_count_t glm::detail::number_of_elements_ (genType const & m)"

.SS "GLM_FUNC_QUALIFIER unsigned int glm::detail::ones32 (unsigned int x)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator* (fquatSIMD const & q1, fquatSIMD const & q2)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (fquatSIMD const & q, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (fvec4SIMD const & v, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (fvec4SIMD const & v, fquatSIMD const & q)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator* (fquatSIMD const & q, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (float s, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator* (float s, fquatSIMD const & q)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (fvec4SIMD const & v1, fvec4SIMD const & v2)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator* (const fmat4x4SIMD & m, float const & s)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator* (float const & s, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (const fmat4x4SIMD & m, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator* (fvec4SIMD const & v, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator* (const fmat4x4SIMD & m1, const fmat4x4SIMD & m2)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator+ (fquatSIMD const & q1, fquatSIMD const & q2)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator+ (fvec4SIMD const & v, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator+ (float s, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator+ (fvec4SIMD const & v1, fvec4SIMD const & v2)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator+ (const fmat4x4SIMD & m, float const & s)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator+ (float const & s, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator+ (const fmat4x4SIMD & m1, const fmat4x4SIMD & m2)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator++ (fvec4SIMD const & v, int)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD const glm::detail::operator++ (fmat4x4SIMD const & m, int)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator\- (fquatSIMD const & q)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator\- (fvec4SIMD const & v, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator\- (float s, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator\- (fvec4SIMD const & v1, fvec4SIMD const & v2)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator\- (fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator\- (const fmat4x4SIMD & m, float const & s)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator\- (float const & s, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator\- (const fmat4x4SIMD & m1, const fmat4x4SIMD & m2)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD const glm::detail::operator\- (fmat4x4SIMD const & m)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator\-\- (fvec4SIMD const & v, int)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD const glm::detail::operator\-\- (fmat4x4SIMD const & m, int)"

.SS "GLM_FUNC_QUALIFIER fquatSIMD glm::detail::operator/ (fquatSIMD const & q, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator/ (fvec4SIMD const & v, float s)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator/ (float s, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator/ (fvec4SIMD const & v1, fvec4SIMD const & v2)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator/ (const fmat4x4SIMD & m, float const & s)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator/ (float const & s, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator/ (const fmat4x4SIMD & m, fvec4SIMD const & v)"

.SS "GLM_FUNC_QUALIFIER fvec4SIMD glm::detail::operator/ (fvec4SIMD const & v, const fmat4x4SIMD & m)"

.SS "GLM_FUNC_QUALIFIER fmat4x4SIMD glm::detail::operator/ (const fmat4x4SIMD & m1, const fmat4x4SIMD & m2)"

.SS "GLM_FUNC_QUALIFIER float glm::detail::packed10bitToFloat (\fBglm::uint\fP x)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::packed10ToFloat (\fBglm::uint32\fP p)"

.SS "GLM_FUNC_QUALIFIER float glm::detail::packed11bitToFloat (\fBglm::uint\fP x)"

.SS "GLM_FUNC_QUALIFIER \fBglm::uint32\fP glm::detail::packed11ToFloat (\fBglm::uint32\fP p)"

.SS "template<typename T , precision P, template< typename, precision > class vecType> GLM_FUNC_QUALIFIER vecType<T, P> glm::detail::taylorCos (vecType< T, P > const & x)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Fusion3D from the source code\&.
