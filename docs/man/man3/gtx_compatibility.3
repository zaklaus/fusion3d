.TH "gtx_compatibility" 3 "Tue Nov 24 2015" "Version 0.0.0.1" "Fusion3D" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gtx_compatibility \- GLM_GTX_compatibility
.PP
Provide functions to increase the compatibility with Cg and HLSL languages\&.  

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef bool \fBglm::bool1\fP"
.br
.RI "\fIboolean type with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec2< bool, highp > \fBglm::bool2\fP"
.br
.RI "\fIboolean type with 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec3< bool, highp > \fBglm::bool3\fP"
.br
.RI "\fIboolean type with 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec4< bool, highp > \fBglm::bool4\fP"
.br
.RI "\fIboolean type with 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef bool \fBglm::bool1x1\fP"
.br
.RI "\fIboolean matrix with 1 x 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x2< bool, highp > \fBglm::bool2x2\fP"
.br
.RI "\fIboolean matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x3< bool, highp > \fBglm::bool2x3\fP"
.br
.RI "\fIboolean matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x4< bool, highp > \fBglm::bool2x4\fP"
.br
.RI "\fIboolean matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x2< bool, highp > \fBglm::bool3x2\fP"
.br
.RI "\fIboolean matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x3< bool, highp > \fBglm::bool3x3\fP"
.br
.RI "\fIboolean matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x4< bool, highp > \fBglm::bool3x4\fP"
.br
.RI "\fIboolean matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x2< bool, highp > \fBglm::bool4x2\fP"
.br
.RI "\fIboolean matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x3< bool, highp > \fBglm::bool4x3\fP"
.br
.RI "\fIboolean matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x4< bool, highp > \fBglm::bool4x4\fP"
.br
.RI "\fIboolean matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef int \fBglm::int1\fP"
.br
.RI "\fIinteger vector with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec2< int, highp > \fBglm::int2\fP"
.br
.RI "\fIinteger vector with 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec3< int, highp > \fBglm::int3\fP"
.br
.RI "\fIinteger vector with 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec4< int, highp > \fBglm::int4\fP"
.br
.RI "\fIinteger vector with 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef int \fBglm::int1x1\fP"
.br
.RI "\fIinteger matrix with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x2< int, highp > \fBglm::int2x2\fP"
.br
.RI "\fIinteger matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x3< int, highp > \fBglm::int2x3\fP"
.br
.RI "\fIinteger matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x4< int, highp > \fBglm::int2x4\fP"
.br
.RI "\fIinteger matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x2< int, highp > \fBglm::int3x2\fP"
.br
.RI "\fIinteger matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x3< int, highp > \fBglm::int3x3\fP"
.br
.RI "\fIinteger matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x4< int, highp > \fBglm::int3x4\fP"
.br
.RI "\fIinteger matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x2< int, highp > \fBglm::int4x2\fP"
.br
.RI "\fIinteger matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x3< int, highp > \fBglm::int4x3\fP"
.br
.RI "\fIinteger matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x4< int, highp > \fBglm::int4x4\fP"
.br
.RI "\fIinteger matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef float \fBglm::float1\fP"
.br
.RI "\fIsingle-precision floating-point vector with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec2< float, highp > \fBglm::float2\fP"
.br
.RI "\fIsingle-precision floating-point vector with 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec3< float, highp > \fBglm::float3\fP"
.br
.RI "\fIsingle-precision floating-point vector with 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec4< float, highp > \fBglm::float4\fP"
.br
.RI "\fIsingle-precision floating-point vector with 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef float \fBglm::float1x1\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x2< float, highp > \fBglm::float2x2\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x3< float, highp > \fBglm::float2x3\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x4< float, highp > \fBglm::float2x4\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x2< float, highp > \fBglm::float3x2\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x3< float, highp > \fBglm::float3x3\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x4< float, highp > \fBglm::float3x4\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x2< float, highp > \fBglm::float4x2\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x3< float, highp > \fBglm::float4x3\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x4< float, highp > \fBglm::float4x4\fP"
.br
.RI "\fIsingle-precision floating-point matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef double \fBglm::double1\fP"
.br
.RI "\fIdouble-precision floating-point vector with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec2< double, highp > \fBglm::double2\fP"
.br
.RI "\fIdouble-precision floating-point vector with 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec3< double, highp > \fBglm::double3\fP"
.br
.RI "\fIdouble-precision floating-point vector with 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tvec4< double, highp > \fBglm::double4\fP"
.br
.RI "\fIdouble-precision floating-point vector with 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef double \fBglm::double1x1\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 1 component\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x2< double, highp > \fBglm::double2x2\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x3< double, highp > \fBglm::double2x3\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat2x4< double, highp > \fBglm::double2x4\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x2< double, highp > \fBglm::double3x2\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x3< double, highp > \fBglm::double3x3\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat3x4< double, highp > \fBglm::double3x4\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x2< double, highp > \fBglm::double4x2\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x3< double, highp > \fBglm::double4x3\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) \fP"
.ti -1c
.RI "typedef tmat4x4< double, highp > \fBglm::double4x4\fP"
.br
.RI "\fIdouble-precision floating-point matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > GLM_FUNC_QUALIFIER T \fBglm::lerp\fP (T x, T y, T a)"
.br
.RI "\fIReturns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2< T, P > \fBglm::lerp\fP (const tvec2< T, P > &x, const tvec2< T, P > &y, T a)"
.br
.RI "\fIReturns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3< T, P > \fBglm::lerp\fP (const tvec3< T, P > &x, const tvec3< T, P > &y, T a)"
.br
.RI "\fIReturns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4< T, P > \fBglm::lerp\fP (const tvec4< T, P > &x, const tvec4< T, P > &y, T a)"
.br
.RI "\fIReturns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2< T, P > \fBglm::lerp\fP (const tvec2< T, P > &x, const tvec2< T, P > &y, const tvec2< T, P > &a)"
.br
.RI "\fIReturns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3< T, P > \fBglm::lerp\fP (const tvec3< T, P > &x, const tvec3< T, P > &y, const tvec3< T, P > &a)"
.br
.RI "\fIReturns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4< T, P > \fBglm::lerp\fP (const tvec4< T, P > &x, const tvec4< T, P > &y, const tvec4< T, P > &a)"
.br
.RI "\fIReturns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER T \fBglm::saturate\fP (T x)"
.br
.RI "\fIReturns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2< T, P > \fBglm::saturate\fP (const tvec2< T, P > &x)"
.br
.RI "\fIReturns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3< T, P > \fBglm::saturate\fP (const tvec3< T, P > &x)"
.br
.RI "\fIReturns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4< T, P > \fBglm::saturate\fP (const tvec4< T, P > &x)"
.br
.RI "\fIReturns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER T \fBglm::atan2\fP (T x, T y)"
.br
.RI "\fIArc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2< T, P > \fBglm::atan2\fP (const tvec2< T, P > &x, const tvec2< T, P > &y)"
.br
.RI "\fIArc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3< T, P > \fBglm::atan2\fP (const tvec3< T, P > &x, const tvec3< T, P > &y)"
.br
.RI "\fIArc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4< T, P > \fBglm::atan2\fP (const tvec4< T, P > &x, const tvec4< T, P > &y)"
.br
.RI "\fIArc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename genType > GLM_FUNC_DECL bool \fBglm::isfinite\fP (genType const &x)"
.br
.RI "\fITest whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_DECL tvec1< bool, P > \fBglm::isfinite\fP (const tvec1< T, P > &x)"
.br
.RI "\fITest whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_DECL tvec2< bool, P > \fBglm::isfinite\fP (const tvec2< T, P > &x)"
.br
.RI "\fITest whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_DECL tvec3< bool, P > \fBglm::isfinite\fP (const tvec3< T, P > &x)"
.br
.RI "\fITest whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) \fP"
.ti -1c
.RI "template<typename T , precision P> GLM_FUNC_DECL tvec4< bool, P > \fBglm::isfinite\fP (const tvec4< T, P > &x)"
.br
.RI "\fITest whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) \fP"
.in -1c
.SH "Detailed Description"
.PP 
Provide functions to increase the compatibility with Cg and HLSL languages\&. 

<\fBglm/gtx/compatibility\&.hpp\fP> need to be included to use these functionalities\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef bool \fBglm::bool1\fP"

.PP
boolean type with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef bool \fBglm::bool1x1\fP"

.PP
boolean matrix with 1 x 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec2<bool, highp> \fBglm::bool2\fP"

.PP
boolean type with 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x2<bool, highp> \fBglm::bool2x2\fP"

.PP
boolean matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x3<bool, highp> \fBglm::bool2x3\fP"

.PP
boolean matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x4<bool, highp> \fBglm::bool2x4\fP"

.PP
boolean matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec3<bool, highp> \fBglm::bool3\fP"

.PP
boolean type with 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x2<bool, highp> \fBglm::bool3x2\fP"

.PP
boolean matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x3<bool, highp> \fBglm::bool3x3\fP"

.PP
boolean matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x4<bool, highp> \fBglm::bool3x4\fP"

.PP
boolean matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec4<bool, highp> \fBglm::bool4\fP"

.PP
boolean type with 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x2<bool, highp> \fBglm::bool4x2\fP"

.PP
boolean matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x3<bool, highp> \fBglm::bool4x3\fP"

.PP
boolean matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x4<bool, highp> \fBglm::bool4x4\fP"

.PP
boolean matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef double \fBglm::double1\fP"

.PP
double-precision floating-point vector with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef double \fBglm::double1x1\fP"

.PP
double-precision floating-point matrix with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec2<double, highp> \fBglm::double2\fP"

.PP
double-precision floating-point vector with 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x2<double, highp> \fBglm::double2x2\fP"

.PP
double-precision floating-point matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x3<double, highp> \fBglm::double2x3\fP"

.PP
double-precision floating-point matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x4<double, highp> \fBglm::double2x4\fP"

.PP
double-precision floating-point matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec3<double, highp> \fBglm::double3\fP"

.PP
double-precision floating-point vector with 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x2<double, highp> \fBglm::double3x2\fP"

.PP
double-precision floating-point matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x3<double, highp> \fBglm::double3x3\fP"

.PP
double-precision floating-point matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x4<double, highp> \fBglm::double3x4\fP"

.PP
double-precision floating-point matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec4<double, highp> \fBglm::double4\fP"

.PP
double-precision floating-point vector with 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x2<double, highp> \fBglm::double4x2\fP"

.PP
double-precision floating-point matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x3<double, highp> \fBglm::double4x3\fP"

.PP
double-precision floating-point matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x4<double, highp> \fBglm::double4x4\fP"

.PP
double-precision floating-point matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef float \fBglm::float1\fP"

.PP
single-precision floating-point vector with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef float \fBglm::float1x1\fP"

.PP
single-precision floating-point matrix with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec2<float, highp> \fBglm::float2\fP"

.PP
single-precision floating-point vector with 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x2<float, highp> \fBglm::float2x2\fP"

.PP
single-precision floating-point matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x3<float, highp> \fBglm::float2x3\fP"

.PP
single-precision floating-point matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x4<float, highp> \fBglm::float2x4\fP"

.PP
single-precision floating-point matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec3<float, highp> \fBglm::float3\fP"

.PP
single-precision floating-point vector with 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x2<float, highp> \fBglm::float3x2\fP"

.PP
single-precision floating-point matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x3<float, highp> \fBglm::float3x3\fP"

.PP
single-precision floating-point matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x4<float, highp> \fBglm::float3x4\fP"

.PP
single-precision floating-point matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec4<float, highp> \fBglm::float4\fP"

.PP
single-precision floating-point vector with 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x2<float, highp> \fBglm::float4x2\fP"

.PP
single-precision floating-point matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x3<float, highp> \fBglm::float4x3\fP"

.PP
single-precision floating-point matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x4<float, highp> \fBglm::float4x4\fP"

.PP
single-precision floating-point matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef int \fBglm::int1\fP"

.PP
integer vector with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef int \fBglm::int1x1\fP"

.PP
integer matrix with 1 component\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec2<int, highp> \fBglm::int2\fP"

.PP
integer vector with 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x2<int, highp> \fBglm::int2x2\fP"

.PP
integer matrix with 2 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x3<int, highp> \fBglm::int2x3\fP"

.PP
integer matrix with 2 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat2x4<int, highp> \fBglm::int2x4\fP"

.PP
integer matrix with 2 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec3<int, highp> \fBglm::int3\fP"

.PP
integer vector with 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x2<int, highp> \fBglm::int3x2\fP"

.PP
integer matrix with 3 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x3<int, highp> \fBglm::int3x3\fP"

.PP
integer matrix with 3 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat3x4<int, highp> \fBglm::int3x4\fP"

.PP
integer matrix with 3 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tvec4<int, highp> \fBglm::int4\fP"

.PP
integer vector with 4 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x2<int, highp> \fBglm::int4x2\fP"

.PP
integer matrix with 4 x 2 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x3<int, highp> \fBglm::int4x3\fP"

.PP
integer matrix with 4 x 3 components\&. (From GLM_GTX_compatibility extension) 
.SS "typedef tmat4x4<int, highp> \fBglm::int4x4\fP"

.PP
integer matrix with 4 x 4 components\&. (From GLM_GTX_compatibility extension) 
.SH "Function Documentation"
.PP 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER T glm::atan2 (T x, T y)"

.PP
Arc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2<T, P> glm::atan2 (const tvec2< T, P > & x, const tvec2< T, P > & y)"

.PP
Arc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3<T, P> glm::atan2 (const tvec3< T, P > & x, const tvec3< T, P > & y)"

.PP
Arc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4<T, P> glm::atan2 (const tvec4< T, P > & x, const tvec4< T, P > & y)"

.PP
Arc tangent\&. Returns an angle whose tangent is y/x\&. The signs of x and y are used to determine what quadrant the angle is in\&. The range of values returned by this function is [-PI, PI]\&. Results are undefined if x and y are both 0\&. (From GLM_GTX_compatibility) 
.SS "template<typename genType > GLM_FUNC_DECL bool glm::isfinite (genType const & x)"

.PP
Test whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_DECL tvec1<bool, P> glm::isfinite (const tvec1< T, P > & x)"

.PP
Test whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_DECL tvec2<bool, P> glm::isfinite (const tvec2< T, P > & x)"

.PP
Test whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_DECL tvec3<bool, P> glm::isfinite (const tvec3< T, P > & x)"

.PP
Test whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_DECL tvec4<bool, P> glm::isfinite (const tvec4< T, P > & x)"

.PP
Test whether or not a scalar or each vector component is a finite value\&. (From GLM_GTX_compatibility) 
.SS "template<typename T > GLM_FUNC_QUALIFIER T glm::lerp (T x, T y, T a)"

.PP
Returns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2<T, P> glm::lerp (const tvec2< T, P > & x, const tvec2< T, P > & y, T a)"

.PP
Returns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3<T, P> glm::lerp (const tvec3< T, P > & x, const tvec3< T, P > & y, T a)"

.PP
Returns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4<T, P> glm::lerp (const tvec4< T, P > & x, const tvec4< T, P > & y, T a)"

.PP
Returns x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using the floating-point value a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2<T, P> glm::lerp (const tvec2< T, P > & x, const tvec2< T, P > & y, const tvec2< T, P > & a)"

.PP
Returns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3<T, P> glm::lerp (const tvec3< T, P > & x, const tvec3< T, P > & y, const tvec3< T, P > & a)"

.PP
Returns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4<T, P> glm::lerp (const tvec4< T, P > & x, const tvec4< T, P > & y, const tvec4< T, P > & a)"

.PP
Returns the component-wise result of x * (1\&.0 - a) + y * a, i\&.e\&., the linear blend of x and y using vector a\&. The value for a is not restricted to the range [0, 1]\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER T glm::saturate (T x)"

.PP
Returns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec2<T, P> glm::saturate (const tvec2< T, P > & x)"

.PP
Returns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec3<T, P> glm::saturate (const tvec3< T, P > & x)"

.PP
Returns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) 
.SS "template<typename T , precision P> GLM_FUNC_QUALIFIER tvec4<T, P> glm::saturate (const tvec4< T, P > & x)"

.PP
Returns clamp(x, 0, 1) for each component in x\&. (From GLM_GTX_compatibility) 
.SH "Author"
.PP 
Generated automatically by Doxygen for Fusion3D from the source code\&.
