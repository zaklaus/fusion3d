{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GLM_GTC_packing\par \pard\plain 
{\tc\tcl2 \v GLM_GTC_packing}
{\xe \v GLM_GTC_packing}
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This extension provides a set of function to convert vertors to packed formats. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint8} {\b glm::packUnorm1x8} (float v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL float {\b glm::unpackUnorm1x8} ({\b uint8} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint16} {\b glm::packUnorm2x8} (vec2 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec2 {\b glm::unpackUnorm2x8} ({\b uint16} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint8} {\b glm::packSnorm1x8} (float s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL float {\b glm::unpackSnorm1x8} ({\b uint8} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint16} {\b glm::packSnorm2x8} (vec2 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec2 {\b glm::unpackSnorm2x8} ({\b uint16} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint16} {\b glm::packUnorm1x16} (float v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL float {\b glm::unpackUnorm1x16} ({\b uint16} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL uint64 {\b glm::packUnorm4x16} (vec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec4 {\b glm::unpackUnorm4x16} (uint64 p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint16} {\b glm::packSnorm1x16} (float v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL float {\b glm::unpackSnorm1x16} ({\b uint16} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL uint64 {\b glm::packSnorm4x16} (vec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec4 {\b glm::unpackSnorm4x16} (uint64 p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint16} {\b glm::packHalf1x16} (float v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL float {\b glm::unpackHalf1x16} ({\b uint16} v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL uint64 {\b glm::packHalf4x16} (vec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec4 {\b glm::unpackHalf4x16} (uint64 p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint32} {\b glm::packI3x10_1x2} (ivec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL ivec4 {\b glm::unpackI3x10_1x2} ({\b uint32} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint32} {\b glm::packU3x10_1x2} (uvec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL uvec4 {\b glm::unpackU3x10_1x2} ({\b uint32} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint32} {\b glm::packSnorm3x10_1x2} (vec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec4 {\b glm::unpackSnorm3x10_1x2} ({\b uint32} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint32} {\b glm::packUnorm3x10_1x2} (vec4 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec4 {\b glm::unpackUnorm3x10_1x2} ({\b uint32} p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL {\b uint32} {\b glm::packF2x11_1x10} (vec3 const &v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GLM_FUNC_DECL vec3 {\b glm::unpackF2x11_1x10} ({\b uint32} p)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This extension provides a set of function to convert vertors to packed formats. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<{\b glm/gtc/packing.hpp}> need to be included to use these features. \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v packF2x11_1x10\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packF2x11_1x10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint32} glm::packF2x11_1x10 (vec3 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values. Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value. Then, the results are packed into the returned 32-bit unsigned integer.\par
The first vector component specifies the 11 least-significant bits of the result; the last component specifies the 10 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec3 unpackF2x11_1x10(uint32 const & p) \par
}}}
{\xe \v packHalf1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packHalf1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint16} glm::packHalf1x16 (float  {\i v})}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an unsigned integer obtained by converting the components of a floating-point scalar to the 16-bit floating-point representation found in the OpenGL Specification, and then packing this 16-bit value into a 16-bit unsigned integer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} packHalf2x16(vec2 const & v) \par
{\b uint64} {\b packHalf4x16(vec4 const & v)} \par
{\f2 GLSL packHalf2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packHalf4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packHalf4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_DECL uint64 glm::packHalf4x16 (vec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an unsigned integer obtained by converting the components of a four-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these four 16-bit values into a 64-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the forth component specifies the 16 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} packHalf1x16(float const & v) \par
{\b uint32} packHalf2x16(vec2 const & v) \par
{\f2 GLSL packHalf2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packI3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packI3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint32} glm::packI3x10_1x2 (ivec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an unsigned integer obtained by converting the components of a four-component signed integer vector to the 10-10-10-2-bit signed integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} packI3x10_1x2(uvec4 const & v) \par
{\b uint32} {\b packSnorm3x10_1x2(vec4 const & v)} \par
{\b uint32} {\b packUnorm3x10_1x2(vec4 const & v)} \par
ivec4 unpackI3x10_1x2(uint32 const & p) \par
}}}
{\xe \v packSnorm1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packSnorm1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint16} glm::packSnorm1x16 (float  {\i v})}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the normalized floating-point value v into 16-bit integer value. Then, the results are packed into the returned 16-bit unsigned integer.\par
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 32767.0)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} packSnorm2x16(vec2 const & v) \par
{\b uint64} {\b packSnorm4x16(vec4 const & v)} \par
{\f2 GLSL packSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packSnorm1x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packSnorm1x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint8} glm::packSnorm1x8 (float  {\i s})}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the normalized floating-point value v into 8-bit integer value. Then, the results are packed into the returned 8-bit unsigned integer.\par
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 127.0)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} {\b packSnorm2x8(vec2 const & v)} \par
{\b uint32} packSnorm4x8(vec4 const & v) \par
{\f2 GLSL packSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packSnorm2x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packSnorm2x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint16} glm::packSnorm2x8 (vec2 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts each component of the normalized floating-point value v into 8-bit integer values. Then, the results are packed into the returned 16-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 127.0)\par
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint8} packSnorm1x8(float const & v) \par
{\b uint32} packSnorm4x8(vec4 const & v) \par
{\f2 GLSL packSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packSnorm3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packSnorm3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint32} glm::packSnorm3x10_1x2 (vec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the first three components of the normalized floating-point value v into 10-bit signed integer values. Then, converts the forth component of the normalized floating-point value v into 2-bit signed integer values. Then, the results are packed into the returned 32-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packSnorm3x10_1x2(xyz): round(clamp(c, -1, +1) * 511.0) packSnorm3x10_1x2(w): round(clamp(c, -1, +1) * 1.0)\par
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec4 unpackSnorm3x10_1x2(uint32 const & p) \par
{\b uint32} {\b packUnorm3x10_1x2(vec4 const & v)} \par
{\b uint32} {\b packU3x10_1x2(uvec4 const & v)} \par
{\b uint32} {\b packI3x10_1x2(ivec4 const & v)} \par
}}}
{\xe \v packSnorm4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packSnorm4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER uint64 glm::packSnorm4x16 (vec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts each component of the normalized floating-point value v into 16-bit integer values. Then, the results are packed into the returned 64-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 32767.0)\par
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} packSnorm1x16(float const & v) \par
{\b uint32} packSnorm2x16(vec2 const & v) \par
{\f2 GLSL packSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packU3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packU3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint32} glm::packU3x10_1x2 (uvec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an unsigned integer obtained by converting the components of a four-component unsigned integer vector to the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packI3x10_1x2(ivec4 const & v)} \par
{\b uint32} {\b packSnorm3x10_1x2(vec4 const & v)} \par
{\b uint32} {\b packUnorm3x10_1x2(vec4 const & v)} \par
ivec4 unpackU3x10_1x2(uint32 const & p) \par
}}}
{\xe \v packUnorm1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packUnorm1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint16} glm::packUnorm1x16 (float  {\i v})}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the normalized floating-point value v into a 16-bit integer value. Then, the results are packed into the returned 16-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packUnorm1x16: round(clamp(c, 0, +1) * 65535.0)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} packSnorm1x16(float const & v) \par
{\b uint64} {\b packSnorm4x16(vec4 const & v)} \par
{\f2 GLSL packUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packUnorm1x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packUnorm1x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint8} glm::packUnorm1x8 (float  {\i v})}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the normalized floating-point value v into a 8-bit integer value. Then, the results are packed into the returned 8-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packUnorm1x8: round(clamp(c, 0, +1) * 255.0)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} {\b packUnorm2x8(vec2 const & v)} \par
{\b uint32} packUnorm4x8(vec4 const & v) \par
{\f2 GLSL packUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packUnorm2x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packUnorm2x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint16} glm::packUnorm2x8 (vec2 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts each component of the normalized floating-point value v into 8-bit integer values. Then, the results are packed into the returned 16-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packUnorm2x8: round(clamp(c, 0, +1) * 255.0)\par
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint8} packUnorm1x8(float const & v) \par
{\b uint32} packUnorm4x8(vec4 const & v) \par
{\f2 GLSL packUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v packUnorm3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packUnorm3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER {\b uint32} glm::packUnorm3x10_1x2 (vec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values. Then, converts the forth component of the normalized floating-point value v into 2-bit signed uninteger values. Then, the results are packed into the returned 32-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packUnorm3x10_1x2(xyz): round(clamp(c, 0, +1) * 1023.0) packUnorm3x10_1x2(w): round(clamp(c, 0, +1) * 3.0)\par
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec4 unpackUnorm3x10_1x2(uint32 const & p) \par
{\b uint32} {\b packUnorm3x10_1x2(vec4 const & v)} \par
{\b uint32} {\b packU3x10_1x2(uvec4 const & v)} \par
{\b uint32} {\b packI3x10_1x2(ivec4 const & v)} \par
}}}
{\xe \v packUnorm4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:packUnorm4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER uint64 glm::packUnorm4x16 (vec4 const &  {\i v})}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, converts each component of the normalized floating-point value v into 16-bit integer values. Then, the results are packed into the returned 64-bit unsigned integer.\par
The conversion for component c of v to fixed point is done as follows: packUnorm4x16: round(clamp(c, 0, +1) * 65535.0)\par
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint16} packUnorm1x16(float const & v) \par
{\b uint32} packUnorm2x16(vec2 const & v) \par
{\f2 GLSL packUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackF2x11_1x10\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackF2x11_1x10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec3 glm::unpackF2x11_1x10 ({\b uint32}  {\i p})}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value . Then, each component is converted to a normalized floating-point value to generate the returned three-component vector.\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packF2x11_1x10(vec3 const & v)} \par
}}}
{\xe \v unpackHalf1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackHalf1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER float glm::unpackHalf1x16 ({\b uint16}  {\i v})}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value, interpreted as a 16-bit floating-point number according to the OpenGL Specification, and converting it to 32-bit floating-point values.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec2 unpackHalf2x16(uint32 const & v) \par
vec4 unpackHalf4x16(uint64 const & v) \par
{\f2 GLSL unpackHalf2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackHalf4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackHalf4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER glm::vec4 glm::unpackHalf4x16 ({\b uint64}  {\i p})}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a four-component floating-point vector with components obtained by unpacking a 64-bit unsigned integer into four 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the forth component is obtained from the 16 most-significant bits of v.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
float unpackHalf1x16(uint16 const & v) \par
vec2 unpackHalf2x16(uint32 const & v) \par
{\f2 GLSL unpackHalf2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackI3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackI3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER ivec4 glm::unpackI3x10_1x2 ({\b uint32}  {\i p})}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit signed integers.\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packU3x10_1x2(uvec4 const & v)} \par
vec4 unpackSnorm3x10_1x2(uint32 const & p); \par
uvec4 unpackI3x10_1x2(uint32 const & p); \par
}}}
{\xe \v unpackSnorm1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackSnorm1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER float glm::unpackSnorm1x16 ({\b uint16}  {\i p})}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 16-bit unsigned integer p into a single 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned scalar.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x16: clamp(f / 32767.0, -1, +1)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec2 unpackSnorm2x16(uint32 p) \par
vec4 {\b unpackSnorm4x16(uint64 p)} \par
{\f2 GLSL unpackSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackSnorm1x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackSnorm1x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER float glm::unpackSnorm1x8 ({\b uint8}  {\i p})}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 8-bit unsigned integer p into a single 8-bit signed integers. Then, the value is converted to a normalized floating-point value to generate the returned scalar.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x8: clamp(f / 127.0, -1, +1)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec2 {\b unpackSnorm2x8(uint16 p)} \par
vec4 unpackSnorm4x8(uint32 p) \par
{\f2 GLSL unpackSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackSnorm2x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackSnorm2x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec2 glm::unpackSnorm2x8 ({\b uint16}  {\i p})}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm2x8: clamp(f / 127.0, -1, +1)\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
float {\b unpackSnorm1x8(uint8 p)} \par
vec4 unpackSnorm4x8(uint32 p) \par
{\f2 GLSL unpackSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackSnorm3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackSnorm3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec4 glm::unpackSnorm3x10_1x2 ({\b uint32}  {\i p})}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 511.0, -1, +1) unpackSnorm3x10_1x2(w): clamp(f / 511.0, -1, +1)\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packSnorm3x10_1x2(vec4 const & v)} \par
vec4 unpackUnorm3x10_1x2(uint32 const & p)) \par
uvec4 unpackI3x10_1x2(uint32 const & p) \par
uvec4 unpackU3x10_1x2(uint32 const & p) \par
}}}
{\xe \v unpackSnorm4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackSnorm4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec4 glm::unpackSnorm4x16 ({\b uint64}  {\i p})}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 64-bit unsigned integer p into four 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm4x16: clamp(f / 32767.0, -1, +1)\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
float {\b unpackSnorm1x16(uint16 p)} \par
vec2 unpackSnorm2x16(uint32 p) \par
{\f2 GLSL unpackSnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackU3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackU3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER uvec4 glm::unpackU3x10_1x2 ({\b uint32}  {\i p})}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers.\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packU3x10_1x2(uvec4 const & v)} \par
vec4 unpackSnorm3x10_1x2(uint32 const & p); \par
uvec4 unpackI3x10_1x2(uint32 const & p); \par
}}}
{\xe \v unpackUnorm1x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackUnorm1x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER float glm::unpackUnorm1x16 ({\b uint16}  {\i p})}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers. Then, the value is converted to a normalized floating-point value to generate the returned scalar.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm1x16: f / 65535.0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec2 unpackUnorm2x16(uint32 p) \par
vec4 {\b unpackUnorm4x16(uint64 p)} \par
{\f2 GLSL unpackUnorm2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackUnorm1x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackUnorm1x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER float glm::unpackUnorm1x8 ({\b uint8}  {\i p})}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convert a single 8-bit integer to a normalized floating-point value.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255.0\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
vec2 {\b unpackUnorm2x8(uint16 p)} \par
vec4 unpackUnorm4x8(uint32 p) \par
{\f2 GLSL unpackUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackUnorm2x8\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackUnorm2x8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec2 glm::unpackUnorm2x8 ({\b uint16}  {\i p})}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255.0\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
float {\b unpackUnorm1x8(uint8 v)} \par
vec4 unpackUnorm4x8(uint32 p) \par
{\f2 GLSL unpackUnorm4x8 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
{\xe \v unpackUnorm3x10_1x2\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackUnorm3x10_1x2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec4 glm::unpackUnorm3x10_1x2 ({\b uint32}  {\i p})}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 1023.0, 0, +1) unpackSnorm3x10_1x2(w): clamp(f / 3.0, 0, +1)\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
{\b uint32} {\b packSnorm3x10_1x2(vec4 const & v)} \par
vec4 unpackInorm3x10_1x2(uint32 const & p)) \par
uvec4 unpackI3x10_1x2(uint32 const & p) \par
uvec4 unpackU3x10_1x2(uint32 const & p) \par
}}}
{\xe \v unpackUnorm4x16\:GLM_GTC_packing}
{\xe \v GLM_GTC_packing\:unpackUnorm4x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GLM_FUNC_QUALIFIER vec4 glm::unpackUnorm4x16 ({\b uint64}  {\i p})}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.\par
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnormx4x16: f / 65535.0\par
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b GLM_GTC_packing} \par
float {\b unpackUnorm1x16(uint16 p)} \par
vec2 unpackUnorm2x16(uint32 p) \par
{\f2 GLSL unpackUnorm2x16 man page} \par
{\f2 GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions} \par
}}}
}