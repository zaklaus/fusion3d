; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	e:\fusion3d_work\engine\src\core\entity.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0GM@LMOAMGID@Assert?5e?3?2fusion3d_work?2lib?2bull@ ; `string'
PUBLIC	??_C@_0BK@ILJDJEOD@btConvexInternalShapeData?$AA@ ; `string'
PUBLIC	??_C@_06FKFPCBEF@SPHERE?$AA@			; `string'
PUBLIC	??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ ; `string'
PUBLIC	??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ ; `string'
PUBLIC	??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ ; `string'
PUBLIC	??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ ; `string'
PUBLIC	??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ ; `string'
PUBLIC	??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ ; `string'
PUBLIC	??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ ; `string'
PUBLIC	??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ ; `string'
PUBLIC	??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ ; `string'
PUBLIC	??_C@_0BA@LLDLEGBI@EntityComponent?$AA@		; `string'
PUBLIC	??_C@_09PGGEFGOE@RigidBody?$AA@			; `string'
PUBLIC	??_C@_05KFCIHKGL@shape?$AA@			; `string'
PUBLIC	??_C@_03LCMMOKCG@bvh?$AA@			; `string'
PUBLIC	??_C@_06OAMDAHCP@convex?$AA@			; `string'
PUBLIC	??_C@_03OLPJGAII@box?$AA@			; `string'
PUBLIC	??_C@_06FOHEPPJH@sphere?$AA@			; `string'
PUBLIC	??_C@_07FJIOKKEJ@capsule?$AA@			; `string'
PUBLIC	??_C@_08GNLJBPEP@cylinder?$AA@			; `string'
PUBLIC	??_C@_0BO@ILCGBKME@Unsupported?5collision?5shape?$CB?5?$AA@ ; `string'
PUBLIC	??_C@_1JM@EPLIDHMN@?$AAe?$AA?3?$AA?2?$AAf?$AAu?$AAs?$AAi?$AAo?$AAn?$AA3?$AAd?$AA_?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAe?$AAn?$AAg?$AAi?$AAn?$AAe?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAc?$AAo?$AAm?$AAp@ ; `string'
PUBLIC	??_C@_1O@HEOOEKLB@?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BO@GEOEHOMC@Unspecified?5collision?5shape?$CB?5?$AA@ ; `string'
PUBLIC	??_C@_04IJEANHEE@mass?$AA@			; `string'
PUBLIC	??_C@_0M@NEEMJLF@calcInertia?$AA@		; `string'
PUBLIC	??_C@_07IKGGBMHK@inertia?$AA@			; `string'
PUBLIC	??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JO@KJPPJIKP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1MC@NHEIOOEP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1BME@NCIPHHDN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	??_C@_1BBA@POHNFPDP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BAO@DGCLFBOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1OO@HAKMEMBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1OM@HKICCNDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1BAI@MFPHLFHP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1OG@NINHJLHM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1NM@MILGICEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ ; `string'
PUBLIC	??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1NE@OMIDEADP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_R4btConvexInternalShape@@6B@			; btConvexInternalShape::`RTTI Complete Object Locator'
PUBLIC	??_R2EntityComponent@@8				; EntityComponent::`RTTI Base Class Array'
PUBLIC	??_R0?AVbtConvexShape@@@8			; btConvexShape `RTTI Type Descriptor'
PUBLIC	??_7RigidBody@@6B@				; RigidBody::`vftable'
PUBLIC	??_R1A@?0A@EA@btConvexInternalShape@@8		; btConvexInternalShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3btDefaultMotionState@@8			; btDefaultMotionState::`RTTI Class Hierarchy Descriptor'
PUBLIC	?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
PUBLIC	??_7btMotionState@@6B@				; btMotionState::`vftable'
PUBLIC	??_R2btDefaultMotionState@@8			; btDefaultMotionState::`RTTI Base Class Array'
PUBLIC	??_R0?AVbtCollisionShape@@@8			; btCollisionShape `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Entity@@8				; Entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVEntityComponent@@@8			; EntityComponent `RTTI Type Descriptor'
PUBLIC	??_R2btConvexShape@@8				; btConvexShape::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@btDefaultMotionState@@8		; btDefaultMotionState::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2Entity@@8					; Entity::`RTTI Base Class Array'
PUBLIC	??_R0?AVRigidBody@@@8				; RigidBody `RTTI Type Descriptor'
PUBLIC	??_7btDefaultMotionState@@6B@			; btDefaultMotionState::`vftable'
PUBLIC	??_7Entity@@6B@					; Entity::`vftable'
PUBLIC	??_R3btMotionState@@8				; btMotionState::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3EntityComponent@@8				; EntityComponent::`RTTI Class Hierarchy Descriptor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_R4Entity@@6B@				; Entity::`RTTI Complete Object Locator'
PUBLIC	?identityTransform@?1??getIdentity@btTransform@@SAABV2@XZ@4V2@B ; `btTransform::getIdentity'::`2'::identityTransform
PUBLIC	??_R3RigidBody@@8				; RigidBody::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2btConvexInternalShape@@8			; btConvexInternalShape::`RTTI Base Class Array'
PUBLIC	??_R4RigidBody@@6B@				; RigidBody::`RTTI Complete Object Locator'
PUBLIC	??_R2btSphereShape@@8				; btSphereShape::`RTTI Base Class Array'
PUBLIC	??_7EntityComponent@@6B@			; EntityComponent::`vftable'
PUBLIC	??_R1A@?0A@EA@btSphereShape@@8			; btSphereShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@EntityComponent@@8		; EntityComponent::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVEntity@@@8				; Entity `RTTI Type Descriptor'
PUBLIC	??_R2btMotionState@@8				; btMotionState::`RTTI Base Class Array'
PUBLIC	??_R0?AVbtMotionState@@@8			; btMotionState `RTTI Type Descriptor'
PUBLIC	??_R3Entity@@8					; Entity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RigidBody@@8				; RigidBody::`RTTI Base Class Array'
PUBLIC	??_R4btSphereShape@@6B@				; btSphereShape::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@btMotionState@@8			; btMotionState::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3btCollisionShape@@8			; btCollisionShape::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7btConvexInternalShape@@6B@			; btConvexInternalShape::`vftable'
PUBLIC	?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
PUBLIC	??_R4btDefaultMotionState@@6B@			; btDefaultMotionState::`RTTI Complete Object Locator'
PUBLIC	??_7btSphereShape@@6B@				; btSphereShape::`vftable'
PUBLIC	??_R3btSphereShape@@8				; btSphereShape::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@RigidBody@@8			; RigidBody::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@btConvexShape@@8			; btConvexShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4btMotionState@@6B@				; btMotionState::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbtConvexInternalShape@@@8		; btConvexInternalShape `RTTI Type Descriptor'
PUBLIC	??_R2btCollisionShape@@8			; btCollisionShape::`RTTI Base Class Array'
PUBLIC	??_R3btConvexShape@@8				; btConvexShape::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3btConvexInternalShape@@8			; btConvexInternalShape::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVbtSphereShape@@@8			; btSphereShape `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@btCollisionShape@@8		; btCollisionShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?identityMatrix@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4V2@B ; `btMatrix3x3::getIdentity'::`2'::identityMatrix
PUBLIC	??_R4EntityComponent@@6B@			; EntityComponent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUbtDefaultMotionState@@@8		; btDefaultMotionState `RTTI Type Descriptor'
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__purecall:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	??0btConvexTriangleMeshShape@@QAE@PAVbtStridingMeshInterface@@_N@Z:PROC ; btConvexTriangleMeshShape::btConvexTriangleMeshShape
EXTRN	__imp___wassert:PROC
EXTRN	??0btCapsuleShape@@QAE@MM@Z:PROC		; btCapsuleShape::btCapsuleShape
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp__sqrt:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	?btAlignedAllocInternal@@YAPAXIH@Z:PROC		; btAlignedAllocInternal
EXTRN	__imp__atoi:PROC
EXTRN	??0btCylinderShape@@QAE@ABVbtVector3@@@Z:PROC	; btCylinderShape::btCylinderShape
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	??1btConvexShape@@UAE@XZ:PROC			; btConvexShape::~btConvexShape
EXTRN	?project@btConvexShape@@UBEXABVbtTransform@@ABVbtVector3@@AAM2AAV3@3@Z:PROC ; btConvexShape::project
EXTRN	__imp__memcmp:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__imp__strlen:PROC
EXTRN	??0btConvexInternalShape@@IAE@XZ:PROC		; btConvexInternalShape::btConvexInternalShape
EXTRN	?localGetSupportingVertex@btConvexInternalShape@@UBE?AVbtVector3@@ABV2@@Z:PROC ; btConvexInternalShape::localGetSupportingVertex
EXTRN	?getAabbSlow@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z:PROC ; btConvexInternalShape::getAabbSlow
EXTRN	?setLocalScaling@btConvexInternalShape@@UAEXABVbtVector3@@@Z:PROC ; btConvexInternalShape::setLocalScaling
EXTRN	__Init_thread_header:PROC
EXTRN	?localGetSupportingVertex@btSphereShape@@UBE?AVbtVector3@@ABV2@@Z:PROC ; btSphereShape::localGetSupportingVertex
EXTRN	?localGetSupportingVertexWithoutMargin@btSphereShape@@UBE?AVbtVector3@@ABV2@@Z:PROC ; btSphereShape::localGetSupportingVertexWithoutMargin
EXTRN	?batchedUnitVectorGetSupportingVertexWithoutMargin@btSphereShape@@UBEXPBVbtVector3@@PAV2@H@Z:PROC ; btSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin
EXTRN	?calculateLocalInertia@btSphereShape@@UBEXMAAVbtVector3@@@Z:PROC ; btSphereShape::calculateLocalInertia
EXTRN	?getAabb@btSphereShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z:PROC ; btSphereShape::getAabb
EXTRN	__imp___purecall:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__Init_thread_footer:PROC
EXTRN	??0btBoxShape@@QAE@ABVbtVector3@@@Z:PROC	; btBoxShape::btBoxShape
EXTRN	??0btBvhTriangleMeshShape@@QAE@PAVbtStridingMeshInterface@@_N1@Z:PROC ; btBvhTriangleMeshShape::btBvhTriangleMeshShape
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?btAlignedFreeInternal@@YAXPAX@Z:PROC		; btAlignedFreeInternal
EXTRN	??0btRigidBody@@QAE@ABUbtRigidBodyConstructionInfo@0@@Z:PROC ; btRigidBody::btRigidBody
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	?getBoundingSphere@btCollisionShape@@UBEXAAVbtVector3@@AAM@Z:PROC ; btCollisionShape::getBoundingSphere
EXTRN	?getAngularMotionDisc@btCollisionShape@@UBEMXZ:PROC ; btCollisionShape::getAngularMotionDisc
EXTRN	?getContactBreakingThreshold@btCollisionShape@@UBEMM@Z:PROC ; btCollisionShape::getContactBreakingThreshold
EXTRN	?serialize@btCollisionShape@@UBEPBDPAXPAVbtSerializer@@@Z:PROC ; btCollisionShape::serialize
EXTRN	?serializeSingleShape@btCollisionShape@@UBEXPAVbtSerializer@@@Z:PROC ; btCollisionShape::serializeSingleShape
EXTRN	__Init_thread_epoch:DWORD
EXTRN	__imp__memcpy:PROC
EXTRN	__imp__memmove:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?identityTransform@?1??getIdentity@btTransform@@SAABV2@XZ@4V2@B
_BSS	SEGMENT
?identityTransform@?1??getIdentity@btTransform@@SAABV2@XZ@4V2@B DB 040H DUP (?) ; `btTransform::getIdentity'::`2'::identityTransform
_BSS	ENDS
;	COMDAT ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
_BSS	ENDS
;	COMDAT ?identityMatrix@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4V2@B
_BSS	SEGMENT
?identityMatrix@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4V2@B DB 030H DUP (?) ; `btMatrix3x3::getIdentity'::`2'::identityMatrix
_BSS	ENDS
;	COMDAT ??_R0?AUbtDefaultMotionState@@@8
data$r	SEGMENT
??_R0?AUbtDefaultMotionState@@@8 DD FLAT:??_7type_info@@6B@ ; btDefaultMotionState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUbtDefaultMotionState@@', 00H
data$r	ENDS
;	COMDAT ??_R4EntityComponent@@6B@
rdata$r	SEGMENT
??_R4EntityComponent@@6B@ DD 00H			; EntityComponent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEntityComponent@@@8
	DD	FLAT:??_R3EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btCollisionShape@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btCollisionShape@@8 DD FLAT:??_R0?AVbtCollisionShape@@@8 ; btCollisionShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btCollisionShape@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbtSphereShape@@@8
data$r	SEGMENT
??_R0?AVbtSphereShape@@@8 DD FLAT:??_7type_info@@6B@	; btSphereShape `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbtSphereShape@@', 00H
data$r	ENDS
;	COMDAT ??_R3btConvexInternalShape@@8
rdata$r	SEGMENT
??_R3btConvexInternalShape@@8 DD 00H			; btConvexInternalShape::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2btConvexInternalShape@@8
rdata$r	ENDS
;	COMDAT ??_R3btConvexShape@@8
rdata$r	SEGMENT
??_R3btConvexShape@@8 DD 00H				; btConvexShape::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2btConvexShape@@8
rdata$r	ENDS
;	COMDAT ??_R2btCollisionShape@@8
rdata$r	SEGMENT
??_R2btCollisionShape@@8 DD FLAT:??_R1A@?0A@EA@btCollisionShape@@8 ; btCollisionShape::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVbtConvexInternalShape@@@8
data$r	SEGMENT
??_R0?AVbtConvexInternalShape@@@8 DD FLAT:??_7type_info@@6B@ ; btConvexInternalShape `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbtConvexInternalShape@@', 00H
data$r	ENDS
;	COMDAT ??_R4btMotionState@@6B@
rdata$r	SEGMENT
??_R4btMotionState@@6B@ DD 00H				; btMotionState::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbtMotionState@@@8
	DD	FLAT:??_R3btMotionState@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btConvexShape@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btConvexShape@@8 DD FLAT:??_R0?AVbtConvexShape@@@8 ; btConvexShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btConvexShape@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RigidBody@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RigidBody@@8 DD FLAT:??_R0?AVRigidBody@@@8 ; RigidBody::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RigidBody@@8
rdata$r	ENDS
;	COMDAT ??_R3btSphereShape@@8
rdata$r	SEGMENT
??_R3btSphereShape@@8 DD 00H				; btSphereShape::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2btSphereShape@@8
rdata$r	ENDS
;	COMDAT ??_7btSphereShape@@6B@
CONST	SEGMENT
??_7btSphereShape@@6B@ DD FLAT:??_R4btSphereShape@@6B@	; btSphereShape::`vftable'
	DD	FLAT:??_EbtSphereShape@@UAEPAXI@Z
	DD	FLAT:?getAabb@btSphereShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z
	DD	FLAT:?getBoundingSphere@btCollisionShape@@UBEXAAVbtVector3@@AAM@Z
	DD	FLAT:?getAngularMotionDisc@btCollisionShape@@UBEMXZ
	DD	FLAT:?getContactBreakingThreshold@btCollisionShape@@UBEMM@Z
	DD	FLAT:?setLocalScaling@btConvexInternalShape@@UAEXABVbtVector3@@@Z
	DD	FLAT:?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ
	DD	FLAT:?calculateLocalInertia@btSphereShape@@UBEXMAAVbtVector3@@@Z
	DD	FLAT:?getName@btSphereShape@@UBEPBDXZ
	DD	FLAT:?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ
	DD	FLAT:?setMargin@btSphereShape@@UAEXM@Z
	DD	FLAT:?getMargin@btSphereShape@@UBEMXZ
	DD	FLAT:?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ
	DD	FLAT:?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z
	DD	FLAT:?serializeSingleShape@btCollisionShape@@UBEXPAVbtSerializer@@@Z
	DD	FLAT:?localGetSupportingVertex@btSphereShape@@UBE?AVbtVector3@@ABV2@@Z
	DD	FLAT:?localGetSupportingVertexWithoutMargin@btSphereShape@@UBE?AVbtVector3@@ABV2@@Z
	DD	FLAT:?project@btConvexShape@@UBEXABVbtTransform@@ABVbtVector3@@AAM2AAV3@3@Z
	DD	FLAT:?batchedUnitVectorGetSupportingVertexWithoutMargin@btSphereShape@@UBEXPBVbtVector3@@PAV2@H@Z
	DD	FLAT:?getAabbSlow@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z
	DD	FLAT:?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ
	DD	FLAT:?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z
CONST	ENDS
;	COMDAT ??_R4btDefaultMotionState@@6B@
rdata$r	SEGMENT
??_R4btDefaultMotionState@@6B@ DD 00H			; btDefaultMotionState::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUbtDefaultMotionState@@@8
	DD	FLAT:??_R3btDefaultMotionState@@8
rdata$r	ENDS
;	COMDAT ??_7btConvexInternalShape@@6B@
CONST	SEGMENT
??_7btConvexInternalShape@@6B@ DD FLAT:??_R4btConvexInternalShape@@6B@ ; btConvexInternalShape::`vftable'
	DD	FLAT:??_EbtConvexInternalShape@@UAEPAXI@Z
	DD	FLAT:?getAabb@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z
	DD	FLAT:?getBoundingSphere@btCollisionShape@@UBEXAAVbtVector3@@AAM@Z
	DD	FLAT:?getAngularMotionDisc@btCollisionShape@@UBEMXZ
	DD	FLAT:?getContactBreakingThreshold@btCollisionShape@@UBEMM@Z
	DD	FLAT:?setLocalScaling@btConvexInternalShape@@UAEXABVbtVector3@@@Z
	DD	FLAT:?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ
	DD	FLAT:?setMargin@btConvexInternalShape@@UAEXM@Z
	DD	FLAT:?getMargin@btConvexInternalShape@@UBEMXZ
	DD	FLAT:?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ
	DD	FLAT:?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z
	DD	FLAT:?serializeSingleShape@btCollisionShape@@UBEXPAVbtSerializer@@@Z
	DD	FLAT:?localGetSupportingVertex@btConvexInternalShape@@UBE?AVbtVector3@@ABV2@@Z
	DD	FLAT:__purecall
	DD	FLAT:?project@btConvexShape@@UBEXABVbtTransform@@ABVbtVector3@@AAM2AAV3@3@Z
	DD	FLAT:__purecall
	DD	FLAT:?getAabbSlow@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z
	DD	FLAT:?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ
	DD	FLAT:?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z
CONST	ENDS
;	COMDAT ??_R3btCollisionShape@@8
rdata$r	SEGMENT
??_R3btCollisionShape@@8 DD 00H				; btCollisionShape::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2btCollisionShape@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btMotionState@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btMotionState@@8 DD FLAT:??_R0?AVbtMotionState@@@8 ; btMotionState::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btMotionState@@8
rdata$r	ENDS
;	COMDAT ??_R4btSphereShape@@6B@
rdata$r	SEGMENT
??_R4btSphereShape@@6B@ DD 00H				; btSphereShape::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbtSphereShape@@@8
	DD	FLAT:??_R3btSphereShape@@8
rdata$r	ENDS
;	COMDAT ??_R2RigidBody@@8
rdata$r	SEGMENT
??_R2RigidBody@@8 DD FLAT:??_R1A@?0A@EA@RigidBody@@8	; RigidBody::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R3Entity@@8
rdata$r	SEGMENT
??_R3Entity@@8 DD 00H					; Entity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Entity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbtMotionState@@@8
data$r	SEGMENT
??_R0?AVbtMotionState@@@8 DD FLAT:??_7type_info@@6B@	; btMotionState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbtMotionState@@', 00H
data$r	ENDS
;	COMDAT ??_R2btMotionState@@8
rdata$r	SEGMENT
??_R2btMotionState@@8 DD FLAT:??_R1A@?0A@EA@btMotionState@@8 ; btMotionState::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVEntity@@@8
data$r	SEGMENT
??_R0?AVEntity@@@8 DD FLAT:??_7type_info@@6B@		; Entity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEntity@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@EntityComponent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EntityComponent@@8 DD FLAT:??_R0?AVEntityComponent@@@8 ; EntityComponent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btSphereShape@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btSphereShape@@8 DD FLAT:??_R0?AVbtSphereShape@@@8 ; btSphereShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btSphereShape@@8
rdata$r	ENDS
;	COMDAT ??_7EntityComponent@@6B@
CONST	SEGMENT
??_7EntityComponent@@6B@ DD FLAT:??_R4EntityComponent@@6B@ ; EntityComponent::`vftable'
	DD	FLAT:?__ClassType__@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:??_EEntityComponent@@UAEPAXI@Z
	DD	FLAT:?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Init@EntityComponent@@UAEXXZ
	DD	FLAT:?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
	DD	FLAT:?Update@EntityComponent@@UAEXM@Z
	DD	FLAT:?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?DataDeploy@EntityComponent@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	FLAT:?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z
	DD	FLAT:?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
CONST	ENDS
;	COMDAT ??_R2btSphereShape@@8
rdata$r	SEGMENT
??_R2btSphereShape@@8 DD FLAT:??_R1A@?0A@EA@btSphereShape@@8 ; btSphereShape::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@btConvexInternalShape@@8
	DD	FLAT:??_R1A@?0A@EA@btConvexShape@@8
	DD	FLAT:??_R1A@?0A@EA@btCollisionShape@@8
rdata$r	ENDS
;	COMDAT ??_R4RigidBody@@6B@
rdata$r	SEGMENT
??_R4RigidBody@@6B@ DD 00H				; RigidBody::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRigidBody@@@8
	DD	FLAT:??_R3RigidBody@@8
rdata$r	ENDS
;	COMDAT ??_R2btConvexInternalShape@@8
rdata$r	SEGMENT
??_R2btConvexInternalShape@@8 DD FLAT:??_R1A@?0A@EA@btConvexInternalShape@@8 ; btConvexInternalShape::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@btConvexShape@@8
	DD	FLAT:??_R1A@?0A@EA@btCollisionShape@@8
rdata$r	ENDS
;	COMDAT ??_R3RigidBody@@8
rdata$r	SEGMENT
??_R3RigidBody@@8 DD 00H				; RigidBody::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RigidBody@@8
rdata$r	ENDS
;	COMDAT ??_R4Entity@@6B@
rdata$r	SEGMENT
??_R4Entity@@6B@ DD 00H					; Entity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEntity@@@8
	DD	FLAT:??_R3Entity@@8
rdata$r	ENDS
;	COMDAT ??_R3EntityComponent@@8
rdata$r	SEGMENT
??_R3EntityComponent@@8 DD 00H				; EntityComponent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R3btMotionState@@8
rdata$r	SEGMENT
??_R3btMotionState@@8 DD 00H				; btMotionState::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2btMotionState@@8
rdata$r	ENDS
;	COMDAT ??_7Entity@@6B@
CONST	SEGMENT
??_7Entity@@6B@ DD FLAT:??_R4Entity@@6B@		; Entity::`vftable'
	DD	FLAT:??_EEntity@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7btDefaultMotionState@@6B@
CONST	SEGMENT
??_7btDefaultMotionState@@6B@ DD FLAT:??_R4btDefaultMotionState@@6B@ ; btDefaultMotionState::`vftable'
	DD	FLAT:??_EbtDefaultMotionState@@UAEPAXI@Z
	DD	FLAT:?getWorldTransform@btDefaultMotionState@@UBEXAAVbtTransform@@@Z
	DD	FLAT:?setWorldTransform@btDefaultMotionState@@UAEXABVbtTransform@@@Z
CONST	ENDS
;	COMDAT ??_R0?AVRigidBody@@@8
data$r	SEGMENT
??_R0?AVRigidBody@@@8 DD FLAT:??_7type_info@@6B@	; RigidBody `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRigidBody@@', 00H
data$r	ENDS
;	COMDAT ??_R2Entity@@8
rdata$r	SEGMENT
??_R2Entity@@8 DD FLAT:??_R1A@?0A@EA@Entity@@8		; Entity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btDefaultMotionState@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btDefaultMotionState@@8 DD FLAT:??_R0?AUbtDefaultMotionState@@@8 ; btDefaultMotionState::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btDefaultMotionState@@8
rdata$r	ENDS
;	COMDAT ??_R2btConvexShape@@8
rdata$r	SEGMENT
??_R2btConvexShape@@8 DD FLAT:??_R1A@?0A@EA@btConvexShape@@8 ; btConvexShape::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@btCollisionShape@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEntityComponent@@@8
data$r	SEGMENT
??_R0?AVEntityComponent@@@8 DD FLAT:??_7type_info@@6B@	; EntityComponent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEntityComponent@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Entity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Entity@@8 DD FLAT:??_R0?AVEntity@@@8	; Entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Entity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbtCollisionShape@@@8
data$r	SEGMENT
??_R0?AVbtCollisionShape@@@8 DD FLAT:??_7type_info@@6B@	; btCollisionShape `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbtCollisionShape@@', 00H
data$r	ENDS
;	COMDAT ??_R2btDefaultMotionState@@8
rdata$r	SEGMENT
??_R2btDefaultMotionState@@8 DD FLAT:??_R1A@?0A@EA@btDefaultMotionState@@8 ; btDefaultMotionState::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@btMotionState@@8
rdata$r	ENDS
;	COMDAT ??_7btMotionState@@6B@
CONST	SEGMENT
??_7btMotionState@@6B@ DD FLAT:??_R4btMotionState@@6B@	; btMotionState::`vftable'
	DD	FLAT:??_EbtMotionState@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R3btDefaultMotionState@@8
rdata$r	SEGMENT
??_R3btDefaultMotionState@@8 DD 00H			; btDefaultMotionState::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2btDefaultMotionState@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@btConvexInternalShape@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@btConvexInternalShape@@8 DD FLAT:??_R0?AVbtConvexInternalShape@@@8 ; btConvexInternalShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3btConvexInternalShape@@8
rdata$r	ENDS
;	COMDAT ??_7RigidBody@@6B@
CONST	SEGMENT
??_7RigidBody@@6B@ DD FLAT:??_R4RigidBody@@6B@		; RigidBody::`vftable'
	DD	FLAT:?__ClassType__@RigidBody@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:??_ERigidBody@@UAEPAXI@Z
	DD	FLAT:?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Init@RigidBody@@UAEXXZ
	DD	FLAT:?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
	DD	FLAT:?Update@RigidBody@@UAEXM@Z
	DD	FLAT:?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	FLAT:?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z
	DD	FLAT:?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
CONST	ENDS
;	COMDAT ??_R0?AVbtConvexShape@@@8
data$r	SEGMENT
??_R0?AVbtConvexShape@@@8 DD FLAT:??_7type_info@@6B@	; btConvexShape `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbtConvexShape@@', 00H
data$r	ENDS
;	COMDAT ??_R2EntityComponent@@8
rdata$r	SEGMENT
??_R2EntityComponent@@8 DD FLAT:??_R1A@?0A@EA@EntityComponent@@8 ; EntityComponent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4btConvexInternalShape@@6B@
rdata$r	SEGMENT
??_R4btConvexInternalShape@@6B@ DD 00H			; btConvexInternalShape::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbtConvexInternalShape@@@8
	DD	FLAT:??_R3btConvexInternalShape@@8
rdata$r	ENDS
;	COMDAT ??_C@_1NE@OMIDEADP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NE@OMIDEADP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
CONST	SEGMENT
??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@MILGICEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NM@MILGICEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '+', 00H, '=', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OG@NINHJLHM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OG@NINHJLHM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAI@MFPHLFHP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1BAI@MFPHLFHP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a', 00H, 'i'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'R', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 'd'
	DB	00H, 'B', 00H, 'o', 00H, 'd', 00H, 'y', 00H, ' ', 00H, '*', 00H
	DB	',', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
CONST	SEGMENT
??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H
	DB	'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1OM@HKICCNDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OM@HKICCNDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1OO@HAKMEMBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OO@HAKMEMBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '+'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAO@DGCLFBOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1BAO@DGCLFBOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a', 00H, 'i'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'R', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 'd'
	DB	00H, 'B', 00H, 'o', 00H, 'd', 00H, 'y', 00H, ' ', 00H, '*', 00H
	DB	',', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BBA@POHNFPDP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1BBA@POHNFPDP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a', 00H, 'i'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'R', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 'd'
	DB	00H, 'B', 00H, 'o', 00H, 'd', 00H, 'y', 00H, ' ', 00H, '*', 00H
	DB	',', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BME@NCIPHHDN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1BME@NCIPHHDN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i'
	DB	00H, 'c', 00H, '_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H
	DB	't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1MC@NHEIOOEP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn@
CONST	SEGMENT
??_C@_1MC@NHEIOOEP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H
	DB	':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 't'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@KJPPJIKP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1JO@KJPPJIKP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, ','
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 't', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':'
	DB	00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
$SG4294966771 DB 'undefined', 00H
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
?btInfinityMask@@3HA DD 07f800000H			; btInfinityMask
$SG4294966598 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (!pair.m_algorithm'
	DB	')', 0aH, 00H
$SG4294966597 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (!pair.m_algorithm'
	DB	')', 0aH, 00H
$SG4294966568 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (m_firstFreeHandle'
	DB	')', 0aH, 00H
$SG4294966567 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (handle > 0 && han'
	DB	'dle < m_maxHandles)', 0aH, 00H
?btNanMask@@3HA DD 07f800001H				; btNanMask
$SG4294966566 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (m_firstFreeHandle'
	DB	')', 0aH, 00H
$SG4294966565 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (handle > 0 && han'
	DB	'dle < m_maxHandles)', 0aH, 00H
CONST	ENDS
;	COMDAT ??_C@_07IKGGBMHK@inertia?$AA@
CONST	SEGMENT
??_C@_07IKGGBMHK@inertia?$AA@ DB 'inertia', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEEMJLF@calcInertia?$AA@
CONST	SEGMENT
??_C@_0M@NEEMJLF@calcInertia?$AA@ DB 'calcInertia', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJEANHEE@mass?$AA@
CONST	SEGMENT
??_C@_04IJEANHEE@mass?$AA@ DB 'mass', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEOEHOMC@Unspecified?5collision?5shape?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BO@GEOEHOMC@Unspecified?5collision?5shape?$CB?5?$AA@ DB 'Unspecifi'
	DB	'ed collision shape! ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@HEOOEKLB@?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@HEOOEKLB@?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB '1', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@EPLIDHMN@?$AAe?$AA?3?$AA?2?$AAf?$AAu?$AAs?$AAi?$AAo?$AAn?$AA3?$AAd?$AA_?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAe?$AAn?$AAg?$AAi?$AAn?$AAe?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAc?$AAo?$AAm?$AAp@
CONST	SEGMENT
??_C@_1JM@EPLIDHMN@?$AAe?$AA?3?$AA?2?$AAf?$AAu?$AAs?$AAi?$AAo?$AAn?$AA3?$AAd?$AA_?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAe?$AAn?$AAg?$AAi?$AAn?$AAe?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAc?$AAo?$AAm?$AAp@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '3', 00H, 'd', 00H, '_', 00H, 'w', 00H, 'o'
	DB	00H, 'r', 00H, 'k', 00H, '\', 00H, 'e', 00H, 'n', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H
	DB	'n', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, '.'
	DB	00H, '.', 00H, '/', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '/'
	DB	00H, 'p', 00H, 'h', 00H, 'y', 00H, 's', 00H, 'i', 00H, 'c', 00H
	DB	's', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ILCGBKME@Unsupported?5collision?5shape?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BO@ILCGBKME@Unsupported?5collision?5shape?$CB?5?$AA@ DB 'Unsupport'
	DB	'ed collision shape! ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNLJBPEP@cylinder?$AA@
CONST	SEGMENT
??_C@_08GNLJBPEP@cylinder?$AA@ DB 'cylinder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJIOKKEJ@capsule?$AA@
CONST	SEGMENT
??_C@_07FJIOKKEJ@capsule?$AA@ DB 'capsule', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOHEPPJH@sphere?$AA@
CONST	SEGMENT
??_C@_06FOHEPPJH@sphere?$AA@ DB 'sphere', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OLPJGAII@box?$AA@
CONST	SEGMENT
??_C@_03OLPJGAII@box?$AA@ DB 'box', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAMDAHCP@convex?$AA@
CONST	SEGMENT
??_C@_06OAMDAHCP@convex?$AA@ DB 'convex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCMMOKCG@bvh?$AA@
CONST	SEGMENT
??_C@_03LCMMOKCG@bvh?$AA@ DB 'bvh', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCIHKGL@shape?$AA@
CONST	SEGMENT
??_C@_05KFCIHKGL@shape?$AA@ DB 'shape', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGGEFGOE@RigidBody?$AA@
CONST	SEGMENT
??_C@_09PGGEFGOE@RigidBody?$AA@ DB 'RigidBody', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLDLEGBI@EntityComponent?$AA@
CONST	SEGMENT
??_C@_0BA@LLDLEGBI@EntityComponent?$AA@ DB 'EntityComponent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
CONST	SEGMENT
??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '-', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'N', 00H
	DB	'O', 00H, 'N', 00H, '_', 00H, 'U', 00H, 'S', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '"', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
CONST	SEGMENT
??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ DB '_Ptr_u'
	DB	'ser - _Ptr_container <= _NON_USER_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ DB '"'
	DB	00H, '2', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'v', 00H, 'o'
	DB	00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r'
	DB	00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 'e', 00H, 'r', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
CONST	SEGMENT
??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ DB '2'
	DB	' * sizeof(void *) <= _Ptr_user - _Ptr_container', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
CONST	SEGMENT
??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ DB '_Ptr_containe'
	DB	'r < _Ptr_user', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
CONST	SEGMENT
??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ DB '"'
	DB	00H, 'r', 00H, 'e', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 't', 00H, '_', 00H, 'c'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, '<', 00H, 'u', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, '>', 00H, '(', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'p', 00H, 't', 00H, 'r', 00H, ')'
	DB	00H, '[', 00H, '-', 00H, '1', 00H, ']', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_'
	DB	00H, 'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'N', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'L', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
CONST	SEGMENT
??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ DB 'rei'
	DB	'nterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_S'
	DB	'ENTINEL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
CONST	SEGMENT
??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ DB '"'
	DB	00H, '(', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H
	DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_', 00H
	DB	'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
CONST	SEGMENT
??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ DB '(_Ptr'
	DB	'_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ DB '"'
	DB	00H, '_', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H
	DB	'-', 00H, '1', 00H, ')', 00H, ' ', 00H, '/', 00H, ' ', 00H, '_'
	DB	00H, 'S', 00H, 'z', 00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
CONST	SEGMENT
??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ DB '_'
	DB	'Count <= (size_t)(-1) / _Sz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@ DB '_Ptr != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ DB '_Ptr_container !='
	DB	' 0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FKFPCBEF@SPHERE?$AA@
CONST	SEGMENT
??_C@_06FKFPCBEF@SPHERE?$AA@ DB 'SPHERE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ILJDJEOD@btConvexInternalShapeData?$AA@
CONST	SEGMENT
??_C@_0BK@ILJDJEOD@btConvexInternalShapeData?$AA@ DB 'btConvexInternalSha'
	DB	'peData', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@LMOAMGID@Assert?5e?3?2fusion3d_work?2lib?2bull@
CONST	SEGMENT
??_C@_0GM@LMOAMGID@Assert?5e?3?2fusion3d_work?2lib?2bull@ DB 'Assert e:\f'
	DB	'usion3d_work\lib\bullet3\include\bulletcollision\collisionsha'
	DB	'pes\btConvexInternalShape.h:%u (0)', 0aH, 00H ; `string'
CONST	ENDS
PUBLIC	??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z ; std::_Move<Entity * &>
PUBLIC	??$swap@PAVEntity@@@std@@YAXAAPAVEntity@@0@Z	; std::swap<Entity *>
PUBLIC	??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z ; std::_Debug_pointer<EntityComponent *>
PUBLIC	??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ; std::iter_swap<Entity * *,Entity * *>
PUBLIC	??$_Debug_range_ptr2@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<EntityComponent * *,EntityComponent * *>
PUBLIC	??$_Iter_cat@PAPAVEntityComponent@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntityComponent@@@Z ; std::_Iter_cat<EntityComponent * *>
PUBLIC	??$_Debug_range_ptr2@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<Entity * *,Entity * *>
PUBLIC	??$_Reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<Entity * *>
PUBLIC	??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
PUBLIC	??$_Uninit_copy@PAVEntity@@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Entity *,Entity *>
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unchecked
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Debug_range_ptr@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<EntityComponent * *,EntityComponent * *>
PUBLIC	??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<Entity * *,Entity * *>
PUBLIC	??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ; std::allocator<std::pair<RigidBody *,int> >::destroy<std::pair<RigidBody *,int> >
PUBLIC	??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z ; std::reverse<Entity * *>
PUBLIC	??$_Debug_range2@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Entity * *>
PUBLIC	??$_Uninit_copy@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninit_copy<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator!=
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator<
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Uninit_move@PAVEntityComponent@@PAV1@PAV1@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EntityComponent *,EntityComponent *,EntityComponent *>
PUBLIC	??$_Val_type@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Val_type<EntityComponent * *>
PUBLIC	??$_Uninit_move@PAVEntity@@PAV1@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Entity *,Entity *,Entity *>
PUBLIC	??$_Val_type@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Val_type<Entity * *>
PUBLIC	??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator_traits@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@PAU?$pair@PAVRigidBody@@H@1@@Z ; std::allocator_traits<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
PUBLIC	??$_Rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<Entity * *>
PUBLIC	??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ; std::_Iter_cat<Entity * *>
PUBLIC	??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z ; std::_Debug_range<Entity * *>
PUBLIC	??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
PUBLIC	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Rechecked@PAPAVEntityComponent@@PAPAV1@@std@@YAAAPAPAVEntityComponent@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<EntityComponent * *,EntityComponent * *>
PUBLIC	??$_Uninit_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Uninit_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
PUBLIC	??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Unchecked<EntityComponent * *>
PUBLIC	??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<Entity * *,Entity * *>
PUBLIC	??$_Uninit_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninit_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
PUBLIC	??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PAVEntityComponent@@ABQAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * const &>
PUBLIC	??$construct@PAVEntityComponent@@AAPAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * &>
PUBLIC	??$construct@PAVEntity@@ABQAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ; std::allocator<Entity *>::construct<Entity *,Entity * const &>
PUBLIC	??$construct@PAVEntity@@AAPAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ; std::allocator<Entity *>::construct<Entity *,Entity * &>
PUBLIC	??$rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00@Z ; std::rotate<Entity * *>
PUBLIC	??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Ucopy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
PUBLIC	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
PUBLIC	??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z ; std::_Ptr_cat<EntityComponent *,EntityComponent *>
PUBLIC	??$_Uninitialized_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Uninitialized_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z ; std::_Ptr_cat<Entity *,Entity *>
PUBLIC	??$_Uninitialized_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninitialized_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
PUBLIC	??$_Ptr_cat@U?$pair@PAVRigidBody@@H@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@PAVRigidBody@@H@0@0@Z ; std::_Ptr_cat<std::pair<RigidBody *,int>,std::pair<RigidBody *,int> >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@ABV?$allocator@PAVEntity@@@std@@@std@@YAABV?$allocator@PAVEntity@@@0@ABV10@@Z ; std::forward<std::allocator<Entity *> const &>
PUBLIC	??$forward@V?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ; std::forward<std::allocator<Entity *> >
PUBLIC	??$forward@ABV?$allocator@PAVEntityComponent@@@std@@@std@@YAABV?$allocator@PAVEntityComponent@@@0@ABV10@@Z ; std::forward<std::allocator<EntityComponent *> const &>
PUBLIC	??$forward@V?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ; std::forward<std::allocator<EntityComponent *> >
PUBLIC	??$_Addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@YAABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<RigidBody *,int> > const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$construct@PAVEntityComponent@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@ABQAV3@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>
PUBLIC	??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z ; std::forward<EntityComponent * const &>
PUBLIC	??$construct@PAVEntityComponent@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@AAPAV3@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>
PUBLIC	??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z ; std::forward<EntityComponent * &>
PUBLIC	??$_Addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<EntityComponent * const>
PUBLIC	??$construct@PAVEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * const &>
PUBLIC	??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z ; std::forward<Entity * const &>
PUBLIC	??$construct@PAVEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * &>
PUBLIC	??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z ; std::forward<Entity * &>
PUBLIC	??$_Addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<Entity * const>
PUBLIC	??$_Addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<std::pair<RigidBody *,int> >
PUBLIC	??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<char>
PUBLIC	??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
PUBLIC	??$?0PAVEntityComponent@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><EntityComponent *>
PUBLIC	??$?0U?$pair@PAVRigidBody@@H@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<RigidBody *,int> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0?$allocator@PAVEntityComponent@@@std@@QAE@ABV01@@Z ; std::allocator<EntityComponent *>::allocator<EntityComponent *>
PUBLIC	??0?$allocator@PAVEntity@@@std@@QAE@ABV01@@Z	; std::allocator<Entity *>::allocator<Entity *>
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=
PUBLIC	??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::_Wrap_alloc<std::allocator<Entity *> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::_Wrap_alloc<std::allocator<EntityComponent *> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::_Vector_val<std::_Simple_types<EntityComponent *> >
PUBLIC	??B?$function@$$A6AXPAVRigidBody@@@Z@std@@QBE_NXZ ; std::function<void __cdecl(RigidBody *)>::operator bool
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
PUBLIC	??$_Umove@PAPAVEntityComponent@@@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEPAPAVEntityComponent@@PAPAV2@00@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Umove<EntityComponent * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Entity *> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<EntityComponent *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z	; std::_Debug_pointer_if<char const >
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$?0ABV?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> const &>
PUBLIC	??$?0V?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntity@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> >
PUBLIC	??$move@AAV?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ; std::move<std::allocator<Entity *> &>
PUBLIC	??$?0ABV?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> const &>
PUBLIC	??$?0V?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> >
PUBLIC	??$move@AAV?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ; std::move<std::allocator<EntityComponent *> &>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1><std::allocator<std::pair<RigidBody *,int> > const &>
PUBLIC	??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char const >
PUBLIC	??$forward@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@0@AAV10@@Z ; std::forward<std::vector<EntityComponent *,std::allocator<EntityComponent *> > >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<EntityComponent *> > &>
PUBLIC	??$construct@PAVEntityComponent@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>
PUBLIC	??$construct@PAVEntityComponent@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>
PUBLIC	??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z ; std::addressof<EntityComponent * const>
PUBLIC	??$forward@V?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@0@AAV10@@Z ; std::forward<std::vector<Entity *,std::allocator<Entity *> > >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<Entity *> > &>
PUBLIC	??$construct@PAVEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * const &>
PUBLIC	??$construct@PAVEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * &>
PUBLIC	??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z ; std::addressof<Entity * const>
PUBLIC	??$addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@@Z ; std::addressof<std::pair<RigidBody *,int> >
PUBLIC	??$forward@PAVRigidBody@@@std@@YA$$QAPAVRigidBody@@AAPAV1@@Z ; std::forward<RigidBody *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z ; std::vector<Entity *,std::allocator<Entity *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z ; std::operator!=<void __cdecl(RigidBody *)>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z	; Matrix4<float>::Matrix4<float><4>
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator@PAVEntityComponent@@@std@@QBEIXZ ; std::allocator<EntityComponent *>::max_size
PUBLIC	?max_size@?$allocator@PAVEntity@@@std@@QBEIXZ	; std::allocator<Entity *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?allocate@?$allocator@PAVEntityComponent@@@std@@QAEPAPAVEntityComponent@@I@Z ; std::allocator<EntityComponent *>::allocate
PUBLIC	?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ; std::allocator<Entity *>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ; std::allocator_traits<std::allocator<Entity *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAIABV?$allocator@PAVEntityComponent@@@2@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first
PUBLIC	?_Getspace@?$_Func_class@XPAVRigidBody@@@std@@ABEPBXXZ ; std::_Func_class<void,RigidBody *>::_Getspace
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::allocator<EntityComponent *>::deallocate
PUBLIC	?capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::capacity
PUBLIC	?deallocate@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate
PUBLIC	?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::capacity
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ; std::allocator<std::pair<RigidBody *,int> >::deallocate
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
PUBLIC	?_Local@?$_Func_class@XPAVRigidBody@@@std@@ABE_NXZ ; std::_Func_class<void,RigidBody *>::_Local
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
PUBLIC	?_Unused_capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Unused_capacity
PUBLIC	?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::max_size
PUBLIC	?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEII@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reallocate
PUBLIC	?_Xlen@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xlen
PUBLIC	?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unused_capacity
PUBLIC	?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
PUBLIC	?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Reallocate
PUBLIC	?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Xlen
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getpfirst
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all
PUBLIC	?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Swap_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getpfirst
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all
PUBLIC	?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Swap_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Compat
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second
PUBLIC	?_Destroy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXPAU?$pair@PAVRigidBody@@H@2@0@Z ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Destroy
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Free_proxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Orphan_all
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::deallocate
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Compat
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_second
PUBLIC	?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ ; std::_Func_class<void,RigidBody *>::_Tidy
PUBLIC	?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z ; std::_Func_class<void,RigidBody *>::_Set
PUBLIC	??1?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::~_Vector_val<std::_Simple_types<Entity *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::~_Vector_val<std::_Simple_types<EntityComponent *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::~_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	??0?$Vector3@M@@QAE@MMM@Z			; Vector3<float>::Vector3<float>
PUBLIC	??0?$Vector@M$02@@QAE@XZ			; Vector<float,3>::Vector<float,3>
PUBLIC	??0?$Vector@M$03@@QAE@XZ			; Vector<float,4>::Vector<float,4>
PUBLIC	??A?$Matrix@M$03@@QAEPAMH@Z			; Matrix<float,4>::operator[]
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
PUBLIC	??0?$allocator@PAVEntityComponent@@@std@@QAE@XZ	; std::allocator<EntityComponent *>::allocator<EntityComponent *>
PUBLIC	?_Assign_rv@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Assign_rv
PUBLIC	?_Inside@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBE_NPBQAVEntityComponent@@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Inside
PUBLIC	?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Tidy
PUBLIC	?_Xran@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xran
PUBLIC	?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Orphan_range
PUBLIC	??0?$allocator@PAVEntity@@@std@@QAE@XZ		; std::allocator<Entity *>::allocator<Entity *>
PUBLIC	?_Assign_rv@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Assign_rv
PUBLIC	?_Inside@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBE_NPBQAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Inside
PUBLIC	?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::~_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::~_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAVEntityComponent@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator==
PUBLIC	??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@XZ ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >
PUBLIC	?_Tidy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::~_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myend
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEABU?$pair@PAVRigidBody@@H@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator==
PUBLIC	??0?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ	; std::_Func_class<void,RigidBody *>::_Func_class<void,RigidBody *>
PUBLIC	??1?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ	; std::_Func_class<void,RigidBody *>::~_Func_class<void,RigidBody *>
PUBLIC	?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ ; std::_Func_class<void,RigidBody *>::_Empty
PUBLIC	?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ; std::_Func_class<void,RigidBody *>::_Getimpl
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	??0?$Vector3@M@@QAE@XZ				; Vector3<float>::Vector3<float>
PUBLIC	?GetX@?$Vector3@M@@QBEMXZ			; Vector3<float>::GetX
PUBLIC	?GetY@?$Vector3@M@@QBEMXZ			; Vector3<float>::GetY
PUBLIC	?GetZ@?$Vector3@M@@QBEMXZ			; Vector3<float>::GetZ
PUBLIC	?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ		; Vector3<float>::GetBT
PUBLIC	?GetFT@?$Vector3@M@@SA?AV1@ABVbtVector3@@@Z	; Vector3<float>::GetFT
PUBLIC	??A?$Vector@M$02@@QAEAAMI@Z			; Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$02@@QBEMI@Z			; Vector<float,3>::operator[]
PUBLIC	??0?$Vector4@M@@QAE@XZ				; Vector4<float>::Vector4<float>
PUBLIC	?GetX@?$Vector4@M@@QBEMXZ			; Vector4<float>::GetX
PUBLIC	?GetY@?$Vector4@M@@QBEMXZ			; Vector4<float>::GetY
PUBLIC	?GetZ@?$Vector4@M@@QBEMXZ			; Vector4<float>::GetZ
PUBLIC	?GetW@?$Vector4@M@@QBEMXZ			; Vector4<float>::GetW
PUBLIC	??0?$Matrix4@M@@QAE@XZ				; Matrix4<float>::Matrix4<float>
PUBLIC	??A?$Vector@M$03@@QAEAAMI@Z			; Vector<float,4>::operator[]
PUBLIC	??A?$Vector@M$03@@QBEMI@Z			; Vector<float,4>::operator[]
PUBLIC	?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ		; Matrix<float,4>::InitIdentity
PUBLIC	??A?$Matrix@M$03@@QBEPBMH@Z			; Matrix<float,4>::operator[]
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
PUBLIC	??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
PUBLIC	??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
PUBLIC	?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::begin
PUBLIC	?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::end
PUBLIC	?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
PUBLIC	?at@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::at
PUBLIC	??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
PUBLIC	??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
PUBLIC	?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::push_back
PUBLIC	??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
PUBLIC	??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
PUBLIC	??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
PUBLIC	?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::begin
PUBLIC	?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::end
PUBLIC	?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
PUBLIC	??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
PUBLIC	??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
PUBLIC	?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEAAPAVEntityComponent@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator!=
PUBLIC	??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>
PUBLIC	??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
PUBLIC	??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
PUBLIC	??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::~vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
PUBLIC	?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::begin
PUBLIC	?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::end
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator!=
PUBLIC	??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z ; std::_Func_class<void,RigidBody *>::operator()
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
PUBLIC	?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; Entity::GetComponentsByType
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ ; Entity::GetAllAttached
PUBLIC	?SetEngine@Entity@@QAEXPAVCoreEngine@@@Z	; Entity::SetEngine
PUBLIC	?PostRender@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::PostRender
PUBLIC	?Render@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::Render
PUBLIC	?Update@Entity@@AAEXM@Z				; Entity::Update
PUBLIC	?ProcessInput@Entity@@AAEXABVInput@@M@Z		; Entity::ProcessInput
PUBLIC	?Init@Entity@@AAEXXZ				; Entity::Init
PUBLIC	?PostRenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::PostRenderAll
PUBLIC	?RenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::RenderAll
PUBLIC	?UpdateAll@Entity@@QAEXM@Z			; Entity::UpdateAll
PUBLIC	?ProcessInputAll@Entity@@QAEXABVInput@@M@Z	; Entity::ProcessInputAll
PUBLIC	?InitAll@Entity@@QAEXXZ				; Entity::InitAll
PUBLIC	?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z ; Entity::AddComponents
PUBLIC	?AddComponent@Entity@@QAEPAV1@PAVEntityComponent@@@Z ; Entity::AddComponent
PUBLIC	?AddChild@Entity@@QAEPAV1@PAV1@@Z		; Entity::AddChild
PUBLIC	??1Entity@@UAE@XZ				; Entity::~Entity
PUBLIC	??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z	; Entity::Entity
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
PUBLIC	??_GRigidBody@@UAEPAXI@Z			; RigidBody::`scalar deleting destructor'
PUBLIC	?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ	; RigidBody::GetBody
PUBLIC	?Exit@RigidBody@@QAEXXZ				; RigidBody::Exit
PUBLIC	?Stay@RigidBody@@QAEXXZ				; RigidBody::Stay
PUBLIC	?Update@RigidBody@@UAEXM@Z			; RigidBody::Update
PUBLIC	?Init@RigidBody@@UAEXXZ				; RigidBody::Init
PUBLIC	?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z ; RigidBody::DataDeploy
PUBLIC	??1RigidBody@@UAE@XZ				; RigidBody::~RigidBody
PUBLIC	??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z ; RigidBody::RigidBody
PUBLIC	?__ClassType__@RigidBody@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; RigidBody::__ClassType__
PUBLIC	?SetSimulation@CoreEngine@@QAEX_N@Z		; CoreEngine::SetSimulation
PUBLIC	?GetCoreEngine@CoreEngine@@SAPAV1@XZ		; CoreEngine::GetCoreEngine
PUBLIC	?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ ; CoreEngine::GetPhysicsEngine
PUBLIC	?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ ; PhysicsEngine::GetWorld
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_GEntityComponent@@UAEPAXI@Z			; EntityComponent::`scalar deleting destructor'
PUBLIC	?SetParent@EntityComponent@@UAEXPAVEntity@@@Z	; EntityComponent::SetParent
PUBLIC	?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
PUBLIC	?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z ; EntityComponent::AddToEngine
PUBLIC	?DataDeploy@EntityComponent@@UAEXPAVXMLElement@tinyxml2@@@Z ; EntityComponent::DataDeploy
PUBLIC	?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; EntityComponent::PostRender
PUBLIC	?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; EntityComponent::Render
PUBLIC	?Update@EntityComponent@@UAEXM@Z		; EntityComponent::Update
PUBLIC	?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z ; EntityComponent::ProcessInput
PUBLIC	?Init@EntityComponent@@UAEXXZ			; EntityComponent::Init
PUBLIC	?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; EntityComponent::_GetClassName_
PUBLIC	??1EntityComponent@@UAE@XZ			; EntityComponent::~EntityComponent
PUBLIC	??0EntityComponent@@QAE@XZ			; EntityComponent::EntityComponent
PUBLIC	?__ClassType__@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; EntityComponent::__ClassType__
PUBLIC	??_GEntity@@UAEPAXI@Z				; Entity::`scalar deleting destructor'
PUBLIC	?SetParent@Entity@@QAEXPAV1@@Z			; Entity::SetParent
PUBLIC	?GetTransform@Entity@@QAEPAVTransform@@XZ	; Entity::GetTransform
PUBLIC	?SetParent@Transform@@QAEXPAV1@@Z		; Transform::SetParent
PUBLIC	?SetRot@Transform@@QAEXABVQuaternion@@@Z	; Transform::SetRot
PUBLIC	?SetPos@Transform@@QAEXABVVector3f@@@Z		; Transform::SetPos
PUBLIC	?GetBT@Transform@@QAE?AVbtTransform@@XZ		; Transform::GetBT
PUBLIC	?GetScale@Transform@@QBEMXZ			; Transform::GetScale
PUBLIC	?GetRot@Transform@@QAEPAVQuaternion@@XZ		; Transform::GetRot
PUBLIC	?GetPos@Transform@@QAEPAVVector3f@@XZ		; Transform::GetPos
PUBLIC	??0Transform@@QAE@ABVVector3f@@ABVQuaternion@@M@Z ; Transform::Transform
PUBLIC	?GetFT@Quaternion@@SA?AV1@ABVbtQuaternion@@@Z	; Quaternion::GetFT
PUBLIC	?GetBT@Quaternion@@QBE?AVbtQuaternion@@XZ	; Quaternion::GetBT
PUBLIC	??0Quaternion@@QAE@MMMM@Z			; Quaternion::Quaternion
PUBLIC	??0Vector3f@@QAE@ABV?$Vector3@M@@@Z		; Vector3f::Vector3f
PUBLIC	??0Vector3f@@QAE@MMM@Z				; Vector3f::Vector3f
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z	; std::_Container_base12::_Swap_all
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?getMotionState@btRigidBody@@QAEPAVbtMotionState@@XZ ; btRigidBody::getMotionState
PUBLIC	??0btRigidBodyConstructionInfo@btRigidBody@@QAE@MPAVbtMotionState@@PAVbtCollisionShape@@ABVbtVector3@@@Z ; btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo
PUBLIC	??0btMotionState@@QAE@XZ			; btMotionState::btMotionState
PUBLIC	??1btDefaultMotionState@@UAE@XZ			; btDefaultMotionState::~btDefaultMotionState
PUBLIC	??_GbtDefaultMotionState@@UAEPAXI@Z		; btDefaultMotionState::`scalar deleting destructor'
PUBLIC	?setWorldTransform@btDefaultMotionState@@UAEXABVbtTransform@@@Z ; btDefaultMotionState::setWorldTransform
PUBLIC	?getWorldTransform@btDefaultMotionState@@UBEXAAVbtTransform@@@Z ; btDefaultMotionState::getWorldTransform
PUBLIC	??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z ; btDefaultMotionState::btDefaultMotionState
PUBLIC	??3btDefaultMotionState@@SAXPAX@Z		; btDefaultMotionState::operator delete
PUBLIC	??2btDefaultMotionState@@SAPAXI@Z		; btDefaultMotionState::operator new
PUBLIC	??3btBvhTriangleMeshShape@@SAXPAX@Z		; btBvhTriangleMeshShape::operator delete
PUBLIC	??2btBvhTriangleMeshShape@@SAPAXI@Z		; btBvhTriangleMeshShape::operator new
PUBLIC	??3btConvexTriangleMeshShape@@SAXPAX@Z		; btConvexTriangleMeshShape::operator delete
PUBLIC	??2btConvexTriangleMeshShape@@SAPAXI@Z		; btConvexTriangleMeshShape::operator new
PUBLIC	??3btCylinderShape@@SAXPAX@Z			; btCylinderShape::operator delete
PUBLIC	??2btCylinderShape@@SAPAXI@Z			; btCylinderShape::operator new
PUBLIC	??3btCapsuleShape@@SAXPAX@Z			; btCapsuleShape::operator delete
PUBLIC	??2btCapsuleShape@@SAPAXI@Z			; btCapsuleShape::operator new
PUBLIC	??1btSphereShape@@UAE@XZ			; btSphereShape::~btSphereShape
PUBLIC	??_GbtSphereShape@@UAEPAXI@Z			; btSphereShape::`scalar deleting destructor'
PUBLIC	?getMargin@btSphereShape@@UBEMXZ		; btSphereShape::getMargin
PUBLIC	?setMargin@btSphereShape@@UAEXM@Z		; btSphereShape::setMargin
PUBLIC	?getName@btSphereShape@@UBEPBDXZ		; btSphereShape::getName
PUBLIC	?getRadius@btSphereShape@@QBEMXZ		; btSphereShape::getRadius
PUBLIC	??0btSphereShape@@QAE@M@Z			; btSphereShape::btSphereShape
PUBLIC	??3btSphereShape@@SAXPAX@Z			; btSphereShape::operator delete
PUBLIC	??2btSphereShape@@SAPAXI@Z			; btSphereShape::operator new
PUBLIC	??3btBoxShape@@SAXPAX@Z				; btBoxShape::operator delete
PUBLIC	??2btBoxShape@@SAPAXI@Z				; btBoxShape::operator new
PUBLIC	?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z ; btConvexInternalShape::serialize
PUBLIC	?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ ; btConvexInternalShape::calculateSerializeBufferSize
PUBLIC	??_GbtConvexInternalShape@@UAEPAXI@Z		; btConvexInternalShape::`scalar deleting destructor'
PUBLIC	?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z ; btConvexInternalShape::getPreferredPenetrationDirection
PUBLIC	?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ ; btConvexInternalShape::getNumPreferredPenetrationDirections
PUBLIC	?getMargin@btConvexInternalShape@@UBEMXZ	; btConvexInternalShape::getMargin
PUBLIC	?setMargin@btConvexInternalShape@@UAEXM@Z	; btConvexInternalShape::setMargin
PUBLIC	?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ ; btConvexInternalShape::getLocalScaling
PUBLIC	?getAabb@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z ; btConvexInternalShape::getAabb
PUBLIC	??1btConvexInternalShape@@UAE@XZ		; btConvexInternalShape::~btConvexInternalShape
PUBLIC	??3btConvexInternalShape@@SAXPAX@Z		; btConvexInternalShape::operator delete
PUBLIC	?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ ; btCollisionShape::getAnisotropicRollingFrictionDirection
PUBLIC	?setUserPointer@btCollisionObject@@QAEXPAX@Z	; btCollisionObject::setUserPointer
PUBLIC	?setCollisionFlags@btCollisionObject@@QAEXH@Z	; btCollisionObject::setCollisionFlags
PUBLIC	?getCollisionFlags@btCollisionObject@@QBEHXZ	; btCollisionObject::getCollisionFlags
PUBLIC	??3btCollisionObject@@SAXPAX@Z			; btCollisionObject::operator delete
PUBLIC	??2btCollisionObject@@SAPAXI@Z			; btCollisionObject::operator new
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??_GbtMotionState@@UAEPAXI@Z			; btMotionState::`scalar deleting destructor'
PUBLIC	??1btMotionState@@UAE@XZ			; btMotionState::~btMotionState
PUBLIC	??DbtTransform@@QBE?AV0@ABV0@@Z			; btTransform::operator*
PUBLIC	?getIdentity@btTransform@@SAABV1@XZ		; btTransform::getIdentity
PUBLIC	?inverse@btTransform@@QBE?AV1@XZ		; btTransform::inverse
PUBLIC	?setIdentity@btTransform@@QAEXXZ		; btTransform::setIdentity
PUBLIC	?getRotation@btTransform@@QBE?AVbtQuaternion@@XZ ; btTransform::getRotation
PUBLIC	?getOrigin@btTransform@@QAEAAVbtVector3@@XZ	; btTransform::getOrigin
PUBLIC	??RbtTransform@@QBE?AVbtVector3@@ABV1@@Z	; btTransform::operator()
PUBLIC	??4btTransform@@QAEAAV0@ABV0@@Z			; btTransform::operator=
PUBLIC	??0btTransform@@QAE@ABV0@@Z			; btTransform::btTransform
PUBLIC	??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z ; btTransform::btTransform
PUBLIC	??0btTransform@@QAE@ABVbtQuaternion@@ABVbtVector3@@@Z ; btTransform::btTransform
PUBLIC	??0btTransform@@QAE@XZ				; btTransform::btTransform
PUBLIC	??D@YA?AVbtMatrix3x3@@ABV0@0@Z			; operator*
PUBLIC	??D@YA?AVbtVector3@@ABVbtMatrix3x3@@ABV0@@Z	; operator*
PUBLIC	?transpose@btMatrix3x3@@QBE?AV1@XZ		; btMatrix3x3::transpose
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z	; btMatrix3x3::tdotz
PUBLIC	?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z	; btMatrix3x3::tdoty
PUBLIC	?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z	; btMatrix3x3::tdotx
PUBLIC	?getRotation@btMatrix3x3@@QBEXAAVbtQuaternion@@@Z ; btMatrix3x3::getRotation
PUBLIC	?getIdentity@btMatrix3x3@@SAABV1@XZ		; btMatrix3x3::getIdentity
PUBLIC	?setIdentity@btMatrix3x3@@QAEXXZ		; btMatrix3x3::setIdentity
PUBLIC	?setRotation@btMatrix3x3@@QAEXABVbtQuaternion@@@Z ; btMatrix3x3::setRotation
PUBLIC	?setValue@btMatrix3x3@@QAEXABM00000000@Z	; btMatrix3x3::setValue
PUBLIC	??AbtMatrix3x3@@QBEABVbtVector3@@H@Z		; btMatrix3x3::operator[]
PUBLIC	??4btMatrix3x3@@QAEAAV0@ABV0@@Z			; btMatrix3x3::operator=
PUBLIC	??0btMatrix3x3@@QAE@ABV0@@Z			; btMatrix3x3::btMatrix3x3
PUBLIC	??0btMatrix3x3@@QAE@ABM00000000@Z		; btMatrix3x3::btMatrix3x3
PUBLIC	??0btMatrix3x3@@QAE@ABVbtQuaternion@@@Z		; btMatrix3x3::btMatrix3x3
PUBLIC	??0btMatrix3x3@@QAE@XZ				; btMatrix3x3::btMatrix3x3
PUBLIC	?getW@btQuaternion@@QBEABMXZ			; btQuaternion::getW
PUBLIC	?length2@btQuaternion@@QBEMXZ			; btQuaternion::length2
PUBLIC	?dot@btQuaternion@@QBEMABV1@@Z			; btQuaternion::dot
PUBLIC	??0btQuaternion@@QAE@ABM000@Z			; btQuaternion::btQuaternion
PUBLIC	??0btQuaternion@@QAE@XZ				; btQuaternion::btQuaternion
PUBLIC	??0btQuadWord@@QAE@ABM000@Z			; btQuadWord::btQuadWord
PUBLIC	??0btQuadWord@@QAE@XZ				; btQuadWord::btQuadWord
PUBLIC	?setValue@btQuadWord@@QAEXABM000@Z		; btQuadWord::setValue
PUBLIC	?w@btQuadWord@@QBEABMXZ				; btQuadWord::w
PUBLIC	?z@btQuadWord@@QBEABMXZ				; btQuadWord::z
PUBLIC	?y@btQuadWord@@QBEABMXZ				; btQuadWord::y
PUBLIC	?x@btQuadWord@@QBEABMXZ				; btQuadWord::x
PUBLIC	?getZ@btQuadWord@@QBEABMXZ			; btQuadWord::getZ
PUBLIC	?getY@btQuadWord@@QBEABMXZ			; btQuadWord::getY
PUBLIC	?getX@btQuadWord@@QBEABMXZ			; btQuadWord::getX
PUBLIC	?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z ; btVector3::serializeFloat
PUBLIC	??G@YA?AVbtVector3@@ABV0@@Z			; operator-
PUBLIC	??H@YA?AVbtVector3@@ABV0@0@Z			; operator+
PUBLIC	?dot3@btVector3@@QBE?AV1@ABV1@00@Z		; btVector3::dot3
PUBLIC	?setValue@btVector3@@QAEXABM00@Z		; btVector3::setValue
PUBLIC	??9btVector3@@QBE_NABV0@@Z			; btVector3::operator!=
PUBLIC	??8btVector3@@QBE_NABV0@@Z			; btVector3::operator==
PUBLIC	??BbtVector3@@QBEPBMXZ				; btVector3::operator float const *
PUBLIC	?z@btVector3@@QBEABMXZ				; btVector3::z
PUBLIC	?y@btVector3@@QBEABMXZ				; btVector3::y
PUBLIC	?x@btVector3@@QBEABMXZ				; btVector3::x
PUBLIC	?setX@btVector3@@QAEXM@Z			; btVector3::setX
PUBLIC	?getZ@btVector3@@QBEABMXZ			; btVector3::getZ
PUBLIC	?getY@btVector3@@QBEABMXZ			; btVector3::getY
PUBLIC	?getX@btVector3@@QBEABMXZ			; btVector3::getX
PUBLIC	?dot@btVector3@@QBEMABV1@@Z			; btVector3::dot
PUBLIC	??0btVector3@@QAE@ABM00@Z			; btVector3::btVector3
PUBLIC	??0btVector3@@QAE@XZ				; btVector3::btVector3
PUBLIC	?btSqrt@@YAMM@Z					; btSqrt
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	_sqrtf
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@37a7c5ac
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c888889
PUBLIC	__real@3c8efa35
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e000000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f3504f3
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@403de44e
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4066800000000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41f00000
PUBLIC	__real@42a00000
PUBLIC	__real@42c80000
PUBLIC	__real@43160000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@447a0000
PUBLIC	__real@46180000
PUBLIC	__real@46180400
PUBLIC	__real@461c0000
PUBLIC	__real@461c0400
PUBLIC	__real@461c0800
PUBLIC	__real@461c0c00
PUBLIC	__real@47012f00
PUBLIC	__real@bf800000
PUBLIC	__real@bfc90fdb
PUBLIC	__real@c0000000
PUBLIC	__real@c0490fdb
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_EbtDefaultMotionState@@UAEPAXI@Z:PROC	; btDefaultMotionState::`vector deleting destructor'
EXTRN	??_EEntity@@UAEPAXI@Z:PROC			; Entity::`vector deleting destructor'
EXTRN	??_EEntityComponent@@UAEPAXI@Z:PROC		; EntityComponent::`vector deleting destructor'
EXTRN	??_EbtMotionState@@UAEPAXI@Z:PROC		; btMotionState::`vector deleting destructor'
EXTRN	??_ERigidBody@@UAEPAXI@Z:PROC			; RigidBody::`vector deleting destructor'
EXTRN	??_EbtSphereShape@@UAEPAXI@Z:PROC		; btSphereShape::`vector deleting destructor'
EXTRN	??_EbtConvexInternalShape@@UAEPAXI@Z:PROC	; btConvexInternalShape::`vector deleting destructor'
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ltod3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bfc90fdb
CONST	SEGMENT
__real@bfc90fdb DD 0bfc90fdbr			; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47012f00
CONST	SEGMENT
__real@47012f00 DD 047012f00r			; 33071
CONST	ENDS
;	COMDAT __real@461c0c00
CONST	SEGMENT
__real@461c0c00 DD 0461c0c00r			; 9987
CONST	ENDS
;	COMDAT __real@461c0800
CONST	SEGMENT
__real@461c0800 DD 0461c0800r			; 9986
CONST	ENDS
;	COMDAT __real@461c0400
CONST	SEGMENT
__real@461c0400 DD 0461c0400r			; 9985
CONST	ENDS
;	COMDAT __real@461c0000
CONST	SEGMENT
__real@461c0000 DD 0461c0000r			; 9984
CONST	ENDS
;	COMDAT __real@46180400
CONST	SEGMENT
__real@46180400 DD 046180400r			; 9729
CONST	ENDS
;	COMDAT __real@46180000
CONST	SEGMENT
__real@46180000 DD 046180000r			; 9728
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@403de44e
CONST	SEGMENT
__real@403de44e DD 0403de44er			; 2.96706
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f3504f3
CONST	SEGMENT
__real@3f3504f3 DD 03f3504f3r			; 0.707107
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c888889
CONST	SEGMENT
__real@3c888889 DD 03c888889r			; 0.0166667
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3c000000
CONST	SEGMENT
__real@3c000000 DD 03c000000r			; 0.0078125
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@37a7c5ac
CONST	SEGMENT
__real@37a7c5ac DD 037a7c5acr			; 2e-05
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getIdentity@btMatrix3x3@@SAABV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getIdentity@btMatrix3x3@@SAABV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getIdentity@btMatrix3x3@@SAABV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getIdentity@btMatrix3x3@@SAABV1@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getIdentity@btTransform@@SAABV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getIdentity@btTransform@@SAABV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getIdentity@btTransform@@SAABV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getIdentity@btTransform@@SAABV1@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btCollisionObject@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btConvexInternalShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btBoxShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btSphereShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0btSphereShape@@QAE@M@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0btSphereShape@@QAE@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0btSphereShape@@QAE@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0btSphereShape@@QAE@M@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btCapsuleShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btCylinderShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btConvexTriangleMeshShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btBvhTriangleMeshShape@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3btDefaultMotionState@@SAXPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Container_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1RigidBody@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$9
	DD	0bH
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Init@RigidBody@@UAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Init@RigidBody@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Init@RigidBody@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@RigidBody@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@RigidBody@@UAEXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Stay@RigidBody@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Stay@RigidBody@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Stay@RigidBody@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Stay@RigidBody@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Stay@RigidBody@@QAEXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Exit@RigidBody@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Exit@RigidBody@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Exit@RigidBody@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Exit@RigidBody@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Exit@RigidBody@@QAEXXZ$1
xdata$x	ENDS
xdata$x	SEGMENT
__ehfuncinfo$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$3
__ehfuncinfo$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$4
__ehfuncinfo$?Init@Entity@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Init@Entity@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Init@Entity@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@Entity@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Init@Entity@@AAEXXZ$1
__ehfuncinfo$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z$0
__ehfuncinfo$??1Entity@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 05H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$13
__unwindtable$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$7
	DD	02H
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$9
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$11
__catchsym$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z$0
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 746  :         return (float)sqrt(_X);

  0000c	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00011	8b f4		 mov	 esi, esp
  00013	83 ec 08	 sub	 esp, 8
  00016	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sqrt
  00021	83 c4 08	 add	 esp, 8
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	d9 5d fc	 fstp	 DWORD PTR tv73[ebp]
  0002e	d9 45 fc	 fld	 DWORD PTR tv73[ebp]

; 747  :     }

  00031	5e		 pop	 esi
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 640  : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  00015	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
  0001a	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00029	52		 push	 edx
  0002a	8b f4		 mov	 esi, esp
  0002c	6a 01		 push	 1
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __vfprintf_l
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 955  :     __crt_va_end(_ArgList);

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 956  :     return _Result;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 957  : }

  00054	5e		 pop	 esi
  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btscalar.h
;	COMDAT ?btSqrt@@YAMM@Z
_TEXT	SEGMENT
_y$ = 8							; size = 4
?btSqrt@@YAMM@Z PROC					; btSqrt, COMDAT

; 419  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  : #ifdef USE_APPROXIMATION
; 421  : #ifdef __LP64__
; 422  :     float xhalf = 0.5f*y;
; 423  :     int i = *(int*)&y;
; 424  :     i = 0x5f375a86 - (i>>1);
; 425  :     y = *(float*)&i;
; 426  :     y = y*(1.5f - xhalf*y*y);
; 427  :     y = y*(1.5f - xhalf*y*y);
; 428  :     y = y*(1.5f - xhalf*y*y);
; 429  :     y=1/y;
; 430  :     return y;
; 431  : #else
; 432  :     double x, z, tempf;
; 433  :     unsigned long *tfptr = ((unsigned long *)&tempf) + 1;
; 434  :     tempf = y;
; 435  :     *tfptr = (0xbfcdd90a - *tfptr)>>1; /* estimate of 1/sqrt(y) */
; 436  :     x =  tempf;
; 437  :     z =  y*btScalar(0.5);
; 438  :     x = (btScalar(1.5)*x)-(x*x)*(x*z);         /* iteration formula     */
; 439  :     x = (btScalar(1.5)*x)-(x*x)*(x*z);
; 440  :     x = (btScalar(1.5)*x)-(x*x)*(x*z);
; 441  :     x = (btScalar(1.5)*x)-(x*x)*(x*z);
; 442  :     x = (btScalar(1.5)*x)-(x*x)*(x*z);
; 443  :     return x*y;
; 444  : #endif
; 445  : #else
; 446  : 	return sqrtf(y); 

  00003	51		 push	 ecx
  00004	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _y$[ebp]
  00009	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0000e	e8 00 00 00 00	 call	 _sqrtf
  00013	83 c4 04	 add	 esp, 4

; 447  : #endif
; 448  : }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?btSqrt@@YAMM@Z ENDP					; btSqrt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??0btVector3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btVector3@@QAE@XZ PROC				; btVector3::btVector3, COMDAT
; _this$ = ecx

; 119  : 	SIMD_FORCE_INLINE btVector3() 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	{
; 121  : 
; 122  : 	}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0btVector3@@QAE@XZ ENDP				; btVector3::btVector3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??0btVector3@@QAE@ABM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0btVector3@@QAE@ABM00@Z PROC				; btVector3::btVector3, COMDAT
; _this$ = ecx

; 131  : 	SIMD_FORCE_INLINE btVector3(const btScalar& _x, const btScalar& _y, const btScalar& _z)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 	{
; 133  : 		m_floats[0] = _x;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __x$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 134  : 		m_floats[1] = _y;

  00021	b9 04 00 00 00	 mov	 ecx, 4
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __y$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 135  : 		m_floats[2] = _z;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	d1 e1		 shl	 ecx, 1
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR __z$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 136  : 		m_floats[3] = btScalar(0.f);

  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	6b d1 03	 imul	 edx, ecx, 3
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00059	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 137  : 	}

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
??0btVector3@@QAE@ABM00@Z ENDP				; btVector3::btVector3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?dot@btVector3@@QBEMABV1@@Z
_TEXT	SEGMENT
tv135 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?dot@btVector3@@QBEMABV1@@Z PROC			; btVector3::dot, COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : #if defined BT_USE_SIMD_VECTOR3 && defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 238  : 		__m128 vd = _mm_mul_ps(mVec128, v.mVec128);
; 239  : 		__m128 z = _mm_movehl_ps(vd, vd);
; 240  : 		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
; 241  : 		vd = _mm_add_ss(vd, y);
; 242  : 		vd = _mm_add_ss(vd, z);
; 243  : 		return _mm_cvtss_f32(vd);
; 244  : #elif defined(BT_USE_NEON)
; 245  : 		float32x4_t vd = vmulq_f32(mVec128, v.mVec128);
; 246  : 		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_low_f32(vd));  
; 247  : 		x = vadd_f32(x, vget_high_f32(vd));
; 248  : 		return vget_lane_f32(x, 0);
; 249  : #else	
; 250  : 		return	m_floats[0] * v.m_floats[0] + 

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	6b c8 00	 imul	 ecx, eax, 0
  00020	ba 04 00 00 00	 mov	 edx, 4
  00025	6b c2 00	 imul	 eax, edx, 0
  00028	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  0002e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00033	f3 0f 59 04 06	 mulss	 xmm0, DWORD PTR [esi+eax]
  00038	b8 04 00 00 00	 mov	 eax, 4
  0003d	c1 e0 00	 shl	 eax, 0
  00040	b9 04 00 00 00	 mov	 ecx, 4
  00045	c1 e1 00	 shl	 ecx, 0
  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  0004e	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00053	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00058	f3 0f 58 c1	 addss	 xmm0, xmm1
  0005c	b8 04 00 00 00	 mov	 eax, 4
  00061	d1 e0		 shl	 eax, 1
  00063	b9 04 00 00 00	 mov	 ecx, 4
  00068	d1 e1		 shl	 ecx, 1
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  00070	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00075	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  0007a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0007e	f3 0f 11 45 f8	 movss	 DWORD PTR tv135[ebp], xmm0
  00083	d9 45 f8	 fld	 DWORD PTR tv135[ebp]

; 251  : 				m_floats[1] * v.m_floats[1] + 
; 252  : 				m_floats[2] * v.m_floats[2];
; 253  : #endif
; 254  : 	}

  00086	5e		 pop	 esi
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?dot@btVector3@@QBEMABV1@@Z ENDP			; btVector3::dot
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?getX@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@btVector3@@QBEABMXZ PROC				; btVector3::getX, COMDAT
; _this$ = ecx

; 561  : 		SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 00	 imul	 eax, eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?getX@btVector3@@QBEABMXZ ENDP				; btVector3::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?getY@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@btVector3@@QBEABMXZ PROC				; btVector3::getY, COMDAT
; _this$ = ecx

; 563  : 		SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	c1 e0 00	 shl	 eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?getY@btVector3@@QBEABMXZ ENDP				; btVector3::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?getZ@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getZ@btVector3@@QBEABMXZ PROC				; btVector3::getZ, COMDAT
; _this$ = ecx

; 565  : 		SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	d1 e0		 shl	 eax, 1
  00015	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?getZ@btVector3@@QBEABMXZ ENDP				; btVector3::getZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?setX@btVector3@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
?setX@btVector3@@QAEXM@Z PROC				; btVector3::setX, COMDAT
; _this$ = ecx

; 567  : 		SIMD_FORCE_INLINE void	setX(btScalar _x) { m_floats[0] = _x;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  0001e	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?setX@btVector3@@QAEXM@Z ENDP				; btVector3::setX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?x@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?x@btVector3@@QBEABMXZ PROC				; btVector3::x, COMDAT
; _this$ = ecx

; 575  : 		SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 00	 imul	 eax, eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?x@btVector3@@QBEABMXZ ENDP				; btVector3::x
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?y@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?y@btVector3@@QBEABMXZ PROC				; btVector3::y, COMDAT
; _this$ = ecx

; 577  : 		SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	c1 e0 00	 shl	 eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?y@btVector3@@QBEABMXZ ENDP				; btVector3::y
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?z@btVector3@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?z@btVector3@@QBEABMXZ PROC				; btVector3::z, COMDAT
; _this$ = ecx

; 579  : 		SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	d1 e0		 shl	 eax, 1
  00015	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?z@btVector3@@QBEABMXZ ENDP				; btVector3::z
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??BbtVector3@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BbtVector3@@QBEPBMXZ PROC				; btVector3::operator float const *, COMDAT
; _this$ = ecx

; 587  : 	SIMD_FORCE_INLINE	operator const btScalar *() const { return &m_floats[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 00	 imul	 eax, eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??BbtVector3@@QBEPBMXZ ENDP				; btVector3::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??8btVector3@@QBE_NABV0@@Z
_TEXT	SEGMENT
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??8btVector3@@QBE_NABV0@@Z PROC				; btVector3::operator==, COMDAT
; _this$ = ecx

; 590  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : #if defined(BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 592  :         return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
; 593  : #else 
; 594  : 		return ((m_floats[3]==other.m_floats[3]) && 

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	6b c8 03	 imul	 ecx, eax, 3
  00020	ba 04 00 00 00	 mov	 edx, 4
  00025	6b c2 03	 imul	 eax, edx, 3
  00028	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 75 08	 mov	 esi, DWORD PTR _other$[ebp]
  0002e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00033	0f 2e 04 06	 ucomiss xmm0, DWORD PTR [esi+eax]
  00037	9f		 lahf
  00038	f6 c4 44	 test	 ah, 68			; 00000044H
  0003b	7a 76		 jp	 SHORT $LN3@operator
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	d1 e0		 shl	 eax, 1
  00044	b9 04 00 00 00	 mov	 ecx, 4
  00049	d1 e1		 shl	 ecx, 1
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 75 08	 mov	 esi, DWORD PTR _other$[ebp]
  00051	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00056	0f 2e 04 0e	 ucomiss xmm0, DWORD PTR [esi+ecx]
  0005a	9f		 lahf
  0005b	f6 c4 44	 test	 ah, 68			; 00000044H
  0005e	7a 53		 jp	 SHORT $LN3@operator
  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	c1 e0 00	 shl	 eax, 0
  00068	b9 04 00 00 00	 mov	 ecx, 4
  0006d	c1 e1 00	 shl	 ecx, 0
  00070	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00073	8b 75 08	 mov	 esi, DWORD PTR _other$[ebp]
  00076	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  0007b	0f 2e 04 0e	 ucomiss xmm0, DWORD PTR [esi+ecx]
  0007f	9f		 lahf
  00080	f6 c4 44	 test	 ah, 68			; 00000044H
  00083	7a 2e		 jp	 SHORT $LN3@operator
  00085	b8 04 00 00 00	 mov	 eax, 4
  0008a	6b c8 00	 imul	 ecx, eax, 0
  0008d	ba 04 00 00 00	 mov	 edx, 4
  00092	6b c2 00	 imul	 eax, edx, 0
  00095	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00098	8b 75 08	 mov	 esi, DWORD PTR _other$[ebp]
  0009b	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000a0	0f 2e 04 06	 ucomiss xmm0, DWORD PTR [esi+eax]
  000a4	9f		 lahf
  000a5	f6 c4 44	 test	 ah, 68			; 00000044H
  000a8	7a 09		 jp	 SHORT $LN3@operator
  000aa	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  000b1	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  000b3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN4@operator:
  000ba	8a 45 f8	 mov	 al, BYTE PTR tv92[ebp]

; 595  :                 (m_floats[2]==other.m_floats[2]) && 
; 596  :                 (m_floats[1]==other.m_floats[1]) && 
; 597  :                 (m_floats[0]==other.m_floats[0]));
; 598  : #endif
; 599  : 	}

  000bd	5e		 pop	 esi
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
??8btVector3@@QBE_NABV0@@Z ENDP				; btVector3::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??9btVector3@@QBE_NABV0@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??9btVector3@@QBE_NABV0@@Z PROC				; btVector3::operator!=, COMDAT
; _this$ = ecx

; 602  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 		return !(*this == other);

  00017	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??8btVector3@@QBE_NABV0@@Z ; btVector3::operator==
  00023	0f b6 c8	 movzx	 ecx, al
  00026	85 c9		 test	 ecx, ecx
  00028	75 09		 jne	 SHORT $LN3@operator
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0003a	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 604  : 	}

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??9btVector3@@QBE_NABV0@@Z ENDP				; btVector3::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?setValue@btVector3@@QAEXABM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
?setValue@btVector3@@QAEXABM00@Z PROC			; btVector3::setValue, COMDAT
; _this$ = ecx

; 641  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 		m_floats[0]=_x;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __x$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 643  : 		m_floats[1]=_y;

  00021	b9 04 00 00 00	 mov	 ecx, 4
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __y$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 644  : 		m_floats[2]=_z;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	d1 e1		 shl	 ecx, 1
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR __z$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 645  : 		m_floats[3] = btScalar(0.f);

  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	6b d1 03	 imul	 edx, ecx, 3
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00059	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 646  : 	}

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
?setValue@btVector3@@QAEXABM00@Z ENDP			; btVector3::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?dot3@btVector3@@QBE?AV1@ABV1@00@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v0$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
?dot3@btVector3@@QBE?AV1@ABV1@00@Z PROC			; btVector3::dot3, COMDAT
; _this$ = ecx

; 720  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 721  : #if defined BT_USE_SIMD_VECTOR3 && defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 722  : 
; 723  :         __m128 a0 = _mm_mul_ps( v0.mVec128, this->mVec128 );
; 724  :         __m128 a1 = _mm_mul_ps( v1.mVec128, this->mVec128 );
; 725  :         __m128 a2 = _mm_mul_ps( v2.mVec128, this->mVec128 );
; 726  :         __m128 b0 = _mm_unpacklo_ps( a0, a1 );
; 727  :         __m128 b1 = _mm_unpackhi_ps( a0, a1 );
; 728  :         __m128 b2 = _mm_unpacklo_ps( a2, _mm_setzero_ps() );
; 729  :         __m128 r = _mm_movelh_ps( b0, b2 );
; 730  :         r = _mm_add_ps( r, _mm_movehl_ps( b2, b0 ));
; 731  :         a2 = _mm_and_ps( a2, btvxyzMaskf);
; 732  :         r = _mm_add_ps( r, btCastdTo128f (_mm_move_sd( btCastfTo128d(a2), btCastfTo128d(b1) )));
; 733  :         return btVector3(r);
; 734  :         
; 735  : #elif defined(BT_USE_NEON)
; 736  :         static const uint32x4_t xyzMask = (const uint32x4_t){ static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0 };
; 737  :         float32x4_t a0 = vmulq_f32( v0.mVec128, this->mVec128);
; 738  :         float32x4_t a1 = vmulq_f32( v1.mVec128, this->mVec128);
; 739  :         float32x4_t a2 = vmulq_f32( v2.mVec128, this->mVec128);
; 740  :         float32x2x2_t zLo = vtrn_f32( vget_high_f32(a0), vget_high_f32(a1));
; 741  :         a2 = (float32x4_t) vandq_u32((uint32x4_t) a2, xyzMask );
; 742  :         float32x2_t b0 = vadd_f32( vpadd_f32( vget_low_f32(a0), vget_low_f32(a1)), zLo.val[0] );
; 743  :         float32x2_t b1 = vpadd_f32( vpadd_f32( vget_low_f32(a2), vget_high_f32(a2)), vdup_n_f32(0.0f));
; 744  :         return btVector3( vcombine_f32(b0, b1) );
; 745  : #else	
; 746  : 		return btVector3( dot(v0), dot(v1), dot(v2));

  0001a	8b 45 14	 mov	 eax, DWORD PTR _v2$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00026	d9 5d f8	 fstp	 DWORD PTR $T3[ebp]
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _v1$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00035	d9 5d f4	 fstp	 DWORD PTR $T2[ebp]
  00038	8b 55 0c	 mov	 edx, DWORD PTR _v0$[ebp]
  0003b	52		 push	 edx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00044	d9 5d f0	 fstp	 DWORD PTR $T1[ebp]
  00047	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  0004a	50		 push	 eax
  0004b	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  0004e	51		 push	 ecx
  0004f	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00052	52		 push	 edx
  00053	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00056	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  0005b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 747  : #endif
; 748  :     }

  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 10 00	 ret	 16			; 00000010H
?dot3@btVector3@@QBE?AV1@ABV1@00@Z ENDP			; btVector3::dot3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??H@YA?AVbtVector3@@ABV0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??H@YA?AVbtVector3@@ABV0@0@Z PROC			; operator+, COMDAT

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 755  : #if defined(BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 756  : 	return btVector3(_mm_add_ps(v1.mVec128, v2.mVec128));
; 757  : #elif defined(BT_USE_NEON)
; 758  : 	return btVector3(vaddq_f32(v1.mVec128, v2.mVec128));
; 759  : #else
; 760  : 	return btVector3(

  0001c	b8 04 00 00 00	 mov	 eax, 4
  00021	d1 e0		 shl	 eax, 1
  00023	b9 04 00 00 00	 mov	 ecx, 4
  00028	d1 e1		 shl	 ecx, 1
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  0002d	8b 75 10	 mov	 esi, DWORD PTR _v2$[ebp]
  00030	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00035	f3 0f 58 04 0e	 addss	 xmm0, DWORD PTR [esi+ecx]
  0003a	f3 0f 11 45 fc	 movss	 DWORD PTR $T3[ebp], xmm0
  0003f	b8 04 00 00 00	 mov	 eax, 4
  00044	c1 e0 00	 shl	 eax, 0
  00047	b9 04 00 00 00	 mov	 ecx, 4
  0004c	c1 e1 00	 shl	 ecx, 0
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00052	8b 75 10	 mov	 esi, DWORD PTR _v2$[ebp]
  00055	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  0005a	f3 0f 58 04 0e	 addss	 xmm0, DWORD PTR [esi+ecx]
  0005f	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp], xmm0
  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	6b c8 00	 imul	 ecx, eax, 0
  0006c	ba 04 00 00 00	 mov	 edx, 4
  00071	6b c2 00	 imul	 eax, edx, 0
  00074	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00077	8b 75 10	 mov	 esi, DWORD PTR _v2$[ebp]
  0007a	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  0007f	f3 0f 58 04 06	 addss	 xmm0, DWORD PTR [esi+eax]
  00084	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp], xmm0
  00089	8d 45 fc	 lea	 eax, DWORD PTR $T3[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  00090	51		 push	 ecx
  00091	8d 55 f4	 lea	 edx, DWORD PTR $T1[ebp]
  00094	52		 push	 edx
  00095	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00098	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  0009d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 761  : 			v1.m_floats[0] + v2.m_floats[0], 
; 762  : 			v1.m_floats[1] + v2.m_floats[1], 
; 763  : 			v1.m_floats[2] + v2.m_floats[2]);
; 764  : #endif
; 765  : }

  000a0	5e		 pop	 esi
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
??H@YA?AVbtVector3@@ABV0@0@Z ENDP			; operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ??G@YA?AVbtVector3@@ABV0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??G@YA?AVbtVector3@@ABV0@@Z PROC			; operator-, COMDAT

; 806  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 807  : #if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined (BT_USE_SSE))
; 808  : 	__m128 r = _mm_xor_ps(v.mVec128, btvMzeroMask);
; 809  : 	return btVector3(_mm_and_ps(r, btvFFF0fMask)); 
; 810  : #elif defined(BT_USE_NEON)
; 811  : 	return btVector3((btSimdFloat4)veorq_s32((int32x4_t)v.mVec128, (int32x4_t)btvMzeroMask));
; 812  : #else	
; 813  : 	return btVector3(-v.m_floats[0], -v.m_floats[1], -v.m_floats[2]);

  0001b	b8 04 00 00 00	 mov	 eax, 4
  00020	d1 e0		 shl	 eax, 1
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00025	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0002a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00031	f3 0f 11 45 fc	 movss	 DWORD PTR $T3[ebp], xmm0
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	c1 e2 00	 shl	 edx, 0
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00041	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00046	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0004d	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp], xmm0
  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 00	 imul	 edx, ecx, 0
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0005d	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00062	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00069	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp], xmm0
  0006e	8d 4d fc	 lea	 ecx, DWORD PTR $T3[ebp]
  00071	51		 push	 ecx
  00072	8d 55 f8	 lea	 edx, DWORD PTR $T2[ebp]
  00075	52		 push	 edx
  00076	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0007d	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  00082	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 814  : #endif
; 815  : }

  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??G@YA?AVbtVector3@@ABV0@@Z ENDP			; operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btvector3.h
;	COMDAT ?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_dataOut$ = 8						; size = 4
?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z PROC ; btVector3::serializeFloat, COMDAT
; _this$ = ecx

; 1313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1314 : 	///could also do a memcpy, check if it is worth it
; 1315 : 	for (int i=0;i<4;i++)

  00018	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@serializeF
$LN2@serializeF:
  00021	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@serializeF:
  0002a	83 7d f8 04	 cmp	 DWORD PTR _i$1[ebp], 4
  0002e	7d 14		 jge	 SHORT $LN3@serializeF

; 1316 : 		dataOut.m_floats[i] = float(m_floats[i]);

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR _dataOut$[ebp]
  00036	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00039	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0003c	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  0003f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00042	eb dd		 jmp	 SHORT $LN2@serializeF
$LN3@serializeF:

; 1317 : }

  00044	5e		 pop	 esi
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z ENDP ; btVector3::serializeFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?getX@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@btQuadWord@@QBEABMXZ PROC				; btQuadWord::getX, COMDAT
; _this$ = ecx

; 102  : 		SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 00	 imul	 eax, eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?getX@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?getY@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@btQuadWord@@QBEABMXZ PROC				; btQuadWord::getY, COMDAT
; _this$ = ecx

; 104  : 		SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	c1 e0 00	 shl	 eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?getY@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?getZ@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getZ@btQuadWord@@QBEABMXZ PROC				; btQuadWord::getZ, COMDAT
; _this$ = ecx

; 106  : 		SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	d1 e0		 shl	 eax, 1
  00015	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?getZ@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::getZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?x@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?x@btQuadWord@@QBEABMXZ PROC				; btQuadWord::x, COMDAT
; _this$ = ecx

; 116  : 		SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 00	 imul	 eax, eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?x@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::x
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?y@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?y@btQuadWord@@QBEABMXZ PROC				; btQuadWord::y, COMDAT
; _this$ = ecx

; 118  : 		SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	c1 e0 00	 shl	 eax, 0
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?y@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::y
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?z@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?z@btQuadWord@@QBEABMXZ PROC				; btQuadWord::z, COMDAT
; _this$ = ecx

; 120  : 		SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	d1 e0		 shl	 eax, 1
  00015	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?z@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::z
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?w@btQuadWord@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?w@btQuadWord@@QBEABMXZ PROC				; btQuadWord::w, COMDAT
; _this$ = ecx

; 122  : 		SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 03	 imul	 eax, eax, 3
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?w@btQuadWord@@QBEABMXZ ENDP				; btQuadWord::w
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ?setValue@btQuadWord@@QAEXABM000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
?setValue@btQuadWord@@QAEXABM000@Z PROC			; btQuadWord::setValue, COMDAT
; _this$ = ecx

; 174  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 175  : 			m_floats[0]=_x;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __x$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 176  : 			m_floats[1]=_y;

  00021	b9 04 00 00 00	 mov	 ecx, 4
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __y$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 177  : 			m_floats[2]=_z;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	d1 e1		 shl	 ecx, 1
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR __z$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 178  : 			m_floats[3]=_w;

  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	6b d1 03	 imul	 edx, ecx, 3
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __w$[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00056	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 179  : 		}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 10 00	 ret	 16			; 00000010H
?setValue@btQuadWord@@QAEXABM000@Z ENDP			; btQuadWord::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ??0btQuadWord@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btQuadWord@@QAE@XZ PROC				; btQuadWord::btQuadWord, COMDAT
; _this$ = ecx

; 181  : 		SIMD_FORCE_INLINE btQuadWord()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		//	:m_floats[0](btScalar(0.)),m_floats[1](btScalar(0.)),m_floats[2](btScalar(0.)),m_floats[3](btScalar(0.))
; 183  : 		{
; 184  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0btQuadWord@@QAE@XZ ENDP				; btQuadWord::btQuadWord
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquadword.h
;	COMDAT ??0btQuadWord@@QAE@ABM000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0btQuadWord@@QAE@ABM000@Z PROC			; btQuadWord::btQuadWord, COMDAT
; _this$ = ecx

; 202  : 		SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z,const btScalar& _w) 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  : 		{
; 204  : 			m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = _w;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __x$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  00021	b9 04 00 00 00	 mov	 ecx, 4
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __y$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	d1 e1		 shl	 ecx, 1
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 10	 mov	 eax, DWORD PTR __z$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	6b d1 03	 imul	 edx, ecx, 3
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR __w$[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00056	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 205  : 		}

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 10 00	 ret	 16			; 00000010H
??0btQuadWord@@QAE@ABM000@Z ENDP			; btQuadWord::btQuadWord
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquaternion.h
;	COMDAT ??0btQuaternion@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btQuaternion@@QAE@XZ PROC				; btQuaternion::btQuaternion, COMDAT
; _this$ = ecx

; 58   : 	btQuaternion() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0btQuadWord@@QAE@XZ	; btQuadWord::btQuadWord
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0btQuaternion@@QAE@XZ ENDP				; btQuaternion::btQuaternion
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquaternion.h
;	COMDAT ??0btQuaternion@@QAE@ABM000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0btQuaternion@@QAE@ABM000@Z PROC			; btQuaternion::btQuaternion, COMDAT
; _this$ = ecx

; 89   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : 		: btQuadWord(_x, _y, _z, _w) 

  0000e	8b 45 14	 mov	 eax, DWORD PTR __w$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __z$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __y$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __x$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??0btQuadWord@@QAE@ABM000@Z ; btQuadWord::btQuadWord

; 89   : 	{}

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 10 00	 ret	 16			; 00000010H
??0btQuaternion@@QAE@ABM000@Z ENDP			; btQuaternion::btQuaternion
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquaternion.h
;	COMDAT ?dot@btQuaternion@@QBEMABV1@@Z
_TEXT	SEGMENT
tv174 = -16						; size = 4
tv180 = -12						; size = 4
tv178 = -8						; size = 4
_this$ = -4						; size = 4
_q$ = 8							; size = 4
?dot@btQuaternion@@QBEMABV1@@Z PROC			; btQuaternion::dot, COMDAT
; _this$ = ecx

; 300  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 301  : #if defined BT_USE_SIMD_VECTOR3 && defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 302  : 		__m128	vd;
; 303  : 		
; 304  : 		vd = _mm_mul_ps(mVec128, q.mVec128);
; 305  : 		
; 306  :         __m128 t = _mm_movehl_ps(vd, vd);
; 307  : 		vd = _mm_add_ps(vd, t);
; 308  : 		t = _mm_shuffle_ps(vd, vd, 0x55);
; 309  : 		vd = _mm_add_ss(vd, t);
; 310  : 		
; 311  :         return _mm_cvtss_f32(vd);
; 312  : #elif defined(BT_USE_NEON)
; 313  : 		float32x4_t vd = vmulq_f32(mVec128, q.mVec128);
; 314  : 		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_high_f32(vd));  
; 315  : 		x = vpadd_f32(x, x);
; 316  : 		return vget_lane_f32(x, 0);
; 317  : #else    
; 318  : 		return  m_floats[0] * q.x() + 

  0001b	b8 04 00 00 00	 mov	 eax, 4
  00020	6b f0 00	 imul	 esi, eax, 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00026	e8 00 00 00 00	 call	 ?x@btQuadWord@@QBEABMXZ	; btQuadWord::x
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	f3 0f 10 04 31	 movss	 xmm0, DWORD PTR [ecx+esi]
  00033	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00037	be 04 00 00 00	 mov	 esi, 4
  0003c	c1 e6 00	 shl	 esi, 0
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00042	f3 0f 11 45 f8	 movss	 DWORD PTR tv178[ebp], xmm0
  00047	e8 00 00 00 00	 call	 ?y@btQuadWord@@QBEABMXZ	; btQuadWord::y
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	f3 0f 10 04 32	 movss	 xmm0, DWORD PTR [edx+esi]
  00054	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00058	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv178[ebp]
  0005d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00061	be 04 00 00 00	 mov	 esi, 4
  00066	d1 e6		 shl	 esi, 1
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0006b	f3 0f 11 4d f4	 movss	 DWORD PTR tv180[ebp], xmm1
  00070	e8 00 00 00 00	 call	 ?z@btQuadWord@@QBEABMXZ	; btQuadWord::z
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	f3 0f 10 04 31	 movss	 xmm0, DWORD PTR [ecx+esi]
  0007d	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00081	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR tv180[ebp]
  00086	f3 0f 58 c8	 addss	 xmm1, xmm0
  0008a	ba 04 00 00 00	 mov	 edx, 4
  0008f	6b c2 03	 imul	 eax, edx, 3
  00092	b9 04 00 00 00	 mov	 ecx, 4
  00097	6b d1 03	 imul	 edx, ecx, 3
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 75 08	 mov	 esi, DWORD PTR _q$[ebp]
  000a0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a5	f3 0f 59 04 16	 mulss	 xmm0, DWORD PTR [esi+edx]
  000aa	f3 0f 58 c8	 addss	 xmm1, xmm0
  000ae	f3 0f 11 4d f0	 movss	 DWORD PTR tv174[ebp], xmm1
  000b3	d9 45 f0	 fld	 DWORD PTR tv174[ebp]

; 319  :                 m_floats[1] * q.y() + 
; 320  :                 m_floats[2] * q.z() + 
; 321  :                 m_floats[3] * q.m_floats[3];
; 322  : #endif
; 323  : 	}

  000b6	5e		 pop	 esi
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?dot@btQuaternion@@QBEMABV1@@Z ENDP			; btQuaternion::dot
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquaternion.h
;	COMDAT ?length2@btQuaternion@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length2@btQuaternion@@QBEMXZ PROC			; btQuaternion::length2, COMDAT
; _this$ = ecx

; 327  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 328  : 		return dot(*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?dot@btQuaternion@@QBEMABV1@@Z ; btQuaternion::dot

; 329  : 	}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?length2@btQuaternion@@QBEMXZ ENDP			; btQuaternion::length2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btquaternion.h
;	COMDAT ?getW@btQuaternion@@QBEABMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getW@btQuaternion@@QBEABMXZ PROC			; btQuaternion::getW, COMDAT
; _this$ = ecx

; 568  : 	SIMD_FORCE_INLINE const btScalar& getW() const { return m_floats[3]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c0 03	 imul	 eax, eax, 3
  00016	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?getW@btQuaternion@@QBEABMXZ ENDP			; btQuaternion::getW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??0btMatrix3x3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btMatrix3x3@@QAE@XZ PROC				; btMatrix3x3::btMatrix3x3, COMDAT
; _this$ = ecx

; 55   : 	btMatrix3x3 () {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??0btVector3@@QAE@XZ ; btVector3::btVector3
  00013	6a 03		 push	 3
  00015	6a 10		 push	 16			; 00000010H
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??0btMatrix3x3@@QAE@XZ ENDP				; btMatrix3x3::btMatrix3x3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??0btMatrix3x3@@QAE@ABVbtQuaternion@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_q$ = 8							; size = 4
??0btMatrix3x3@@QAE@ABVbtQuaternion@@@Z PROC		; btMatrix3x3::btMatrix3x3, COMDAT
; _this$ = ecx

; 60   : 	explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??0btVector3@@QAE@XZ ; btVector3::btVector3
  00013	6a 03		 push	 3
  00015	6a 10		 push	 16			; 00000010H
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?setRotation@btMatrix3x3@@QAEXABVbtQuaternion@@@Z ; btMatrix3x3::setRotation
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??0btMatrix3x3@@QAE@ABVbtQuaternion@@@Z ENDP		; btMatrix3x3::btMatrix3x3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??0btMatrix3x3@@QAE@ABM00000000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xx$ = 8						; size = 4
_xy$ = 12						; size = 4
_xz$ = 16						; size = 4
_yx$ = 20						; size = 4
_yy$ = 24						; size = 4
_yz$ = 28						; size = 4
_zx$ = 32						; size = 4
_zy$ = 36						; size = 4
_zz$ = 40						; size = 4
??0btMatrix3x3@@QAE@ABM00000000@Z PROC			; btMatrix3x3::btMatrix3x3, COMDAT
; _this$ = ecx

; 69   : 	btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 		const btScalar& yx, const btScalar& yy, const btScalar& yz,
; 71   : 		const btScalar& zx, const btScalar& zy, const btScalar& zz)
; 72   : 	{ 

  0000e	68 00 00 00 00	 push	 OFFSET ??0btVector3@@QAE@XZ ; btVector3::btVector3
  00013	6a 03		 push	 3
  00015	6a 10		 push	 16			; 00000010H
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z

; 73   : 		setValue(xx, xy, xz, 

  00020	8b 4d 28	 mov	 ecx, DWORD PTR _zz$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 24	 mov	 edx, DWORD PTR _zy$[ebp]
  00027	52		 push	 edx
  00028	8b 45 20	 mov	 eax, DWORD PTR _zx$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 1c	 mov	 ecx, DWORD PTR _yz$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 18	 mov	 edx, DWORD PTR _yy$[ebp]
  00033	52		 push	 edx
  00034	8b 45 14	 mov	 eax, DWORD PTR _yx$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _xz$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 0c	 mov	 edx, DWORD PTR _xy$[ebp]
  0003f	52		 push	 edx
  00040	8b 45 08	 mov	 eax, DWORD PTR _xx$[ebp]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?setValue@btMatrix3x3@@QAEXABM00000000@Z ; btMatrix3x3::setValue

; 74   : 			yx, yy, yz, 
; 75   : 			zx, zy, zz);
; 76   : 	}

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 c4 04	 add	 esp, 4
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 24 00	 ret	 36			; 00000024H
??0btMatrix3x3@@QAE@ABM00000000@Z ENDP			; btMatrix3x3::btMatrix3x3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??0btMatrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0btMatrix3x3@@QAE@ABV0@@Z PROC			; btMatrix3x3::btMatrix3x3, COMDAT
; _this$ = ecx

; 114  : 	SIMD_FORCE_INLINE btMatrix3x3 (const btMatrix3x3& other)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	{

  0000e	68 00 00 00 00	 push	 OFFSET ??0btVector3@@QAE@XZ ; btVector3::btVector3
  00013	6a 03		 push	 3
  00015	6a 10		 push	 16			; 00000010H
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z

; 116  : 		m_el[0] = other.m_el[0];

  00020	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00025	6b d1 00	 imul	 edx, ecx, 0
  00028	03 55 08	 add	 edx, DWORD PTR _other$[ebp]
  0002b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00030	6b c8 00	 imul	 ecx, eax, 0
  00033	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00040	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00043	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00046	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00049	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 117  : 		m_el[1] = other.m_el[1];

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 45 08	 add	 eax, DWORD PTR _other$[ebp]
  00057	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0005c	c1 e1 00	 shl	 ecx, 0
  0005f	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00062	8b 10		 mov	 edx, DWORD PTR [eax]
  00064	89 11		 mov	 DWORD PTR [ecx], edx
  00066	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00069	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0006c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0006f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00072	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00075	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 118  : 		m_el[2] = other.m_el[2];

  00078	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0007d	d1 e1		 shl	 ecx, 1
  0007f	03 4d 08	 add	 ecx, DWORD PTR _other$[ebp]
  00082	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00087	d1 e2		 shl	 edx, 1
  00089	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0008c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008e	89 02		 mov	 DWORD PTR [edx], eax
  00090	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00093	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00096	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00099	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0009c	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0009f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 119  : 	}

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
??0btMatrix3x3@@QAE@ABV0@@Z ENDP			; btMatrix3x3::btMatrix3x3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??4btMatrix3x3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4btMatrix3x3@@QAEAAV0@ABV0@@Z PROC			; btMatrix3x3::operator=, COMDAT
; _this$ = ecx

; 123  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 		m_el[0] = other.m_el[0];

  0000e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00013	6b c8 00	 imul	 ecx, eax, 0
  00016	03 4d 08	 add	 ecx, DWORD PTR _other$[ebp]
  00019	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0001e	6b c2 00	 imul	 eax, edx, 0
  00021	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	89 10		 mov	 DWORD PTR [eax], edx
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00031	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00034	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00037	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 125  : 		m_el[1] = other.m_el[1];

  0003a	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0003f	c1 e2 00	 shl	 edx, 0
  00042	03 55 08	 add	 edx, DWORD PTR _other$[ebp]
  00045	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0004a	c1 e0 00	 shl	 eax, 0
  0004d	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00050	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00052	89 08		 mov	 DWORD PTR [eax], ecx
  00054	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00057	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0005a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0005d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00060	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00063	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 126  : 		m_el[2] = other.m_el[2];

  00066	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0006b	d1 e0		 shl	 eax, 1
  0006d	03 45 08	 add	 eax, DWORD PTR _other$[ebp]
  00070	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00075	d1 e1		 shl	 ecx, 1
  00077	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00081	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00084	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00087	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0008a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0008d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 127  : 		return *this;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 128  : 	}

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
??4btMatrix3x3@@QAEAAV0@ABV0@@Z ENDP			; btMatrix3x3::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AbtMatrix3x3@@QBEABVbtVector3@@H@Z PROC		; btMatrix3x3::operator[], COMDAT
; _this$ = ecx

; 159  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : 		btFullAssert(0 <= i && i < 3);
; 161  : 		return m_el[i]; 

  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	c1 e0 04	 shl	 eax, 4
  00014	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]

; 162  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ENDP		; btMatrix3x3::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?setValue@btMatrix3x3@@QAEXABM00000000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xx$ = 8						; size = 4
_xy$ = 12						; size = 4
_xz$ = 16						; size = 4
_yx$ = 20						; size = 4
_yy$ = 24						; size = 4
_yz$ = 28						; size = 4
_zx$ = 32						; size = 4
_zy$ = 36						; size = 4
_zz$ = 40						; size = 4
?setValue@btMatrix3x3@@QAEXABM00000000@Z PROC		; btMatrix3x3::setValue, COMDAT
; _this$ = ecx

; 201  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		m_el[0].setValue(xx,xy,xz);

  0000e	8b 45 10	 mov	 eax, DWORD PTR _xz$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _xy$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _xx$[ebp]
  00019	52		 push	 edx
  0001a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0001f	6b c8 00	 imul	 ecx, eax, 0
  00022	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?setValue@btVector3@@QAEXABM00@Z ; btVector3::setValue

; 203  : 		m_el[1].setValue(yx,yy,yz);

  0002a	8b 4d 1c	 mov	 ecx, DWORD PTR _yz$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 18	 mov	 edx, DWORD PTR _yy$[ebp]
  00031	52		 push	 edx
  00032	8b 45 14	 mov	 eax, DWORD PTR _yx$[ebp]
  00035	50		 push	 eax
  00036	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0003b	c1 e1 00	 shl	 ecx, 0
  0003e	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?setValue@btVector3@@QAEXABM00@Z ; btVector3::setValue

; 204  : 		m_el[2].setValue(zx,zy,zz);

  00046	8b 4d 28	 mov	 ecx, DWORD PTR _zz$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 24	 mov	 edx, DWORD PTR _zy$[ebp]
  0004d	52		 push	 edx
  0004e	8b 45 20	 mov	 eax, DWORD PTR _zx$[ebp]
  00051	50		 push	 eax
  00052	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00057	d1 e1		 shl	 ecx, 1
  00059	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?setValue@btVector3@@QAEXABM00@Z ; btVector3::setValue

; 205  : 	}

  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 24 00	 ret	 36			; 00000024H
?setValue@btMatrix3x3@@QAEXABM00000000@Z ENDP		; btMatrix3x3::setValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?setRotation@btMatrix3x3@@QAEXABVbtQuaternion@@@Z
_TEXT	SEGMENT
$T1 = -96						; size = 4
$T2 = -92						; size = 4
$T3 = -88						; size = 4
$T4 = -84						; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 4
$T7 = -72						; size = 4
$T8 = -68						; size = 4
$T9 = -64						; size = 4
_zz$ = -60						; size = 4
_yz$ = -56						; size = 4
_yy$ = -52						; size = 4
_xz$ = -48						; size = 4
_xy$ = -44						; size = 4
_xx$ = -40						; size = 4
_wz$ = -36						; size = 4
_wy$ = -32						; size = 4
_wx$ = -28						; size = 4
_zs$ = -24						; size = 4
_ys$ = -20						; size = 4
_xs$ = -16						; size = 4
_s$ = -12						; size = 4
_d$ = -8						; size = 4
_this$ = -4						; size = 4
_q$ = 8							; size = 4
?setRotation@btMatrix3x3@@QAEXABVbtQuaternion@@@Z PROC	; btMatrix3x3::setRotation, COMDAT
; _this$ = ecx

; 210  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0000b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 		btScalar d = q.length2();

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0001e	e8 00 00 00 00	 call	 ?length2@btQuaternion@@QBEMXZ ; btQuaternion::length2
  00023	d9 5d f8	 fstp	 DWORD PTR _d$[ebp]

; 212  : 		btFullAssert(d != btScalar(0.0));
; 213  : 		btScalar s = btScalar(2.0) / d;

  00026	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0002e	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _d$[ebp]
  00033	f3 0f 11 45 f4	 movss	 DWORD PTR _s$[ebp], xmm0

; 214  :     
; 215  :     #if defined BT_USE_SIMD_VECTOR3 && defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE)
; 216  :         __m128	vs, Q = q.get128();
; 217  : 		__m128i Qi = btCastfTo128i(Q);
; 218  :         __m128	Y, Z;
; 219  :         __m128	V1, V2, V3;
; 220  :         __m128	V11, V21, V31;
; 221  :         __m128	NQ = _mm_xor_ps(Q, btvMzeroMask);
; 222  : 		__m128i NQi = btCastfTo128i(NQ);
; 223  :         
; 224  :         V1 = btCastiTo128f(_mm_shuffle_epi32 (Qi, BT_SHUFFLE(1,0,2,3)));	// Y X Z W
; 225  : 		V2 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(0,0,1,3));     // -X -X  Y  W
; 226  :         V3 = btCastiTo128f(_mm_shuffle_epi32 (Qi, BT_SHUFFLE(2,1,0,3)));	// Z Y X W
; 227  :         V1 = _mm_xor_ps(V1, vMPPP);	//	change the sign of the first element
; 228  : 			
; 229  :         V11	= btCastiTo128f(_mm_shuffle_epi32 (Qi, BT_SHUFFLE(1,1,0,3)));	// Y Y X W
; 230  : 		V21 = _mm_unpackhi_ps(Q, Q);                    //  Z  Z  W  W
; 231  : 		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(0,2,0,3));	//  X  Z -X -W
; 232  : 
; 233  : 		V2 = V2 * V1;	//
; 234  : 		V1 = V1 * V11;	//
; 235  : 		V3 = V3 * V31;	//
; 236  : 
; 237  :         V11 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(2,3,1,3));	//	-Z -W  Y  W
; 238  : 		V11 = V11 * V21;	//
; 239  :         V21 = _mm_xor_ps(V21, vMPPP);	//	change the sign of the first element
; 240  : 		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(3,3,1,3));	//	 W  W -Y -W
; 241  :         V31 = _mm_xor_ps(V31, vMPPP);	//	change the sign of the first element
; 242  : 		Y = btCastiTo128f(_mm_shuffle_epi32 (NQi, BT_SHUFFLE(3,2,0,3)));	// -W -Z -X -W
; 243  : 		Z = btCastiTo128f(_mm_shuffle_epi32 (Qi, BT_SHUFFLE(1,0,1,3)));	//  Y  X  Y  W
; 244  : 
; 245  : 		vs = _mm_load_ss(&s);
; 246  : 		V21 = V21 * Y;
; 247  : 		V31 = V31 * Z;
; 248  : 
; 249  : 		V1 = V1 + V11;
; 250  :         V2 = V2 + V21;
; 251  :         V3 = V3 + V31;
; 252  : 
; 253  :         vs = bt_splat3_ps(vs, 0);
; 254  :             //	s ready
; 255  :         V1 = V1 * vs;
; 256  :         V2 = V2 * vs;
; 257  :         V3 = V3 * vs;
; 258  :         
; 259  :         V1 = V1 + v1000;
; 260  :         V2 = V2 + v0100;
; 261  :         V3 = V3 + v0010;
; 262  :         
; 263  :         m_el[0] = V1; 
; 264  :         m_el[1] = V2;
; 265  :         m_el[2] = V3;
; 266  :     #else    
; 267  : 		btScalar xs = q.x() * s,   ys = q.y() * s,   zs = q.z() * s;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0003b	e8 00 00 00 00	 call	 ?x@btQuadWord@@QBEABMXZ	; btQuadWord::x
  00040	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00044	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00049	f3 0f 11 45 f0	 movss	 DWORD PTR _xs$[ebp], xmm0
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00051	e8 00 00 00 00	 call	 ?y@btQuadWord@@QBEABMXZ	; btQuadWord::y
  00056	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0005a	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _s$[ebp]
  0005f	f3 0f 11 45 ec	 movss	 DWORD PTR _ys$[ebp], xmm0
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00067	e8 00 00 00 00	 call	 ?z@btQuadWord@@QBEABMXZ	; btQuadWord::z
  0006c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00070	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00075	f3 0f 11 45 e8	 movss	 DWORD PTR _zs$[ebp], xmm0

; 268  : 		btScalar wx = q.w() * xs,  wy = q.w() * ys,  wz = q.w() * zs;

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0007d	e8 00 00 00 00	 call	 ?w@btQuadWord@@QBEABMXZ	; btQuadWord::w
  00082	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00086	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _xs$[ebp]
  0008b	f3 0f 11 45 e4	 movss	 DWORD PTR _wx$[ebp], xmm0
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00093	e8 00 00 00 00	 call	 ?w@btQuadWord@@QBEABMXZ	; btQuadWord::w
  00098	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0009c	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _ys$[ebp]
  000a1	f3 0f 11 45 e0	 movss	 DWORD PTR _wy$[ebp], xmm0
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000a9	e8 00 00 00 00	 call	 ?w@btQuadWord@@QBEABMXZ	; btQuadWord::w
  000ae	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b2	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _zs$[ebp]
  000b7	f3 0f 11 45 dc	 movss	 DWORD PTR _wz$[ebp], xmm0

; 269  : 		btScalar xx = q.x() * xs,  xy = q.x() * ys,  xz = q.x() * zs;

  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000bf	e8 00 00 00 00	 call	 ?x@btQuadWord@@QBEABMXZ	; btQuadWord::x
  000c4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000c8	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _xs$[ebp]
  000cd	f3 0f 11 45 d8	 movss	 DWORD PTR _xx$[ebp], xmm0
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000d5	e8 00 00 00 00	 call	 ?x@btQuadWord@@QBEABMXZ	; btQuadWord::x
  000da	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000de	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _ys$[ebp]
  000e3	f3 0f 11 45 d4	 movss	 DWORD PTR _xy$[ebp], xmm0
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000eb	e8 00 00 00 00	 call	 ?x@btQuadWord@@QBEABMXZ	; btQuadWord::x
  000f0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000f4	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _zs$[ebp]
  000f9	f3 0f 11 45 d0	 movss	 DWORD PTR _xz$[ebp], xmm0

; 270  : 		btScalar yy = q.y() * ys,  yz = q.y() * zs,  zz = q.z() * zs;

  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00101	e8 00 00 00 00	 call	 ?y@btQuadWord@@QBEABMXZ	; btQuadWord::y
  00106	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0010a	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _ys$[ebp]
  0010f	f3 0f 11 45 cc	 movss	 DWORD PTR _yy$[ebp], xmm0
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00117	e8 00 00 00 00	 call	 ?y@btQuadWord@@QBEABMXZ	; btQuadWord::y
  0011c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00120	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _zs$[ebp]
  00125	f3 0f 11 45 c8	 movss	 DWORD PTR _yz$[ebp], xmm0
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0012d	e8 00 00 00 00	 call	 ?z@btQuadWord@@QBEABMXZ	; btQuadWord::z
  00132	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00136	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _zs$[ebp]
  0013b	f3 0f 11 45 c4	 movss	 DWORD PTR _zz$[ebp], xmm0

; 271  : 		setValue(

  00140	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _xx$[ebp]
  00145	f3 0f 58 45 cc	 addss	 xmm0, DWORD PTR _yy$[ebp]
  0014a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00152	f3 0f 5c c8	 subss	 xmm1, xmm0
  00156	f3 0f 11 4d c0	 movss	 DWORD PTR $T9[ebp], xmm1
  0015b	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _yz$[ebp]
  00160	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _wx$[ebp]
  00165	f3 0f 11 45 bc	 movss	 DWORD PTR $T8[ebp], xmm0
  0016a	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _xz$[ebp]
  0016f	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _wy$[ebp]
  00174	f3 0f 11 45 b8	 movss	 DWORD PTR $T7[ebp], xmm0
  00179	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _yz$[ebp]
  0017e	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _wx$[ebp]
  00183	f3 0f 11 45 b4	 movss	 DWORD PTR $T6[ebp], xmm0
  00188	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _xx$[ebp]
  0018d	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _zz$[ebp]
  00192	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0019a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0019e	f3 0f 11 4d b0	 movss	 DWORD PTR $T5[ebp], xmm1
  001a3	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  001a8	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _wz$[ebp]
  001ad	f3 0f 11 45 ac	 movss	 DWORD PTR $T4[ebp], xmm0
  001b2	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _xz$[ebp]
  001b7	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _wy$[ebp]
  001bc	f3 0f 11 45 a8	 movss	 DWORD PTR $T3[ebp], xmm0
  001c1	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  001c6	f3 0f 5c 45 dc	 subss	 xmm0, DWORD PTR _wz$[ebp]
  001cb	f3 0f 11 45 a4	 movss	 DWORD PTR $T2[ebp], xmm0
  001d0	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _yy$[ebp]
  001d5	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _zz$[ebp]
  001da	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  001e2	f3 0f 5c c8	 subss	 xmm1, xmm0
  001e6	f3 0f 11 4d a0	 movss	 DWORD PTR $T1[ebp], xmm1
  001eb	8d 45 c0	 lea	 eax, DWORD PTR $T9[ebp]
  001ee	50		 push	 eax
  001ef	8d 4d bc	 lea	 ecx, DWORD PTR $T8[ebp]
  001f2	51		 push	 ecx
  001f3	8d 55 b8	 lea	 edx, DWORD PTR $T7[ebp]
  001f6	52		 push	 edx
  001f7	8d 45 b4	 lea	 eax, DWORD PTR $T6[ebp]
  001fa	50		 push	 eax
  001fb	8d 4d b0	 lea	 ecx, DWORD PTR $T5[ebp]
  001fe	51		 push	 ecx
  001ff	8d 55 ac	 lea	 edx, DWORD PTR $T4[ebp]
  00202	52		 push	 edx
  00203	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  00206	50		 push	 eax
  00207	8d 4d a4	 lea	 ecx, DWORD PTR $T2[ebp]
  0020a	51		 push	 ecx
  0020b	8d 55 a0	 lea	 edx, DWORD PTR $T1[ebp]
  0020e	52		 push	 edx
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00212	e8 00 00 00 00	 call	 ?setValue@btMatrix3x3@@QAEXABM00000000@Z ; btMatrix3x3::setValue

; 272  :             btScalar(1.0) - (yy + zz), xy - wz, xz + wy,
; 273  : 			xy + wz, btScalar(1.0) - (xx + zz), yz - wx,
; 274  : 			xz - wy, yz + wx, btScalar(1.0) - (xx + yy));
; 275  : 	#endif
; 276  :     }

  00217	5f		 pop	 edi
  00218	83 c4 60	 add	 esp, 96			; 00000060H
  0021b	3b ec		 cmp	 ebp, esp
  0021d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c2 04 00	 ret	 4
?setRotation@btMatrix3x3@@QAEXABVbtQuaternion@@@Z ENDP	; btMatrix3x3::setRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?setIdentity@btMatrix3x3@@QAEXXZ
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
$T8 = -12						; size = 4
$T9 = -8						; size = 4
_this$ = -4						; size = 4
?setIdentity@btMatrix3x3@@QAEXXZ PROC			; btMatrix3x3::setIdentity, COMDAT
; _this$ = ecx

; 318  : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0000b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : #if (defined(BT_USE_SSE_IN_API)&& defined (BT_USE_SSE)) || defined(BT_USE_NEON)
; 320  : 			m_el[0] = v1000; 
; 321  : 			m_el[1] = v0100;
; 322  : 			m_el[2] = v0010;
; 323  : #else
; 324  : 		setValue(btScalar(1.0), btScalar(0.0), btScalar(0.0), 

  0001b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00023	f3 0f 11 45 f8	 movss	 DWORD PTR $T9[ebp], xmm0
  00028	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00030	f3 0f 11 45 f4	 movss	 DWORD PTR $T8[ebp], xmm0
  00035	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0003d	f3 0f 11 45 f0	 movss	 DWORD PTR $T7[ebp], xmm0
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0004a	f3 0f 11 45 ec	 movss	 DWORD PTR $T6[ebp], xmm0
  0004f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00057	f3 0f 11 45 e8	 movss	 DWORD PTR $T5[ebp], xmm0
  0005c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00064	f3 0f 11 45 e4	 movss	 DWORD PTR $T4[ebp], xmm0
  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00071	f3 0f 11 45 e0	 movss	 DWORD PTR $T3[ebp], xmm0
  00076	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0007e	f3 0f 11 45 dc	 movss	 DWORD PTR $T2[ebp], xmm0
  00083	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008b	f3 0f 11 45 d8	 movss	 DWORD PTR $T1[ebp], xmm0
  00090	8d 45 f8	 lea	 eax, DWORD PTR $T9[ebp]
  00093	50		 push	 eax
  00094	8d 4d f4	 lea	 ecx, DWORD PTR $T8[ebp]
  00097	51		 push	 ecx
  00098	8d 55 f0	 lea	 edx, DWORD PTR $T7[ebp]
  0009b	52		 push	 edx
  0009c	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0009f	50		 push	 eax
  000a0	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  000a3	51		 push	 ecx
  000a4	8d 55 e4	 lea	 edx, DWORD PTR $T4[ebp]
  000a7	52		 push	 edx
  000a8	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  000ab	50		 push	 eax
  000ac	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  000af	51		 push	 ecx
  000b0	8d 55 d8	 lea	 edx, DWORD PTR $T1[ebp]
  000b3	52		 push	 edx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?setValue@btMatrix3x3@@QAEXABM00000000@Z ; btMatrix3x3::setValue

; 325  : 			btScalar(0.0), btScalar(1.0), btScalar(0.0), 
; 326  : 			btScalar(0.0), btScalar(0.0), btScalar(1.0)); 
; 327  : #endif
; 328  : 	}

  000bc	5f		 pop	 edi
  000bd	83 c4 28	 add	 esp, 40			; 00000028H
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?setIdentity@btMatrix3x3@@QAEXXZ ENDP			; btMatrix3x3::setIdentity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?getIdentity@btMatrix3x3@@SAABV1@XZ
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
$T10 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getIdentity@btMatrix3x3@@SAABV1@XZ PROC		; btMatrix3x3::getIdentity, COMDAT

; 331  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getIdentity@btMatrix3x3@@SAABV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  0001c	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001f	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00022	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00025	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00028	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00031	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00039	33 c5		 xor	 eax, ebp
  0003b	50		 push	 eax
  0003c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 332  : #if (defined(BT_USE_SSE_IN_API)&& defined (BT_USE_SSE)) || defined(BT_USE_NEON)
; 333  :         static const btMatrix3x3 
; 334  :         identityMatrix(v1000, v0100, v0010);
; 335  : #else
; 336  : 		static const btMatrix3x3 
; 337  :         identityMatrix(

  00045	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00053	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR __Init_thread_epoch[ecx]
  00059	0f 8e d8 00 00
	00		 jle	 $LN2@getIdentit
  0005f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00064	e8 00 00 00 00	 call	 __Init_thread_header
  00069	83 c4 04	 add	 esp, 4
  0006c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA, -1 ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00073	0f 85 be 00 00
	00		 jne	 $LN2@getIdentit
  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00080	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00088	f3 0f 11 45 f0	 movss	 DWORD PTR $T10[ebp], xmm0
  0008d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00095	f3 0f 11 45 ec	 movss	 DWORD PTR $T9[ebp], xmm0
  0009a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000a2	f3 0f 11 45 e8	 movss	 DWORD PTR $T8[ebp], xmm0
  000a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000af	f3 0f 11 45 e4	 movss	 DWORD PTR $T7[ebp], xmm0
  000b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000bc	f3 0f 11 45 e0	 movss	 DWORD PTR $T6[ebp], xmm0
  000c1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000c9	f3 0f 11 45 dc	 movss	 DWORD PTR $T5[ebp], xmm0
  000ce	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000d6	f3 0f 11 45 d8	 movss	 DWORD PTR $T4[ebp], xmm0
  000db	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000e3	f3 0f 11 45 d4	 movss	 DWORD PTR $T3[ebp], xmm0
  000e8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000f0	f3 0f 11 45 d0	 movss	 DWORD PTR $T2[ebp], xmm0
  000f5	8d 45 f0	 lea	 eax, DWORD PTR $T10[ebp]
  000f8	50		 push	 eax
  000f9	8d 4d ec	 lea	 ecx, DWORD PTR $T9[ebp]
  000fc	51		 push	 ecx
  000fd	8d 55 e8	 lea	 edx, DWORD PTR $T8[ebp]
  00100	52		 push	 edx
  00101	8d 45 e4	 lea	 eax, DWORD PTR $T7[ebp]
  00104	50		 push	 eax
  00105	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  00108	51		 push	 ecx
  00109	8d 55 dc	 lea	 edx, DWORD PTR $T5[ebp]
  0010c	52		 push	 edx
  0010d	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00110	50		 push	 eax
  00111	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  00114	51		 push	 ecx
  00115	8d 55 d0	 lea	 edx, DWORD PTR $T2[ebp]
  00118	52		 push	 edx
  00119	b9 00 00 00 00	 mov	 ecx, OFFSET ?identityMatrix@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4V2@B ; `btMatrix3x3::getIdentity'::`2'::identityMatrix
  0011e	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABM00000000@Z ; btMatrix3x3::btMatrix3x3
  00123	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012a	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  0012f	e8 00 00 00 00	 call	 __Init_thread_footer
  00134	83 c4 04	 add	 esp, 4
$LN2@getIdentit:

; 338  :             btScalar(1.0), btScalar(0.0), btScalar(0.0), 
; 339  : 			btScalar(0.0), btScalar(1.0), btScalar(0.0), 
; 340  : 			btScalar(0.0), btScalar(0.0), btScalar(1.0));
; 341  : #endif
; 342  : 		return identityMatrix;

  00137	b8 00 00 00 00	 mov	 eax, OFFSET ?identityMatrix@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4V2@B ; `btMatrix3x3::getIdentity'::`2'::identityMatrix

; 343  : 	}

  0013c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00146	59		 pop	 ecx
  00147	83 c4 30	 add	 esp, 48			; 00000030H
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getIdentity@btMatrix3x3@@SAABV1@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btMatrix3x3@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btMatrix3x3::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
__ehhandler$?getIdentity@btMatrix3x3@@SAABV1@XZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getIdentity@btMatrix3x3@@SAABV1@XZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getIdentity@btMatrix3x3@@SAABV1@XZ ENDP		; btMatrix3x3::getIdentity
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?getRotation@btMatrix3x3@@QBEXAAVbtQuaternion@@@Z
_TEXT	SEGMENT
tv414 = -76						; size = 4
tv197 = -72						; size = 4
tv198 = -68						; size = 4
tv185 = -64						; size = 4
tv412 = -60						; size = 4
_s$1 = -56						; size = 4
_k$2 = -52						; size = 4
_j$3 = -48						; size = 4
_i$4 = -44						; size = 4
_s$5 = -40						; size = 4
_temp$ = -32						; size = 16
_trace$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
?getRotation@btMatrix3x3@@QBEXAAVbtQuaternion@@@Z PROC	; btMatrix3x3::getRotation, COMDAT
; _this$ = ecx

; 401  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  0000c	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 402  : #if (defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE))|| defined (BT_USE_NEON)
; 403  :         btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
; 404  :         btScalar s, x;
; 405  :         
; 406  :         union {
; 407  :             btSimdFloat4 vec;
; 408  :             btScalar f[4];
; 409  :         } temp;
; 410  :         
; 411  :         if (trace > btScalar(0.0)) 
; 412  :         {
; 413  :             x = trace + btScalar(1.0);
; 414  : 
; 415  :             temp.f[0]=m_el[2].y() - m_el[1].z();
; 416  :             temp.f[1]=m_el[0].z() - m_el[2].x();
; 417  :             temp.f[2]=m_el[1].x() - m_el[0].y();
; 418  :             temp.f[3]=x;
; 419  :             //temp.f[3]= s * btScalar(0.5);
; 420  :         } 
; 421  :         else 
; 422  :         {
; 423  :             int i, j, k;
; 424  :             if(m_el[0].x() < m_el[1].y()) 
; 425  :             { 
; 426  :                 if( m_el[1].y() < m_el[2].z() )
; 427  :                     { i = 2; j = 0; k = 1; }
; 428  :                 else
; 429  :                     { i = 1; j = 2; k = 0; }
; 430  :             }
; 431  :             else
; 432  :             {
; 433  :                 if( m_el[0].x() < m_el[2].z())
; 434  :                     { i = 2; j = 0; k = 1; }
; 435  :                 else
; 436  :                     { i = 0; j = 1; k = 2; }
; 437  :             }
; 438  : 
; 439  :             x = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);
; 440  : 
; 441  :             temp.f[3] = (m_el[k][j] - m_el[j][k]);
; 442  :             temp.f[j] = (m_el[j][i] + m_el[i][j]);
; 443  :             temp.f[k] = (m_el[k][i] + m_el[i][k]);
; 444  :             temp.f[i] = x;
; 445  :             //temp.f[i] = s * btScalar(0.5);
; 446  :         }
; 447  : 
; 448  :         s = btSqrt(x);
; 449  :         q.set128(temp.vec);
; 450  :         s = btScalar(0.5) / s;
; 451  : 
; 452  :         q *= s;
; 453  : #else    
; 454  : 		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();

  00026	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00036	8b f0		 mov	 esi, eax
  00038	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0003d	c1 e1 00	 shl	 ecx, 0
  00040	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00048	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0004c	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00050	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00055	d1 e1		 shl	 ecx, 1
  00057	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  0005a	f3 0f 11 45 c4	 movss	 DWORD PTR tv412[ebp], xmm0
  0005f	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  00064	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR tv412[ebp]
  00069	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0006d	f3 0f 11 45 f4	 movss	 DWORD PTR _trace$[ebp], xmm0

; 455  : 
; 456  : 		btScalar temp[4];
; 457  : 
; 458  : 		if (trace > btScalar(0.0)) 

  00072	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _trace$[ebp]
  00077	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0007e	0f 86 04 01 00
	00		 jbe	 $LN2@getRotatio

; 459  : 		{
; 460  : 			btScalar s = btSqrt(trace + btScalar(1.0));

  00084	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _trace$[ebp]
  00089	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00091	51		 push	 ecx
  00092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00097	e8 00 00 00 00	 call	 ?btSqrt@@YAMM@Z		; btSqrt
  0009c	83 c4 04	 add	 esp, 4
  0009f	d9 5d d8	 fstp	 DWORD PTR _s$5[ebp]

; 461  : 			temp[3]=(s * btScalar(0.5));

  000a2	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _s$5[ebp]
  000a7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000af	b9 04 00 00 00	 mov	 ecx, 4
  000b4	6b d1 03	 imul	 edx, ecx, 3
  000b7	f3 0f 11 44 15
	e0		 movss	 DWORD PTR _temp$[ebp+edx], xmm0

; 462  : 			s = btScalar(0.5) / s;

  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000c5	f3 0f 5e 45 d8	 divss	 xmm0, DWORD PTR _s$5[ebp]
  000ca	f3 0f 11 45 d8	 movss	 DWORD PTR _s$5[ebp], xmm0

; 463  : 
; 464  : 			temp[0]=((m_el[2].y() - m_el[1].z()) * s);

  000cf	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000d4	d1 e1		 shl	 ecx, 1
  000d6	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  000d9	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  000de	8b f0		 mov	 esi, eax
  000e0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000e5	c1 e1 00	 shl	 ecx, 0
  000e8	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  000f0	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  000f4	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  000f8	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _s$5[ebp]
  000fd	b8 04 00 00 00	 mov	 eax, 4
  00102	6b c8 00	 imul	 ecx, eax, 0
  00105	f3 0f 11 44 0d
	e0		 movss	 DWORD PTR _temp$[ebp+ecx], xmm0

; 465  : 			temp[1]=((m_el[0].z() - m_el[2].x()) * s);

  0010b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00110	6b ca 00	 imul	 ecx, edx, 0
  00113	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00116	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0011b	8b f0		 mov	 esi, eax
  0011d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00122	d1 e1		 shl	 ecx, 1
  00124	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00127	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  0012c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00130	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00134	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _s$5[ebp]
  00139	b8 04 00 00 00	 mov	 eax, 4
  0013e	c1 e0 00	 shl	 eax, 0
  00141	f3 0f 11 44 05
	e0		 movss	 DWORD PTR _temp$[ebp+eax], xmm0

; 466  : 			temp[2]=((m_el[1].x() - m_el[0].y()) * s);

  00147	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0014c	c1 e1 00	 shl	 ecx, 0
  0014f	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00152	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00157	8b f0		 mov	 esi, eax
  00159	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0015e	6b c9 00	 imul	 ecx, ecx, 0
  00161	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00169	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0016d	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00171	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _s$5[ebp]
  00176	ba 04 00 00 00	 mov	 edx, 4
  0017b	d1 e2		 shl	 edx, 1
  0017d	f3 0f 11 44 15
	e0		 movss	 DWORD PTR _temp$[ebp+edx], xmm0

; 467  : 		} 
; 468  : 		else 

  00183	e9 1d 02 00 00	 jmp	 $LN3@getRotatio
$LN2@getRotatio:

; 469  : 		{
; 470  : 			int i = m_el[0].x() < m_el[1].y() ? 

  00188	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0018d	6b c8 00	 imul	 ecx, eax, 0
  00190	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00198	8b f0		 mov	 esi, eax
  0019a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0019f	c1 e1 00	 shl	 ecx, 0
  001a2	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  001aa	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001ae	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  001b1	76 42		 jbe	 SHORT $LN9@getRotatio
  001b3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001b8	c1 e1 00	 shl	 ecx, 0
  001bb	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  001c3	8b f0		 mov	 esi, eax
  001c5	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001ca	d1 e1		 shl	 ecx, 1
  001cc	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  001d4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d8	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  001db	76 09		 jbe	 SHORT $LN5@getRotatio
  001dd	c7 45 c0 02 00
	00 00		 mov	 DWORD PTR tv185[ebp], 2
  001e4	eb 07		 jmp	 SHORT $LN6@getRotatio
$LN5@getRotatio:
  001e6	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR tv185[ebp], 1
$LN6@getRotatio:
  001ed	8b 4d c0	 mov	 ecx, DWORD PTR tv185[ebp]
  001f0	89 4d bc	 mov	 DWORD PTR tv198[ebp], ecx
  001f3	eb 40		 jmp	 SHORT $LN10@getRotatio
$LN9@getRotatio:
  001f5	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  001fa	6b ca 00	 imul	 ecx, edx, 0
  001fd	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00205	8b f0		 mov	 esi, eax
  00207	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0020c	d1 e1		 shl	 ecx, 1
  0020e	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00211	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  00216	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0021a	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  0021d	76 09		 jbe	 SHORT $LN7@getRotatio
  0021f	c7 45 b8 02 00
	00 00		 mov	 DWORD PTR tv197[ebp], 2
  00226	eb 07		 jmp	 SHORT $LN8@getRotatio
$LN7@getRotatio:
  00228	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv197[ebp], 0
$LN8@getRotatio:
  0022f	8b 45 b8	 mov	 eax, DWORD PTR tv197[ebp]
  00232	89 45 bc	 mov	 DWORD PTR tv198[ebp], eax
$LN10@getRotatio:
  00235	8b 4d bc	 mov	 ecx, DWORD PTR tv198[ebp]
  00238	89 4d d4	 mov	 DWORD PTR _i$4[ebp], ecx

; 471  : 				(m_el[1].y() < m_el[2].z() ? 2 : 1) :
; 472  : 				(m_el[0].x() < m_el[2].z() ? 2 : 0); 
; 473  : 			int j = (i + 1) % 3;  

  0023b	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  0023e	83 c0 01	 add	 eax, 1
  00241	99		 cdq
  00242	b9 03 00 00 00	 mov	 ecx, 3
  00247	f7 f9		 idiv	 ecx
  00249	89 55 d0	 mov	 DWORD PTR _j$3[ebp], edx

; 474  : 			int k = (i + 2) % 3;

  0024c	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  0024f	83 c0 02	 add	 eax, 2
  00252	99		 cdq
  00253	b9 03 00 00 00	 mov	 ecx, 3
  00258	f7 f9		 idiv	 ecx
  0025a	89 55 cc	 mov	 DWORD PTR _k$2[ebp], edx

; 475  : 
; 476  : 			btScalar s = btSqrt(m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0));

  0025d	8b 4d d4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00260	c1 e1 04	 shl	 ecx, 4
  00263	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00266	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0026b	8b f0		 mov	 esi, eax
  0026d	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  00270	c1 e1 04	 shl	 ecx, 4
  00273	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00276	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0027b	8b 55 d4	 mov	 edx, DWORD PTR _i$4[ebp]
  0027e	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  00281	f3 0f 10 04 96	 movss	 xmm0, DWORD PTR [esi+edx*4]
  00286	f3 0f 5c 04 88	 subss	 xmm0, DWORD PTR [eax+ecx*4]
  0028b	8b 4d cc	 mov	 ecx, DWORD PTR _k$2[ebp]
  0028e	c1 e1 04	 shl	 ecx, 4
  00291	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00294	f3 0f 11 45 b4	 movss	 DWORD PTR tv414[ebp], xmm0
  00299	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0029e	8b 55 cc	 mov	 edx, DWORD PTR _k$2[ebp]
  002a1	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv414[ebp]
  002a6	f3 0f 5c 04 90	 subss	 xmm0, DWORD PTR [eax+edx*4]
  002ab	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  002b3	51		 push	 ecx
  002b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b9	e8 00 00 00 00	 call	 ?btSqrt@@YAMM@Z		; btSqrt
  002be	83 c4 04	 add	 esp, 4
  002c1	d9 5d c8	 fstp	 DWORD PTR _s$1[ebp]

; 477  : 			temp[i] = s * btScalar(0.5);

  002c4	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _s$1[ebp]
  002c9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  002d1	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  002d4	f3 0f 11 44 85
	e0		 movss	 DWORD PTR _temp$[ebp+eax*4], xmm0

; 478  : 			s = btScalar(0.5) / s;

  002da	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  002e2	f3 0f 5e 45 c8	 divss	 xmm0, DWORD PTR _s$1[ebp]
  002e7	f3 0f 11 45 c8	 movss	 DWORD PTR _s$1[ebp], xmm0

; 479  : 
; 480  : 			temp[3] = (m_el[k][j] - m_el[j][k]) * s;

  002ec	8b 4d cc	 mov	 ecx, DWORD PTR _k$2[ebp]
  002ef	c1 e1 04	 shl	 ecx, 4
  002f2	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  002f5	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  002fa	8b f0		 mov	 esi, eax
  002fc	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  002ff	c1 e1 04	 shl	 ecx, 4
  00302	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00305	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0030a	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  0030d	8b 55 cc	 mov	 edx, DWORD PTR _k$2[ebp]
  00310	f3 0f 10 04 8e	 movss	 xmm0, DWORD PTR [esi+ecx*4]
  00315	f3 0f 5c 04 90	 subss	 xmm0, DWORD PTR [eax+edx*4]
  0031a	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR _s$1[ebp]
  0031f	b8 04 00 00 00	 mov	 eax, 4
  00324	6b c8 03	 imul	 ecx, eax, 3
  00327	f3 0f 11 44 0d
	e0		 movss	 DWORD PTR _temp$[ebp+ecx], xmm0

; 481  : 			temp[j] = (m_el[j][i] + m_el[i][j]) * s;

  0032d	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  00330	c1 e1 04	 shl	 ecx, 4
  00333	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00336	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0033b	8b f0		 mov	 esi, eax
  0033d	8b 4d d4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00340	c1 e1 04	 shl	 ecx, 4
  00343	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00346	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  0034b	8b 55 d4	 mov	 edx, DWORD PTR _i$4[ebp]
  0034e	8b 4d d0	 mov	 ecx, DWORD PTR _j$3[ebp]
  00351	f3 0f 10 04 96	 movss	 xmm0, DWORD PTR [esi+edx*4]
  00356	f3 0f 58 04 88	 addss	 xmm0, DWORD PTR [eax+ecx*4]
  0035b	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR _s$1[ebp]
  00360	8b 55 d0	 mov	 edx, DWORD PTR _j$3[ebp]
  00363	f3 0f 11 44 95
	e0		 movss	 DWORD PTR _temp$[ebp+edx*4], xmm0

; 482  : 			temp[k] = (m_el[k][i] + m_el[i][k]) * s;

  00369	8b 4d cc	 mov	 ecx, DWORD PTR _k$2[ebp]
  0036c	c1 e1 04	 shl	 ecx, 4
  0036f	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00372	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  00377	8b f0		 mov	 esi, eax
  00379	8b 4d d4	 mov	 ecx, DWORD PTR _i$4[ebp]
  0037c	c1 e1 04	 shl	 ecx, 4
  0037f	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00382	e8 00 00 00 00	 call	 ??BbtVector3@@QBEPBMXZ	; btVector3::operator float const *
  00387	8b 4d d4	 mov	 ecx, DWORD PTR _i$4[ebp]
  0038a	8b 55 cc	 mov	 edx, DWORD PTR _k$2[ebp]
  0038d	f3 0f 10 04 8e	 movss	 xmm0, DWORD PTR [esi+ecx*4]
  00392	f3 0f 58 04 90	 addss	 xmm0, DWORD PTR [eax+edx*4]
  00397	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR _s$1[ebp]
  0039c	8b 45 cc	 mov	 eax, DWORD PTR _k$2[ebp]
  0039f	f3 0f 11 44 85
	e0		 movss	 DWORD PTR _temp$[ebp+eax*4], xmm0
$LN3@getRotatio:

; 483  : 		}
; 484  : 		q.setValue(temp[0],temp[1],temp[2],temp[3]);

  003a5	b9 04 00 00 00	 mov	 ecx, 4
  003aa	6b d1 03	 imul	 edx, ecx, 3
  003ad	8d 44 15 e0	 lea	 eax, DWORD PTR _temp$[ebp+edx]
  003b1	50		 push	 eax
  003b2	b9 04 00 00 00	 mov	 ecx, 4
  003b7	d1 e1		 shl	 ecx, 1
  003b9	8d 54 0d e0	 lea	 edx, DWORD PTR _temp$[ebp+ecx]
  003bd	52		 push	 edx
  003be	b8 04 00 00 00	 mov	 eax, 4
  003c3	c1 e0 00	 shl	 eax, 0
  003c6	8d 4c 05 e0	 lea	 ecx, DWORD PTR _temp$[ebp+eax]
  003ca	51		 push	 ecx
  003cb	ba 04 00 00 00	 mov	 edx, 4
  003d0	6b c2 00	 imul	 eax, edx, 0
  003d3	8d 4c 05 e0	 lea	 ecx, DWORD PTR _temp$[ebp+eax]
  003d7	51		 push	 ecx
  003d8	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  003db	e8 00 00 00 00	 call	 ?setValue@btQuadWord@@QAEXABM000@Z ; btQuadWord::setValue

; 485  : #endif
; 486  : 	}

  003e0	52		 push	 edx
  003e1	8b cd		 mov	 ecx, ebp
  003e3	50		 push	 eax
  003e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@getRotatio
  003ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003ef	58		 pop	 eax
  003f0	5a		 pop	 edx
  003f1	5f		 pop	 edi
  003f2	5e		 pop	 esi
  003f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f6	33 cd		 xor	 ecx, ebp
  003f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fd	83 c4 4c	 add	 esp, 76			; 0000004cH
  00400	3b ec		 cmp	 ebp, esp
  00402	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00407	8b e5		 mov	 esp, ebp
  00409	5d		 pop	 ebp
  0040a	c2 04 00	 ret	 4
  0040d	0f 1f 00	 npad	 3
$LN13@getRotatio:
  00410	01 00 00 00	 DD	 1
  00414	00 00 00 00	 DD	 $LN12@getRotatio
$LN12@getRotatio:
  00418	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0041c	10 00 00 00	 DD	 16			; 00000010H
  00420	00 00 00 00	 DD	 $LN11@getRotatio
$LN11@getRotatio:
  00424	74		 DB	 116			; 00000074H
  00425	65		 DB	 101			; 00000065H
  00426	6d		 DB	 109			; 0000006dH
  00427	70		 DB	 112			; 00000070H
  00428	00		 DB	 0
?getRotation@btMatrix3x3@@QBEXAAVbtQuaternion@@@Z ENDP	; btMatrix3x3::getRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv141 = -12						; size = 4
tv139 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z PROC		; btMatrix3x3::tdotx, COMDAT
; _this$ = ecx

; 638  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 639  : 		return m_el[0].x() * v.x() + m_el[1].x() * v.y() + m_el[2].x() * v.z();

  0001b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00030	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00035	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00039	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0003d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00042	c1 e1 00	 shl	 ecx, 0
  00045	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00048	f3 0f 11 45 f8	 movss	 DWORD PTR tv139[ebp], xmm0
  0004d	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00052	8b f0		 mov	 esi, eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00057	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  0005c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00060	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00064	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv139[ebp]
  00069	f3 0f 58 c8	 addss	 xmm1, xmm0
  0006d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00072	d1 e1		 shl	 ecx, 1
  00074	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00077	f3 0f 11 4d f4	 movss	 DWORD PTR tv141[ebp], xmm1
  0007c	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00086	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0008b	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0008f	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00093	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR tv141[ebp]
  00098	f3 0f 58 c8	 addss	 xmm1, xmm0
  0009c	f3 0f 11 4d f0	 movss	 DWORD PTR tv135[ebp], xmm1
  000a1	d9 45 f0	 fld	 DWORD PTR tv135[ebp]

; 640  : 	}

  000a4	5e		 pop	 esi
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z ENDP		; btMatrix3x3::tdotx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv141 = -12						; size = 4
tv139 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z PROC		; btMatrix3x3::tdoty, COMDAT
; _this$ = ecx

; 642  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return m_el[0].y() * v.x() + m_el[1].y() * v.y() + m_el[2].y() * v.z();

  0001b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00030	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00035	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00039	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0003d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00042	c1 e1 00	 shl	 ecx, 0
  00045	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00048	f3 0f 11 45 f8	 movss	 DWORD PTR tv139[ebp], xmm0
  0004d	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00052	8b f0		 mov	 esi, eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00057	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  0005c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00060	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00064	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv139[ebp]
  00069	f3 0f 58 c8	 addss	 xmm1, xmm0
  0006d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00072	d1 e1		 shl	 ecx, 1
  00074	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00077	f3 0f 11 4d f4	 movss	 DWORD PTR tv141[ebp], xmm1
  0007c	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00086	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0008b	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0008f	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00093	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR tv141[ebp]
  00098	f3 0f 58 c8	 addss	 xmm1, xmm0
  0009c	f3 0f 11 4d f0	 movss	 DWORD PTR tv135[ebp], xmm1
  000a1	d9 45 f0	 fld	 DWORD PTR tv135[ebp]

; 644  : 	}

  000a4	5e		 pop	 esi
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z ENDP		; btMatrix3x3::tdoty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv141 = -12						; size = 4
tv139 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z PROC		; btMatrix3x3::tdotz, COMDAT
; _this$ = ecx

; 646  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		return m_el[0].z() * v.x() + m_el[1].z() * v.y() + m_el[2].z() * v.z();

  0001b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00030	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00035	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00039	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0003d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00042	c1 e1 00	 shl	 ecx, 0
  00045	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00048	f3 0f 11 45 f8	 movss	 DWORD PTR tv139[ebp], xmm0
  0004d	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  00052	8b f0		 mov	 esi, eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00057	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  0005c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00060	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00064	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv139[ebp]
  00069	f3 0f 58 c8	 addss	 xmm1, xmm0
  0006d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00072	d1 e1		 shl	 ecx, 1
  00074	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00077	f3 0f 11 4d f4	 movss	 DWORD PTR tv141[ebp], xmm1
  0007c	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00086	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0008b	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0008f	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00093	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR tv141[ebp]
  00098	f3 0f 58 c8	 addss	 xmm1, xmm0
  0009c	f3 0f 11 4d f0	 movss	 DWORD PTR tv135[ebp], xmm1
  000a1	d9 45 f0	 fld	 DWORD PTR tv135[ebp]

; 648  : 	}

  000a4	5e		 pop	 esi
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z ENDP		; btMatrix3x3::tdotz
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
$LN2@vector:
  00015	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00024	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00028	76 09		 jbe	 SHORT $LN5@vector
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN6@vector
$LN5@vector:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN6@vector:
  0003a	83 7d f8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	74 1a		 je	 SHORT $LN1@vector
  00040	8b f4		 mov	 esi, esp
  00042	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00045	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00052	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00055	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00058	eb bb		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0005a	5e		 pop	 esi
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ?transpose@btMatrix3x3@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?transpose@btMatrix3x3@@QBE?AV1@XZ PROC			; btMatrix3x3::transpose, COMDAT
; _this$ = ecx

; 1002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 : #if defined BT_USE_SIMD_VECTOR3 && (defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE))
; 1004 :     __m128 v0 = m_el[0].mVec128;
; 1005 :     __m128 v1 = m_el[1].mVec128;
; 1006 :     __m128 v2 = m_el[2].mVec128;    //  x2 y2 z2 w2
; 1007 :     __m128 vT;
; 1008 :     
; 1009 :     v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0
; 1010 :     
; 1011 :     vT = _mm_unpackhi_ps(v0, v1);	//	z0 z1 * *
; 1012 :     v0 = _mm_unpacklo_ps(v0, v1);	//	x0 x1 y0 y1
; 1013 : 
; 1014 :     v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3) );	// y0 y1 y2 0
; 1015 :     v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3) );	// x0 x1 x2 0
; 1016 :     v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));	// z0 z1 z2 0
; 1017 : 
; 1018 : 
; 1019 :     return btMatrix3x3( v0, v1, v2 );
; 1020 : #elif defined(BT_USE_NEON)
; 1021 :     // note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
; 1022 :     static const uint32x2_t zMask = (const uint32x2_t) {static_cast<uint32_t>(-1), 0 };
; 1023 :     float32x4x2_t top = vtrnq_f32( m_el[0].mVec128, m_el[1].mVec128 );  // {x0 x1 z0 z1}, {y0 y1 w0 w1}
; 1024 :     float32x2x2_t bl = vtrn_f32( vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f) );       // {x2  0 }, {y2 0}
; 1025 :     float32x4_t v0 = vcombine_f32( vget_low_f32(top.val[0]), bl.val[0] );
; 1026 :     float32x4_t v1 = vcombine_f32( vget_low_f32(top.val[1]), bl.val[1] );
; 1027 :     float32x2_t q = (float32x2_t) vand_u32( (uint32x2_t) vget_high_f32( m_el[2].mVec128), zMask );
; 1028 :     float32x4_t v2 = vcombine_f32( vget_high_f32(top.val[0]), q );       // z0 z1 z2  0
; 1029 :     return btMatrix3x3( v0, v1, v2 ); 
; 1030 : #else
; 1031 : 	return btMatrix3x3( m_el[0].x(), m_el[1].x(), m_el[2].x(),

  0000e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00013	d1 e1		 shl	 ecx, 1
  00015	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0001d	50		 push	 eax
  0001e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00023	c1 e1 00	 shl	 ecx, 0
  00026	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0002e	50		 push	 eax
  0002f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00034	6b c8 00	 imul	 ecx, eax, 0
  00037	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?z@btVector3@@QBEABMXZ	; btVector3::z
  0003f	50		 push	 eax
  00040	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00045	d1 e1		 shl	 ecx, 1
  00047	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  0004f	50		 push	 eax
  00050	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00055	c1 e1 00	 shl	 ecx, 0
  00058	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00060	50		 push	 eax
  00061	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00066	6b c9 00	 imul	 ecx, ecx, 0
  00069	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?y@btVector3@@QBEABMXZ	; btVector3::y
  00071	50		 push	 eax
  00072	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00077	d1 e1		 shl	 ecx, 1
  00079	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00081	50		 push	 eax
  00082	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00087	c1 e1 00	 shl	 ecx, 0
  0008a	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  00092	50		 push	 eax
  00093	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00098	6b ca 00	 imul	 ecx, edx, 0
  0009b	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?x@btVector3@@QBEABMXZ	; btVector3::x
  000a3	50		 push	 eax
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a7	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABM00000000@Z ; btMatrix3x3::btMatrix3x3
  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1032 :                         m_el[0].y(), m_el[1].y(), m_el[2].y(),
; 1033 :                         m_el[0].z(), m_el[1].z(), m_el[2].z());
; 1034 : #endif
; 1035 : }

  000af	83 c4 04	 add	 esp, 4
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
?transpose@btMatrix3x3@@QBE?AV1@XZ ENDP			; btMatrix3x3::transpose
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??D@YA?AVbtVector3@@ABVbtMatrix3x3@@ABV0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AVbtVector3@@ABVbtMatrix3x3@@ABV0@@Z PROC	; operator*, COMDAT

; 1168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1169 : #if (defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE))|| defined (BT_USE_NEON)
; 1170 :     return v.dot3(m[0], m[1], m[2]);
; 1171 : #else
; 1172 : 	return btVector3(m[0].dot(v), m[1].dot(v), m[2].dot(v));

  0001b	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	50		 push	 eax
  0001f	6a 02		 push	 2
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _m$[ebp]
  00024	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00029	8b c8		 mov	 ecx, eax
  0002b	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00030	d9 5d fc	 fstp	 DWORD PTR $T3[ebp]
  00033	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00036	51		 push	 ecx
  00037	6a 01		 push	 1
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _m$[ebp]
  0003c	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00048	d9 5d f8	 fstp	 DWORD PTR $T2[ebp]
  0004b	8b 55 10	 mov	 edx, DWORD PTR _v$[ebp]
  0004e	52		 push	 edx
  0004f	6a 00		 push	 0
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _m$[ebp]
  00054	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?dot@btVector3@@QBEMABV1@@Z ; btVector3::dot
  00060	d9 5d f4	 fstp	 DWORD PTR $T1[ebp]
  00063	8d 45 fc	 lea	 eax, DWORD PTR $T3[ebp]
  00066	50		 push	 eax
  00067	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	51		 push	 ecx
  0006b	8d 55 f4	 lea	 edx, DWORD PTR $T1[ebp]
  0006e	52		 push	 edx
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00072	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  00077	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1173 : #endif
; 1174 : }

  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??D@YA?AVbtVector3@@ABVbtMatrix3x3@@ABV0@@Z ENDP	; operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmatrix3x3.h
;	COMDAT ??D@YA?AVbtMatrix3x3@@ABV0@0@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
$T7 = -12						; size = 4
$T8 = -8						; size = 4
$T9 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_m1$ = 12						; size = 4
_m2$ = 16						; size = 4
??D@YA?AVbtMatrix3x3@@ABV0@0@Z PROC			; operator*, COMDAT

; 1219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1220 : #if defined BT_USE_SIMD_VECTOR3 && (defined (BT_USE_SSE_IN_API) && defined (BT_USE_SSE))
; 1221 : 
; 1222 :     __m128 m10 = m1[0].mVec128;  
; 1223 :     __m128 m11 = m1[1].mVec128;
; 1224 :     __m128 m12 = m1[2].mVec128;
; 1225 :     
; 1226 :     __m128 m2v = _mm_and_ps(m2[0].mVec128, btvFFF0fMask);
; 1227 :     
; 1228 :     __m128 c0 = bt_splat_ps( m10, 0);
; 1229 :     __m128 c1 = bt_splat_ps( m11, 0);
; 1230 :     __m128 c2 = bt_splat_ps( m12, 0);
; 1231 :     
; 1232 :     c0 = _mm_mul_ps(c0, m2v);
; 1233 :     c1 = _mm_mul_ps(c1, m2v);
; 1234 :     c2 = _mm_mul_ps(c2, m2v);
; 1235 :     
; 1236 :     m2v = _mm_and_ps(m2[1].mVec128, btvFFF0fMask);
; 1237 :     
; 1238 :     __m128 c0_1 = bt_splat_ps( m10, 1);
; 1239 :     __m128 c1_1 = bt_splat_ps( m11, 1);
; 1240 :     __m128 c2_1 = bt_splat_ps( m12, 1);
; 1241 :     
; 1242 :     c0_1 = _mm_mul_ps(c0_1, m2v);
; 1243 :     c1_1 = _mm_mul_ps(c1_1, m2v);
; 1244 :     c2_1 = _mm_mul_ps(c2_1, m2v);
; 1245 :     
; 1246 :     m2v = _mm_and_ps(m2[2].mVec128, btvFFF0fMask);
; 1247 :     
; 1248 :     c0 = _mm_add_ps(c0, c0_1);
; 1249 :     c1 = _mm_add_ps(c1, c1_1);
; 1250 :     c2 = _mm_add_ps(c2, c2_1);
; 1251 :     
; 1252 :     m10 = bt_splat_ps( m10, 2);
; 1253 :     m11 = bt_splat_ps( m11, 2);
; 1254 :     m12 = bt_splat_ps( m12, 2);
; 1255 :     
; 1256 :     m10 = _mm_mul_ps(m10, m2v);
; 1257 :     m11 = _mm_mul_ps(m11, m2v);
; 1258 :     m12 = _mm_mul_ps(m12, m2v);
; 1259 :     
; 1260 :     c0 = _mm_add_ps(c0, m10);
; 1261 :     c1 = _mm_add_ps(c1, m11);
; 1262 :     c2 = _mm_add_ps(c2, m12);
; 1263 :     
; 1264 :     return btMatrix3x3(c0, c1, c2);
; 1265 : 
; 1266 : #elif defined(BT_USE_NEON)
; 1267 : 
; 1268 :     float32x4_t rv0, rv1, rv2;
; 1269 :     float32x4_t v0, v1, v2;
; 1270 :     float32x4_t mv0, mv1, mv2;
; 1271 : 
; 1272 :     v0 = m1[0].mVec128;
; 1273 :     v1 = m1[1].mVec128;
; 1274 :     v2 = m1[2].mVec128;
; 1275 : 
; 1276 :     mv0 = (float32x4_t) vandq_s32((int32x4_t)m2[0].mVec128, btvFFF0Mask); 
; 1277 :     mv1 = (float32x4_t) vandq_s32((int32x4_t)m2[1].mVec128, btvFFF0Mask); 
; 1278 :     mv2 = (float32x4_t) vandq_s32((int32x4_t)m2[2].mVec128, btvFFF0Mask); 
; 1279 :     
; 1280 :     rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
; 1281 :     rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
; 1282 :     rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);
; 1283 :     
; 1284 :     rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
; 1285 :     rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
; 1286 :     rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);
; 1287 :     
; 1288 :     rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
; 1289 :     rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
; 1290 :     rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);
; 1291 : 
; 1292 : 	return btMatrix3x3(rv0, rv1, rv2);
; 1293 :         
; 1294 : #else	
; 1295 : 	return btMatrix3x3(

  00026	6a 02		 push	 2
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  0002b	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00030	50		 push	 eax
  00031	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  00034	e8 00 00 00 00	 call	 ?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotz
  00039	d9 5d fc	 fstp	 DWORD PTR $T9[ebp]
  0003c	6a 02		 push	 2
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  00041	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00046	50		 push	 eax
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  0004a	e8 00 00 00 00	 call	 ?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdoty
  0004f	d9 5d f8	 fstp	 DWORD PTR $T8[ebp]
  00052	6a 02		 push	 2
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  00057	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  0005c	50		 push	 eax
  0005d	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  00060	e8 00 00 00 00	 call	 ?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotx
  00065	d9 5d f4	 fstp	 DWORD PTR $T7[ebp]
  00068	6a 01		 push	 1
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  0006d	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00072	50		 push	 eax
  00073	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  00076	e8 00 00 00 00	 call	 ?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotz
  0007b	d9 5d f0	 fstp	 DWORD PTR $T6[ebp]
  0007e	6a 01		 push	 1
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  00083	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00088	50		 push	 eax
  00089	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  0008c	e8 00 00 00 00	 call	 ?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdoty
  00091	d9 5d ec	 fstp	 DWORD PTR $T5[ebp]
  00094	6a 01		 push	 1
  00096	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  00099	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  0009e	50		 push	 eax
  0009f	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  000a2	e8 00 00 00 00	 call	 ?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotx
  000a7	d9 5d e8	 fstp	 DWORD PTR $T4[ebp]
  000aa	6a 00		 push	 0
  000ac	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  000af	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  000b4	50		 push	 eax
  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  000b8	e8 00 00 00 00	 call	 ?tdotz@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotz
  000bd	d9 5d e4	 fstp	 DWORD PTR $T3[ebp]
  000c0	6a 00		 push	 0
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  000c5	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  000ca	50		 push	 eax
  000cb	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  000ce	e8 00 00 00 00	 call	 ?tdoty@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdoty
  000d3	d9 5d e0	 fstp	 DWORD PTR $T2[ebp]
  000d6	6a 00		 push	 0
  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _m1$[ebp]
  000db	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  000e0	50		 push	 eax
  000e1	8b 4d 10	 mov	 ecx, DWORD PTR _m2$[ebp]
  000e4	e8 00 00 00 00	 call	 ?tdotx@btMatrix3x3@@QBEMABVbtVector3@@@Z ; btMatrix3x3::tdotx
  000e9	d9 5d dc	 fstp	 DWORD PTR $T1[ebp]
  000ec	8d 45 fc	 lea	 eax, DWORD PTR $T9[ebp]
  000ef	50		 push	 eax
  000f0	8d 4d f8	 lea	 ecx, DWORD PTR $T8[ebp]
  000f3	51		 push	 ecx
  000f4	8d 55 f4	 lea	 edx, DWORD PTR $T7[ebp]
  000f7	52		 push	 edx
  000f8	8d 45 f0	 lea	 eax, DWORD PTR $T6[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d ec	 lea	 ecx, DWORD PTR $T5[ebp]
  000ff	51		 push	 ecx
  00100	8d 55 e8	 lea	 edx, DWORD PTR $T4[ebp]
  00103	52		 push	 edx
  00104	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00107	50		 push	 eax
  00108	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp]
  0010b	51		 push	 ecx
  0010c	8d 55 dc	 lea	 edx, DWORD PTR $T1[ebp]
  0010f	52		 push	 edx
  00110	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00113	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABM00000000@Z ; btMatrix3x3::btMatrix3x3
  00118	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : 		m2.tdotx( m1[0]), m2.tdoty( m1[0]), m2.tdotz( m1[0]),
; 1297 : 		m2.tdotx( m1[1]), m2.tdoty( m1[1]), m2.tdotz( m1[1]),
; 1298 : 		m2.tdotx( m1[2]), m2.tdoty( m1[2]), m2.tdotz( m1[2]));
; 1299 : #endif
; 1300 : }

  0011b	83 c4 24	 add	 esp, 36			; 00000024H
  0011e	3b ec		 cmp	 ebp, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
??D@YA?AVbtMatrix3x3@@ABV0@0@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??0btTransform@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btTransform@@QAE@XZ PROC				; btTransform::btTransform, COMDAT
; _this$ = ecx

; 44   : 	btTransform() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@XZ	; btMatrix3x3::btMatrix3x3
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 30	 add	 ecx, 48			; 00000030H
  0001c	e8 00 00 00 00	 call	 ??0btVector3@@QAE@XZ	; btVector3::btVector3
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0btTransform@@QAE@XZ ENDP				; btTransform::btTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??0btTransform@@QAE@ABVbtQuaternion@@ABVbtVector3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_q$ = 8							; size = 4
_c$ = 12						; size = 4
??0btTransform@@QAE@ABVbtQuaternion@@ABVbtVector3@@@Z PROC ; btTransform::btTransform, COMDAT
; _this$ = ecx

; 52   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 		: m_basis(q),

  0000e	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABVbtQuaternion@@@Z ; btMatrix3x3::btMatrix3x3

; 51   : 		m_origin(c)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00030	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00033	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00036	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 52   : 	{}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??0btTransform@@QAE@ABVbtQuaternion@@ABVbtVector3@@@Z ENDP ; btTransform::btTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 4
_c$ = 12						; size = 4
??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z PROC ; btTransform::btTransform, COMDAT
; _this$ = ecx

; 61   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		: m_basis(b),

  0000e	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABV0@@Z ; btMatrix3x3::btMatrix3x3

; 60   : 		m_origin(c)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00030	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00033	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00036	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 61   : 	{}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z ENDP ; btTransform::btTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??0btTransform@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0btTransform@@QAE@ABV0@@Z PROC			; btTransform::btTransform, COMDAT
; _this$ = ecx

; 66   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 		: m_basis(other.m_basis),

  0000e	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0btMatrix3x3@@QAE@ABV0@@Z ; btMatrix3x3::btMatrix3x3

; 65   : 		m_origin(other.m_origin)

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	83 c2 30	 add	 edx, 48			; 00000030H
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	89 02		 mov	 DWORD PTR [edx], eax
  0002a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002d	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00030	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00033	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00036	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00039	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 67   : 	}

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 c4 04	 add	 esp, 4
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??0btTransform@@QAE@ABV0@@Z ENDP			; btTransform::btTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??4btTransform@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4btTransform@@QAEAAV0@ABV0@@Z PROC			; btTransform::operator=, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 		m_basis = other.m_basis;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??4btMatrix3x3@@QAEAAV0@ABV0@@Z ; btMatrix3x3::operator=

; 72   : 		m_origin = other.m_origin;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	83 c2 30	 add	 edx, 48			; 00000030H
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	89 02		 mov	 DWORD PTR [edx], eax
  0002a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002d	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00030	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00033	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00036	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00039	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 73   : 		return *this;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 74   : 	}

  0003f	83 c4 04	 add	 esp, 4
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??4btTransform@@QAEAAV0@ABV0@@Z ENDP			; btTransform::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??RbtTransform@@QBE?AVbtVector3@@ABV1@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
??RbtTransform@@QBE?AVbtVector3@@ABV1@@Z PROC		; btTransform::operator(), COMDAT
; _this$ = ecx

; 95   : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 20	 sub	 esp, 32			; 00000020H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00021	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00024	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00027	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00030	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00033	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00036	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :         return x.dot3(m_basis[0], m_basis[1], m_basis[2]) + m_origin;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 c0 30	 add	 eax, 48			; 00000030H
  0003f	50		 push	 eax
  00040	6a 02		 push	 2
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  0004a	50		 push	 eax
  0004b	6a 01		 push	 1
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00055	50		 push	 eax
  00056	6a 00		 push	 0
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??AbtMatrix3x3@@QBEABVbtVector3@@H@Z ; btMatrix3x3::operator[]
  00060	50		 push	 eax
  00061	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00064	51		 push	 ecx
  00065	8b 4b 0c	 mov	 ecx, DWORD PTR _x$[ebx]
  00068	e8 00 00 00 00	 call	 ?dot3@btVector3@@QBE?AV1@ABV1@00@Z ; btVector3::dot3
  0006d	50		 push	 eax
  0006e	8b 53 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebx]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ??H@YA?AVbtVector3@@ABV0@0@Z ; operator+
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 97   : 	}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	8b e3		 mov	 esp, ebx
  00082	5b		 pop	 ebx
  00083	c2 08 00	 ret	 8
??RbtTransform@@QBE?AVbtVector3@@ABV1@@Z ENDP		; btTransform::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ?getOrigin@btTransform@@QAEAAVbtVector3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOrigin@btTransform@@QAEAAVbtVector3@@XZ PROC	; btTransform::getOrigin, COMDAT
; _this$ = ecx

; 117  : 	SIMD_FORCE_INLINE btVector3&         getOrigin()         { return m_origin; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 30	 add	 eax, 48			; 00000030H
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?getOrigin@btTransform@@QAEAAVbtVector3@@XZ ENDP	; btTransform::getOrigin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ?getRotation@btTransform@@QBE?AVbtQuaternion@@XZ
_TEXT	SEGMENT
_q$ = -32						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getRotation@btTransform@@QBE?AVbtQuaternion@@XZ PROC	; btTransform::getRotation, COMDAT
; _this$ = ecx

; 122  : 	btQuaternion getRotation() const { 

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 30	 sub	 esp, 48			; 00000030H
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 		btQuaternion q;

  0002e	8d 4d e0	 lea	 ecx, DWORD PTR _q$[ebp]
  00031	e8 00 00 00 00	 call	 ??0btQuaternion@@QAE@XZ	; btQuaternion::btQuaternion

; 124  : 		m_basis.getRotation(q);

  00036	8d 45 e0	 lea	 eax, DWORD PTR _q$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?getRotation@btMatrix3x3@@QBEXAAVbtQuaternion@@@Z ; btMatrix3x3::getRotation

; 125  : 		return q;

  00042	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00045	8b 55 e0	 mov	 edx, DWORD PTR _q$[ebp]
  00048	89 11		 mov	 DWORD PTR [ecx], edx
  0004a	8b 45 e4	 mov	 eax, DWORD PTR _q$[ebp+4]
  0004d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00050	8b 55 e8	 mov	 edx, DWORD PTR _q$[ebp+8]
  00053	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00056	8b 45 ec	 mov	 eax, DWORD PTR _q$[ebp+12]
  00059	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0005c	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 126  : 	}

  0005f	52		 push	 edx
  00060	8b cd		 mov	 ecx, ebp
  00062	50		 push	 eax
  00063	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@getRotatio
  00069	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006e	58		 pop	 eax
  0006f	5a		 pop	 edx
  00070	5f		 pop	 edi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	8b e3		 mov	 esp, ebx
  00076	5b		 pop	 ebx
  00077	c2 04 00	 ret	 4
  0007a	66 90		 npad	 2
$LN5@getRotatio:
  0007c	01 00 00 00	 DD	 1
  00080	00 00 00 00	 DD	 $LN4@getRotatio
$LN4@getRotatio:
  00084	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00088	10 00 00 00	 DD	 16			; 00000010H
  0008c	00 00 00 00	 DD	 $LN3@getRotatio
$LN3@getRotatio:
  00090	71		 DB	 113			; 00000071H
  00091	00		 DB	 0
?getRotation@btTransform@@QBE?AVbtQuaternion@@XZ ENDP	; btTransform::getRotation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ?setIdentity@btTransform@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?setIdentity@btTransform@@QAEXXZ PROC			; btTransform::setIdentity, COMDAT
; _this$ = ecx

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 		m_basis.setIdentity();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?setIdentity@btMatrix3x3@@QAEXXZ ; btMatrix3x3::setIdentity

; 175  : 		m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));

  00022	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0002a	f3 0f 11 45 f8	 movss	 DWORD PTR $T3[ebp], xmm0
  0002f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00037	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp], xmm0
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00044	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0
  00049	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  00050	51		 push	 ecx
  00051	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00054	52		 push	 edx
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 30	 add	 ecx, 48			; 00000030H
  0005b	e8 00 00 00 00	 call	 ?setValue@btVector3@@QAEXABM00@Z ; btVector3::setValue

; 176  : 	}

  00060	83 c4 10	 add	 esp, 16			; 00000010H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?setIdentity@btTransform@@QAEXXZ ENDP			; btTransform::setIdentity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ?inverse@btTransform@@QBE?AV1@XZ
_TEXT	SEGMENT
$T1 = -112						; size = 16
$T2 = -96						; size = 16
_inv$ = -64						; size = 48
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?inverse@btTransform@@QBE?AV1@XZ PROC			; btTransform::inverse, COMDAT
; _this$ = ecx

; 189  : 	{ 

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 70	 sub	 esp, 112		; 00000070H
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d 90	 lea	 edi, DWORD PTR [ebp-112]
  0001e	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 190  : 		btMatrix3x3 inv = m_basis.transpose();

  00038	8d 45 c0	 lea	 eax, DWORD PTR _inv$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?transpose@btMatrix3x3@@QBE?AV1@XZ ; btMatrix3x3::transpose

; 191  : 		return btTransform(inv, inv * -m_origin);

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 30	 add	 ecx, 48			; 00000030H
  0004a	51		 push	 ecx
  0004b	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ??G@YA?AVbtVector3@@ABV0@@Z ; operator-
  00054	83 c4 08	 add	 esp, 8
  00057	50		 push	 eax
  00058	8d 45 c0	 lea	 eax, DWORD PTR _inv$[ebp]
  0005b	50		 push	 eax
  0005c	8d 4d 90	 lea	 ecx, DWORD PTR $T1[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??D@YA?AVbtVector3@@ABVbtMatrix3x3@@ABV0@@Z ; operator*
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	50		 push	 eax
  00069	8d 55 c0	 lea	 edx, DWORD PTR _inv$[ebp]
  0006c	52		 push	 edx
  0006d	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00070	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z ; btTransform::btTransform
  00075	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 192  : 	}

  00078	52		 push	 edx
  00079	8b cd		 mov	 ecx, ebp
  0007b	50		 push	 eax
  0007c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@inverse
  00082	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00087	58		 pop	 eax
  00088	5a		 pop	 edx
  00089	5f		 pop	 edi
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	8b e3		 mov	 esp, ebx
  00099	5b		 pop	 ebx
  0009a	c2 04 00	 ret	 4
  0009d	0f 1f 00	 npad	 3
$LN5@inverse:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@inverse
$LN4@inverse:
  000a8	c0 ff ff ff	 DD	 -64			; ffffffc0H
  000ac	30 00 00 00	 DD	 48			; 00000030H
  000b0	00 00 00 00	 DD	 $LN3@inverse
$LN3@inverse:
  000b4	69		 DB	 105			; 00000069H
  000b5	6e		 DB	 110			; 0000006eH
  000b6	76		 DB	 118			; 00000076H
  000b7	00		 DB	 0
?inverse@btTransform@@QBE?AV1@XZ ENDP			; btTransform::inverse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ?getIdentity@btTransform@@SAABV1@XZ
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 16
__$EHRec$ = -12						; size = 12
?getIdentity@btTransform@@SAABV1@XZ PROC		; btTransform::getIdentity, COMDAT

; 204  : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?getIdentity@btTransform@@SAABV1@XZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 20	 sub	 esp, 32			; 00000020H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  00030	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  00033	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00036	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00039	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0003c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0003f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00042	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0004a	33 c5		 xor	 eax, ebp
  0004c	50		 push	 eax
  0004d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00050	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 205  : 		static const btTransform identityTransform(btMatrix3x3::getIdentity());

  00056	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00064	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR __Init_thread_epoch[ecx]
  0006a	7e 7d		 jle	 SHORT $LN2@getIdentit
  0006c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00071	e8 00 00 00 00	 call	 __Init_thread_header
  00076	83 c4 04	 add	 esp, 4
  00079	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA, -1 ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00080	75 67		 jne	 SHORT $LN2@getIdentit
  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00091	f3 0f 11 45 dc	 movss	 DWORD PTR $T4[ebp], xmm0
  00096	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0009e	f3 0f 11 45 d8	 movss	 DWORD PTR $T3[ebp], xmm0
  000a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000ab	f3 0f 11 45 d4	 movss	 DWORD PTR $T2[ebp], xmm0
  000b0	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000b3	50		 push	 eax
  000b4	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000b7	51		 push	 ecx
  000b8	8d 55 d4	 lea	 edx, DWORD PTR $T2[ebp]
  000bb	52		 push	 edx
  000bc	8d 4d e0	 lea	 ecx, DWORD PTR $T5[ebp]
  000bf	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?getIdentity@btMatrix3x3@@SAABV1@XZ ; btMatrix3x3::getIdentity
  000ca	50		 push	 eax
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?identityTransform@?1??getIdentity@btTransform@@SAABV2@XZ@4V2@B ; `btTransform::getIdentity'::`2'::identityTransform
  000d0	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z ; btTransform::btTransform
  000d5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dc	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  000e1	e8 00 00 00 00	 call	 __Init_thread_footer
  000e6	83 c4 04	 add	 esp, 4
$LN2@getIdentit:

; 206  : 		return identityTransform;

  000e9	b8 00 00 00 00	 mov	 eax, OFFSET ?identityTransform@?1??getIdentity@btTransform@@SAABV2@XZ@4V2@B ; `btTransform::getIdentity'::`2'::identityTransform

; 207  : 	}

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f8	59		 pop	 ecx
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	8b e3		 mov	 esp, ebx
  000fe	5b		 pop	 ebx
  000ff	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getIdentity@btTransform@@SAABV1@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??getIdentity@btTransform@@SAABV2@XZ@4HA ; TSS0<`template-parameter-2',btTransform::etIdentity, ?? :: ?? ::HA::XZ::XZ::BV2 * const volatile>
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
__ehhandler$?getIdentity@btTransform@@SAABV1@XZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getIdentity@btTransform@@SAABV1@XZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getIdentity@btTransform@@SAABV1@XZ ENDP		; btTransform::getIdentity
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\bttransform.h
;	COMDAT ??DbtTransform@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 16
$T2 = -64						; size = 48
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_t$ = 12						; size = 4
??DbtTransform@@QBE?AV0@ABV0@@Z PROC			; btTransform::operator*, COMDAT
; _this$ = ecx

; 239  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 50	 sub	 esp, 80			; 00000050H
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0001e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 	return btTransform(m_basis * t.m_basis, 

  00038	8b 43 0c	 mov	 eax, DWORD PTR _t$[ebx]
  0003b	83 c0 30	 add	 eax, 48			; 00000030H
  0003e	50		 push	 eax
  0003f	8d 4d b0	 lea	 ecx, DWORD PTR $T1[ebp]
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??RbtTransform@@QBE?AVbtVector3@@ABV1@@Z ; btTransform::operator()
  0004b	50		 push	 eax
  0004c	8b 53 0c	 mov	 edx, DWORD PTR _t$[ebx]
  0004f	52		 push	 edx
  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	50		 push	 eax
  00054	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??D@YA?AVbtMatrix3x3@@ABV0@0@Z ; operator*
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	50		 push	 eax
  00061	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00064	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABVbtMatrix3x3@@ABVbtVector3@@@Z ; btTransform::btTransform
  00069	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 241  : 		(*this)(t.m_origin));
; 242  : }

  0006c	5f		 pop	 edi
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	8b e3		 mov	 esp, ebx
  0007c	5b		 pop	 ebx
  0007d	c2 08 00	 ret	 8
??DbtTransform@@QBE?AV0@ABV0@@Z ENDP			; btTransform::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btmotionstate.h
;	COMDAT ??1btMotionState@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1btMotionState@@UAE@XZ PROC				; btMotionState::~btMotionState, COMDAT
; _this$ = ecx

; 28   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7btMotionState@@6B@

; 29   : 			
; 30   : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1btMotionState@@UAE@XZ ENDP				; btMotionState::~btMotionState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GbtMotionState@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GbtMotionState@@UAEPAXI@Z PROC			; btMotionState::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btMotionState@@UAE@XZ ; btMotionState::~btMotionState
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 04		 push	 4
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GbtMotionState@@UAEPAXI@Z ENDP			; btMotionState::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisiondispatch\btcollisionobject.h
;	COMDAT ??2btCollisionObject@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btCollisionObject@@SAPAXI@Z PROC			; btCollisionObject::operator new, COMDAT

; 120  : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btCollisionObject@@SAPAXI@Z ENDP			; btCollisionObject::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisiondispatch\btcollisionobject.h
;	COMDAT ??3btCollisionObject@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btCollisionObject@@SAXPAX@Z PROC			; btCollisionObject::operator delete, COMDAT

; 120  : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btCollisionObject@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btCollisionObject@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btCollisionObject@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btCollisionObject@@SAXPAX@Z ENDP			; btCollisionObject::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisiondispatch\btcollisionobject.h
;	COMDAT ?getCollisionFlags@btCollisionObject@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCollisionFlags@btCollisionObject@@QBEHXZ PROC	; btCollisionObject::getCollisionFlags, COMDAT
; _this$ = ecx

; 430  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 431  : 		return m_collisionFlags;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [eax+216]

; 432  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?getCollisionFlags@btCollisionObject@@QBEHXZ ENDP	; btCollisionObject::getCollisionFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisiondispatch\btcollisionobject.h
;	COMDAT ?setCollisionFlags@btCollisionObject@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flags$ = 8						; size = 4
?setCollisionFlags@btCollisionObject@@QAEXH@Z PROC	; btCollisionObject::setCollisionFlags, COMDAT
; _this$ = ecx

; 435  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 436  : 		m_collisionFlags = flags;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _flags$[ebp]
  00014	89 88 d8 00 00
	00		 mov	 DWORD PTR [eax+216], ecx

; 437  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?setCollisionFlags@btCollisionObject@@QAEXH@Z ENDP	; btCollisionObject::setCollisionFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisiondispatch\btcollisionobject.h
;	COMDAT ?setUserPointer@btCollisionObject@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_userPointer$ = 8					; size = 4
?setUserPointer@btCollisionObject@@QAEXPAX@Z PROC	; btCollisionObject::setUserPointer, COMDAT
; _this$ = ecx

; 481  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 482  : 		m_userObjectPointer = userPointer;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _userPointer$[ebp]
  00014	89 88 fc 00 00
	00		 mov	 DWORD PTR [eax+252], ecx

; 483  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?setUserPointer@btCollisionObject@@QAEXPAX@Z ENDP	; btCollisionObject::setUserPointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btcollisionshape.h
;	COMDAT ?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ PROC ; btCollisionShape::getAnisotropicRollingFrictionDirection, COMDAT
; _this$ = ecx

; 117  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		return btVector3(1,1,1);

  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00022	f3 0f 11 45 f8	 movss	 DWORD PTR $T3[ebp], xmm0
  00027	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0002f	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp], xmm0
  00034	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0003c	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0
  00041	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00044	50		 push	 eax
  00045	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  00048	51		 push	 ecx
  00049	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 119  : 	}

  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?getAnisotropicRollingFrictionDirection@btCollisionShape@@UBE?AVbtVector3@@XZ ENDP ; btCollisionShape::getAnisotropicRollingFrictionDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ??3btConvexInternalShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btConvexInternalShape@@SAXPAX@Z PROC			; btConvexInternalShape::operator delete, COMDAT

; 47   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btConvexInternalShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btConvexInternalShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btConvexInternalShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btConvexInternalShape@@SAXPAX@Z ENDP			; btConvexInternalShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ??1btConvexInternalShape@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1btConvexInternalShape@@UAE@XZ PROC			; btConvexInternalShape::~btConvexInternalShape, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7btConvexInternalShape@@6B@

; 51   : 
; 52   : 	}

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??1btConvexShape@@UAE@XZ ; btConvexShape::~btConvexShape
  0001f	83 c4 04	 add	 esp, 4
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??1btConvexInternalShape@@UAE@XZ ENDP			; btConvexInternalShape::~btConvexInternalShape
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?getAabb@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
_aabbMin$ = 12						; size = 4
_aabbMax$ = 16						; size = 4
?getAabb@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z PROC ; btConvexInternalShape::getAabb, COMDAT
; _this$ = ecx

; 89   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 		getAabbSlow(t,aabbMin,aabbMax);

  0000f	8b f4		 mov	 esi, esp
  00011	8b 45 10	 mov	 eax, DWORD PTR _aabbMax$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _aabbMin$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR _t$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 10		 mov	 edx, DWORD PTR [eax]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00028	ff d0		 call	 eax
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 91   : 	}

  00031	5e		 pop	 esi
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?getAabb@btConvexInternalShape@@UBEXABVbtTransform@@AAVbtVector3@@1@Z ENDP ; btConvexInternalShape::getAabb
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ PROC ; btConvexInternalShape::getLocalScaling, COMDAT
; _this$ = ecx

; 100  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  : 		return m_localScaling;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 102  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?getLocalScaling@btConvexInternalShape@@UBEABVbtVector3@@XZ ENDP ; btConvexInternalShape::getLocalScaling
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?setMargin@btConvexInternalShape@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_margin$ = 8						; size = 4
?setMargin@btConvexInternalShape@@UAEXM@Z PROC		; btConvexInternalShape::setMargin, COMDAT
; _this$ = ecx

; 110  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 		m_collisionMargin = margin;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _margin$[ebp]
  00016	f3 0f 11 40 30	 movss	 DWORD PTR [eax+48], xmm0

; 112  : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?setMargin@btConvexInternalShape@@UAEXM@Z ENDP		; btConvexInternalShape::setMargin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?getMargin@btConvexInternalShape@@UBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMargin@btConvexInternalShape@@UBEMXZ PROC		; btConvexInternalShape::getMargin, COMDAT
; _this$ = ecx

; 114  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 		return m_collisionMargin;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	d9 40 30	 fld	 DWORD PTR [eax+48]

; 116  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?getMargin@btConvexInternalShape@@UBEMXZ ENDP		; btConvexInternalShape::getMargin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ PROC ; btConvexInternalShape::getNumPreferredPenetrationDirections, COMDAT
; _this$ = ecx

; 124  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return 0;

  0000e	33 c0		 xor	 eax, eax

; 126  : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?getNumPreferredPenetrationDirections@btConvexInternalShape@@UBEHXZ ENDP ; btConvexInternalShape::getNumPreferredPenetrationDirections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_penetrationVector$ = 12				; size = 4
?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z PROC ; btConvexInternalShape::getPreferredPenetrationDirection, COMDAT
; _this$ = ecx

; 129  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 		(void)penetrationVector;
; 131  : 		(void)index;
; 132  : 		btAssert(0);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	85 c0		 test	 eax, eax
  00015	74 13		 je	 SHORT $LN1@getPreferr
  00017	68 84 00 00 00	 push	 132			; 00000084H
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@LMOAMGID@Assert?5e?3?2fusion3d_work?2lib?2bull@
  00021	e8 00 00 00 00	 call	 _printf
  00026	83 c4 08	 add	 esp, 8
  00029	cc		 int	 3
$LN1@getPreferr:

; 133  : 	}

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?getPreferredPenetrationDirection@btConvexInternalShape@@UBEXHAAVbtVector3@@@Z ENDP ; btConvexInternalShape::getPreferredPenetrationDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GbtConvexInternalShape@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GbtConvexInternalShape@@UAEPAXI@Z PROC		; btConvexInternalShape::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btConvexInternalShape@@UAE@XZ ; btConvexInternalShape::~btConvexInternalShape
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 24		 je	 SHORT $LN2@scalar
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___flags$[ebp]
  00021	83 e1 04	 and	 ecx, 4
  00024	75 0e		 jne	 SHORT $LN3@scalar
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ??3btConvexInternalShape@@SAXPAX@Z ; btConvexInternalShape::operator delete
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 0e		 jmp	 SHORT $LN2@scalar
$LN3@scalar:
  00034	6a 40		 push	 64			; 00000040H
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
??_GbtConvexInternalShape@@UAEPAXI@Z ENDP		; btConvexInternalShape::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ PROC ; btConvexInternalShape::calculateSerializeBufferSize, COMDAT
; _this$ = ecx

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	return sizeof(btConvexInternalShapeData);

  0000e	b8 34 00 00 00	 mov	 eax, 52			; 00000034H

; 163  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?calculateSerializeBufferSize@btConvexInternalShape@@UBEHXZ ENDP ; btConvexInternalShape::calculateSerializeBufferSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvexinternalshape.h
;	COMDAT ?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z
_TEXT	SEGMENT
_shapeData$ = -8					; size = 4
_this$ = -4						; size = 4
_dataBuffer$ = 8					; size = 4
_serializer$ = 12					; size = 4
?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z PROC ; btConvexInternalShape::serialize, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 168  : 	btConvexInternalShapeData* shapeData = (btConvexInternalShapeData*) dataBuffer;

  00017	8b 45 08	 mov	 eax, DWORD PTR _dataBuffer$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR _shapeData$[ebp], eax

; 169  : 	btCollisionShape::serialize(&shapeData->m_collisionShapeData, serializer);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _serializer$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 f8	 mov	 edx, DWORD PTR _shapeData$[ebp]
  00024	52		 push	 edx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?serialize@btCollisionShape@@UBEPBDPAXPAVbtSerializer@@@Z ; btCollisionShape::serialize

; 170  : 
; 171  : 	m_implicitShapeDimensions.serializeFloat(shapeData->m_implicitShapeDimensions);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _shapeData$[ebp]
  00030	83 c0 1c	 add	 eax, 28			; 0000001cH
  00033	50		 push	 eax
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 20	 add	 ecx, 32			; 00000020H
  0003a	e8 00 00 00 00	 call	 ?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z ; btVector3::serializeFloat

; 172  : 	m_localScaling.serializeFloat(shapeData->m_localScaling);

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _shapeData$[ebp]
  00042	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 10	 add	 ecx, 16			; 00000010H
  0004c	e8 00 00 00 00	 call	 ?serializeFloat@btVector3@@QBEXAAUbtVector3FloatData@@@Z ; btVector3::serializeFloat

; 173  : 	shapeData->m_collisionMargin = float(m_collisionMargin);

  00051	8b 55 f8	 mov	 edx, DWORD PTR _shapeData$[ebp]
  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0005a	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 174  : 
; 175  : 	return "btConvexInternalShapeData";

  0005d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BK@ILJDJEOD@btConvexInternalShapeData?$AA@

; 176  : }

  00062	83 c4 08	 add	 esp, 8
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
?serialize@btConvexInternalShape@@UBEPBDPAXPAVbtSerializer@@@Z ENDP ; btConvexInternalShape::serialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btboxshape.h
;	COMDAT ??2btBoxShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btBoxShape@@SAPAXI@Z PROC				; btBoxShape::operator new, COMDAT

; 34   : BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btBoxShape@@SAPAXI@Z ENDP				; btBoxShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btboxshape.h
;	COMDAT ??3btBoxShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btBoxShape@@SAXPAX@Z PROC				; btBoxShape::operator delete, COMDAT

; 34   : BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btBoxShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btBoxShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btBoxShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btBoxShape@@SAXPAX@Z ENDP				; btBoxShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ??2btSphereShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btSphereShape@@SAPAXI@Z PROC				; btSphereShape::operator new, COMDAT

; 27   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btSphereShape@@SAPAXI@Z ENDP				; btSphereShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ??3btSphereShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btSphereShape@@SAXPAX@Z PROC				; btSphereShape::operator delete, COMDAT

; 27   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btSphereShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btSphereShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btSphereShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btSphereShape@@SAXPAX@Z ENDP				; btSphereShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ??0btSphereShape@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_radius$ = 8						; size = 4
??0btSphereShape@@QAE@M@Z PROC				; btSphereShape::btSphereShape, COMDAT
; _this$ = ecx

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0btSphereShape@@QAE@M@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	btSphereShape (btScalar radius) : btConvexInternalShape ()

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0btConvexInternalShape@@IAE@XZ ; btConvexInternalShape::btConvexInternalShape
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 30   : 	{

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7btSphereShape@@6B@

; 31   : 		m_shapeType = SPHERE_SHAPE_PROXYTYPE;

  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	c7 41 04 08 00
	00 00		 mov	 DWORD PTR [ecx+4], 8

; 32   : 		m_implicitShapeDimensions.setX(radius);

  0004f	51		 push	 ecx
  00050	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 20	 add	 ecx, 32			; 00000020H
  00060	e8 00 00 00 00	 call	 ?setX@btVector3@@QAEXM@Z ; btVector3::setX

; 33   : 		m_collisionMargin = radius;

  00065	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00068	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _radius$[ebp]
  0006d	f3 0f 11 42 30	 movss	 DWORD PTR [edx+48], xmm0

; 34   : 	}

  00072	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00086	59		 pop	 ecx
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0btSphereShape@@QAE@M@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1btConvexInternalShape@@UAE@XZ ; btConvexInternalShape::~btConvexInternalShape
__ehhandler$??0btSphereShape@@QAE@M@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0btSphereShape@@QAE@M@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0btSphereShape@@QAE@M@Z ENDP				; btSphereShape::btSphereShape
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ?getRadius@btSphereShape@@QBEMXZ
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
?getRadius@btSphereShape@@QBEMXZ PROC			; btSphereShape::getRadius, COMDAT
; _this$ = ecx

; 47   : 	btScalar	getRadius() const { return m_implicitShapeDimensions.getX() * m_localScaling.getX();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 20	 add	 ecx, 32			; 00000020H
  0001e	e8 00 00 00 00	 call	 ?getX@btVector3@@QBEABMXZ ; btVector3::getX
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 10	 add	 ecx, 16			; 00000010H
  0002b	e8 00 00 00 00	 call	 ?getX@btVector3@@QBEABMXZ ; btVector3::getX
  00030	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00034	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00038	f3 0f 11 45 f8	 movss	 DWORD PTR tv85[ebp], xmm0
  0003d	d9 45 f8	 fld	 DWORD PTR tv85[ebp]
  00040	5e		 pop	 esi
  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?getRadius@btSphereShape@@QBEMXZ ENDP			; btSphereShape::getRadius
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ?getName@btSphereShape@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@btSphereShape@@UBEPBDXZ PROC			; btSphereShape::getName, COMDAT
; _this$ = ecx

; 56   : 	virtual const char*	getName()const {return "SPHERE";}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06FKFPCBEF@SPHERE?$AA@
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?getName@btSphereShape@@UBEPBDXZ ENDP			; btSphereShape::getName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ?setMargin@btSphereShape@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_margin$ = 8						; size = 4
?setMargin@btSphereShape@@UAEXM@Z PROC			; btSphereShape::setMargin, COMDAT
; _this$ = ecx

; 59   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 		btConvexInternalShape::setMargin(margin);

  0000e	51		 push	 ecx
  0000f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _margin$[ebp]
  00014	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?setMargin@btConvexInternalShape@@UAEXM@Z ; btConvexInternalShape::setMargin

; 61   : 	}

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?setMargin@btSphereShape@@UAEXM@Z ENDP			; btSphereShape::setMargin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btsphereshape.h
;	COMDAT ?getMargin@btSphereShape@@UBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMargin@btSphereShape@@UBEMXZ PROC			; btSphereShape::getMargin, COMDAT
; _this$ = ecx

; 63   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 		//to improve gjk behaviour, use radius+margin as the full margin, so never get into the penetration case
; 65   : 		//this means, non-uniform scaling is not supported anymore
; 66   : 		return getRadius();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?getRadius@btSphereShape@@QBEMXZ ; btSphereShape::getRadius

; 67   : 	}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?getMargin@btSphereShape@@UBEMXZ ENDP			; btSphereShape::getMargin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GbtSphereShape@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GbtSphereShape@@UAEPAXI@Z PROC			; btSphereShape::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btSphereShape@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 24		 je	 SHORT $LN2@scalar
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___flags$[ebp]
  00021	83 e1 04	 and	 ecx, 4
  00024	75 0e		 jne	 SHORT $LN3@scalar
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ??3btSphereShape@@SAXPAX@Z ; btSphereShape::operator delete
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 0e		 jmp	 SHORT $LN2@scalar
$LN3@scalar:
  00034	6a 40		 push	 64			; 00000040H
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
??_GbtSphereShape@@UAEPAXI@Z ENDP			; btSphereShape::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1btSphereShape@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1btSphereShape@@UAE@XZ PROC				; btSphereShape::~btSphereShape, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btConvexInternalShape@@UAE@XZ ; btConvexInternalShape::~btConvexInternalShape
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1btSphereShape@@UAE@XZ ENDP				; btSphereShape::~btSphereShape
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btcapsuleshape.h
;	COMDAT ??2btCapsuleShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btCapsuleShape@@SAPAXI@Z PROC			; btCapsuleShape::operator new, COMDAT

; 37   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btCapsuleShape@@SAPAXI@Z ENDP			; btCapsuleShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btcapsuleshape.h
;	COMDAT ??3btCapsuleShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btCapsuleShape@@SAXPAX@Z PROC			; btCapsuleShape::operator delete, COMDAT

; 37   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btCapsuleShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btCapsuleShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btCapsuleShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btCapsuleShape@@SAXPAX@Z ENDP			; btCapsuleShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btcylindershape.h
;	COMDAT ??2btCylinderShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btCylinderShape@@SAPAXI@Z PROC			; btCylinderShape::operator new, COMDAT

; 34   : BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btCylinderShape@@SAPAXI@Z ENDP			; btCylinderShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btcylindershape.h
;	COMDAT ??3btCylinderShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btCylinderShape@@SAXPAX@Z PROC			; btCylinderShape::operator delete, COMDAT

; 34   : BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btCylinderShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btCylinderShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btCylinderShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btCylinderShape@@SAXPAX@Z ENDP			; btCylinderShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvextrianglemeshshape.h
;	COMDAT ??2btConvexTriangleMeshShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btConvexTriangleMeshShape@@SAPAXI@Z PROC		; btConvexTriangleMeshShape::operator new, COMDAT

; 31   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btConvexTriangleMeshShape@@SAPAXI@Z ENDP		; btConvexTriangleMeshShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btconvextrianglemeshshape.h
;	COMDAT ??3btConvexTriangleMeshShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btConvexTriangleMeshShape@@SAXPAX@Z PROC		; btConvexTriangleMeshShape::operator delete, COMDAT

; 31   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btConvexTriangleMeshShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btConvexTriangleMeshShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btConvexTriangleMeshShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btConvexTriangleMeshShape@@SAXPAX@Z ENDP		; btConvexTriangleMeshShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btbvhtrianglemeshshape.h
;	COMDAT ??2btBvhTriangleMeshShape@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btBvhTriangleMeshShape@@SAPAXI@Z PROC		; btBvhTriangleMeshShape::operator new, COMDAT

; 46   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btBvhTriangleMeshShape@@SAPAXI@Z ENDP		; btBvhTriangleMeshShape::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletcollision\collisionshapes\btbvhtrianglemeshshape.h
;	COMDAT ??3btBvhTriangleMeshShape@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btBvhTriangleMeshShape@@SAXPAX@Z PROC		; btBvhTriangleMeshShape::operator delete, COMDAT

; 46   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btBvhTriangleMeshShape@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btBvhTriangleMeshShape@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btBvhTriangleMeshShape@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btBvhTriangleMeshShape@@SAXPAX@Z ENDP		; btBvhTriangleMeshShape::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btdefaultmotionstate.h
;	COMDAT ??2btDefaultMotionState@@SAPAXI@Z
_TEXT	SEGMENT
_sizeInBytes$ = 8					; size = 4
??2btDefaultMotionState@@SAPAXI@Z PROC			; btDefaultMotionState::operator new, COMDAT

; 14   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 08	 mov	 eax, DWORD PTR _sizeInBytes$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?btAlignedAllocInternal@@YAPAXIH@Z ; btAlignedAllocInternal
  0000e	83 c4 08	 add	 esp, 8
  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??2btDefaultMotionState@@SAPAXI@Z ENDP			; btDefaultMotionState::operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btdefaultmotionstate.h
;	COMDAT ??3btDefaultMotionState@@SAXPAX@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ptr$ = 8						; size = 4
??3btDefaultMotionState@@SAXPAX@Z PROC			; btDefaultMotionState::operator delete, COMDAT

; 14   : 	BT_DECLARE_ALIGNED_ALLOCATOR();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3btDefaultMotionState@@SAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?btAlignedFreeInternal@@YAXPAX@Z ; btAlignedFreeInternal
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3btDefaultMotionState@@SAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3btDefaultMotionState@@SAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3btDefaultMotionState@@SAXPAX@Z ENDP			; btDefaultMotionState::operator delete
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btdefaultmotionstate.h
;	COMDAT ??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_startTrans$ = 8					; size = 4
_centerOfMassOffset$ = 12				; size = 4
??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z PROC	; btDefaultMotionState::btDefaultMotionState, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0btMotionState@@QAE@XZ
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7btDefaultMotionState@@6B@

; 17   : 		: m_graphicsWorldTrans(startTrans),

  00045	8b 4d 08	 mov	 ecx, DWORD PTR _startTrans$[ebp]
  00048	51		 push	 ecx
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 10	 add	 ecx, 16			; 00000010H
  0004f	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABV0@@Z ; btTransform::btTransform

; 18   : 		m_centerOfMassOffset(centerOfMassOffset),

  00054	8b 55 0c	 mov	 edx, DWORD PTR _centerOfMassOffset$[ebp]
  00057	52		 push	 edx
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 50	 add	 ecx, 80			; 00000050H
  0005e	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABV0@@Z ; btTransform::btTransform

; 19   : 		m_startWorldTrans(startTrans),

  00063	8b 45 08	 mov	 eax, DWORD PTR _startTrans$[ebp]
  00066	50		 push	 eax
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00070	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABV0@@Z ; btTransform::btTransform

; 20   : 		m_userPointer(0)

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	c7 81 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+208], 0

; 23   : 	}

  00082	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	83 c4 10	 add	 esp, 16			; 00000010H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1btMotionState@@UAE@XZ ; btMotionState::~btMotionState
__ehhandler$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z ENDP	; btDefaultMotionState::btDefaultMotionState
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btdefaultmotionstate.h
;	COMDAT ?getWorldTransform@btDefaultMotionState@@UBEXAAVbtTransform@@@Z
_TEXT	SEGMENT
$T1 = -144						; size = 64
$T2 = -80						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_centerOfMassWorldTrans$ = 8				; size = 4
?getWorldTransform@btDefaultMotionState@@UBEXAAVbtTransform@@@Z PROC ; btDefaultMotionState::getWorldTransform, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	57		 push	 edi
  0001d	51		 push	 ecx
  0001e	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00024	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	59		 pop	 ecx
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 			centerOfMassWorldTrans = m_graphicsWorldTrans * m_centerOfMassOffset.inverse() ;

  0003e	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00041	50		 push	 eax
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 50	 add	 ecx, 80			; 00000050H
  00048	e8 00 00 00 00	 call	 ?inverse@btTransform@@QBE?AV1@XZ ; btTransform::inverse
  0004d	50		 push	 eax
  0004e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00054	51		 push	 ecx
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 10	 add	 ecx, 16			; 00000010H
  0005b	e8 00 00 00 00	 call	 ??DbtTransform@@QBE?AV0@ABV0@@Z ; btTransform::operator*
  00060	50		 push	 eax
  00061	8b 4b 08	 mov	 ecx, DWORD PTR _centerOfMassWorldTrans$[ebx]
  00064	e8 00 00 00 00	 call	 ??4btTransform@@QAEAAV0@ABV0@@Z ; btTransform::operator=

; 29   : 	}

  00069	5f		 pop	 edi
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	8b e3		 mov	 esp, ebx
  00079	5b		 pop	 ebx
  0007a	c2 04 00	 ret	 4
?getWorldTransform@btDefaultMotionState@@UBEXAAVbtTransform@@@Z ENDP ; btDefaultMotionState::getWorldTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\linearmath\btdefaultmotionstate.h
;	COMDAT ?setWorldTransform@btDefaultMotionState@@UAEXABVbtTransform@@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_centerOfMassWorldTrans$ = 8				; size = 4
?setWorldTransform@btDefaultMotionState@@UAEXABVbtTransform@@@Z PROC ; btDefaultMotionState::setWorldTransform, COMDAT
; _this$ = ecx

; 34   : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 50	 sub	 esp, 80			; 00000050H
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0001e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 			m_graphicsWorldTrans = centerOfMassWorldTrans * m_centerOfMassOffset;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 50	 add	 eax, 80			; 00000050H
  0003e	50		 push	 eax
  0003f	8d 4d b0	 lea	 ecx, DWORD PTR $T1[ebp]
  00042	51		 push	 ecx
  00043	8b 4b 08	 mov	 ecx, DWORD PTR _centerOfMassWorldTrans$[ebx]
  00046	e8 00 00 00 00	 call	 ??DbtTransform@@QBE?AV0@ABV0@@Z ; btTransform::operator*
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 10	 add	 ecx, 16			; 00000010H
  00052	e8 00 00 00 00	 call	 ??4btTransform@@QAEAAV0@ABV0@@Z ; btTransform::operator=

; 36   : 	}

  00057	5f		 pop	 edi
  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	8b e3		 mov	 esp, ebx
  00067	5b		 pop	 ebx
  00068	c2 04 00	 ret	 4
?setWorldTransform@btDefaultMotionState@@UAEXABVbtTransform@@@Z ENDP ; btDefaultMotionState::setWorldTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GbtDefaultMotionState@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GbtDefaultMotionState@@UAEPAXI@Z PROC		; btDefaultMotionState::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btDefaultMotionState@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 27		 je	 SHORT $LN2@scalar
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___flags$[ebp]
  00021	83 e1 04	 and	 ecx, 4
  00024	75 0e		 jne	 SHORT $LN3@scalar
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ??3btDefaultMotionState@@SAXPAX@Z ; btDefaultMotionState::operator delete
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 11		 jmp	 SHORT $LN2@scalar
$LN3@scalar:
  00034	68 e0 00 00 00	 push	 224			; 000000e0H
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00042	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_GbtDefaultMotionState@@UAEPAXI@Z ENDP		; btDefaultMotionState::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1btDefaultMotionState@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1btDefaultMotionState@@UAE@XZ PROC			; btDefaultMotionState::~btDefaultMotionState, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1btMotionState@@UAE@XZ ; btMotionState::~btMotionState
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1btDefaultMotionState@@UAE@XZ ENDP			; btDefaultMotionState::~btDefaultMotionState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0btMotionState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0btMotionState@@QAE@XZ PROC				; btMotionState::btMotionState, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7btMotionState@@6B@
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0btMotionState@@QAE@XZ ENDP				; btMotionState::btMotionState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletdynamics\dynamics\btrigidbody.h
;	COMDAT ??0btRigidBodyConstructionInfo@btRigidBody@@QAE@MPAVbtMotionState@@PAVbtCollisionShape@@ABVbtVector3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mass$ = 8						; size = 4
_motionState$ = 12					; size = 4
_collisionShape$ = 16					; size = 4
_localInertia$ = 20					; size = 4
??0btRigidBodyConstructionInfo@btRigidBody@@QAE@MPAVbtMotionState@@PAVbtCollisionShape@@ABVbtVector3@@@Z PROC ; btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo, COMDAT
; _this$ = ecx

; 169  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 		m_mass(mass),

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _mass$[ebp]
  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 154  : 			m_motionState(motionState),

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _motionState$[ebp]
  00020	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 169  : 		{

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 10	 add	 ecx, 16			; 00000010H
  00029	e8 00 00 00 00	 call	 ??0btTransform@@QAE@XZ	; btTransform::btTransform

; 155  : 			m_collisionShape(collisionShape),

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 10	 mov	 ecx, DWORD PTR _collisionShape$[ebp]
  00034	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 156  : 			m_localInertia(localInertia),

  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	83 c2 60	 add	 edx, 96			; 00000060H
  0003d	8b 45 14	 mov	 eax, DWORD PTR _localInertia$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	89 0a		 mov	 DWORD PTR [edx], ecx
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00050	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00053	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 157  : 			m_linearDamping(btScalar(0.)),

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00061	f3 0f 11 41 70	 movss	 DWORD PTR [ecx+112], xmm0

; 158  : 			m_angularDamping(btScalar(0.)),

  00066	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00071	f3 0f 11 42 74	 movss	 DWORD PTR [edx+116], xmm0

; 159  : 			m_friction(btScalar(0.5)),

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00081	f3 0f 11 40 78	 movss	 DWORD PTR [eax+120], xmm0

; 160  : 			m_rollingFriction(btScalar(0)),

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00091	f3 0f 11 41 7c	 movss	 DWORD PTR [ecx+124], xmm0

; 161  : 			m_restitution(btScalar(0.)),

  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000a1	f3 0f 11 82 80
	00 00 00	 movss	 DWORD PTR [edx+128], xmm0

; 162  : 			m_linearSleepingThreshold(btScalar(0.8)),

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  000b4	f3 0f 11 80 84
	00 00 00	 movss	 DWORD PTR [eax+132], xmm0

; 163  : 			m_angularSleepingThreshold(btScalar(1.f)),

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c7	f3 0f 11 81 88
	00 00 00	 movss	 DWORD PTR [ecx+136], xmm0

; 164  : 			m_additionalDamping(false),

  000cf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	c6 82 8c 00 00
	00 00		 mov	 BYTE PTR [edx+140], 0

; 165  : 			m_additionalDampingFactor(btScalar(0.005)),

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ba3d70a
  000e4	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [eax+144], xmm0

; 166  : 			m_additionalLinearDampingThresholdSqr(btScalar(0.01)),

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  000f7	f3 0f 11 81 94
	00 00 00	 movss	 DWORD PTR [ecx+148], xmm0

; 167  : 			m_additionalAngularDampingThresholdSqr(btScalar(0.01)),

  000ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00102	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  0010a	f3 0f 11 82 98
	00 00 00	 movss	 DWORD PTR [edx+152], xmm0

; 168  : 			m_additionalAngularDampingFactor(btScalar(0.01))

  00112	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00115	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  0011d	f3 0f 11 80 9c
	00 00 00	 movss	 DWORD PTR [eax+156], xmm0

; 170  : 			m_startWorldTransform.setIdentity();

  00125	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	83 c1 10	 add	 ecx, 16			; 00000010H
  0012b	e8 00 00 00 00	 call	 ?setIdentity@btTransform@@QAEXXZ ; btTransform::setIdentity

; 171  : 		}

  00130	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00133	83 c4 04	 add	 esp, 4
  00136	3b ec		 cmp	 ebp, esp
  00138	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 10 00	 ret	 16			; 00000010H
??0btRigidBodyConstructionInfo@btRigidBody@@QAE@MPAVbtMotionState@@PAVbtCollisionShape@@ABVbtVector3@@@Z ENDP ; btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\lib\bullet3\include\bulletdynamics\dynamics\btrigidbody.h
;	COMDAT ?getMotionState@btRigidBody@@QAEPAVbtMotionState@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMotionState@btRigidBody@@QAEPAVbtMotionState@@XZ PROC ; btRigidBody::getMotionState, COMDAT
; _this$ = ecx

; 472  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return m_optionalMotionState;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 80 14 02 00
	00		 mov	 eax, DWORD PTR [eax+532]

; 474  : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?getMotionState@btRigidBody@@QAEPAVbtMotionState@@XZ ENDP ; btRigidBody::getMotionState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 517  : 		return (_Count == 0 ? 0

  0000c	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00010	75 09		 jne	 SHORT $LN3@compare
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00019	eb 21		 jmp	 SHORT $LN4@compare
$LN3@compare:
  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcmp
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN4@compare:
  0003c	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0003f	5e		 pop	 esi
  00040	83 c4 04	 add	 esp, 4
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 523  : 		return (*_First == 0 ? 0

  0000c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00012	85 c9		 test	 ecx, ecx
  00014	75 09		 jne	 SHORT $LN3@length
  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0001d	eb 19		 jmp	 SHORT $LN4@length
$LN3@length:
  0001f	8b f4		 mov	 esi, esp
  00021	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00024	52		 push	 edx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
$LN4@length:
  00038	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0003b	5e		 pop	 esi
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 530  : 		return (_Count == 0 ? _First1

  0000c	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00010	75 08		 jne	 SHORT $LN3@copy
  00012	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00018	eb 21		 jmp	 SHORT $LN4@copy
$LN3@copy:
  0001a	8b f4		 mov	 esi, esp
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN4@copy:
  0003b	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0003e	5e		 pop	 esi
  0003f	83 c4 04	 add	 esp, 4
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 553  : 		return (_Count == 0 ? _First1

  0000c	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00010	75 08		 jne	 SHORT $LN3@move
  00012	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00018	eb 21		 jmp	 SHORT $LN4@move
$LN3@move:
  0001a	8b f4		 mov	 esi, esp
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN4@move:
  0003b	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0003e	5e		 pop	 esi
  0003f	83 c4 04	 add	 esp, 4
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 595  : 		return (_Left == _Right);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00015	75 09		 jne	 SHORT $LN3@eq_int_typ
  00017	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0001e	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00027	8a 45 fc	 mov	 al, BYTE PTR tv65[ebp]

; 596  : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 605  : 		{	// return end-of-file metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 606  : 		return (EOF);

  00003	83 c8 ff	 or	 eax, -1

; 607  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 69   : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		{	// construct childless container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 		: _Myproxy(0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 81   : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Container_base12@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 		_Orphan_all();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 96   : 		}

  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Container_base12@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Container_base12@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Container_base12::_Getpfirst, COMDAT
; _this$ = ecx

; 99   : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	75 09		 jne	 SHORT $LN3@Getpfirst
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00026	eb 0b		 jmp	 SHORT $LN4@Getpfirst
$LN3@Getpfirst:
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	83 c2 04	 add	 edx, 4
  00030	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
$LN4@Getpfirst:
  00033	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 101  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Container_base12::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 115  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 120  : 		*this = _Right;

  00021	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00024	52		 push	 edx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 121  : 		}

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00020	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00023	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00044	75 02		 jne	 SHORT $LN2@operator
  00046	eb 56		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

  00048	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0004b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004e	74 12		 je	 SHORT $LN4@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	50		 push	 eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 129  : 		else

  00060	eb 3c		 jmp	 SHORT $LN3@operator
$LN4@operator:

; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);

  00062	8b f4		 mov	 esi, esp
  00064	6a 03		 push	 3
  00066	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 			_Orphan_me();

  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b f4		 mov	 esi, esp
  0008e	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:

; 136  : 		return (*this);

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 137  : 		}

  000a1	52		 push	 edx
  000a2	8b cd		 mov	 ecx, ebp
  000a4	50		 push	 eax
  000a5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@operator
  000ab	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b0	58		 pop	 eax
  000b1	5a		 pop	 edx
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5e		 pop	 esi
  000be	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
  000ce	66 90		 npad	 2
$LN11@operator:
  000d0	01 00 00 00	 DD	 1
  000d4	00 00 00 00	 DD	 $LN10@operator
$LN10@operator:
  000d8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000dc	04 00 00 00	 DD	 4
  000e0	00 00 00 00	 DD	 $LN8@operator
$LN8@operator:
  000e4	5f		 DB	 95			; 0000005fH
  000e5	4c		 DB	 76			; 0000004cH
  000e6	6f		 DB	 111			; 0000006fH
  000e7	63		 DB	 99			; 00000063H
  000e8	6b		 DB	 107			; 0000006bH
  000e9	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 140  : 		{	// destroy the iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Iterator_base12@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00020	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00023	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0003a	8b f4		 mov	 esi, esp
  0003c	6a 03		 push	 3
  0003e	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 143  : 		_Orphan_me();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  00056	8b f4		 mov	 esi, esp
  00058	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	52		 push	 edx
  00069	8b cd		 mov	 ecx, ebp
  0006b	50		 push	 eax
  0006c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Iterator_b
  00072	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00077	58		 pop	 eax
  00078	5a		 pop	 edx
  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	5e		 pop	 esi
  00085	83 c4 1c	 add	 esp, 28			; 0000001cH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
  00093	90		 npad	 1
$LN6@Iterator_b:
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN5@Iterator_b
$LN5@Iterator_b:
  0009c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a0	04 00 00 00	 DD	 4
  000a4	00 00 00 00	 DD	 $LN3@Iterator_b
$LN3@Iterator_b:
  000a8	5f		 DB	 95			; 0000005fH
  000a9	4c		 DB	 76			; 0000004cH
  000aa	6f		 DB	 111			; 0000006fH
  000ab	63		 DB	 99			; 00000063H
  000ac	6b		 DB	 107			; 0000006bH
  000ad	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Iterator_base12@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -40						; size = 4
__Parent_proxy$3 = -32					; size = 4
__Lock$4 = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 148  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001d	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00020	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00023	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00026	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00029	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00037	33 c5		 xor	 eax, ebp
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00043	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 		if (_Parent == 0)

  00046	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  0004a	75 3e		 jne	 SHORT $LN2@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);

  0004c	8b f4		 mov	 esi, esp
  0004e	6a 03		 push	 3
  00050	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 153  : 			_Orphan_me();

  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}

  0006f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00076	8b f4		 mov	 esi, esp
  00078	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 156  : 		else

  00088	eb 6b		 jmp	 SHORT $LN1@Adopt
$LN2@Adopt:

; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

  0008a	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  0008d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008f	89 4d e0	 mov	 DWORD PTR __Parent_proxy$3[ebp], ecx

; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)

  00092	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00095	8b 02		 mov	 eax, DWORD PTR [edx]
  00097	3b 45 e0	 cmp	 eax, DWORD PTR __Parent_proxy$3[ebp]
  0009a	74 59		 je	 SHORT $LN1@Adopt

; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);

  0009c	8b f4		 mov	 esi, esp
  0009e	6a 03		 push	 3
  000a0	8d 4d d8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 164  : 				_Orphan_me();

  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

  000bf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	8b 55 e0	 mov	 edx, DWORD PTR __Parent_proxy$3[ebp]
  000c5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 166  : 				_Parent_proxy->_Myfirstiter = this;

  000cb	8b 4d e0	 mov	 ecx, DWORD PTR __Parent_proxy$3[ebp]
  000ce	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 167  : 				_Myproxy = _Parent_proxy;

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8b 4d e0	 mov	 ecx, DWORD PTR __Parent_proxy$3[ebp]
  000da	89 08		 mov	 DWORD PTR [eax], ecx

; 168  : 				}

  000dc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e3	8b f4		 mov	 esi, esp
  000e5	8d 4d d8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Adopt:

; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;
; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

  000f5	52		 push	 edx
  000f6	8b cd		 mov	 ecx, ebp
  000f8	50		 push	 eax
  000f9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Adopt
  000ff	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00104	58		 pop	 eax
  00105	5a		 pop	 edx
  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5e		 pop	 esi
  00112	83 c4 2c	 add	 esp, 44			; 0000002cH
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 04 00	 ret	 4
  00122	66 90		 npad	 2
$LN12@Adopt:
  00124	02 00 00 00	 DD	 2
  00128	00 00 00 00	 DD	 $LN11@Adopt
$LN11@Adopt:
  0012c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00130	04 00 00 00	 DD	 4
  00134	00 00 00 00	 DD	 $LN8@Adopt
  00138	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0013c	04 00 00 00	 DD	 4
  00140	00 00 00 00	 DD	 $LN9@Adopt
$LN9@Adopt:
  00144	5f		 DB	 95			; 0000005fH
  00145	4c		 DB	 76			; 0000004cH
  00146	6f		 DB	 111			; 0000006fH
  00147	63		 DB	 99			; 00000063H
  00148	6b		 DB	 107			; 0000006bH
  00149	00		 DB	 0
$LN8@Adopt:
  0014a	5f		 DB	 95			; 0000005fH
  0014b	4c		 DB	 76			; 0000004cH
  0014c	6f		 DB	 111			; 0000006fH
  0014d	63		 DB	 99			; 00000063H
  0014e	6b		 DB	 107			; 0000006bH
  0014f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
  00012	8b f4		 mov	 esi, esp
  00014	8d 4d d8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0001d	3b f4		 cmp	 esi, esp
  0001f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 177  : 		{	// disown owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 178  : 		_Myproxy = 0;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 179  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 182  : 		{	// get owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	75 09		 jne	 SHORT $LN3@Getcont
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00026	eb 0a		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
$LN4@Getcont:
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 184  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 187  : 		{	// get address of remaining iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 		return (&_Mynextiter);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 04	 add	 eax, 4

; 189  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 192  : 		{	// cut ties with parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 194  : 		if (_Myproxy != 0)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 67		 je	 SHORT $LN1@Orphan_me

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 f8	 mov	 DWORD PTR __Pnext$1[ebp], edx
$LN2@Orphan_me:

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0002e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00031	74 17		 je	 SHORT $LN3@Orphan_me
  00033	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	3b 55 fc	 cmp	 edx, DWORD PTR _this$[ebp]
  0003b	74 0d		 je	 SHORT $LN3@Orphan_me

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	83 c1 04	 add	 ecx, 4
  00045	89 4d f8	 mov	 DWORD PTR __Pnext$1[ebp], ecx
  00048	eb e1		 jmp	 SHORT $LN2@Orphan_me
$LN3@Orphan_me:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  0004a	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  0004d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00050	75 21		 jne	 SHORT $LN5@Orphan_me

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  00052	8b f4		 mov	 esi, esp
  00054	68 c9 00 00 00	 push	 201			; 000000c9H
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Orphan_me:

; 202  : 			*_Pnext = _Mynextiter;

  00073	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007c	89 10		 mov	 DWORD PTR [eax], edx

; 203  : 			_Myproxy = 0;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Orphan_me:

; 204  : 			}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 		}

  00087	5e		 pop	 esi
  00088	83 c4 08	 add	 esp, 8
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
__Lock$2 = -12						; size = 4
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != 0)

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 38 00	 cmp	 DWORD PTR [eax], 0
  00024	74 61		 je	 SHORT $LN1@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00026	8b f4		 mov	 esi, esp
  00028	6a 03		 push	 3
  0002a	8d 4d f4	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	83 c2 04	 add	 edx, 4
  00042	89 55 ec	 mov	 DWORD PTR __Pnext$1[ebp], edx
  00045	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 55 ec	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  0004f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00052	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  00054	8b 4d ec	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00057	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0005a	74 0d		 je	 SHORT $LN3@Orphan_all

; 222  : 			(*_Pnext)->_Myproxy = 0;

  0005c	8b 55 ec	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00067	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 224  : 		}

  00075	8b f4		 mov	 esi, esp
  00077	8d 4d f4	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  00087	52		 push	 edx
  00088	8b cd		 mov	 ecx, ebp
  0008a	50		 push	 eax
  0008b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@Orphan_all
  00091	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00096	58		 pop	 eax
  00097	5a		 pop	 edx
  00098	5e		 pop	 esi
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
  000a7	90		 npad	 1
$LN10@Orphan_all:
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN9@Orphan_all
$LN9@Orphan_all:
  000b0	f4 ff ff ff	 DD	 -12			; fffffff4H
  000b4	04 00 00 00	 DD	 4
  000b8	00 00 00 00	 DD	 $LN8@Orphan_all
$LN8@Orphan_all:
  000bc	5f		 DB	 95			; 0000005fH
  000bd	4c		 DB	 76			; 0000004cH
  000be	6f		 DB	 111			; 0000006fH
  000bf	63		 DB	 99			; 00000063H
  000c0	6b		 DB	 107			; 0000006bH
  000c1	00		 DB	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -20						; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 229  : 	{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  0001e	8b f4		 mov	 esi, esp
  00020	6a 03		 push	 3
  00022	8d 4d f4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 4d ec	 mov	 DWORD PTR __Temp$[ebp], ecx

; 235  : 	_Myproxy = _Right._Myproxy;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	89 0a		 mov	 DWORD PTR [edx], ecx

; 236  : 	_Right._Myproxy = _Temp;

  00044	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00047	8b 45 ec	 mov	 eax, DWORD PTR __Temp$[ebp]
  0004a	89 02		 mov	 DWORD PTR [edx], eax

; 237  : 
; 238  : 	if (_Myproxy != 0)

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00052	74 0a		 je	 SHORT $LN2@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  00054	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Swap_all:

; 240  : 	if (_Right._Myproxy != 0)

  0005e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00061	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00064	74 0a		 je	 SHORT $LN3@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00066	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0006e	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Swap_all:

; 242  : 	}

  00070	8b f4		 mov	 esi, esp
  00072	8d 4d f4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	52		 push	 edx
  00083	8b cd		 mov	 ecx, ebp
  00085	50		 push	 eax
  00086	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Swap_all
  0008c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00091	58		 pop	 eax
  00092	5a		 pop	 edx
  00093	5e		 pop	 esi
  00094	83 c4 14	 add	 esp, 20			; 00000014H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
$LN8@Swap_all:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN7@Swap_all
$LN7@Swap_all:
  000ac	f4 ff ff ff	 DD	 -12			; fffffff4H
  000b0	04 00 00 00	 DD	 4
  000b4	00 00 00 00	 DD	 $LN6@Swap_all
$LN6@Swap_all:
  000b8	5f		 DB	 95			; 0000005fH
  000b9	4c		 DB	 76			; 0000004cH
  000ba	6f		 DB	 111			; 0000006fH
  000bb	63		 DB	 99			; 00000063H
  000bc	6b		 DB	 107			; 0000006bH
  000bd	00		 DB	 0
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Ptr_container$1 = -16					; size = 4
__Block_size$2 = -12					; size = 4
__User_size$ = -8					; size = 4
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 55   : 	void *_Ptr = 0;

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 56   : 
; 57   : 	if (_Count == 0)

  0001f	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00023	75 08		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00028	e9 7b 01 00 00	 jmp	 $LN9@Allocate
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0002d	83 c8 ff	 or	 eax, -1
  00030	33 d2		 xor	 edx, edx
  00032	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00035	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00038	73 0f		 jae	 SHORT $LN3@Allocate

; 62   : 		_Xbad_alloc();	// report no memory

  0003a	8b f4		 mov	 esi, esp
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Allocate:

; 63   : 	const size_t _User_size = _Count * _Sz;

  00049	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0004c	0f af 45 0c	 imul	 eax, DWORD PTR __Sz$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __User_size$[ebp], eax

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00053	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Try_aligned_allocation$[ebp]
  00057	85 c9		 test	 ecx, ecx
  00059	0f 84 d2 00 00
	00		 je	 $LN4@Allocate
  0005f	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  00066	0f 82 c5 00 00
	00		 jb	 $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0006c	8b 55 f8	 mov	 edx, DWORD PTR __User_size$[ebp]
  0006f	83 c2 27	 add	 edx, 39			; 00000027H
  00072	89 55 f4	 mov	 DWORD PTR __Block_size$2[ebp], edx

; 72   : 		if (_Block_size <= _User_size)

  00075	8b 45 f4	 mov	 eax, DWORD PTR __Block_size$2[ebp]
  00078	3b 45 f8	 cmp	 eax, DWORD PTR __User_size$[ebp]
  0007b	77 0f		 ja	 SHORT $LN6@Allocate

; 73   : 			_Xbad_alloc();	// report no memory

  0007d	8b f4		 mov	 esi, esp
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Allocate:

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __Block_size$2[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00095	83 c4 04	 add	 esp, 4
  00098	89 45 f0	 mov	 DWORD PTR __Ptr_container$1[ebp], eax

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0009b	83 7d f0 00	 cmp	 DWORD PTR __Ptr_container$1[ebp], 0
  0009f	75 5f		 jne	 SHORT $LN7@Allocate
  000a1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
  000a6	85 d2		 test	 edx, edx
  000a8	74 04		 je	 SHORT $LN10@Allocate
  000aa	33 c0		 xor	 eax, eax
  000ac	75 2d		 jne	 SHORT $LN11@Allocate
$LN10@Allocate:
  000ae	8b f4		 mov	 esi, esp
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000ba	6a 00		 push	 0
  000bc	6a 4c		 push	 76			; 0000004cH
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000c3	6a 02		 push	 2
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	75 01		 jne	 SHORT $LN11@Allocate
  000da	cc		 int	 3
$LN11@Allocate:
  000db	8b f4		 mov	 esi, esp
  000dd	6a 00		 push	 0
  000df	6a 4c		 push	 76			; 0000004cH
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000f6	83 c4 14	 add	 esp, 20			; 00000014H
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@Allocate:

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00100	8b 55 f0	 mov	 edx, DWORD PTR __Ptr_container$1[ebp]
  00103	83 c2 27	 add	 edx, 39			; 00000027H
  00106	83 e2 e0	 and	 edx, -32		; ffffffe0H
  00109	89 55 fc	 mov	 DWORD PTR __Ptr$[ebp], edx

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0010c	b8 04 00 00 00	 mov	 eax, 4
  00111	6b c8 ff	 imul	 ecx, eax, -1
  00114	8b 55 fc	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00117	8b 45 f0	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  0011a	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;

  0011d	b9 04 00 00 00	 mov	 ecx, 4
  00122	6b d1 fe	 imul	 edx, ecx, -2
  00125	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00128	c7 04 10 fa fa
	fa fa		 mov	 DWORD PTR [eax+edx], -84215046 ; fafafafaH

; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else

  0012f	eb 74		 jmp	 SHORT $LN5@Allocate
$LN4@Allocate:

; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00131	8b 4d f8	 mov	 ecx, DWORD PTR __User_size$[ebp]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0013a	83 c4 04	 add	 esp, 4
  0013d	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00140	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00144	75 5f		 jne	 SHORT $LN5@Allocate
  00146	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
  0014b	85 d2		 test	 edx, edx
  0014d	74 04		 je	 SHORT $LN12@Allocate
  0014f	33 c0		 xor	 eax, eax
  00151	75 2d		 jne	 SHORT $LN13@Allocate
$LN12@Allocate:
  00153	8b f4		 mov	 esi, esp
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0015f	6a 00		 push	 0
  00161	6a 5a		 push	 90			; 0000005aH
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00168	6a 02		 push	 2
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00170	83 c4 18	 add	 esp, 24			; 00000018H
  00173	3b f4		 cmp	 esi, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017a	83 f8 01	 cmp	 eax, 1
  0017d	75 01		 jne	 SHORT $LN13@Allocate
  0017f	cc		 int	 3
$LN13@Allocate:
  00180	8b f4		 mov	 esi, esp
  00182	6a 00		 push	 0
  00184	6a 5a		 push	 90			; 0000005aH
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0019b	83 c4 14	 add	 esp, 20			; 00000014H
  0019e	3b f4		 cmp	 esi, esp
  001a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Allocate:

; 91   : 		}
; 92   : 	return (_Ptr);

  001a5	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN9@Allocate:

; 93   : 	}

  001a8	5e		 pop	 esi
  001a9	83 c4 10	 add	 esp, 16			; 00000010H
  001ac	3b ec		 cmp	 ebp, esp
  001ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr_container$1 = -16					; size = 4
__Ptr_ptr$2 = -12					; size = 4
__Ptr_user$3 = -8					; size = 4
__User_size$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00018	83 c8 ff	 or	 eax, -1
  0001b	33 d2		 xor	 edx, edx
  0001d	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  00020	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  00023	76 5f		 jbe	 SHORT $LN2@Deallocate
  00025	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN10@Deallocate
  0002e	33 c9		 xor	 ecx, ecx
  00030	75 2d		 jne	 SHORT $LN11@Deallocate
$LN10@Deallocate:
  00032	8b f4		 mov	 esi, esp
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0003e	6a 00		 push	 0
  00040	6a 64		 push	 100			; 00000064H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00047	6a 02		 push	 2
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0004f	83 c4 18	 add	 esp, 24			; 00000018H
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	83 f8 01	 cmp	 eax, 1
  0005c	75 01		 jne	 SHORT $LN11@Deallocate
  0005e	cc		 int	 3
$LN11@Deallocate:
  0005f	8b f4		 mov	 esi, esp
  00061	6a 00		 push	 0
  00063	6a 64		 push	 100			; 00000064H
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Deallocate:

; 101  : 	const size_t _User_size = _Count * _Sz;

  00084	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00087	0f af 45 10	 imul	 eax, DWORD PTR __Sz$[ebp]
  0008b	89 45 fc	 mov	 DWORD PTR __User_size$[ebp], eax

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0008e	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  00095	0f 82 38 02 00
	00		 jb	 $LN3@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009e	89 4d f8	 mov	 DWORD PTR __Ptr_user$3[ebp], ecx

; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  000a1	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$3[ebp]
  000a4	83 e2 1f	 and	 edx, 31			; 0000001fH
  000a7	74 5f		 je	 SHORT $LN4@Deallocate
  000a9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
  000ae	85 c0		 test	 eax, eax
  000b0	74 04		 je	 SHORT $LN12@Deallocate
  000b2	33 c9		 xor	 ecx, ecx
  000b4	75 2d		 jne	 SHORT $LN13@Deallocate
$LN12@Deallocate:
  000b6	8b f4		 mov	 esi, esp
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000c2	6a 00		 push	 0
  000c4	6a 6a		 push	 106			; 0000006aH
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000cb	6a 02		 push	 2
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
  000d6	3b f4		 cmp	 esi, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	83 f8 01	 cmp	 eax, 1
  000e0	75 01		 jne	 SHORT $LN13@Deallocate
  000e2	cc		 int	 3
$LN13@Deallocate:
  000e3	8b f4		 mov	 esi, esp
  000e5	6a 00		 push	 0
  000e7	6a 6a		 push	 106			; 0000006aH
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000fe	83 c4 14	 add	 esp, 20			; 00000014H
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@Deallocate:

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);

  00108	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  0010b	83 e8 04	 sub	 eax, 4
  0010e	89 45 f4	 mov	 DWORD PTR __Ptr_ptr$2[ebp], eax

; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_ptr$2[ebp]
  00114	8b 11		 mov	 edx, DWORD PTR [ecx]
  00116	89 55 f0	 mov	 DWORD PTR __Ptr_container$1[ebp], edx

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00119	b8 04 00 00 00	 mov	 eax, 4
  0011e	6b c8 ff	 imul	 ecx, eax, -1
  00121	8b 55 f4	 mov	 edx, DWORD PTR __Ptr_ptr$2[ebp]
  00124	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0012b	74 5f		 je	 SHORT $LN5@Deallocate
  0012d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
  00132	85 c0		 test	 eax, eax
  00134	74 04		 je	 SHORT $LN14@Deallocate
  00136	33 c9		 xor	 ecx, ecx
  00138	75 2d		 jne	 SHORT $LN15@Deallocate
$LN14@Deallocate:
  0013a	8b f4		 mov	 esi, esp
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00146	6a 00		 push	 0
  00148	6a 74		 push	 116			; 00000074H
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0014f	6a 02		 push	 2
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00157	83 c4 18	 add	 esp, 24			; 00000018H
  0015a	3b f4		 cmp	 esi, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	83 f8 01	 cmp	 eax, 1
  00164	75 01		 jne	 SHORT $LN15@Deallocate
  00166	cc		 int	 3
$LN15@Deallocate:
  00167	8b f4		 mov	 esi, esp
  00169	6a 00		 push	 0
  0016b	6a 74		 push	 116			; 00000074H
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00182	83 c4 14	 add	 esp, 20			; 00000014H
  00185	3b f4		 cmp	 esi, esp
  00187	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Deallocate:

; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0018c	8b 45 f0	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  0018f	3b 45 f8	 cmp	 eax, DWORD PTR __Ptr_user$3[ebp]
  00192	72 5f		 jb	 SHORT $LN6@Deallocate
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
  00199	85 c9		 test	 ecx, ecx
  0019b	74 04		 je	 SHORT $LN16@Deallocate
  0019d	33 d2		 xor	 edx, edx
  0019f	75 2d		 jne	 SHORT $LN17@Deallocate
$LN16@Deallocate:
  001a1	8b f4		 mov	 esi, esp
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  001ad	6a 00		 push	 0
  001af	6a 78		 push	 120			; 00000078H
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001b6	6a 02		 push	 2
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  001be	83 c4 18	 add	 esp, 24			; 00000018H
  001c1	3b f4		 cmp	 esi, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	83 f8 01	 cmp	 eax, 1
  001cb	75 01		 jne	 SHORT $LN17@Deallocate
  001cd	cc		 int	 3
$LN17@Deallocate:
  001ce	8b f4		 mov	 esi, esp
  001d0	6a 00		 push	 0
  001d2	6a 78		 push	 120			; 00000078H
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001e9	83 c4 14	 add	 esp, 20			; 00000014H
  001ec	3b f4		 cmp	 esi, esp
  001ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)

  001f3	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_user$3[ebp]
  001f6	2b 4d f0	 sub	 ecx, DWORD PTR __Ptr_container$1[ebp]
  001f9	83 f9 08	 cmp	 ecx, 8
  001fc	73 5f		 jae	 SHORT $LN7@Deallocate
  001fe	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
  00203	85 d2		 test	 edx, edx
  00205	74 04		 je	 SHORT $LN18@Deallocate
  00207	33 c0		 xor	 eax, eax
  00209	75 2d		 jne	 SHORT $LN19@Deallocate
$LN18@Deallocate:
  0020b	8b f4		 mov	 esi, esp
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00217	6a 00		 push	 0
  00219	6a 7c		 push	 124			; 0000007cH
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00220	6a 02		 push	 2
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00228	83 c4 18	 add	 esp, 24			; 00000018H
  0022b	3b f4		 cmp	 esi, esp
  0022d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00232	83 f8 01	 cmp	 eax, 1
  00235	75 01		 jne	 SHORT $LN19@Deallocate
  00237	cc		 int	 3
$LN19@Deallocate:
  00238	8b f4		 mov	 esi, esp
  0023a	6a 00		 push	 0
  0023c	6a 7c		 push	 124			; 0000007cH
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00253	83 c4 14	 add	 esp, 20			; 00000014H
  00256	3b f4		 cmp	 esi, esp
  00258	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@Deallocate:

; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)
; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0025d	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$3[ebp]
  00260	2b 55 f0	 sub	 edx, DWORD PTR __Ptr_container$1[ebp]
  00263	83 fa 27	 cmp	 edx, 39			; 00000027H
  00266	76 65		 jbe	 SHORT $LN8@Deallocate
  00268	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
  0026d	85 c0		 test	 eax, eax
  0026f	74 04		 je	 SHORT $LN20@Deallocate
  00271	33 c9		 xor	 ecx, ecx
  00273	75 30		 jne	 SHORT $LN21@Deallocate
$LN20@Deallocate:
  00275	8b f4		 mov	 esi, esp
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00281	6a 00		 push	 0
  00283	68 84 00 00 00	 push	 132			; 00000084H
  00288	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0028d	6a 02		 push	 2
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00295	83 c4 18	 add	 esp, 24			; 00000018H
  00298	3b f4		 cmp	 esi, esp
  0029a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029f	83 f8 01	 cmp	 eax, 1
  002a2	75 01		 jne	 SHORT $LN21@Deallocate
  002a4	cc		 int	 3
$LN21@Deallocate:
  002a5	8b f4		 mov	 esi, esp
  002a7	6a 00		 push	 0
  002a9	68 84 00 00 00	 push	 132			; 00000084H
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  002c3	83 c4 14	 add	 esp, 20			; 00000014H
  002c6	3b f4		 cmp	 esi, esp
  002c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  002cd	8b 45 f0	 mov	 eax, DWORD PTR __Ptr_container$1[ebp]
  002d0	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  002d3	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  002d6	51		 push	 ecx
  002d7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002dc	83 c4 04	 add	 esp, 4

; 139  : 	}

  002df	5e		 pop	 esi
  002e0	83 c4 10	 add	 esp, 16			; 00000010H
  002e3	3b ec		 cmp	 ebp, esp
  002e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ea	8b e5		 mov	 esp, ebp
  002ec	5d		 pop	 ebp
  002ed	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0Vector3f@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
??0Vector3f@@QAE@MMM@Z PROC				; Vector3f::Vector3f, COMDAT
; _this$ = ecx

; 700  : 	Vector3f(float x = 0.0f, float y = 0.0f, float z = 0.0f)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  : 	{

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$Vector3@M@@QAE@XZ	; Vector3<float>::Vector3<float>

; 702  : 		(*this)[0] = x;

  00016	6a 00		 push	 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00020	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 703  : 		(*this)[1] = y;

  00029	6a 01		 push	 1
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00038	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 704  : 		(*this)[2] = z;

  0003c	6a 02		 push	 2
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00046	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0004b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 705  : 	}

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
??0Vector3f@@QAE@MMM@Z ENDP				; Vector3f::Vector3f
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0Vector3f@@QAE@ABV?$Vector3@M@@@Z
_TEXT	SEGMENT
tv158 = -16						; size = 4
tv156 = -12						; size = 4
tv154 = -8						; size = 4
_this$ = -4						; size = 4
_r$ = 8							; size = 4
??0Vector3f@@QAE@ABV?$Vector3@M@@@Z PROC		; Vector3f::Vector3f, COMDAT
; _this$ = ecx

; 707  : 	Vector3f(const Vector3<float>& r)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 708  : 	{

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0?$Vector3@M@@QAE@XZ	; Vector3<float>::Vector3<float>

; 709  : 		(*this)[0] = r[0];

  00022	6a 00		 push	 0
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00027	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  0002c	6a 00		 push	 0
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	d9 5d f8	 fstp	 DWORD PTR tv154[ebp]
  00034	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00039	d9 45 f8	 fld	 DWORD PTR tv154[ebp]
  0003c	d9 18		 fstp	 DWORD PTR [eax]

; 710  : 		(*this)[1] = r[1];

  0003e	6a 01		 push	 1
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00043	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00048	6a 01		 push	 1
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	d9 5d f4	 fstp	 DWORD PTR tv156[ebp]
  00050	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00055	d9 45 f4	 fld	 DWORD PTR tv156[ebp]
  00058	d9 18		 fstp	 DWORD PTR [eax]

; 711  : 		(*this)[2] = r[2];

  0005a	6a 02		 push	 2
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0005f	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00064	6a 02		 push	 2
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	d9 5d f0	 fstp	 DWORD PTR tv158[ebp]
  0006c	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00071	d9 45 f0	 fld	 DWORD PTR tv158[ebp]
  00074	d9 18		 fstp	 DWORD PTR [eax]

; 712  : 	}

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	83 c4 10	 add	 esp, 16			; 00000010H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
??0Vector3f@@QAE@ABV?$Vector3@M@@@Z ENDP		; Vector3f::Vector3f
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0Quaternion@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_w$ = 20						; size = 4
??0Quaternion@@QAE@MMMM@Z PROC				; Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 847  : 	Quaternion(float x = 0.0f, float y = 0.0f, float z = 0.0f, float w = 1.0f)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 848  : 	{

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$Vector4@M@@QAE@XZ	; Vector4<float>::Vector4<float>

; 849  : 		(*this)[0] = x;

  00016	6a 00		 push	 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QAEAAMI@Z ; Vector<float,4>::operator[]
  00020	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 850  : 		(*this)[1] = y;

  00029	6a 01		 push	 1
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QAEAAMI@Z ; Vector<float,4>::operator[]
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00038	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 851  : 		(*this)[2] = z;

  0003c	6a 02		 push	 2
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QAEAAMI@Z ; Vector<float,4>::operator[]
  00046	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0004b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 852  : 		(*this)[3] = w;

  0004f	6a 03		 push	 3
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QAEAAMI@Z ; Vector<float,4>::operator[]
  00059	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _w$[ebp]
  0005e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 853  : 	}

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	83 c4 04	 add	 esp, 4
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 10 00	 ret	 16			; 00000010H
??0Quaternion@@QAE@MMMM@Z ENDP				; Quaternion::Quaternion
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetBT@Quaternion@@QBE?AVbtQuaternion@@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBT@Quaternion@@QBE?AVbtQuaternion@@XZ PROC		; Quaternion::GetBT, COMDAT
; _this$ = ecx

; 968  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 969  : 		return btQuaternion(GetX(), GetY(), GetZ(), GetW());

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetW@?$Vector4@M@@QBEMXZ ; Vector4<float>::GetW
  00025	d9 5d f8	 fstp	 DWORD PTR $T4[ebp]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetZ@?$Vector4@M@@QBEMXZ ; Vector4<float>::GetZ
  00030	d9 5d f4	 fstp	 DWORD PTR $T3[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetY@?$Vector4@M@@QBEMXZ ; Vector4<float>::GetY
  0003b	d9 5d f0	 fstp	 DWORD PTR $T2[ebp]
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?GetX@?$Vector4@M@@QBEMXZ ; Vector4<float>::GetX
  00046	d9 5d ec	 fstp	 DWORD PTR $T1[ebp]
  00049	8d 45 f8	 lea	 eax, DWORD PTR $T4[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d f4	 lea	 ecx, DWORD PTR $T3[ebp]
  00050	51		 push	 ecx
  00051	8d 55 f0	 lea	 edx, DWORD PTR $T2[ebp]
  00054	52		 push	 edx
  00055	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005c	e8 00 00 00 00	 call	 ??0btQuaternion@@QAE@ABM000@Z ; btQuaternion::btQuaternion
  00061	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 970  : 	}

  00064	83 c4 14	 add	 esp, 20			; 00000014H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?GetBT@Quaternion@@QBE?AVbtQuaternion@@XZ ENDP		; Quaternion::GetBT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetFT@Quaternion@@SA?AV1@ABVbtQuaternion@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_bt$ = 12						; size = 4
?GetFT@Quaternion@@SA?AV1@ABVbtQuaternion@@@Z PROC	; Quaternion::GetFT, COMDAT

; 973  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 974  : 		return Quaternion(bt.getX(), bt.getY(), bt.getZ(), bt.getW());

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  00006	e8 00 00 00 00	 call	 ?getW@btQuaternion@@QBEABMXZ ; btQuaternion::getW
  0000b	51		 push	 ecx
  0000c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00010	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  00018	e8 00 00 00 00	 call	 ?getZ@btQuadWord@@QBEABMXZ ; btQuadWord::getZ
  0001d	51		 push	 ecx
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  0002a	e8 00 00 00 00	 call	 ?getY@btQuadWord@@QBEABMXZ ; btQuadWord::getY
  0002f	51		 push	 ecx
  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  0003c	e8 00 00 00 00	 call	 ?getX@btQuadWord@@QBEABMXZ ; btQuadWord::getX
  00041	51		 push	 ecx
  00042	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004e	e8 00 00 00 00	 call	 ??0Quaternion@@QAE@MMMM@Z ; Quaternion::Quaternion
  00053	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 975  : 	}

  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GetFT@Quaternion@@SA?AV1@ABVbtQuaternion@@@Z ENDP	; Quaternion::GetFT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ??0Transform@@QAE@ABVVector3f@@ABVQuaternion@@M@Z
_TEXT	SEGMENT
$T1 = -136						; size = 64
$T2 = -72						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_rot$ = 12						; size = 4
_scale$ = 16						; size = 4
??0Transform@@QAE@ABVVector3f@@ABVQuaternion@@M@Z PROC	; Transform::Transform, COMDAT
; _this$ = ecx

; 34   : 		m_initializedOldStuff(false) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 78 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-136]
  00011	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		m_pos(pos),

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 30   : 		m_rot(rot),

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00047	8b 55 0c	 mov	 edx, DWORD PTR _rot$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00051	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00054	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00057	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0005a	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0005d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 31   : 		m_scale(scale),

  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _scale$[ebp]
  00068	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 32   : 		m_parent(0),

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 33   : 		m_parentMatrix(Matrix4f().InitIdentity()),

  00077	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0007d	52		 push	 edx
  0007e	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  00081	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  00086	8b c8		 mov	 ecx, eax
  00088	e8 00 00 00 00	 call	 ?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ ; Matrix<float,4>::InitIdentity
  0008d	50		 push	 eax
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	83 c1 24	 add	 ecx, 36			; 00000024H
  00094	e8 00 00 00 00	 call	 ??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z ; Matrix4<float>::Matrix4<float><4>

; 34   : 		m_initializedOldStuff(false) {}

  00099	51		 push	 ecx
  0009a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a7	51		 push	 ecx
  000a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	51		 push	 ecx
  000b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	83 c1 64	 add	 ecx, 100		; 00000064H
  000c9	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f
  000ce	51		 push	 ecx
  000cf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	51		 push	 ecx
  000dd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ea	51		 push	 ecx
  000eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f8	51		 push	 ecx
  000f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00101	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00106	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	83 c1 70	 add	 ecx, 112		; 00000070H
  0010c	e8 00 00 00 00	 call	 ??0Quaternion@@QAE@MMMM@Z ; Quaternion::Quaternion
  00111	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00114	c6 80 84 00 00
	00 00		 mov	 BYTE PTR [eax+132], 0
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	5f		 pop	 edi
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0012f	3b ec		 cmp	 ebp, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 0c 00	 ret	 12			; 0000000cH
??0Transform@@QAE@ABVVector3f@@ABVQuaternion@@M@Z ENDP	; Transform::Transform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?GetPos@Transform@@QAEPAVVector3f@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPos@Transform@@QAEPAVVector3f@@XZ PROC		; Transform::GetPos, COMDAT
; _this$ = ecx

; 48   : 	inline Vector3f* GetPos()                   { return &m_pos; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetPos@Transform@@QAEPAVVector3f@@XZ ENDP		; Transform::GetPos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?GetRot@Transform@@QAEPAVQuaternion@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRot@Transform@@QAEPAVQuaternion@@XZ PROC		; Transform::GetRot, COMDAT
; _this$ = ecx

; 50   : 	inline Quaternion* GetRot()                 { return &m_rot; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 0c	 add	 eax, 12			; 0000000cH
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetRot@Transform@@QAEPAVQuaternion@@XZ ENDP		; Transform::GetRot
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?GetScale@Transform@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScale@Transform@@QBEMXZ PROC			; Transform::GetScale, COMDAT
; _this$ = ecx

; 52   : 	inline float GetScale()               const { return m_scale; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	d9 40 1c	 fld	 DWORD PTR [eax+28]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetScale@Transform@@QBEMXZ ENDP			; Transform::GetScale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?GetBT@Transform@@QAE?AVbtTransform@@XZ
_TEXT	SEGMENT
$T1 = -48						; size = 16
$T2 = -32						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBT@Transform@@QAE?AVbtTransform@@XZ PROC		; Transform::GetBT, COMDAT
; _this$ = ecx

; 57   : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 30	 sub	 esp, 48			; 00000030H
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		return btTransform(GetRot()->GetBT(), GetPos()->GetBT());

  0002e	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetPos@Transform@@QAEPAVVector3f@@XZ ; Transform::GetPos
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 ?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ ; Vector3<float>::GetBT
  00041	50		 push	 eax
  00042	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?GetRot@Transform@@QAEPAVQuaternion@@XZ ; Transform::GetRot
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ?GetBT@Quaternion@@QBE?AVbtQuaternion@@XZ ; Quaternion::GetBT
  00055	50		 push	 eax
  00056	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00059	e8 00 00 00 00	 call	 ??0btTransform@@QAE@ABVbtQuaternion@@ABVbtVector3@@@Z ; btTransform::btTransform
  0005e	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 59   : 	}

  00061	5f		 pop	 edi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	8b e3		 mov	 esp, ebx
  00067	5b		 pop	 ebx
  00068	c2 04 00	 ret	 4
?GetBT@Transform@@QAE?AVbtTransform@@XZ ENDP		; Transform::GetBT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?SetPos@Transform@@QAEXABVVector3f@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?SetPos@Transform@@QAEXABVVector3f@@@Z PROC		; Transform::SetPos, COMDAT
; _this$ = ecx

; 66   : 	inline void SetPos(const Vector3f& pos) { m_pos = pos; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	89 11		 mov	 DWORD PTR [ecx], edx
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?SetPos@Transform@@QAEXABVVector3f@@@Z ENDP		; Transform::SetPos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?SetRot@Transform@@QAEXABVQuaternion@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rot$ = 8						; size = 4
?SetRot@Transform@@QAEXABVQuaternion@@@Z PROC		; Transform::SetRot, COMDAT
; _this$ = ecx

; 67   : 	inline void SetRot(const Quaternion& rot) { m_rot = rot; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 0c	 add	 eax, 12			; 0000000cH
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _rot$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00027	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0002a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?SetRot@Transform@@QAEXABVQuaternion@@@Z ENDP		; Transform::SetRot
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\transform.h
;	COMDAT ?SetParent@Transform@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parent$ = 8						; size = 4
?SetParent@Transform@@QAEXPAV1@@Z PROC			; Transform::SetParent, COMDAT
; _this$ = ecx

; 69   : 	inline void SetParent(Transform* parent) { m_parent = parent; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00014	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?SetParent@Transform@@QAEXPAV1@@Z ENDP			; Transform::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.h
;	COMDAT ?GetTransform@Entity@@QAEPAVTransform@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTransform@Entity@@QAEPAVTransform@@XZ PROC		; Entity::GetTransform, COMDAT
; _this$ = ecx

; 55   : 	inline Transform* GetTransform() { return &m_transform; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 44	 add	 eax, 68			; 00000044H
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetTransform@Entity@@QAEPAVTransform@@XZ ENDP		; Entity::GetTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.h
;	COMDAT ?SetParent@Entity@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parent$ = 8						; size = 4
?SetParent@Entity@@QAEXPAV1@@Z PROC			; Entity::SetParent, COMDAT
; _this$ = ecx

; 58   : 	inline void SetParent(Entity* parent) { m_parent = parent; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?SetParent@Entity@@QAEXPAV1@@Z ENDP			; Entity::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GEntity@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GEntity@@UAEPAXI@Z PROC				; Entity::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1Entity@@UAE@XZ	; Entity::~Entity
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 11		 je	 SHORT $LN2@scalar
  0001e	68 d8 00 00 00	 push	 216			; 000000d8H
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??_GEntity@@UAEPAXI@Z ENDP				; Entity::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?__ClassType__@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?__ClassType__@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; EntityComponent::__ClassType__, COMDAT
; _this$ = ecx

; 36   : 	FCLASS (EntityComponent);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LLDLEGBI@EntityComponent?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?__ClassType__@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; EntityComponent::__ClassType__
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ??0EntityComponent@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0EntityComponent@@QAE@XZ PROC				; EntityComponent::EntityComponent, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7EntityComponent@@6B@

; 39   : 		m_parent(0) 

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 41   : 		//Mapper::RegisterComponent("EntityComponent", &fCreate<EntityComponent>);
; 42   : 	}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0EntityComponent@@QAE@XZ ENDP				; EntityComponent::EntityComponent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ??1EntityComponent@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1EntityComponent@@UAE@XZ PROC				; EntityComponent::~EntityComponent, COMDAT
; _this$ = ecx

; 43   : 	virtual ~EntityComponent() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7EntityComponent@@6B@
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1EntityComponent@@UAE@XZ ENDP				; EntityComponent::~EntityComponent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; EntityComponent::_GetClassName_, COMDAT
; _this$ = ecx

; 45   : 	virtual std::string _GetClassName_() { return "EntityComponent"; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LLDLEGBI@EntityComponent?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; EntityComponent::_GetClassName_
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?Init@EntityComponent@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@EntityComponent@@UAEXXZ PROC			; EntityComponent::Init, COMDAT
; _this$ = ecx

; 46   : 	virtual void Init() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Init@EntityComponent@@UAEXXZ ENDP			; EntityComponent::Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_delta$ = 12						; size = 4
?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z PROC	; EntityComponent::ProcessInput, COMDAT
; _this$ = ecx

; 47   : 	virtual void ProcessInput(const Input& input, float delta) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z ENDP	; EntityComponent::ProcessInput
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?Update@EntityComponent@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_delta$ = 8						; size = 4
?Update@EntityComponent@@UAEXM@Z PROC			; EntityComponent::Update, COMDAT
; _this$ = ecx

; 48   : 	virtual void Update(float delta) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?Update@EntityComponent@@UAEXM@Z ENDP			; EntityComponent::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; EntityComponent::Render, COMDAT
; _this$ = ecx

; 49   : 	virtual void Render(const Shader& shader, const RenderingEngine& renderingEngine, const Camera& camera) const {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 0c 00	 ret	 12			; 0000000cH
?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; EntityComponent::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; EntityComponent::PostRender, COMDAT
; _this$ = ecx

; 50   : 	virtual void PostRender(const Shader& shader, const RenderingEngine& renderingEngine, const Camera& camera) const {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 0c 00	 ret	 12			; 0000000cH
?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; EntityComponent::PostRender
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?DataDeploy@EntityComponent@@UAEXPAVXMLElement@tinyxml2@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_data$ = 8						; size = 4
?DataDeploy@EntityComponent@@UAEXPAVXMLElement@tinyxml2@@@Z PROC ; EntityComponent::DataDeploy, COMDAT
; _this$ = ecx

; 51   : 	virtual void DataDeploy(tinyxml2::XMLElement* data) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?DataDeploy@EntityComponent@@UAEXPAVXMLElement@tinyxml2@@@Z ENDP ; EntityComponent::DataDeploy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_engine$ = 8						; size = 4
?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z PROC ; EntityComponent::AddToEngine, COMDAT
; _this$ = ecx

; 52   : 	virtual void AddToEngine(CoreEngine* engine) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?AddToEngine@EntityComponent@@UAEXPAVCoreEngine@@@Z ENDP ; EntityComponent::AddToEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTransform@EntityComponent@@QAEPAVTransform@@XZ PROC	; EntityComponent::GetTransform, COMDAT
; _this$ = ecx

; 54   : 	inline Transform* GetTransform()             { return m_parent->GetTransform(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	e8 00 00 00 00	 call	 ?GetTransform@Entity@@QAEPAVTransform@@XZ ; Entity::GetTransform
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ENDP	; EntityComponent::GetTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entitycomponent.h
;	COMDAT ?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parent$ = 8						; size = 4
?SetParent@EntityComponent@@UAEXPAVEntity@@@Z PROC	; EntityComponent::SetParent, COMDAT
; _this$ = ecx

; 57   : 	virtual void SetParent(Entity* parent) { m_parent = parent; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?SetParent@EntityComponent@@UAEXPAVEntity@@@Z ENDP	; EntityComponent::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GEntityComponent@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GEntityComponent@@UAEPAXI@Z PROC			; EntityComponent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1EntityComponent@@UAE@XZ ; EntityComponent::~EntityComponent
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 08		 push	 8
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GEntityComponent@@UAEPAXI@Z ENDP			; EntityComponent::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\physics\physicsengine.h
;	COMDAT ?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ PROC ; PhysicsEngine::GetWorld, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 		return m_world;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 77   : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ ENDP ; PhysicsEngine::GetWorld
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\coreengine.h
;	COMDAT ?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ PROC ; CoreEngine::GetPhysicsEngine, COMDAT
; _this$ = ecx

; 44   : 	inline PhysicsEngine* GetPhysicsEngine() { return m_physicsEngine; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ ENDP ; CoreEngine::GetPhysicsEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\coreengine.h
;	COMDAT ?GetCoreEngine@CoreEngine@@SAPAV1@XZ
_TEXT	SEGMENT
?GetCoreEngine@CoreEngine@@SAPAV1@XZ PROC		; CoreEngine::GetCoreEngine, COMDAT

; 45   : 	inline static CoreEngine* GetCoreEngine() { return m_coreEngine; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_coreEngine@CoreEngine@@0PAV1@A ; CoreEngine::m_coreEngine
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetCoreEngine@CoreEngine@@SAPAV1@XZ ENDP		; CoreEngine::GetCoreEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\coreengine.h
;	COMDAT ?SetSimulation@CoreEngine@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?SetSimulation@CoreEngine@@QAEX_N@Z PROC		; CoreEngine::SetSimulation, COMDAT
; _this$ = ecx

; 47   : 	inline void SetSimulation(bool state) { m_isSimulating = state; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 4d 08	 mov	 cl, BYTE PTR _state$[ebp]
  00014	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?SetSimulation@CoreEngine@@QAEX_N@Z ENDP		; CoreEngine::SetSimulation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?__ClassType__@RigidBody@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?__ClassType__@RigidBody@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; RigidBody::__ClassType__, COMDAT
; _this$ = ecx

; 50   : 	FCLASS (RigidBody);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_09PGGEFGOE@RigidBody?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?__ClassType__@RigidBody@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; RigidBody::__ClassType__
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_shape$ = 8						; size = 4
_mass$ = 12						; size = 4
_calcInertia$ = 16					; size = 1
_inertia$ = 20						; size = 12
??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z PROC ; RigidBody::RigidBody, COMDAT
; _this$ = ecx

; 55   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??0EntityComponent@@QAE@XZ ; EntityComponent::EntityComponent
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7RigidBody@@6B@

; 53   : 		m_shape (shape),

  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _shape$[ebp]
  0004c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 54   : 		m_mass (mass)

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _mass$[ebp]
  00057	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 55   : 	{

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 20	 add	 ecx, 32			; 00000020H
  00062	e8 00 00 00 00	 call	 ??0btVector3@@QAE@XZ	; btVector3::btVector3
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 30	 add	 ecx, 48			; 00000030H
  0006d	e8 00 00 00 00	 call	 ??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
  00072	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	83 c1 40	 add	 ecx, 64			; 00000040H
  0007c	e8 00 00 00 00	 call	 ??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>
  00081	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 68	 add	 ecx, 104		; 00000068H
  0008b	e8 00 00 00 00	 call	 ??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>
  00090	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0009d	e8 00 00 00 00	 call	 ??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>
  000a2	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 56   : 		if (calcInertia)

  000a6	0f b6 4d 10	 movzx	 ecx, BYTE PTR _calcInertia$[ebp]
  000aa	85 c9		 test	 ecx, ecx
  000ac	74 31		 je	 SHORT $LN2@RigidBody

; 57   : 		{
; 58   : 			m_shape->calculateLocalInertia (m_mass, m_inertia);

  000ae	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	83 c2 20	 add	 edx, 32			; 00000020H
  000b4	8b f4		 mov	 esi, esp
  000b6	52		 push	 edx
  000b7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	51		 push	 ecx
  000bb	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000cb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	8b 12		 mov	 edx, DWORD PTR [edx]
  000d0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000d6	ff d0		 call	 eax
  000d8	3b f4		 cmp	 esi, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@RigidBody:

; 59   : 		}
; 60   : 
; 61   : 		CoreEngine::GetCoreEngine ()->SetSimulation (true);

  000df	6a 01		 push	 1
  000e1	e8 00 00 00 00	 call	 ?GetCoreEngine@CoreEngine@@SAPAV1@XZ ; CoreEngine::GetCoreEngine
  000e6	8b c8		 mov	 ecx, eax
  000e8	e8 00 00 00 00	 call	 ?SetSimulation@CoreEngine@@QAEX_N@Z ; CoreEngine::SetSimulation

; 62   : 	}

  000ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00101	59		 pop	 ecx
  00102	5e		 pop	 esi
  00103	83 c4 10	 add	 esp, 16			; 00000010H
  00106	3b ec		 cmp	 ebp, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1EntityComponent@@UAE@XZ ; EntityComponent::~EntityComponent
__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::~vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 40	 add	 ecx, 64			; 00000040H
  00019	e9 00 00 00 00	 jmp	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 68	 add	 ecx, 104		; 00000068H
  00024	e9 00 00 00 00	 jmp	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
__unwindfunclet$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00032	e9 00 00 00 00	 jmp	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
__ehhandler$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z ENDP ; RigidBody::RigidBody
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ??1RigidBody@@UAE@XZ
_TEXT	SEGMENT
tv92 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RigidBody@@UAE@XZ PROC				; RigidBody::~RigidBody, COMDAT
; _this$ = ecx

; 65   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1RigidBody@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001c	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	50		 push	 eax
  0002b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00034	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7RigidBody@@6B@

; 66   : 		CoreEngine::GetCoreEngine ()->GetPhysicsEngine ()->GetWorld ()->removeRigidBody (m_body);

  00040	e8 00 00 00 00	 call	 ?GetCoreEngine@CoreEngine@@SAPAV1@XZ ; CoreEngine::GetCoreEngine
  00045	8b c8		 mov	 ecx, eax
  00047	e8 00 00 00 00	 call	 ?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ ; CoreEngine::GetPhysicsEngine
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ ; PhysicsEngine::GetWorld
  00053	89 45 ec	 mov	 DWORD PTR tv92[ebp], eax
  00056	8b f4		 mov	 esi, esp
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005e	52		 push	 edx
  0005f	8b 45 ec	 mov	 eax, DWORD PTR tv92[ebp]
  00062	8b 10		 mov	 edx, DWORD PTR [eax]
  00064	8b 4d ec	 mov	 ecx, DWORD PTR tv92[ebp]
  00067	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0006a	ff d0		 call	 eax
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 67   : 	}

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0007c	e8 00 00 00 00	 call	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	83 c1 68	 add	 ecx, 104		; 00000068H
  00087	e8 00 00 00 00	 call	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c1 40	 add	 ecx, 64			; 00000040H
  00092	e8 00 00 00 00	 call	 ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 30	 add	 ecx, 48			; 00000030H
  0009d	e8 00 00 00 00	 call	 ??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::~vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ??1EntityComponent@@UAE@XZ ; EntityComponent::~EntityComponent
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5e		 pop	 esi
  000b6	83 c4 14	 add	 esp, 20			; 00000014H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1RigidBody@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1RigidBody@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1RigidBody@@UAE@XZ ENDP				; RigidBody::~RigidBody
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z
_TEXT	SEGMENT
tv498 = -420						; size = 4
tv497 = -416						; size = 4
tv342 = -412						; size = 4
tv339 = -408						; size = 4
tv495 = -404						; size = 4
tv494 = -400						; size = 4
tv297 = -396						; size = 4
tv595 = -392						; size = 4
tv588 = -388						; size = 4
tv249 = -384						; size = 4
tv570 = -380						; size = 4
tv224 = -376						; size = 4
tv221 = -372						; size = 4
tv486 = -368						; size = 4
tv485 = -364						; size = 4
tv179 = -360						; size = 4
tv146 = -356						; size = 4
$T2 = -352						; size = 4
$T3 = -348						; size = 4
$T4 = -344						; size = 4
$T5 = -340						; size = 4
$T6 = -336						; size = 4
$T7 = -332						; size = 4
$T8 = -328						; size = 4
$T9 = -324						; size = 4
$T10 = -320						; size = 4
$T11 = -316						; size = 4
$T12 = -312						; size = 4
$T13 = -308						; size = 4
$T14 = -304						; size = 4
$T15 = -300						; size = 4
$T16 = -296						; size = 4
$T17 = -292						; size = 4
$T18 = -288						; size = 16
$T19 = -268						; size = 12
$T20 = -256						; size = 16
$T21 = -240						; size = 12
$T22 = -228						; size = 28
_p$23 = -196						; size = 16
$T24 = -176						; size = 16
$T25 = -160						; size = 12
$T26 = -148						; size = 28
$T27 = -120						; size = 28
_s$28 = -88						; size = 28
_inertia$ = -52						; size = 12
_calcInertia$ = -33					; size = 1
_mass$ = -32						; size = 4
_shape$ = -28						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z PROC ; RigidBody::DataDeploy, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	51		 push	 ecx
  0002e	8d bd 54 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-428]
  00034	b9 67 00 00 00	 mov	 ecx, 103		; 00000067H
  00039	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0003e	f3 ab		 rep stosd
  00040	59		 pop	 ecx
  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00046	33 c5		 xor	 eax, ebp
  00048	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0004b	50		 push	 eax
  0004c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0004f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00055	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00058	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0

; 71   : 		btCollisionShape* shape = nullptr;

  00062	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _shape$[ebp], 0

; 72   : 		float mass = 0.0f;

  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00071	f3 0f 11 45 e0	 movss	 DWORD PTR _mass$[ebp], xmm0

; 73   : 		bool calcInertia = false;

  00076	c6 45 df 00	 mov	 BYTE PTR _calcInertia$[ebp], 0

; 74   : 		Vector3f inertia = Vector3f (0, 0, 0);

  0007a	51		 push	 ecx
  0007b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	51		 push	 ecx
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	51		 push	 ecx
  00097	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0009f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a4	8d 4d cc	 lea	 ecx, DWORD PTR _inertia$[ebp]
  000a7	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f

; 75   : 
; 76   : 		if (data->Attribute ("shape"))

  000ac	6a 00		 push	 0
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05KFCIHKGL@shape?$AA@
  000b3	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  000b6	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000bb	85 c0		 test	 eax, eax
  000bd	0f 84 8a 05 00
	00		 je	 $LN2@DataDeploy

; 77   : 		{
; 78   : 			std::string s = data->Attribute ("shape");

  000c3	6a 00		 push	 0
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_05KFCIHKGL@shape?$AA@
  000ca	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  000cd	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000d2	50		 push	 eax
  000d3	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  000d6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 79   : 
; 80   : 			if (s == "bvh")

  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_03LCMMOKCG@bvh?$AA@
  000e7	8d 45 a8	 lea	 eax, DWORD PTR _s$28[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  000f0	83 c4 08	 add	 esp, 8
  000f3	0f b6 c8	 movzx	 ecx, al
  000f6	85 c9		 test	 ecx, ecx
  000f8	0f 84 b1 00 00
	00		 je	 $LN4@DataDeploy

; 81   : 			{
; 82   : 				shape = new btBvhTriangleMeshShape (Mesh::ImportCollision (data->GetText ()), true);

  000fe	6a 70		 push	 112			; 00000070H
  00100	e8 00 00 00 00	 call	 ??2btBvhTriangleMeshShape@@SAPAXI@Z ; btBvhTriangleMeshShape::operator new
  00105	83 c4 04	 add	 esp, 4
  00108	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
  0010e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00112	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR $T16[ebp], 0
  00119	74 48		 je	 SHORT $LN23@DataDeploy
  0011b	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  0011e	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  00123	50		 push	 eax
  00124	8d 4d 88	 lea	 ecx, DWORD PTR $T27[ebp]
  00127	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00130	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00136	83 ca 01	 or	 edx, 1
  00139	89 95 a0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0013f	6a 01		 push	 1
  00141	6a 01		 push	 1
  00143	8d 45 88	 lea	 eax, DWORD PTR $T27[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ?ImportCollision@Mesh@@SAPAVbtTriangleMesh@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Mesh::ImportCollision
  0014c	83 c4 04	 add	 esp, 4
  0014f	50		 push	 eax
  00150	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  00156	e8 00 00 00 00	 call	 ??0btBvhTriangleMeshShape@@QAE@PAVbtStridingMeshInterface@@_N1@Z ; btBvhTriangleMeshShape::btBvhTriangleMeshShape
  0015b	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv146[ebp], eax
  00161	eb 0a		 jmp	 SHORT $LN24@DataDeploy
$LN23@DataDeploy:
  00163	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv146[ebp], 0
$LN24@DataDeploy:
  0016d	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv146[ebp]
  00173	89 8d dc fe ff
	ff		 mov	 DWORD PTR $T17[ebp], ecx
  00179	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00180	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T17[ebp]
  00186	89 55 e4	 mov	 DWORD PTR _shape$[ebp], edx
  00189	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00190	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00196	83 e0 01	 and	 eax, 1
  00199	74 0f		 je	 SHORT $LN41@DataDeploy
  0019b	83 a5 a0 fe ff
	ff fe		 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  001a2	8d 4d 88	 lea	 ecx, DWORD PTR $T27[ebp]
  001a5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN41@DataDeploy:

; 83   : 			}
; 84   : 			else if (s == "convex")

  001aa	e9 8d 04 00 00	 jmp	 $LN35@DataDeploy
$LN4@DataDeploy:
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_06OAMDAHCP@convex?$AA@
  001b4	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001bd	83 c4 08	 add	 esp, 8
  001c0	0f b6 d0	 movzx	 edx, al
  001c3	85 d2		 test	 edx, edx
  001c5	0f 84 bb 00 00
	00		 je	 $LN6@DataDeploy

; 85   : 			{
; 86   : 				shape = new btConvexTriangleMeshShape (Mesh::ImportCollision (data->GetText ()), true);

  001cb	68 90 00 00 00	 push	 144			; 00000090H
  001d0	e8 00 00 00 00	 call	 ??2btConvexTriangleMeshShape@@SAPAXI@Z ; btConvexTriangleMeshShape::operator new
  001d5	83 c4 04	 add	 esp, 4
  001d8	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
  001de	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001e2	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR $T14[ebp], 0
  001e9	74 4c		 je	 SHORT $LN25@DataDeploy
  001eb	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  001ee	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  001f3	50		 push	 eax
  001f4	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  001fa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ff	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00203	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00209	83 c8 02	 or	 eax, 2
  0020c	89 85 a0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00212	6a 01		 push	 1
  00214	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 ?ImportCollision@Mesh@@SAPAVbtTriangleMesh@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Mesh::ImportCollision
  00220	83 c4 04	 add	 esp, 4
  00223	50		 push	 eax
  00224	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  0022a	e8 00 00 00 00	 call	 ??0btConvexTriangleMeshShape@@QAE@PAVbtStridingMeshInterface@@_N@Z ; btConvexTriangleMeshShape::btConvexTriangleMeshShape
  0022f	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  00235	eb 0a		 jmp	 SHORT $LN26@DataDeploy
$LN25@DataDeploy:
  00237	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv179[ebp], 0
$LN26@DataDeploy:
  00241	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR tv179[ebp]
  00247	89 95 d4 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], edx
  0024d	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00254	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  0025a	89 45 e4	 mov	 DWORD PTR _shape$[ebp], eax
  0025d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00264	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0026a	83 e1 02	 and	 ecx, 2
  0026d	74 12		 je	 SHORT $LN45@DataDeploy
  0026f	83 a5 a0 fe ff
	ff fd		 and	 DWORD PTR $T2[ebp], -3	; fffffffdH
  00276	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0027c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN45@DataDeploy:

; 87   : 			}
; 88   : 			else if (s == "box")

  00281	e9 b6 03 00 00	 jmp	 $LN35@DataDeploy
$LN6@DataDeploy:
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_03OLPJGAII@box?$AA@
  0028b	8d 55 a8	 lea	 edx, DWORD PTR _s$28[ebp]
  0028e	52		 push	 edx
  0028f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00294	83 c4 08	 add	 esp, 8
  00297	0f b6 c0	 movzx	 eax, al
  0029a	85 c0		 test	 eax, eax
  0029c	0f 84 ab 00 00
	00		 je	 $LN8@DataDeploy

; 89   : 			{
; 90   : 				shape = new btBoxShape (Util::ParseVector3 (data->GetText ()).GetBT ());

  002a2	6a 50		 push	 80			; 00000050H
  002a4	e8 00 00 00 00	 call	 ??2btBoxShape@@SAPAXI@Z	; btBoxShape::operator new
  002a9	83 c4 04	 add	 esp, 4
  002ac	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
  002b2	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  002b6	83 bd c8 fe ff
	ff 00		 cmp	 DWORD PTR $T12[ebp], 0
  002bd	74 66		 je	 SHORT $LN27@DataDeploy
  002bf	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  002c5	51		 push	 ecx
  002c6	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  002c9	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  002ce	83 ec 1c	 sub	 esp, 28			; 0000001cH
  002d1	8b cc		 mov	 ecx, esp
  002d3	89 a5 c4 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], esp
  002d9	50		 push	 eax
  002da	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002df	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv485[ebp], eax
  002e5	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T25[ebp]
  002eb	52		 push	 edx
  002ec	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  002f1	83 c4 20	 add	 esp, 32			; 00000020H
  002f4	89 85 90 fe ff
	ff		 mov	 DWORD PTR tv486[ebp], eax
  002fa	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR tv486[ebp]
  00300	e8 00 00 00 00	 call	 ?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ ; Vector3<float>::GetBT
  00305	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  0030b	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  00311	50		 push	 eax
  00312	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  00318	e8 00 00 00 00	 call	 ??0btBoxShape@@QAE@ABVbtVector3@@@Z ; btBoxShape::btBoxShape
  0031d	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv224[ebp], eax
  00323	eb 0a		 jmp	 SHORT $LN28@DataDeploy
$LN27@DataDeploy:
  00325	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv224[ebp], 0
$LN28@DataDeploy:
  0032f	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv224[ebp]
  00335	89 8d cc fe ff
	ff		 mov	 DWORD PTR $T13[ebp], ecx
  0033b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0033f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T13[ebp]
  00345	89 55 e4	 mov	 DWORD PTR _shape$[ebp], edx
  00348	e9 ef 02 00 00	 jmp	 $LN35@DataDeploy
$LN8@DataDeploy:

; 91   : 			}
; 92   : 			else if (s == "sphere")

  0034d	68 00 00 00 00	 push	 OFFSET ??_C@_06FOHEPPJH@sphere?$AA@
  00352	8d 45 a8	 lea	 eax, DWORD PTR _s$28[ebp]
  00355	50		 push	 eax
  00356	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0035b	83 c4 08	 add	 esp, 8
  0035e	0f b6 c8	 movzx	 ecx, al
  00361	85 c9		 test	 ecx, ecx
  00363	0f 84 83 00 00
	00		 je	 $LN10@DataDeploy

; 93   : 			{
; 94   : 				shape = new btSphereShape (atof (data->GetText ()));

  00369	6a 40		 push	 64			; 00000040H
  0036b	e8 00 00 00 00	 call	 ??2btSphereShape@@SAPAXI@Z ; btSphereShape::operator new
  00370	83 c4 04	 add	 esp, 4
  00373	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  00379	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0037d	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  00384	74 3e		 je	 SHORT $LN29@DataDeploy
  00386	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  00389	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  0038e	8b f4		 mov	 esi, esp
  00390	50		 push	 eax
  00391	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00397	83 c4 04	 add	 esp, 4
  0039a	3b f4		 cmp	 esi, esp
  0039c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a1	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR tv570[ebp]
  003a7	d9 85 84 fe ff
	ff		 fld	 DWORD PTR tv570[ebp]
  003ad	51		 push	 ecx
  003ae	d9 1c 24	 fstp	 DWORD PTR [esp]
  003b1	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  003b7	e8 00 00 00 00	 call	 ??0btSphereShape@@QAE@M@Z ; btSphereShape::btSphereShape
  003bc	89 85 80 fe ff
	ff		 mov	 DWORD PTR tv249[ebp], eax
  003c2	eb 0a		 jmp	 SHORT $LN30@DataDeploy
$LN29@DataDeploy:
  003c4	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv249[ebp], 0
$LN30@DataDeploy:
  003ce	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR tv249[ebp]
  003d4	89 95 c0 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], edx
  003da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003de	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  003e4	89 45 e4	 mov	 DWORD PTR _shape$[ebp], eax
  003e7	e9 50 02 00 00	 jmp	 $LN35@DataDeploy
$LN10@DataDeploy:

; 95   : 			}
; 96   : 			else if (s == "capsule")

  003ec	68 00 00 00 00	 push	 OFFSET ??_C@_07FJIOKKEJ@capsule?$AA@
  003f1	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003fa	83 c4 08	 add	 esp, 8
  003fd	0f b6 d0	 movzx	 edx, al
  00400	85 d2		 test	 edx, edx
  00402	0f 84 18 01 00
	00		 je	 $LN12@DataDeploy

; 97   : 			{
; 98   : 				std::vector<std::string> p = Util::Split (data->GetText (), ';');

  00408	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  0040b	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  00410	50		 push	 eax
  00411	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00417	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0041c	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00420	6a 3b		 push	 59			; 0000003bH
  00422	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  00428	50		 push	 eax
  00429	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _p$23[ebp]
  0042f	51		 push	 ecx
  00430	e8 00 00 00 00	 call	 ?Split@Util@@YA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@D@Z ; Util::Split
  00435	83 c4 0c	 add	 esp, 12			; 0000000cH
  00438	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0043c	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00442	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 99   : 				shape = new btCapsuleShape (atof (p[0].c_str ()), atof (p[1].c_str ()));

  00447	6a 50		 push	 80			; 00000050H
  00449	e8 00 00 00 00	 call	 ??2btCapsuleShape@@SAPAXI@Z ; btCapsuleShape::operator new
  0044e	83 c4 04	 add	 esp, 4
  00451	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00457	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0045b	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  00462	0f 84 81 00 00
	00		 je	 $LN31@DataDeploy
  00468	6a 01		 push	 1
  0046a	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _p$23[ebp]
  00470	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  00475	8b c8		 mov	 ecx, eax
  00477	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0047c	8b f4		 mov	 esi, esp
  0047e	50		 push	 eax
  0047f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00485	83 c4 04	 add	 esp, 4
  00488	3b f4		 cmp	 esi, esp
  0048a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0048f	d9 9d 7c fe ff
	ff		 fstp	 DWORD PTR tv588[ebp]
  00495	d9 85 7c fe ff
	ff		 fld	 DWORD PTR tv588[ebp]
  0049b	51		 push	 ecx
  0049c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0049f	6a 00		 push	 0
  004a1	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _p$23[ebp]
  004a7	e8 00 00 00 00	 call	 ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
  004ac	8b c8		 mov	 ecx, eax
  004ae	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  004b3	8b f4		 mov	 esi, esp
  004b5	50		 push	 eax
  004b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  004bc	83 c4 04	 add	 esp, 4
  004bf	3b f4		 cmp	 esi, esp
  004c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c6	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR tv595[ebp]
  004cc	d9 85 78 fe ff
	ff		 fld	 DWORD PTR tv595[ebp]
  004d2	51		 push	 ecx
  004d3	d9 1c 24	 fstp	 DWORD PTR [esp]
  004d6	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  004dc	e8 00 00 00 00	 call	 ??0btCapsuleShape@@QAE@MM@Z ; btCapsuleShape::btCapsuleShape
  004e1	89 85 74 fe ff
	ff		 mov	 DWORD PTR tv297[ebp], eax
  004e7	eb 0a		 jmp	 SHORT $LN32@DataDeploy
$LN31@DataDeploy:
  004e9	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN32@DataDeploy:
  004f3	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR tv297[ebp]
  004f9	89 95 b8 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
  004ff	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00503	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00509	89 45 e4	 mov	 DWORD PTR _shape$[ebp], eax

; 100  : 			}

  0050c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00510	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _p$23[ebp]
  00516	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0051b	e9 1c 01 00 00	 jmp	 $LN35@DataDeploy
$LN12@DataDeploy:

; 101  : 			else if (s == "cylinder")

  00520	68 00 00 00 00	 push	 OFFSET ??_C@_08GNLJBPEP@cylinder?$AA@
  00525	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  00528	51		 push	 ecx
  00529	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0052e	83 c4 08	 add	 esp, 8
  00531	0f b6 d0	 movzx	 edx, al
  00534	85 d2		 test	 edx, edx
  00536	0f 84 a8 00 00
	00		 je	 $LN14@DataDeploy

; 102  : 			{
; 103  : 				shape = new btCylinderShape (Util::ParseVector3 (data->GetText ()).GetBT ());

  0053c	6a 50		 push	 80			; 00000050H
  0053e	e8 00 00 00 00	 call	 ??2btCylinderShape@@SAPAXI@Z ; btCylinderShape::operator new
  00543	83 c4 04	 add	 esp, 4
  00546	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0054c	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00550	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  00557	74 66		 je	 SHORT $LN33@DataDeploy
  00559	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  0055f	50		 push	 eax
  00560	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  00563	e8 00 00 00 00	 call	 ?GetText@XMLElement@tinyxml2@@QBEPBDXZ ; tinyxml2::XMLElement::GetText
  00568	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0056b	8b cc		 mov	 ecx, esp
  0056d	89 a5 a8 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], esp
  00573	50		 push	 eax
  00574	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00579	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv494[ebp], eax
  0057f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00585	51		 push	 ecx
  00586	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  0058b	83 c4 20	 add	 esp, 32			; 00000020H
  0058e	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv495[ebp], eax
  00594	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv495[ebp]
  0059a	e8 00 00 00 00	 call	 ?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ ; Vector3<float>::GetBT
  0059f	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv339[ebp], eax
  005a5	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv339[ebp]
  005ab	52		 push	 edx
  005ac	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  005b2	e8 00 00 00 00	 call	 ??0btCylinderShape@@QAE@ABVbtVector3@@@Z ; btCylinderShape::btCylinderShape
  005b7	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv342[ebp], eax
  005bd	eb 0a		 jmp	 SHORT $LN34@DataDeploy
$LN33@DataDeploy:
  005bf	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv342[ebp], 0
$LN34@DataDeploy:
  005c9	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv342[ebp]
  005cf	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  005d5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005d9	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  005df	89 4d e4	 mov	 DWORD PTR _shape$[ebp], ecx

; 104  : 			}
; 105  : 			else

  005e2	eb 58		 jmp	 SHORT $LN35@DataDeploy
$LN14@DataDeploy:

; 106  : 			{
; 107  : 				std::cerr << "Unsupported collision shape! " << s << std::endl;

  005e4	8b f4		 mov	 esi, esp
  005e6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005eb	8d 55 a8	 lea	 edx, DWORD PTR _s$28[ebp]
  005ee	52		 push	 edx
  005ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@ILCGBKME@Unsupported?5collision?5shape?$CB?5?$AA@
  005f4	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005f9	50		 push	 eax
  005fa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005ff	83 c4 08	 add	 esp, 8
  00602	50		 push	 eax
  00603	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00608	83 c4 08	 add	 esp, 8
  0060b	8b c8		 mov	 ecx, eax
  0060d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00613	3b f4		 cmp	 esi, esp
  00615	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 				assert (1 == 0);

  0061a	33 c9		 xor	 ecx, ecx
  0061c	75 1e		 jne	 SHORT $LN35@DataDeploy
  0061e	8b f4		 mov	 esi, esp
  00620	6a 6c		 push	 108			; 0000006cH
  00622	68 00 00 00 00	 push	 OFFSET ??_C@_1JM@EPLIDHMN@?$AAe?$AA?3?$AA?2?$AAf?$AAu?$AAs?$AAi?$AAo?$AAn?$AA3?$AAd?$AA_?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAe?$AAn?$AAg?$AAi?$AAn?$AAe?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAc?$AAo?$AAm?$AAp@
  00627	68 00 00 00 00	 push	 OFFSET ??_C@_1O@HEOOEKLB@?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0062c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00632	83 c4 0c	 add	 esp, 12			; 0000000cH
  00635	3b f4		 cmp	 esi, esp
  00637	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN35@DataDeploy:

; 109  : 			}
; 110  : 		}

  0063c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00643	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  00646	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 111  : 		else

  0064b	eb 4b		 jmp	 SHORT $LN36@DataDeploy
$LN2@DataDeploy:

; 112  : 		{
; 113  : 			std::cerr << "Unspecified collision shape! " << std::endl;

  0064d	8b f4		 mov	 esi, esp
  0064f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00654	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEOEHOMC@Unspecified?5collision?5shape?$CB?5?$AA@
  00659	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00664	83 c4 08	 add	 esp, 8
  00667	8b c8		 mov	 ecx, eax
  00669	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0066f	3b f4		 cmp	 esi, esp
  00671	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 114  : 			assert (1 == 0);

  00676	33 c9		 xor	 ecx, ecx
  00678	75 1e		 jne	 SHORT $LN36@DataDeploy
  0067a	8b f4		 mov	 esi, esp
  0067c	6a 72		 push	 114			; 00000072H
  0067e	68 00 00 00 00	 push	 OFFSET ??_C@_1JM@EPLIDHMN@?$AAe?$AA?3?$AA?2?$AAf?$AAu?$AAs?$AAi?$AAo?$AAn?$AA3?$AAd?$AA_?$AAw?$AAo?$AAr?$AAk?$AA?2?$AAe?$AAn?$AAg?$AAi?$AAn?$AAe?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAc?$AAo?$AAm?$AAp@
  00683	68 00 00 00 00	 push	 OFFSET ??_C@_1O@HEOOEKLB@?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00688	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0068e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00691	3b f4		 cmp	 esi, esp
  00693	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN36@DataDeploy:

; 115  : 		}
; 116  : 
; 117  : 		if (data->Attribute ("mass"))

  00698	6a 00		 push	 0
  0069a	68 00 00 00 00	 push	 OFFSET ??_C@_04IJEANHEE@mass?$AA@
  0069f	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  006a2	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  006a7	85 c0		 test	 eax, eax
  006a9	74 25		 je	 SHORT $LN16@DataDeploy

; 118  : 		{
; 119  : 			mass = atof (data->Attribute ("mass"));

  006ab	6a 00		 push	 0
  006ad	68 00 00 00 00	 push	 OFFSET ??_C@_04IJEANHEE@mass?$AA@
  006b2	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  006b5	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  006ba	8b f4		 mov	 esi, esp
  006bc	50		 push	 eax
  006bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  006c3	83 c4 04	 add	 esp, 4
  006c6	3b f4		 cmp	 esi, esp
  006c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006cd	d9 5d e0	 fstp	 DWORD PTR _mass$[ebp]
$LN16@DataDeploy:

; 120  : 		}
; 121  : 
; 122  : 		if (data->Attribute ("calcInertia"))

  006d0	6a 00		 push	 0
  006d2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NEEMJLF@calcInertia?$AA@
  006d7	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  006da	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  006df	85 c0		 test	 eax, eax
  006e1	74 30		 je	 SHORT $LN19@DataDeploy

; 123  : 		{
; 124  : 			if (atoi (data->Attribute ("calcInertia")) == 0)

  006e3	6a 00		 push	 0
  006e5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NEEMJLF@calcInertia?$AA@
  006ea	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  006ed	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  006f2	8b f4		 mov	 esi, esp
  006f4	50		 push	 eax
  006f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  006fb	83 c4 04	 add	 esp, 4
  006fe	3b f4		 cmp	 esi, esp
  00700	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00705	85 c0		 test	 eax, eax
  00707	75 06		 jne	 SHORT $LN18@DataDeploy

; 125  : 			{
; 126  : 				calcInertia = false;

  00709	c6 45 df 00	 mov	 BYTE PTR _calcInertia$[ebp], 0

; 127  : 			}
; 128  : 			else

  0070d	eb 04		 jmp	 SHORT $LN19@DataDeploy
$LN18@DataDeploy:

; 129  : 			{
; 130  : 				calcInertia = true;

  0070f	c6 45 df 01	 mov	 BYTE PTR _calcInertia$[ebp], 1
$LN19@DataDeploy:

; 131  : 			}
; 132  : 		}
; 133  : 
; 134  : 		if (data->Attribute ("inertia"))

  00713	6a 00		 push	 0
  00715	68 00 00 00 00	 push	 OFFSET ??_C@_07IKGGBMHK@inertia?$AA@
  0071a	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  0071d	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00722	85 c0		 test	 eax, eax
  00724	74 52		 je	 SHORT $LN20@DataDeploy

; 135  : 		{
; 136  : 			inertia = Util::ParseVector3 (data->Attribute ("inertia"));

  00726	6a 00		 push	 0
  00728	68 00 00 00 00	 push	 OFFSET ??_C@_07IKGGBMHK@inertia?$AA@
  0072d	8b 4b 08	 mov	 ecx, DWORD PTR _data$[ebx]
  00730	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00735	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00738	8b cc		 mov	 ecx, esp
  0073a	89 a5 a4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00740	50		 push	 eax
  00741	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00746	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv497[ebp], eax
  0074c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00752	50		 push	 eax
  00753	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  00758	83 c4 20	 add	 esp, 32			; 00000020H
  0075b	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv498[ebp], eax
  00761	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv498[ebp]
  00767	8b 11		 mov	 edx, DWORD PTR [ecx]
  00769	89 55 cc	 mov	 DWORD PTR _inertia$[ebp], edx
  0076c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0076f	89 45 d0	 mov	 DWORD PTR _inertia$[ebp+4], eax
  00772	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00775	89 4d d4	 mov	 DWORD PTR _inertia$[ebp+8], ecx
$LN20@DataDeploy:

; 137  : 		}
; 138  : 
; 139  : 		if (calcInertia)

  00778	0f b6 55 df	 movzx	 edx, BYTE PTR _calcInertia$[ebp]
  0077c	85 d2		 test	 edx, edx
  0077e	74 31		 je	 SHORT $LN21@DataDeploy

; 140  : 		{
; 141  : 			shape->calculateLocalInertia (mass, inertia.GetBT ());

  00780	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00786	50		 push	 eax
  00787	8d 4d cc	 lea	 ecx, DWORD PTR _inertia$[ebp]
  0078a	e8 00 00 00 00	 call	 ?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ ; Vector3<float>::GetBT
  0078f	8b f4		 mov	 esi, esp
  00791	50		 push	 eax
  00792	51		 push	 ecx
  00793	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _mass$[ebp]
  00798	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079d	8b 4d e4	 mov	 ecx, DWORD PTR _shape$[ebp]
  007a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  007a2	8b 4d e4	 mov	 ecx, DWORD PTR _shape$[ebp]
  007a5	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  007a8	ff d0		 call	 eax
  007aa	3b f4		 cmp	 esi, esp
  007ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@DataDeploy:

; 142  : 		}
; 143  : 
; 144  : 		m_shape = shape;

  007b1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  007b4	8b 55 e4	 mov	 edx, DWORD PTR _shape$[ebp]
  007b7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 145  : 		m_mass = mass;

  007ba	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  007bd	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _mass$[ebp]
  007c2	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 146  : 
; 147  : 		CoreEngine::GetCoreEngine ()->SetSimulation (true);

  007c7	6a 01		 push	 1
  007c9	e8 00 00 00 00	 call	 ?GetCoreEngine@CoreEngine@@SAPAV1@XZ ; CoreEngine::GetCoreEngine
  007ce	8b c8		 mov	 ecx, eax
  007d0	e8 00 00 00 00	 call	 ?SetSimulation@CoreEngine@@QAEX_N@Z ; CoreEngine::SetSimulation

; 148  : 	}

  007d5	52		 push	 edx
  007d6	8b cd		 mov	 ecx, ebp
  007d8	50		 push	 eax
  007d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN60@DataDeploy
  007df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007e4	58		 pop	 eax
  007e5	5a		 pop	 edx
  007e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  007e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007f0	59		 pop	 ecx
  007f1	5f		 pop	 edi
  007f2	5e		 pop	 esi
  007f3	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007f6	33 cd		 xor	 ecx, ebp
  007f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007fd	8b e5		 mov	 esp, ebp
  007ff	5d		 pop	 ebp
  00800	8b e3		 mov	 esp, ebx
  00802	5b		 pop	 ebx
  00803	c2 04 00	 ret	 4
  00806	66 90		 npad	 2
$LN60@DataDeploy:
  00808	03 00 00 00	 DD	 3
  0080c	00 00 00 00	 DD	 $LN59@DataDeploy
$LN59@DataDeploy:
  00810	cc ff ff ff	 DD	 -52			; ffffffccH
  00814	0c 00 00 00	 DD	 12			; 0000000cH
  00818	00 00 00 00	 DD	 $LN55@DataDeploy
  0081c	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00820	1c 00 00 00	 DD	 28			; 0000001cH
  00824	00 00 00 00	 DD	 $LN56@DataDeploy
  00828	3c ff ff ff	 DD	 -196			; ffffff3cH
  0082c	10 00 00 00	 DD	 16			; 00000010H
  00830	00 00 00 00	 DD	 $LN57@DataDeploy
$LN57@DataDeploy:
  00834	70		 DB	 112			; 00000070H
  00835	00		 DB	 0
$LN56@DataDeploy:
  00836	73		 DB	 115			; 00000073H
  00837	00		 DB	 0
$LN55@DataDeploy:
  00838	69		 DB	 105			; 00000069H
  00839	6e		 DB	 110			; 0000006eH
  0083a	65		 DB	 101			; 00000065H
  0083b	72		 DB	 114			; 00000072H
  0083c	74		 DB	 116			; 00000074H
  0083d	69		 DB	 105			; 00000069H
  0083e	61		 DB	 97			; 00000061H
  0083f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR _s$28[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$1:
  00008	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3btBvhTriangleMeshShape@@SAXPAX@Z ; btBvhTriangleMeshShape::operator delete
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$2:
  00016	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	0f 84 0f 00 00
	00		 je	 $LN40@DataDeploy
  00025	83 a5 a0 fe ff
	ff fe		 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  0002c	8d 4d 88	 lea	 ecx, DWORD PTR $T27[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN40@DataDeploy:
  00034	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$3:
  00035	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3btConvexTriangleMeshShape@@SAXPAX@Z ; btConvexTriangleMeshShape::operator delete
  00041	59		 pop	 ecx
  00042	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$4:
  00043	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00049	83 e0 02	 and	 eax, 2
  0004c	0f 84 12 00 00
	00		 je	 $LN44@DataDeploy
  00052	83 a5 a0 fe ff
	ff fd		 and	 DWORD PTR $T2[ebp], -3	; fffffffdH
  00059	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0005f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN44@DataDeploy:
  00064	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$5:
  00065	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3btBoxShape@@SAXPAX@Z	; btBoxShape::operator delete
  00071	59		 pop	 ecx
  00072	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$7:
  00073	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??3btSphereShape@@SAXPAX@Z ; btSphereShape::operator delete
  0007f	59		 pop	 ecx
  00080	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$8:
  00081	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00087	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$9:
  0008c	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _p$23[ebp]
  00092	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$10:
  00097	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??3btCapsuleShape@@SAXPAX@Z ; btCapsuleShape::operator delete
  000a3	59		 pop	 ecx
  000a4	c3		 ret	 0
__unwindfunclet$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z$11:
  000a5	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3btCylinderShape@@SAXPAX@Z ; btCylinderShape::operator delete
  000b1	59		 pop	 ecx
  000b2	c3		 ret	 0
__ehhandler$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z:
  000b3	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b7	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ba	8b 8a 54 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-428]
  000c0	33 c8		 xor	 ecx, eax
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000ca	33 c8		 xor	 ecx, eax
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z
  000d6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DataDeploy@RigidBody@@UAEXPAVXMLElement@tinyxml2@@@Z ENDP ; RigidBody::DataDeploy
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?Init@RigidBody@@UAEXXZ
_TEXT	SEGMENT
tv163 = -304						; size = 4
tv146 = -300						; size = 4
tv89 = -296						; size = 4
$T2 = -292						; size = 4
$T3 = -288						; size = 4
$T4 = -284						; size = 4
$T5 = -280						; size = 4
_CI$ = -272						; size = 160
$T6 = -96						; size = 64
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Init@RigidBody@@UAEXXZ PROC				; RigidBody::Init, COMDAT
; _this$ = ecx

; 151  : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?Init@RigidBody@@UAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	51		 push	 ecx
  0002e	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00034	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00039	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0003e	f3 ab		 rep stosd
  00040	59		 pop	 ecx
  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00046	33 c5		 xor	 eax, ebp
  00048	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0004b	50		 push	 eax
  0004c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0004f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00055	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		if (m_shape == nullptr) return;

  00058	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0005f	75 05		 jne	 SHORT $LN2@Init
  00061	e9 58 01 00 00	 jmp	 $LN1@Init
$LN2@Init:

; 153  : 		m_state = new btDefaultMotionState (GetTransform ()->GetBT ());

  00066	68 e0 00 00 00	 push	 224			; 000000e0H
  0006b	e8 00 00 00 00	 call	 ??2btDefaultMotionState@@SAPAXI@Z ; btDefaultMotionState::operator new
  00070	83 c4 04	 add	 esp, 4
  00073	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00080	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR $T4[ebp], 0
  00087	74 2d		 je	 SHORT $LN4@Init
  00089	e8 00 00 00 00	 call	 ?getIdentity@btTransform@@SAABV1@XZ ; btTransform::getIdentity
  0008e	50		 push	 eax
  0008f	8d 4d a0	 lea	 ecx, DWORD PTR $T6[ebp]
  00092	51		 push	 ecx
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  0009b	8b c8		 mov	 ecx, eax
  0009d	e8 00 00 00 00	 call	 ?GetBT@Transform@@QAE?AVbtTransform@@XZ ; Transform::GetBT
  000a2	50		 push	 eax
  000a3	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  000a9	e8 00 00 00 00	 call	 ??0btDefaultMotionState@@QAE@ABVbtTransform@@0@Z ; btDefaultMotionState::btDefaultMotionState
  000ae	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
  000b4	eb 0a		 jmp	 SHORT $LN5@Init
$LN4@Init:
  000b6	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
$LN5@Init:
  000c0	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv89[ebp]
  000c6	89 95 e8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], edx
  000cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  000dc	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 154  : 
; 155  : 		btRigidBody::btRigidBodyConstructionInfo CI
; 156  : 			(m_mass, m_state, m_shape, m_inertia);

  000df	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000e2	83 c2 20	 add	 edx, 32			; 00000020H
  000e5	52		 push	 edx
  000e6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ec	51		 push	 ecx
  000ed	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000f3	50		 push	 eax
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	51		 push	 ecx
  000f8	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  000fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00102	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _CI$[ebp]
  00108	e8 00 00 00 00	 call	 ??0btRigidBodyConstructionInfo@btRigidBody@@QAE@MPAVbtMotionState@@PAVbtCollisionShape@@ABVbtVector3@@@Z ; btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo

; 157  : 
; 158  : 		m_body = new btRigidBody (CI);

  0010d	68 b0 02 00 00	 push	 688			; 000002b0H
  00112	e8 00 00 00 00	 call	 ??2btCollisionObject@@SAPAXI@Z ; btCollisionObject::operator new
  00117	83 c4 04	 add	 esp, 4
  0011a	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00120	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00127	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR $T2[ebp], 0
  0012e	74 1a		 je	 SHORT $LN6@Init
  00130	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _CI$[ebp]
  00136	52		 push	 edx
  00137	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0013d	e8 00 00 00 00	 call	 ??0btRigidBody@@QAE@ABUbtRigidBodyConstructionInfo@0@@Z ; btRigidBody::btRigidBody
  00142	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv146[ebp], eax
  00148	eb 0a		 jmp	 SHORT $LN7@Init
$LN6@Init:
  0014a	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv146[ebp], 0
$LN7@Init:
  00154	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv146[ebp]
  0015a	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00160	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00167	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00170	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 159  : 
; 160  : 		m_body->setUserPointer ((void*)this);

  00173	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00176	50		 push	 eax
  00177	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0017d	e8 00 00 00 00	 call	 ?setUserPointer@btCollisionObject@@QAEXPAX@Z ; btCollisionObject::setUserPointer

; 161  : 
; 162  : 		CoreEngine::GetCoreEngine ()->GetPhysicsEngine ()->GetWorld ()->addRigidBody (m_body);

  00182	e8 00 00 00 00	 call	 ?GetCoreEngine@CoreEngine@@SAPAV1@XZ ; CoreEngine::GetCoreEngine
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 ?GetPhysicsEngine@CoreEngine@@QAEPAVPhysicsEngine@@XZ ; CoreEngine::GetPhysicsEngine
  0018e	8b c8		 mov	 ecx, eax
  00190	e8 00 00 00 00	 call	 ?GetWorld@PhysicsEngine@@QAEPAVbtDiscreteDynamicsWorld@@XZ ; PhysicsEngine::GetWorld
  00195	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv163[ebp], eax
  0019b	8b f4		 mov	 esi, esp
  0019d	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001a0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001a3	50		 push	 eax
  001a4	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv163[ebp]
  001aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ac	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv163[ebp]
  001b2	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  001b5	ff d0		 call	 eax
  001b7	3b f4		 cmp	 esi, esp
  001b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Init:

; 163  : 	}

  001be	52		 push	 edx
  001bf	8b cd		 mov	 ecx, ebp
  001c1	50		 push	 eax
  001c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Init
  001c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001cd	58		 pop	 eax
  001ce	5a		 pop	 edx
  001cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d9	59		 pop	 ecx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001df	33 cd		 xor	 ecx, ebp
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	8b e3		 mov	 esp, ebx
  001eb	5b		 pop	 ebx
  001ec	c3		 ret	 0
  001ed	0f 1f 00	 npad	 3
$LN13@Init:
  001f0	01 00 00 00	 DD	 1
  001f4	00 00 00 00	 DD	 $LN12@Init
$LN12@Init:
  001f8	f0 fe ff ff	 DD	 -272			; fffffef0H
  001fc	a0 00 00 00	 DD	 160			; 000000a0H
  00200	00 00 00 00	 DD	 $LN10@Init
$LN10@Init:
  00204	43		 DB	 67			; 00000043H
  00205	49		 DB	 73			; 00000049H
  00206	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@RigidBody@@UAEXXZ$0:
  00000	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3btDefaultMotionState@@SAXPAX@Z ; btDefaultMotionState::operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__unwindfunclet$?Init@RigidBody@@UAEXXZ$1:
  0000e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3btCollisionObject@@SAXPAX@Z ; btCollisionObject::operator delete
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
__ehhandler$?Init@RigidBody@@UAEXXZ:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 8a c4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-316]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@RigidBody@@UAEXXZ
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@RigidBody@@UAEXXZ ENDP				; RigidBody::Init
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?Update@RigidBody@@UAEXM@Z
_TEXT	SEGMENT
tv69 = -204						; size = 4
$T1 = -200						; size = 4
$T2 = -196						; size = 4
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 4
$T6 = -180						; size = 4
$T7 = -176						; size = 16
$T8 = -160						; size = 16
$T9 = -144						; size = 16
$T10 = -128						; size = 16
$T11 = -108						; size = 12
$T12 = -96						; size = 12
_bt$ = -80						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_delta$ = 8						; size = 4
?Update@RigidBody@@UAEXM@Z PROC				; RigidBody::Update, COMDAT
; _this$ = ecx

; 166  : 	{

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	51		 push	 ecx
  0001f	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00025	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	59		 pop	 ecx
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00037	33 c5		 xor	 eax, ebp
  00039	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003c	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 		btTransform bt;

  0003f	8d 4d b0	 lea	 ecx, DWORD PTR _bt$[ebp]
  00042	e8 00 00 00 00	 call	 ??0btTransform@@QAE@XZ	; btTransform::btTransform

; 168  : 		m_body->getMotionState ()->getWorldTransform (bt);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004d	e8 00 00 00 00	 call	 ?getMotionState@btRigidBody@@QAEPAVbtMotionState@@XZ ; btRigidBody::getMotionState
  00052	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00058	8b f4		 mov	 esi, esp
  0005a	8d 4d b0	 lea	 ecx, DWORD PTR _bt$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv69[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0006c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006f	ff d2		 call	 edx
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  : 		GetTransform ()->SetPos (Vector3f::GetFT (bt.getOrigin ()));

  00078	8d 4d b0	 lea	 ecx, DWORD PTR _bt$[ebp]
  0007b	e8 00 00 00 00	 call	 ?getOrigin@btTransform@@QAEAAVbtVector3@@XZ ; btTransform::getOrigin
  00080	50		 push	 eax
  00081	8d 45 a0	 lea	 eax, DWORD PTR $T12[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?GetFT@?$Vector3@M@@SA?AV1@ABVbtVector3@@@Z ; Vector3<float>::GetFT
  0008a	83 c4 08	 add	 esp, 8
  0008d	50		 push	 eax
  0008e	8d 4d 94	 lea	 ecx, DWORD PTR $T11[ebp]
  00091	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@ABV?$Vector3@M@@@Z ; Vector3f::Vector3f
  00096	8d 4d 94	 lea	 ecx, DWORD PTR $T11[ebp]
  00099	51		 push	 ecx
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 ?SetPos@Transform@@QAEXABVVector3f@@@Z ; Transform::SetPos

; 170  : 		m_shape->setLocalScaling (btVector3 (GetTransform ()->GetScale (), GetTransform ()->GetScale (), GetTransform ()->GetScale ()));

  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  000b1	8b c8		 mov	 ecx, eax
  000b3	e8 00 00 00 00	 call	 ?GetScale@Transform@@QBEMXZ ; Transform::GetScale
  000b8	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR $T6[ebp]
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  000c6	8b c8		 mov	 ecx, eax
  000c8	e8 00 00 00 00	 call	 ?GetScale@Transform@@QBEMXZ ; Transform::GetScale
  000cd	d9 9d 48 ff ff
	ff		 fstp	 DWORD PTR $T5[ebp]
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  000db	8b c8		 mov	 ecx, eax
  000dd	e8 00 00 00 00	 call	 ?GetScale@Transform@@QBEMXZ ; Transform::GetScale
  000e2	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR $T4[ebp]
  000e8	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  000ee	52		 push	 edx
  000ef	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000f5	50		 push	 eax
  000f6	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000fc	51		 push	 ecx
  000fd	8d 4d 80	 lea	 ecx, DWORD PTR $T10[ebp]
  00100	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  00105	8b f4		 mov	 esi, esp
  00107	50		 push	 eax
  00108	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	8b 10		 mov	 edx, DWORD PTR [eax]
  00113	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00116	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00119	ff d0		 call	 eax
  0011b	3b f4		 cmp	 esi, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 171  : 		if (m_inertia != btVector3 (0, 0, 0))

  00122	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0012a	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR $T3[ebp], xmm0
  00132	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0013a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR $T2[ebp], xmm0
  00142	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0014a	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0
  00152	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00158	51		 push	 ecx
  00159	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0015f	52		 push	 edx
  00160	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00166	50		 push	 eax
  00167	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0016d	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  00172	50		 push	 eax
  00173	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	83 c1 20	 add	 ecx, 32			; 00000020H
  00179	e8 00 00 00 00	 call	 ??9btVector3@@QBE_NABV0@@Z ; btVector3::operator!=
  0017e	0f b6 c8	 movzx	 ecx, al
  00181	85 c9		 test	 ecx, ecx
  00183	74 2f		 je	 SHORT $LN2@Update

; 172  : 		{
; 173  : 			GetTransform ()->SetRot (Quaternion::GetFT (bt.getRotation ()));

  00185	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  0018b	52		 push	 edx
  0018c	8d 4d b0	 lea	 ecx, DWORD PTR _bt$[ebp]
  0018f	e8 00 00 00 00	 call	 ?getRotation@btTransform@@QBE?AVbtQuaternion@@XZ ; btTransform::getRotation
  00194	50		 push	 eax
  00195	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?GetFT@Quaternion@@SA?AV1@ABVbtQuaternion@@@Z ; Quaternion::GetFT
  001a1	83 c4 08	 add	 esp, 8
  001a4	50		 push	 eax
  001a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a8	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QAEPAVTransform@@XZ ; EntityComponent::GetTransform
  001ad	8b c8		 mov	 ecx, eax
  001af	e8 00 00 00 00	 call	 ?SetRot@Transform@@QAEXABVQuaternion@@@Z ; Transform::SetRot
$LN2@Update:

; 174  : 		}
; 175  : 
; 176  : 		Stay ();

  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	e8 00 00 00 00	 call	 ?Stay@RigidBody@@QAEXXZ	; RigidBody::Stay

; 177  : 		Exit ();

  001bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	e8 00 00 00 00	 call	 ?Exit@RigidBody@@QAEXXZ	; RigidBody::Exit

; 178  : 	}

  001c4	52		 push	 edx
  001c5	8b cd		 mov	 ecx, ebp
  001c7	50		 push	 eax
  001c8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Update
  001ce	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d3	58		 pop	 eax
  001d4	5a		 pop	 edx
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001da	33 cd		 xor	 ecx, ebp
  001dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	8b e3		 mov	 esp, ebx
  001e6	5b		 pop	 ebx
  001e7	c2 04 00	 ret	 4
  001ea	66 90		 npad	 2
$LN6@Update:
  001ec	01 00 00 00	 DD	 1
  001f0	00 00 00 00	 DD	 $LN5@Update
$LN5@Update:
  001f4	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001f8	40 00 00 00	 DD	 64			; 00000040H
  001fc	00 00 00 00	 DD	 $LN4@Update
$LN4@Update:
  00200	62		 DB	 98			; 00000062H
  00201	74		 DB	 116			; 00000074H
  00202	00		 DB	 0
?Update@RigidBody@@UAEXM@Z ENDP				; RigidBody::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?Stay@RigidBody@@QAEXXZ
_TEXT	SEGMENT
_x$2 = -72						; size = 8
_<end>$L0$3 = -56					; size = 12
_<begin>$L0$4 = -36					; size = 12
_<range>$L0$5 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Stay@RigidBody@@QAEXXZ PROC				; RigidBody::Stay, COMDAT
; _this$ = ecx

; 204  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Stay@RigidBody@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  00019	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 205  : 		for (auto x : m_contacts)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 30	 add	 eax, 48			; 00000030H
  00040	89 45 ec	 mov	 DWORD PTR _<range>$L0$5[ebp], eax
  00043	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00046	51		 push	 ecx
  00047	8b 4d ec	 mov	 ecx, DWORD PTR _<range>$L0$5[ebp]
  0004a	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::begin
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	8d 55 c8	 lea	 edx, DWORD PTR _<end>$L0$3[ebp]
  00059	52		 push	 edx
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _<range>$L0$5[ebp]
  0005d	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::end
  00062	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00066	eb 08		 jmp	 SHORT $LN4@Stay
$LN2@Stay:
  00068	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  0006b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
$LN4@Stay:
  00070	8d 45 c8	 lea	 eax, DWORD PTR _<end>$L0$3[ebp]
  00073	50		 push	 eax
  00074	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00077	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator!=
  0007c	0f b6 c8	 movzx	 ecx, al
  0007f	85 c9		 test	 ecx, ecx
  00081	74 42		 je	 SHORT $LN3@Stay
  00083	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00086	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
  0008b	8b 10		 mov	 edx, DWORD PTR [eax]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	89 55 b8	 mov	 DWORD PTR _x$2[ebp], edx
  00093	89 45 bc	 mov	 DWORD PTR _x$2[ebp+4], eax

; 206  : 		{
; 207  : 			if (x.second == 2)

  00096	83 7d bc 02	 cmp	 DWORD PTR _x$2[ebp+4], 2
  0009a	75 27		 jne	 SHORT $LN5@Stay

; 208  : 			{
; 209  : 				if (m_stay != nullptr)

  0009c	6a 00		 push	 0
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	83 c1 68	 add	 ecx, 104		; 00000068H
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z ; std::operator!=<void __cdecl(RigidBody *)>
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b6 d0	 movzx	 edx, al
  000b0	85 d2		 test	 edx, edx
  000b2	74 0f		 je	 SHORT $LN5@Stay

; 210  : 					m_stay (x.first);

  000b4	8b 45 b8	 mov	 eax, DWORD PTR _x$2[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	83 c1 68	 add	 ecx, 104		; 00000068H
  000be	e8 00 00 00 00	 call	 ??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z ; std::_Func_class<void,RigidBody *>::operator()
$LN5@Stay:

; 211  : 			}

  000c3	eb a3		 jmp	 SHORT $LN2@Stay
$LN3@Stay:

; 212  : 		}

  000c5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c9	8d 4d c8	 lea	 ecx, DWORD PTR _<end>$L0$3[ebp]
  000cc	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
  000d1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d8	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  000db	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ

; 213  : 	}

  000e0	52		 push	 edx
  000e1	8b cd		 mov	 ecx, ebp
  000e3	50		 push	 eax
  000e4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@Stay
  000ea	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ef	58		 pop	 eax
  000f0	5a		 pop	 edx
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	83 c4 4c	 add	 esp, 76			; 0000004cH
  00100	3b ec		 cmp	 ebp, esp
  00102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
  0010b	90		 npad	 1
$LN15@Stay:
  0010c	03 00 00 00	 DD	 3
  00110	00 00 00 00	 DD	 $LN14@Stay
$LN14@Stay:
  00114	dc ff ff ff	 DD	 -36			; ffffffdcH
  00118	0c 00 00 00	 DD	 12			; 0000000cH
  0011c	00 00 00 00	 DD	 $LN10@Stay
  00120	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00124	0c 00 00 00	 DD	 12			; 0000000cH
  00128	00 00 00 00	 DD	 $LN11@Stay
  0012c	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00130	08 00 00 00	 DD	 8
  00134	00 00 00 00	 DD	 $LN12@Stay
$LN12@Stay:
  00138	78		 DB	 120			; 00000078H
  00139	00		 DB	 0
$LN11@Stay:
  0013a	3c		 DB	 60			; 0000003cH
  0013b	65		 DB	 101			; 00000065H
  0013c	6e		 DB	 110			; 0000006eH
  0013d	64		 DB	 100			; 00000064H
  0013e	3e		 DB	 62			; 0000003eH
  0013f	24		 DB	 36			; 00000024H
  00140	4c		 DB	 76			; 0000004cH
  00141	30		 DB	 48			; 00000030H
  00142	00		 DB	 0
$LN10@Stay:
  00143	3c		 DB	 60			; 0000003cH
  00144	62		 DB	 98			; 00000062H
  00145	65		 DB	 101			; 00000065H
  00146	67		 DB	 103			; 00000067H
  00147	69		 DB	 105			; 00000069H
  00148	6e		 DB	 110			; 0000006eH
  00149	3e		 DB	 62			; 0000003eH
  0014a	24		 DB	 36			; 00000024H
  0014b	4c		 DB	 76			; 0000004cH
  0014c	30		 DB	 48			; 00000030H
  0014d	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Stay@RigidBody@@QAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?Stay@RigidBody@@QAEXXZ$1:
  00008	8d 4d c8	 lea	 ecx, DWORD PTR _<end>$L0$3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?Stay@RigidBody@@QAEXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Stay@RigidBody@@QAEXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Stay@RigidBody@@QAEXXZ ENDP				; RigidBody::Stay
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?Exit@RigidBody@@QAEXXZ
_TEXT	SEGMENT
_x$2 = -72						; size = 8
_<end>$L0$3 = -56					; size = 12
_<begin>$L0$4 = -36					; size = 12
_<range>$L0$5 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Exit@RigidBody@@QAEXXZ PROC				; RigidBody::Exit, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Exit@RigidBody@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  00019	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 		for (auto x : m_contacts)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 30	 add	 eax, 48			; 00000030H
  00040	89 45 ec	 mov	 DWORD PTR _<range>$L0$5[ebp], eax
  00043	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00046	51		 push	 ecx
  00047	8b 4d ec	 mov	 ecx, DWORD PTR _<range>$L0$5[ebp]
  0004a	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::begin
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	8d 55 c8	 lea	 edx, DWORD PTR _<end>$L0$3[ebp]
  00059	52		 push	 edx
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _<range>$L0$5[ebp]
  0005d	e8 00 00 00 00	 call	 ?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::end
  00062	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00066	eb 08		 jmp	 SHORT $LN4@Exit
$LN2@Exit:
  00068	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  0006b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
$LN4@Exit:
  00070	8d 45 c8	 lea	 eax, DWORD PTR _<end>$L0$3[ebp]
  00073	50		 push	 eax
  00074	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00077	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator!=
  0007c	0f b6 c8	 movzx	 ecx, al
  0007f	85 c9		 test	 ecx, ecx
  00081	74 57		 je	 SHORT $LN3@Exit
  00083	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00086	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
  0008b	8b 10		 mov	 edx, DWORD PTR [eax]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	89 55 b8	 mov	 DWORD PTR _x$2[ebp], edx
  00093	89 45 bc	 mov	 DWORD PTR _x$2[ebp+4], eax

; 218  : 		{
; 219  : 			if (x.second > 0)

  00096	83 7d bc 00	 cmp	 DWORD PTR _x$2[ebp+4], 0
  0009a	7e 09		 jle	 SHORT $LN5@Exit

; 220  : 			{
; 221  : 				x.second--;

  0009c	8b 4d bc	 mov	 ecx, DWORD PTR _x$2[ebp+4]
  0009f	83 e9 01	 sub	 ecx, 1
  000a2	89 4d bc	 mov	 DWORD PTR _x$2[ebp+4], ecx
$LN5@Exit:

; 222  : 			}
; 223  : 
; 224  : 			if (x.second == 0)

  000a5	83 7d bc 00	 cmp	 DWORD PTR _x$2[ebp+4], 0
  000a9	75 2d		 jne	 SHORT $LN6@Exit

; 225  : 			{
; 226  : 				if (m_exit != nullptr)

  000ab	6a 00		 push	 0
  000ad	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b0	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
  000b6	52		 push	 edx
  000b7	e8 00 00 00 00	 call	 ??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z ; std::operator!=<void __cdecl(RigidBody *)>
  000bc	83 c4 08	 add	 esp, 8
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	85 c0		 test	 eax, eax
  000c4	74 12		 je	 SHORT $LN6@Exit

; 227  : 					m_exit (x.first);

  000c6	8b 4d b8	 mov	 ecx, DWORD PTR _x$2[ebp]
  000c9	51		 push	 ecx
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000d3	e8 00 00 00 00	 call	 ??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z ; std::_Func_class<void,RigidBody *>::operator()
$LN6@Exit:

; 228  : 			}

  000d8	eb 8e		 jmp	 SHORT $LN2@Exit
$LN3@Exit:

; 229  : 		}

  000da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000de	8d 4d c8	 lea	 ecx, DWORD PTR _<end>$L0$3[ebp]
  000e1	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ed	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  000f0	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ

; 230  : 	}

  000f5	52		 push	 edx
  000f6	8b cd		 mov	 ecx, ebp
  000f8	50		 push	 eax
  000f9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@Exit
  000ff	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00104	58		 pop	 eax
  00105	5a		 pop	 edx
  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5f		 pop	 edi
  00112	83 c4 4c	 add	 esp, 76			; 0000004cH
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN16@Exit:
  00120	03 00 00 00	 DD	 3
  00124	00 00 00 00	 DD	 $LN15@Exit
$LN15@Exit:
  00128	dc ff ff ff	 DD	 -36			; ffffffdcH
  0012c	0c 00 00 00	 DD	 12			; 0000000cH
  00130	00 00 00 00	 DD	 $LN11@Exit
  00134	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00138	0c 00 00 00	 DD	 12			; 0000000cH
  0013c	00 00 00 00	 DD	 $LN12@Exit
  00140	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00144	08 00 00 00	 DD	 8
  00148	00 00 00 00	 DD	 $LN13@Exit
$LN13@Exit:
  0014c	78		 DB	 120			; 00000078H
  0014d	00		 DB	 0
$LN12@Exit:
  0014e	3c		 DB	 60			; 0000003cH
  0014f	65		 DB	 101			; 00000065H
  00150	6e		 DB	 110			; 0000006eH
  00151	64		 DB	 100			; 00000064H
  00152	3e		 DB	 62			; 0000003eH
  00153	24		 DB	 36			; 00000024H
  00154	4c		 DB	 76			; 0000004cH
  00155	30		 DB	 48			; 00000030H
  00156	00		 DB	 0
$LN11@Exit:
  00157	3c		 DB	 60			; 0000003cH
  00158	62		 DB	 98			; 00000062H
  00159	65		 DB	 101			; 00000065H
  0015a	67		 DB	 103			; 00000067H
  0015b	69		 DB	 105			; 00000069H
  0015c	6e		 DB	 110			; 0000006eH
  0015d	3e		 DB	 62			; 0000003eH
  0015e	24		 DB	 36			; 00000024H
  0015f	4c		 DB	 76			; 0000004cH
  00160	30		 DB	 48			; 00000030H
  00161	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Exit@RigidBody@@QAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?Exit@RigidBody@@QAEXXZ$1:
  00008	8d 4d c8	 lea	 ecx, DWORD PTR _<end>$L0$3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?Exit@RigidBody@@QAEXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Exit@RigidBody@@QAEXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Exit@RigidBody@@QAEXXZ ENDP				; RigidBody::Exit
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\components\physicsobjectcomponent.h
;	COMDAT ?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ PROC		; RigidBody::GetBody, COMDAT
; _this$ = ecx

; 232  : 	inline btRigidBody* GetBody () { return m_body; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ ENDP		; RigidBody::GetBody
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GRigidBody@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRigidBody@@UAEPAXI@Z PROC				; RigidBody::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1RigidBody@@UAE@XZ	; RigidBody::~RigidBody
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 11		 je	 SHORT $LN2@scalar
  0001e	68 c0 00 00 00	 push	 192			; 000000c0H
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??_GRigidBody@@UAEPAXI@Z ENDP				; RigidBody::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pos$ = 8						; size = 4
_rot$ = 12						; size = 4
_scale$ = 16						; size = 4
??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z PROC	; Entity::Entity
; _this$ = ecx

; 29   :  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Entity@@6B@

; 27   : 		 m_parent(0),

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 29   :  {

  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 08	 add	 ecx, 8
  00046	e8 00 00 00 00	 call	 ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 18	 add	 ecx, 24			; 00000018H
  00058	e8 00 00 00 00	 call	 ??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
  0005d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 26   : 		 m_displayName("undefined"),

  00061	68 00 00 00 00	 push	 OFFSET $SG4294966771
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 28	 add	 ecx, 40			; 00000028H
  0006c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00071	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 24   : 		 m_transform(pos, rot, scale),

  00075	51		 push	 ecx
  00076	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0007b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00080	8b 55 0c	 mov	 edx, DWORD PTR _rot$[ebp]
  00083	52		 push	 edx
  00084	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00087	50		 push	 eax
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	83 c1 44	 add	 ecx, 68			; 00000044H
  0008e	e8 00 00 00 00	 call	 ??0Transform@@QAE@ABVVector3f@@ABVQuaternion@@M@Z ; Transform::Transform

; 25   : 		 m_coreEngine(0),

  00093	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	c7 81 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+204], 0

; 28   : 		 m_destroy(false)

  000a0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	c6 82 d4 00 00
	00 00		 mov	 BYTE PTR [edx+212], 0

; 30   : 
; 31   :  }

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	83 c4 10	 add	 esp, 16			; 00000010H
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 18	 add	 ecx, 24			; 00000018H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
__unwindfunclet$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 28	 add	 ecx, 40			; 00000028H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Entity@@QAE@ABVVector3f@@ABVQuaternion@@M@Z ENDP	; Entity::Entity
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv156 = -60						; size = 4
tv144 = -56						; size = 4
tv91 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
_i$8 = -24						; size = 4
_i$9 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Entity@@UAE@XZ PROC					; Entity::~Entity
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Entity@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0001a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00038	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Entity@@6B@

; 35   : 	for(unsigned int i = 0; i < m_components.size(); i++)

  00044	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$9[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@Entity
$LN2@Entity:
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _i$9[ebp]
  00050	83 c1 01	 add	 ecx, 1
  00053	89 4d ec	 mov	 DWORD PTR _i$9[ebp], ecx
$LN4@Entity:
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 18	 add	 ecx, 24			; 00000018H
  0005c	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00061	39 45 ec	 cmp	 DWORD PTR _i$9[ebp], eax
  00064	73 5a		 jae	 SHORT $LN3@Entity

; 36   : 	{
; 37   : 		if(m_components[i])

  00066	8b 55 ec	 mov	 edx, DWORD PTR _i$9[ebp]
  00069	52		 push	 edx
  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 18	 add	 ecx, 24			; 00000018H
  00070	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  00075	83 38 00	 cmp	 DWORD PTR [eax], 0
  00078	74 44		 je	 SHORT $LN8@Entity

; 38   : 		{	
; 39   : 			delete m_components[i];

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _i$9[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	83 c1 18	 add	 ecx, 24			; 00000018H
  00084	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	89 4d e0	 mov	 DWORD PTR $T6[ebp], ecx
  0008e	8b 55 e0	 mov	 edx, DWORD PTR $T6[ebp]
  00091	89 55 e4	 mov	 DWORD PTR $T7[ebp], edx
  00094	83 7d e4 00	 cmp	 DWORD PTR $T7[ebp], 0
  00098	74 1d		 je	 SHORT $LN11@Entity
  0009a	8b f4		 mov	 esi, esp
  0009c	6a 01		 push	 1
  0009e	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  000a1	8b 10		 mov	 edx, DWORD PTR [eax]
  000a3	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  000a6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a9	ff d0		 call	 eax
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	89 45 cc	 mov	 DWORD PTR tv91[ebp], eax
  000b5	eb 07		 jmp	 SHORT $LN8@Entity
$LN11@Entity:
  000b7	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$LN8@Entity:

; 40   : 		}
; 41   : 	}

  000be	eb 8d		 jmp	 SHORT $LN2@Entity
$LN3@Entity:

; 42   : 	
; 43   : 	for(unsigned int i = 0; i < m_children.size(); i++)

  000c0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  000c7	eb 09		 jmp	 SHORT $LN7@Entity
$LN5@Entity:
  000c9	8b 4d e8	 mov	 ecx, DWORD PTR _i$8[ebp]
  000cc	83 c1 01	 add	 ecx, 1
  000cf	89 4d e8	 mov	 DWORD PTR _i$8[ebp], ecx
$LN7@Entity:
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	83 c1 08	 add	 ecx, 8
  000d8	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  000dd	39 45 e8	 cmp	 DWORD PTR _i$8[ebp], eax
  000e0	73 59		 jae	 SHORT $LN6@Entity

; 44   : 	{
; 45   : 		if(m_children[i]) 

  000e2	8b 55 e8	 mov	 edx, DWORD PTR _i$8[ebp]
  000e5	52		 push	 edx
  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	83 c1 08	 add	 ecx, 8
  000ec	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  000f1	83 38 00	 cmp	 DWORD PTR [eax], 0
  000f4	74 43		 je	 SHORT $LN9@Entity

; 46   : 		{
; 47   : 			delete m_children[i];

  000f6	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	83 c1 08	 add	 ecx, 8
  00100	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00105	8b 08		 mov	 ecx, DWORD PTR [eax]
  00107	89 4d d8	 mov	 DWORD PTR $T4[ebp], ecx
  0010a	8b 55 d8	 mov	 edx, DWORD PTR $T4[ebp]
  0010d	89 55 dc	 mov	 DWORD PTR $T5[ebp], edx
  00110	83 7d dc 00	 cmp	 DWORD PTR $T5[ebp], 0
  00114	74 1c		 je	 SHORT $LN13@Entity
  00116	8b f4		 mov	 esi, esp
  00118	6a 01		 push	 1
  0011a	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0011d	8b 10		 mov	 edx, DWORD PTR [eax]
  0011f	8b 4d dc	 mov	 ecx, DWORD PTR $T5[ebp]
  00122	8b 02		 mov	 eax, DWORD PTR [edx]
  00124	ff d0		 call	 eax
  00126	3b f4		 cmp	 esi, esp
  00128	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012d	89 45 c8	 mov	 DWORD PTR tv144[ebp], eax
  00130	eb 07		 jmp	 SHORT $LN9@Entity
$LN13@Entity:
  00132	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
$LN9@Entity:

; 48   : 		}
; 49   : 	}

  00139	eb 8e		 jmp	 SHORT $LN5@Entity
$LN6@Entity:

; 50   : 	delete m_picker;

  0013b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00144	89 55 d0	 mov	 DWORD PTR $T2[ebp], edx
  00147	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0014a	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0014d	83 7d d4 00	 cmp	 DWORD PTR $T3[ebp], 0
  00151	74 1d		 je	 SHORT $LN15@Entity
  00153	8b f4		 mov	 esi, esp
  00155	6a 01		 push	 1
  00157	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  0015a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015c	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  0015f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00162	ff d0		 call	 eax
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	89 45 c4	 mov	 DWORD PTR tv156[ebp], eax
  0016e	eb 07		 jmp	 SHORT $LN1@Entity
$LN15@Entity:
  00170	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
$LN1@Entity:

; 51   : }

  00177	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	83 c1 28	 add	 ecx, 40			; 00000028H
  0017d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00182	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	83 c1 18	 add	 ecx, 24			; 00000018H
  00188	e8 00 00 00 00	 call	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	83 c1 08	 add	 ecx, 8
  00193	e8 00 00 00 00	 call	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
  00198	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a2	59		 pop	 ecx
  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	83 c4 3c	 add	 esp, 60			; 0000003cH
  001a8	3b ec		 cmp	 ebp, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1Entity@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Entity@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Entity@@UAE@XZ ENDP					; Entity::~Entity
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_child$ = 8						; size = 4
?AddChild@Entity@@QAEPAV1@PAV1@@Z PROC			; Entity::AddChild
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   : 	m_children.push_back(child); 

  0000e	8d 45 08	 lea	 eax, DWORD PTR _child$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back

; 56   : 	child->GetTransform()->SetParent(&m_transform);

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 44	 add	 ecx, 68			; 00000044H
  00023	51		 push	 ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _child$[ebp]
  00027	e8 00 00 00 00	 call	 ?GetTransform@Entity@@QAEPAVTransform@@XZ ; Entity::GetTransform
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?SetParent@Transform@@QAEXPAV1@@Z ; Transform::SetParent

; 57   : 	child->SetParent(this);

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	52		 push	 edx
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _child$[ebp]
  0003a	e8 00 00 00 00	 call	 ?SetParent@Entity@@QAEXPAV1@@Z ; Entity::SetParent

; 58   : 	child->SetEngine(m_coreEngine);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00048	51		 push	 ecx
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _child$[ebp]
  0004c	e8 00 00 00 00	 call	 ?SetEngine@Entity@@QAEXPAVCoreEngine@@@Z ; Entity::SetEngine

; 59   : 	return this;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 60   : }

  00054	83 c4 04	 add	 esp, 4
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?AddChild@Entity@@QAEPAV1@PAV1@@Z ENDP			; Entity::AddChild
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_component$ = 8						; size = 4
?AddComponent@Entity@@QAEPAV1@PAVEntityComponent@@@Z PROC ; Entity::AddComponent
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 	m_components.push_back(component);

  0000f	8d 45 08	 lea	 eax, DWORD PTR _component$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 18	 add	 ecx, 24			; 00000018H
  00019	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::push_back

; 65   : 	component->SetParent(this);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR _component$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _component$[ebp]
  0002c	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  0002f	ff d2		 call	 edx
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   : 	component->Init();

  00038	8b 45 08	 mov	 eax, DWORD PTR _component$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	8b f4		 mov	 esi, esp
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _component$[ebp]
  00042	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00045	ff d0		 call	 eax
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 67   : 	return this;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 68   : }

  00051	5e		 pop	 esi
  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?AddComponent@Entity@@QAEPAV1@PAVEntityComponent@@@Z ENDP ; Entity::AddComponent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
$T2 = -24						; size = 4
_i$3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_components$ = 8					; size = 16
?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z PROC ; Entity::AddComponents
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001b	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00022	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 72   :     for (size_t i = 0; i < components.size(); i++)

  00044	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@AddCompone
$LN2@AddCompone:
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@AddCompone:
  00056	8d 4d 08	 lea	 ecx, DWORD PTR _components$[ebp]
  00059	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  0005e	39 45 ec	 cmp	 DWORD PTR _i$3[ebp], eax
  00061	73 19		 jae	 SHORT $LN3@AddCompone

; 73   :     {
; 74   :         AddComponent(components.at(i));

  00063	8b 4d ec	 mov	 ecx, DWORD PTR _i$3[ebp]
  00066	51		 push	 ecx
  00067	8d 4d 08	 lea	 ecx, DWORD PTR _components$[ebp]
  0006a	e8 00 00 00 00	 call	 ?at@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::at
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	52		 push	 edx
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?AddComponent@Entity@@QAEPAV1@PAVEntityComponent@@@Z ; Entity::AddComponent

; 75   :     }

  0007a	eb d1		 jmp	 SHORT $LN2@AddCompone
$LN3@AddCompone:

; 76   : 
; 77   :     return this;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00082	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8d 4d 08	 lea	 ecx, DWORD PTR _components$[ebp]
  0008c	e8 00 00 00 00	 call	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
  00091	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]

; 78   : }

  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00097	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009e	59		 pop	 ecx
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _components$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
__ehhandler$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddComponents@Entity@@QAEPAV1@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@Z ENDP ; Entity::AddComponents
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?InitAll@Entity@@QAEXXZ PROC				; Entity::InitAll
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 82   : 	Init();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Init@Entity@@AAEXXZ	; Entity::Init

; 83   : 
; 84   : 	for (unsigned int i = 0; i < m_children.size(); i++)

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN4@InitAll
$LN2@InitAll:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@InitAll:
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 08	 add	 ecx, 8
  00037	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  0003c	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0003f	73 2c		 jae	 SHORT $LN1@InitAll

; 85   : 	{
; 86   : 		if (m_children[i] != NULL)

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 08	 add	 ecx, 8
  0004b	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00050	83 38 00	 cmp	 DWORD PTR [eax], 0
  00053	74 16		 je	 SHORT $LN5@InitAll

; 87   : 			m_children[i]->Init();

  00055	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00058	52		 push	 edx
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 08	 add	 ecx, 8
  0005f	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	e8 00 00 00 00	 call	 ?Init@Entity@@AAEXXZ	; Entity::Init
$LN5@InitAll:

; 88   : 	}

  0006b	eb bb		 jmp	 SHORT $LN2@InitAll
$LN1@InitAll:

; 89   : }

  0006d	83 c4 08	 add	 esp, 8
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?InitAll@Entity@@QAEXXZ ENDP				; Entity::InitAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_delta$ = 12						; size = 4
?ProcessInputAll@Entity@@QAEXABVInput@@M@Z PROC		; Entity::ProcessInputAll
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : 	ProcessInput(input, delta);

  00017	51		 push	 ecx
  00018	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _delta$[ebp]
  0001d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00022	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?ProcessInput@Entity@@AAEXABVInput@@M@Z ; Entity::ProcessInput

; 94   : 
; 95   : 	for(unsigned int i = 0; i < m_children.size(); i++)

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00035	eb 09		 jmp	 SHORT $LN4@ProcessInp
$LN2@ProcessInp:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0003a	83 c1 01	 add	 ecx, 1
  0003d	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@ProcessInp:
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 08	 add	 ecx, 8
  00046	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  0004b	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0004e	73 3b		 jae	 SHORT $LN3@ProcessInp

; 96   : 	{
; 97   : 		if (m_children[i] != NULL)

  00050	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00053	52		 push	 edx
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 08	 add	 ecx, 8
  0005a	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0005f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00062	74 25		 je	 SHORT $LN5@ProcessInp

; 98   : 			m_children[i]->ProcessInputAll(input, delta);

  00064	51		 push	 ecx
  00065	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _delta$[ebp]
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00072	50		 push	 eax
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00076	51		 push	 ecx
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	83 c1 08	 add	 ecx, 8
  0007d	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	e8 00 00 00 00	 call	 ?ProcessInputAll@Entity@@QAEXABVInput@@M@Z ; Entity::ProcessInputAll
$LN5@ProcessInp:

; 99   : 	}

  00089	eb ac		 jmp	 SHORT $LN2@ProcessInp
$LN3@ProcessInp:

; 100  : }

  0008b	83 c4 08	 add	 esp, 8
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
?ProcessInputAll@Entity@@QAEXABVInput@@M@Z ENDP		; Entity::ProcessInputAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv88 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_delta$ = 8						; size = 4
?UpdateAll@Entity@@QAEXM@Z PROC				; Entity::UpdateAll
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 	Update(delta);

  0001e	51		 push	 ecx
  0001f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _delta$[ebp]
  00024	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?Update@Entity@@AAEXM@Z	; Entity::Update

; 105  : 	for(unsigned int i = 0; i < m_children.size(); i++)

  00031	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN4@UpdateAll
$LN2@UpdateAll:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@UpdateAll:
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 08	 add	 ecx, 8
  00049	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  0004e	39 45 f8	 cmp	 DWORD PTR _i$3[ebp], eax
  00051	0f 83 b3 00 00
	00		 jae	 $LN3@UpdateAll

; 106  : 	{
; 107  : 		if (m_children[i]->m_destroy)

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0005a	51		 push	 ecx
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 08	 add	 ecx, 8
  00061	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	0f b6 82 d4 00
	00 00		 movzx	 eax, BYTE PTR [edx+212]
  0006f	85 c0		 test	 eax, eax
  00071	74 5d		 je	 SHORT $LN5@UpdateAll

; 108  : 		{
; 109  : 			delete m_children[i];

  00073	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  00076	51		 push	 ecx
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	83 c1 08	 add	 ecx, 8
  0007d	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  00082	8b 10		 mov	 edx, DWORD PTR [eax]
  00084	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00087	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0008a	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0008d	83 7d f4 00	 cmp	 DWORD PTR $T2[ebp], 0
  00091	74 1c		 je	 SHORT $LN8@UpdateAll
  00093	8b f4		 mov	 esi, esp
  00095	6a 01		 push	 1
  00097	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	ff d0		 call	 eax
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	89 45 ec	 mov	 DWORD PTR tv88[ebp], eax
  000ad	eb 07		 jmp	 SHORT $LN9@UpdateAll
$LN8@UpdateAll:
  000af	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$LN9@UpdateAll:

; 110  : 			m_children[i] = NULL;

  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	83 c1 08	 add	 ecx, 8
  000c0	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  000c5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 111  : 			continue;

  000cb	e9 6a ff ff ff	 jmp	 $LN2@UpdateAll
$LN5@UpdateAll:

; 112  : 		}
; 113  : 		if (m_children[i] != NULL)

  000d0	8b 55 f8	 mov	 edx, DWORD PTR _i$3[ebp]
  000d3	52		 push	 edx
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	83 c1 08	 add	 ecx, 8
  000da	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  000df	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e2	74 21		 je	 SHORT $LN6@UpdateAll

; 114  : 			m_children[i]->UpdateAll(delta);

  000e4	51		 push	 ecx
  000e5	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _delta$[ebp]
  000ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	83 c1 08	 add	 ecx, 8
  000f9	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	e8 00 00 00 00	 call	 ?UpdateAll@Entity@@QAEXM@Z ; Entity::UpdateAll
$LN6@UpdateAll:

; 115  : 	}

  00105	e9 30 ff ff ff	 jmp	 $LN2@UpdateAll
$LN3@UpdateAll:

; 116  : }

  0010a	5e		 pop	 esi
  0010b	83 c4 14	 add	 esp, 20			; 00000014H
  0010e	3b ec		 cmp	 ebp, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
?UpdateAll@Entity@@QAEXM@Z ENDP				; Entity::UpdateAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?RenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; Entity::RenderAll
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	Render(shader, renderingEngine, camera);

  00017	8b 45 10	 mov	 eax, DWORD PTR _camera$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _renderingEngine$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _shader$[ebp]
  00022	52		 push	 edx
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Render@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::Render

; 121  : 
; 122  : 	for(unsigned int i = 0; i < m_children.size(); i++)

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN4@RenderAll
$LN2@RenderAll:
  00034	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@RenderAll:
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 08	 add	 ecx, 8
  00043	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00048	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0004b	73 38		 jae	 SHORT $LN1@RenderAll

; 123  : 	{
; 124  : 		if (m_children[i] != NULL)

  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00050	51		 push	 ecx
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 08	 add	 ecx, 8
  00057	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 22		 je	 SHORT $LN5@RenderAll

; 125  : 			m_children[i]->RenderAll(shader, renderingEngine, camera);

  00061	8b 55 10	 mov	 edx, DWORD PTR _camera$[ebp]
  00064	52		 push	 edx
  00065	8b 45 0c	 mov	 eax, DWORD PTR _renderingEngine$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _shader$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00070	52		 push	 edx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 08	 add	 ecx, 8
  00077	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	e8 00 00 00 00	 call	 ?RenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::RenderAll
$LN5@RenderAll:

; 126  : 	}

  00083	eb af		 jmp	 SHORT $LN2@RenderAll
$LN1@RenderAll:

; 127  : }

  00085	83 c4 08	 add	 esp, 8
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
?RenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; Entity::RenderAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?PostRenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; Entity::PostRenderAll
; _this$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 131  : 	PostRender(shader, renderingEngine, camera);

  00017	8b 45 10	 mov	 eax, DWORD PTR _camera$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _renderingEngine$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _shader$[ebp]
  00022	52		 push	 edx
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?PostRender@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::PostRender

; 132  : 
; 133  : 	for (unsigned int i = 0; i < m_children.size(); i++)

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN4@PostRender
$LN2@PostRender:
  00034	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PostRender:
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 08	 add	 ecx, 8
  00043	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00048	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0004b	73 38		 jae	 SHORT $LN1@PostRender

; 134  : 	{
; 135  : 		if (m_children[i] != NULL)

  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00050	51		 push	 ecx
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 08	 add	 ecx, 8
  00057	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 22		 je	 SHORT $LN5@PostRender

; 136  : 			m_children[i]->PostRenderAll(shader, renderingEngine, camera);

  00061	8b 55 10	 mov	 edx, DWORD PTR _camera$[ebp]
  00064	52		 push	 edx
  00065	8b 45 0c	 mov	 eax, DWORD PTR _renderingEngine$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _shader$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00070	52		 push	 edx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 08	 add	 ecx, 8
  00077	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	e8 00 00 00 00	 call	 ?PostRenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ; Entity::PostRenderAll
$LN5@PostRender:

; 137  : 	}

  00083	eb af		 jmp	 SHORT $LN2@PostRender
$LN1@PostRender:

; 138  : }

  00085	83 c4 08	 add	 esp, 8
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
?PostRenderAll@Entity@@QBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; Entity::PostRenderAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv140 = -100						; size = 4
tv138 = -96						; size = 4
$T2 = -92						; size = 4
$T3 = -88						; size = 4
$T4 = -84						; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 12
$T7 = -64						; size = 16
_scale$ = -32						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Init@Entity@@AAEXXZ PROC				; Entity::Init
; _this$ = ecx

; 141  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?Init@Entity@@AAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	51		 push	 ecx
  0002b	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0002e	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00033	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00038	f3 ab		 rep stosd
  0003a	59		 pop	 ecx
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00040	33 c5		 xor	 eax, ebp
  00042	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00045	50		 push	 eax
  00046	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00049	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0004f	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 	auto scale = m_transform.GetScale ();

  00052	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 44	 add	 ecx, 68			; 00000044H
  00058	e8 00 00 00 00	 call	 ?GetScale@Transform@@QBEMXZ ; Transform::GetScale
  0005d	d9 5d e0	 fstp	 DWORD PTR _scale$[ebp]

; 143  : 	m_picker = new RigidBody (new btBoxShape (btVector3(scale, scale, scale)), 0, false);

  00060	68 c0 00 00 00	 push	 192			; 000000c0H
  00065	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 ac	 mov	 DWORD PTR $T4[ebp], eax
  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00077	6a 50		 push	 80			; 00000050H
  00079	e8 00 00 00 00	 call	 ??2btBoxShape@@SAPAXI@Z	; btBoxShape::operator new
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 a4	 mov	 DWORD PTR $T2[ebp], eax
  00084	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00088	83 7d a4 00	 cmp	 DWORD PTR $T2[ebp], 0
  0008c	74 22		 je	 SHORT $LN3@Init
  0008e	8d 45 e0	 lea	 eax, DWORD PTR _scale$[ebp]
  00091	50		 push	 eax
  00092	8d 4d e0	 lea	 ecx, DWORD PTR _scale$[ebp]
  00095	51		 push	 ecx
  00096	8d 55 e0	 lea	 edx, DWORD PTR _scale$[ebp]
  00099	52		 push	 edx
  0009a	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  0009d	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  000a2	50		 push	 eax
  000a3	8b 4d a4	 mov	 ecx, DWORD PTR $T2[ebp]
  000a6	e8 00 00 00 00	 call	 ??0btBoxShape@@QAE@ABVbtVector3@@@Z ; btBoxShape::btBoxShape
  000ab	89 45 a0	 mov	 DWORD PTR tv138[ebp], eax
  000ae	eb 07		 jmp	 SHORT $LN4@Init
$LN3@Init:
  000b0	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
$LN4@Init:
  000b7	8b 45 a0	 mov	 eax, DWORD PTR tv138[ebp]
  000ba	89 45 a8	 mov	 DWORD PTR $T3[ebp], eax
  000bd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c1	51		 push	 ecx
  000c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	51		 push	 ecx
  000d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dd	51		 push	 ecx
  000de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000eb	8d 4d b4	 lea	 ecx, DWORD PTR $T6[ebp]
  000ee	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f
  000f3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000f6	8b cc		 mov	 ecx, esp
  000f8	8b 10		 mov	 edx, DWORD PTR [eax]
  000fa	89 11		 mov	 DWORD PTR [ecx], edx
  000fc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ff	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00102	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00108	6a 00		 push	 0
  0010a	51		 push	 ecx
  0010b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8b 4d a8	 mov	 ecx, DWORD PTR $T3[ebp]
  0011b	51		 push	 ecx
  0011c	8b 4d ac	 mov	 ecx, DWORD PTR $T4[ebp]
  0011f	e8 00 00 00 00	 call	 ??0RigidBody@@QAE@PAVbtCollisionShape@@M_NVVector3f@@@Z ; RigidBody::RigidBody
  00124	89 45 9c	 mov	 DWORD PTR tv140[ebp], eax
  00127	eb 07		 jmp	 SHORT $LN6@Init
  00129	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN6@Init:
  00130	8b 55 9c	 mov	 edx, DWORD PTR tv140[ebp]
  00133	89 55 b0	 mov	 DWORD PTR $T5[ebp], edx
  00136	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0013d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00140	8b 4d b0	 mov	 ecx, DWORD PTR $T5[ebp]
  00143	89 88 d0 00 00
	00		 mov	 DWORD PTR [eax+208], ecx

; 144  : 
; 145  : 	m_picker->SetParent (this);

  00149	8b f4		 mov	 esi, esp
  0014b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0014e	52		 push	 edx
  0014f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00158	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0015b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015d	8b 8a d0 00 00
	00		 mov	 ecx, DWORD PTR [edx+208]
  00163	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00166	ff d2		 call	 edx
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 146  : 	m_picker->Init ();

  0016f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00172	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00178	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0017b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0017d	8b f4		 mov	 esi, esp
  0017f	8b 8a d0 00 00
	00		 mov	 ecx, DWORD PTR [edx+208]
  00185	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00188	ff d2		 call	 edx
  0018a	3b f4		 cmp	 esi, esp
  0018c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 147  : 
; 148  : 	m_picker->GetBody()->setCollisionFlags(m_picker->GetBody ()->getCollisionFlags() | btCollisionObject::CF_NO_CONTACT_RESPONSE);

  00191	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00194	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  0019a	e8 00 00 00 00	 call	 ?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ ; RigidBody::GetBody
  0019f	8b c8		 mov	 ecx, eax
  001a1	e8 00 00 00 00	 call	 ?getCollisionFlags@btCollisionObject@@QBEHXZ ; btCollisionObject::getCollisionFlags
  001a6	83 c8 04	 or	 eax, 4
  001a9	50		 push	 eax
  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 89 d0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+208]
  001b3	e8 00 00 00 00	 call	 ?GetBody@RigidBody@@QAEPAVbtRigidBody@@XZ ; RigidBody::GetBody
  001b8	8b c8		 mov	 ecx, eax
  001ba	e8 00 00 00 00	 call	 ?setCollisionFlags@btCollisionObject@@QAEXH@Z ; btCollisionObject::setCollisionFlags

; 149  : }

  001bf	52		 push	 edx
  001c0	8b cd		 mov	 ecx, ebp
  001c2	50		 push	 eax
  001c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Init
  001c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ce	58		 pop	 eax
  001cf	5a		 pop	 edx
  001d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001da	59		 pop	 ecx
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	8b e3		 mov	 esp, ebx
  001ec	5b		 pop	 ebx
  001ed	c3		 ret	 0
  001ee	66 90		 npad	 2
$LN12@Init:
  001f0	01 00 00 00	 DD	 1
  001f4	00 00 00 00	 DD	 $LN11@Init
$LN11@Init:
  001f8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  001fc	04 00 00 00	 DD	 4
  00200	00 00 00 00	 DD	 $LN9@Init
$LN9@Init:
  00204	73		 DB	 115			; 00000073H
  00205	63		 DB	 99			; 00000063H
  00206	61		 DB	 97			; 00000061H
  00207	6c		 DB	 108			; 0000006cH
  00208	65		 DB	 101			; 00000065H
  00209	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Init@Entity@@AAEXXZ$0:
  00000	68 c0 00 00 00	 push	 192			; 000000c0H
  00005	8b 45 ac	 mov	 eax, DWORD PTR $T4[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?Init@Entity@@AAEXXZ$1:
  00012	8b 45 a4	 mov	 eax, DWORD PTR $T2[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??3btBoxShape@@SAXPAX@Z	; btBoxShape::operator delete
  0001b	59		 pop	 ecx
  0001c	c3		 ret	 0
__ehhandler$?Init@Entity@@AAEXXZ:
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@Entity@@AAEXXZ
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@Entity@@AAEXXZ ENDP				; Entity::Init
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv77 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_delta$ = 12						; size = 4
?ProcessInput@Entity@@AAEXABVInput@@M@Z PROC		; Entity::ProcessInput
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 	m_transform.Update();

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 44	 add	 ecx, 68			; 00000044H
  00025	e8 00 00 00 00	 call	 ?Update@Transform@@QAEXXZ ; Transform::Update

; 154  : 
; 155  : 	for(unsigned int i = 0; i < m_components.size(); i++)

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@ProcessInp
$LN2@ProcessInp:
  00033	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ProcessInp:
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 18	 add	 ecx, 24			; 00000018H
  00042	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00047	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0004a	73 3b		 jae	 SHORT $LN3@ProcessInp

; 156  : 	{
; 157  : 		m_components[i]->ProcessInput(input, delta);

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0004f	51		 push	 ecx
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 18	 add	 ecx, 24			; 00000018H
  00056	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  0005b	8b 10		 mov	 edx, DWORD PTR [eax]
  0005d	89 55 f4	 mov	 DWORD PTR tv77[ebp], edx
  00060	8b f4		 mov	 esi, esp
  00062	51		 push	 ecx
  00063	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _delta$[ebp]
  00068	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  00079	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0007c	ff d0		 call	 eax
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 158  : 	}

  00085	eb ac		 jmp	 SHORT $LN2@ProcessInp
$LN3@ProcessInp:

; 159  : }

  00087	5e		 pop	 esi
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?ProcessInput@Entity@@AAEXABVInput@@M@Z ENDP		; Entity::ProcessInput
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_delta$ = 8						; size = 4
?Update@Entity@@AAEXM@Z PROC				; Entity::Update
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 163  : 	//SCALL (m_picker, m_picker->Update (delta));
; 164  : 
; 165  : 	for(unsigned int i = 0; i < m_components.size(); i++)

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN4@Update
$LN2@Update:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Update:
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  0003c	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0003f	73 37		 jae	 SHORT $LN3@Update

; 166  : 	{
; 167  : 		m_components[i]->Update(delta);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 18	 add	 ecx, 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00055	8b f4		 mov	 esi, esp
  00057	51		 push	 ecx
  00058	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _delta$[ebp]
  0005d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00065	8b 10		 mov	 edx, DWORD PTR [eax]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0006a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006d	ff d0		 call	 eax
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 168  : 	}

  00076	eb b0		 jmp	 SHORT $LN2@Update
$LN3@Update:

; 169  : }

  00078	5e		 pop	 esi
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?Update@Entity@@AAEXM@Z ENDP				; Entity::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?Render@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; Entity::Render
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	for(unsigned int i = 0; i < m_components.size(); i++)

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN4@Render
$LN2@Render:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Render:
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  0003c	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0003f	73 38		 jae	 SHORT $LN1@Render

; 174  : 	{
; 175  : 		m_components[i]->Render(shader, renderingEngine, camera);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 18	 add	 ecx, 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00055	8b f4		 mov	 esi, esp
  00057	8b 45 10	 mov	 eax, DWORD PTR _camera$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _renderingEngine$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 08	 mov	 edx, DWORD PTR _shader$[ebp]
  00062	52		 push	 edx
  00063	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0006b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006e	ff d0		 call	 eax
  00070	3b f4		 cmp	 esi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 176  : 	}

  00077	eb af		 jmp	 SHORT $LN2@Render
$LN1@Render:

; 177  : }

  00079	5e		 pop	 esi
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?Render@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; Entity::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_shader$ = 8						; size = 4
_renderingEngine$ = 12					; size = 4
_camera$ = 16						; size = 4
?PostRender@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z PROC ; Entity::PostRender
; _this$ = ecx

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 181  : 	for (unsigned int i = 0; i < m_components.size(); i++)

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN4@PostRender
$LN2@PostRender:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PostRender:
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  0003c	39 45 f8	 cmp	 DWORD PTR _i$1[ebp], eax
  0003f	73 38		 jae	 SHORT $LN1@PostRender

; 182  : 	{
; 183  : 		m_components[i]->PostRender(shader, renderingEngine, camera);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 18	 add	 ecx, 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00055	8b f4		 mov	 esi, esp
  00057	8b 45 10	 mov	 eax, DWORD PTR _camera$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _renderingEngine$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 08	 mov	 edx, DWORD PTR _shader$[ebp]
  00062	52		 push	 edx
  00063	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0006b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0006e	ff d0		 call	 eax
  00070	3b f4		 cmp	 esi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 184  : 	}

  00077	eb af		 jmp	 SHORT $LN2@PostRender
$LN1@PostRender:

; 185  : }

  00079	5e		 pop	 esi
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?PostRender@Entity@@ABEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z ENDP ; Entity::PostRender
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv78 = -16						; size = 4
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_engine$ = 8						; size = 4
?SetEngine@Entity@@QAEXPAVCoreEngine@@@Z PROC		; Entity::SetEngine
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	if(m_coreEngine != engine)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00024	3b 4d 08	 cmp	 ecx, DWORD PTR _engine$[ebp]
  00027	0f 84 9c 00 00
	00		 je	 $LN1@SetEngine

; 190  : 	{
; 191  : 		m_coreEngine = engine;

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 45 08	 mov	 eax, DWORD PTR _engine$[ebp]
  00033	89 82 cc 00 00
	00		 mov	 DWORD PTR [edx+204], eax

; 192  : 		
; 193  : 		for(unsigned int i = 0; i < m_components.size(); i++)

  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00040	eb 09		 jmp	 SHORT $LN4@SetEngine
$LN2@SetEngine:
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00045	83 c1 01	 add	 ecx, 1
  00048	89 4d f8	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@SetEngine:
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 18	 add	 ecx, 24			; 00000018H
  00051	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00056	39 45 f8	 cmp	 DWORD PTR _i$2[ebp], eax
  00059	73 30		 jae	 SHORT $LN3@SetEngine

; 194  : 		{
; 195  : 			m_components[i]->AddToEngine(engine);

  0005b	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	83 c1 18	 add	 ecx, 24			; 00000018H
  00065	e8 00 00 00 00	 call	 ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
  0006f	8b f4		 mov	 esi, esp
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _engine$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 f0	 mov	 edx, DWORD PTR tv78[ebp]
  00078	8b 02		 mov	 eax, DWORD PTR [edx]
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  0007d	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00080	ff d2		 call	 edx
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 196  : 		}

  00089	eb b7		 jmp	 SHORT $LN2@SetEngine
$LN3@SetEngine:

; 197  : 
; 198  : 		for(unsigned int i = 0; i < m_children.size(); i++)

  0008b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00092	eb 09		 jmp	 SHORT $LN7@SetEngine
$LN5@SetEngine:
  00094	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00097	83 c0 01	 add	 eax, 1
  0009a	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@SetEngine:
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	83 c1 08	 add	 ecx, 8
  000a3	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  000a8	39 45 f4	 cmp	 DWORD PTR _i$1[ebp], eax
  000ab	73 1c		 jae	 SHORT $LN1@SetEngine

; 199  : 		{
; 200  : 			m_children[i]->SetEngine(engine);

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _engine$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  000b4	52		 push	 edx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	83 c1 08	 add	 ecx, 8
  000bb	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	e8 00 00 00 00	 call	 ?SetEngine@Entity@@QAEXPAVCoreEngine@@@Z ; Entity::SetEngine

; 201  : 		}

  000c7	eb cb		 jmp	 SHORT $LN5@SetEngine
$LN1@SetEngine:

; 202  : 	}
; 203  : }

  000c9	5e		 pop	 esi
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
  000cd	3b ec		 cmp	 ebp, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?SetEngine@Entity@@QAEXPAVCoreEngine@@@Z ENDP		; Entity::SetEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv175 = -144						; size = 4
tv183 = -140						; size = 4
tv180 = -136						; size = 4
tv168 = -132						; size = 4
tv178 = -128						; size = 4
tv65 = -124						; size = 4
tv174 = -120						; size = 4
tv77 = -116						; size = 4
$T2 = -112						; size = 4
$T3 = -108						; size = 4
$T4 = -104						; size = 12
$T5 = -92						; size = 12
$T6 = -80						; size = 4
$T7 = -76						; size = 4
$T8 = -72						; size = 4
_childObjects$9 = -64					; size = 16
_i$10 = -44						; size = 4
_result$ = -36						; size = 16
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ PROC ; Entity::GetAllAttached
; _this$ = ecx

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  0001f	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00040	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 207  : 	std::vector<Entity*> result;

  00047	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 208  : 	
; 209  : 	for(unsigned int i = 0; i < m_children.size(); i++)

  00056	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN4@GetAllAtta
$LN2@GetAllAtta:
  0005f	8b 45 d4	 mov	 eax, DWORD PTR _i$10[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 d4	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@GetAllAtta:
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	83 c1 08	 add	 ecx, 8
  0006e	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00073	39 45 d4	 cmp	 DWORD PTR _i$10[ebp], eax
  00076	0f 83 d1 00 00
	00		 jae	 $LN3@GetAllAtta

; 210  : 	{
; 211  : 		std::vector<Entity*> childObjects = m_children[i]->GetAllAttached();

  0007c	8d 4d c0	 lea	 ecx, DWORD PTR _childObjects$9[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 d4	 mov	 edx, DWORD PTR _i$10[ebp]
  00083	52		 push	 edx
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	83 c1 08	 add	 ecx, 8
  0008a	e8 00 00 00 00	 call	 ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
  0008f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00091	e8 00 00 00 00	 call	 ?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ ; Entity::GetAllAttached
  00096	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 212  : 		result.insert(result.end(), childObjects.begin(), childObjects.end());

  0009a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0009d	8b c4		 mov	 eax, esp
  0009f	89 65 b8	 mov	 DWORD PTR $T8[ebp], esp
  000a2	50		 push	 eax
  000a3	8d 4d c0	 lea	 ecx, DWORD PTR _childObjects$9[ebp]
  000a6	e8 00 00 00 00	 call	 ?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::end
  000ab	89 45 8c	 mov	 DWORD PTR tv77[ebp], eax
  000ae	8b 4d 8c	 mov	 ecx, DWORD PTR tv77[ebp]
  000b1	89 4d 88	 mov	 DWORD PTR tv174[ebp], ecx
  000b4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000bb	8b d4		 mov	 edx, esp
  000bd	89 65 b4	 mov	 DWORD PTR $T7[ebp], esp
  000c0	52		 push	 edx
  000c1	8d 4d c0	 lea	 ecx, DWORD PTR _childObjects$9[ebp]
  000c4	e8 00 00 00 00	 call	 ?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::begin
  000c9	89 45 84	 mov	 DWORD PTR tv65[ebp], eax
  000cc	8b 45 84	 mov	 eax, DWORD PTR tv65[ebp]
  000cf	89 45 80	 mov	 DWORD PTR tv178[ebp], eax
  000d2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d6	8d 4d a4	 lea	 ecx, DWORD PTR $T5[ebp]
  000d9	51		 push	 ecx
  000da	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  000dd	e8 00 00 00 00	 call	 ?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::end
  000e2	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  000e8	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv168[ebp]
  000ee	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv180[ebp], edx
  000f4	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000f8	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000fb	8b cc		 mov	 ecx, esp
  000fd	89 65 b0	 mov	 DWORD PTR $T6[ebp], esp
  00100	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv180[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV01@@Z
  0010c	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv183[ebp], eax
  00112	8d 4d 98	 lea	 ecx, DWORD PTR $T4[ebp]
  00115	51		 push	 ecx
  00116	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0011a	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  0011d	e8 00 00 00 00	 call	 ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z ; std::vector<Entity *,std::allocator<Entity *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00122	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
  00128	8d 4d 98	 lea	 ecx, DWORD PTR $T4[ebp]
  0012b	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00130	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00134	8d 4d a4	 lea	 ecx, DWORD PTR $T5[ebp]
  00137	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ

; 213  : 	}

  0013c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00140	8d 4d c0	 lea	 ecx, DWORD PTR _childObjects$9[ebp]
  00143	e8 00 00 00 00	 call	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
  00148	e9 12 ff ff ff	 jmp	 $LN2@GetAllAtta
$LN3@GetAllAtta:

; 214  : 	
; 215  : 	result.push_back(this);

  0014d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00150	89 55 94	 mov	 DWORD PTR $T3[ebp], edx
  00153	8d 45 94	 lea	 eax, DWORD PTR $T3[ebp]
  00156	50		 push	 eax
  00157	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  0015a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back

; 216  : 	return result;

  0015f	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  00162	51		 push	 ecx
  00163	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00166	e8 00 00 00 00	 call	 ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
  0016b	8b 55 90	 mov	 edx, DWORD PTR $T2[ebp]
  0016e	83 ca 01	 or	 edx, 1
  00171	89 55 90	 mov	 DWORD PTR $T2[ebp], edx
  00174	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017b	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  0017e	e8 00 00 00 00	 call	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
  00183	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 217  : }

  00186	52		 push	 edx
  00187	8b cd		 mov	 ecx, ebp
  00189	50		 push	 eax
  0018a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@GetAllAtta
  00190	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00195	58		 pop	 eax
  00196	5a		 pop	 edx
  00197	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a1	59		 pop	 ecx
  001a2	5f		 pop	 edi
  001a3	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  001a9	3b ec		 cmp	 ebp, esp
  001ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 04 00	 ret	 4
  001b6	66 90		 npad	 2
$LN19@GetAllAtta:
  001b8	02 00 00 00	 DD	 2
  001bc	00 00 00 00	 DD	 $LN18@GetAllAtta
$LN18@GetAllAtta:
  001c0	dc ff ff ff	 DD	 -36			; ffffffdcH
  001c4	10 00 00 00	 DD	 16			; 00000010H
  001c8	00 00 00 00	 DD	 $LN15@GetAllAtta
  001cc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  001d0	10 00 00 00	 DD	 16			; 00000010H
  001d4	00 00 00 00	 DD	 $LN16@GetAllAtta
$LN16@GetAllAtta:
  001d8	63		 DB	 99			; 00000063H
  001d9	68		 DB	 104			; 00000068H
  001da	69		 DB	 105			; 00000069H
  001db	6c		 DB	 108			; 0000006cH
  001dc	64		 DB	 100			; 00000064H
  001dd	4f		 DB	 79			; 0000004fH
  001de	62		 DB	 98			; 00000062H
  001df	6a		 DB	 106			; 0000006aH
  001e0	65		 DB	 101			; 00000065H
  001e1	63		 DB	 99			; 00000063H
  001e2	74		 DB	 116			; 00000074H
  001e3	73		 DB	 115			; 00000073H
  001e4	00		 DB	 0
$LN15@GetAllAtta:
  001e5	72		 DB	 114			; 00000072H
  001e6	65		 DB	 101			; 00000065H
  001e7	73		 DB	 115			; 00000073H
  001e8	75		 DB	 117			; 00000075H
  001e9	6c		 DB	 108			; 0000006cH
  001ea	74		 DB	 116			; 00000074H
  001eb	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _result$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _childObjects$9[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$2:
  00010	8b 4d b8	 mov	 ecx, DWORD PTR $T8[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$3:
  00018	8b 4d b4	 mov	 ecx, DWORD PTR $T7[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ$4:
  00020	8d 4d a4	 lea	 ecx, DWORD PTR $T5[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAllAttached@Entity@@QAE?AV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@XZ ENDP ; Entity::GetAllAttached
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
_TEXT	SEGMENT
tv146 = -144						; size = 4
tv73 = -140						; size = 4
$T2 = -136						; size = 4
$T3 = -129						; size = 1
$T4 = -128						; size = 28
_x$5 = -96						; size = 4
_<end>$L0$6 = -84					; size = 12
_<begin>$L0$7 = -64					; size = 12
_<range>$L0$8 = -48					; size = 4
_components$ = -40					; size = 16
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_name$ = 12						; size = 4
?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; Entity::GetComponentsByType
; _this$ = ecx

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	51		 push	 ecx
  0001a	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-144]
  00020	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	59		 pop	 ecx
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00044	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0

; 221  : 	std::vector<EntityComponent*> components;

  0004e	8d 4d d8	 lea	 ecx, DWORD PTR _components$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 222  : 
; 223  : 	for (auto x : m_components)

  0005d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00060	83 c0 18	 add	 eax, 24			; 00000018H
  00063	89 45 d0	 mov	 DWORD PTR _<range>$L0$8[ebp], eax
  00066	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  00069	51		 push	 ecx
  0006a	8b 4d d0	 mov	 ecx, DWORD PTR _<range>$L0$8[ebp]
  0006d	e8 00 00 00 00	 call	 ?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::begin
  00072	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00076	8d 55 ac	 lea	 edx, DWORD PTR _<end>$L0$6[ebp]
  00079	52		 push	 edx
  0007a	8b 4d d0	 mov	 ecx, DWORD PTR _<range>$L0$8[ebp]
  0007d	e8 00 00 00 00	 call	 ?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::end
  00082	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00086	eb 08		 jmp	 SHORT $LN4@GetCompone
$LN2@GetCompone:
  00088	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  0008b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++
$LN4@GetCompone:
  00090	8d 45 ac	 lea	 eax, DWORD PTR _<end>$L0$6[ebp]
  00093	50		 push	 eax
  00094	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  00097	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator!=
  0009c	0f b6 c8	 movzx	 ecx, al
  0009f	85 c9		 test	 ecx, ecx
  000a1	74 7d		 je	 SHORT $LN3@GetCompone
  000a3	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  000a6	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEAAPAVEntityComponent@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*
  000ab	8b 10		 mov	 edx, DWORD PTR [eax]
  000ad	89 55 a0	 mov	 DWORD PTR _x$5[ebp], edx

; 224  : 	{
; 225  : 		if (x->__ClassType__ () == name)

  000b0	8b f4		 mov	 esi, esp
  000b2	8d 45 80	 lea	 eax, DWORD PTR $T4[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d a0	 mov	 ecx, DWORD PTR _x$5[ebp]
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	8b 4d a0	 mov	 ecx, DWORD PTR _x$5[ebp]
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	ff d0		 call	 eax
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  000cf	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  000d5	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv146[ebp], ecx
  000db	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000df	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  000e2	52		 push	 edx
  000e3	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv146[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  000ef	83 c4 08	 add	 esp, 8
  000f2	88 85 7f ff ff
	ff		 mov	 BYTE PTR $T3[ebp], al
  000f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000fc	8d 4d 80	 lea	 ecx, DWORD PTR $T4[ebp]
  000ff	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00104	0f b6 8d 7f ff
	ff ff		 movzx	 ecx, BYTE PTR $T3[ebp]
  0010b	85 c9		 test	 ecx, ecx
  0010d	74 0c		 je	 SHORT $LN5@GetCompone

; 226  : 			components.push_back (x);

  0010f	8d 55 a0	 lea	 edx, DWORD PTR _x$5[ebp]
  00112	52		 push	 edx
  00113	8d 4d d8	 lea	 ecx, DWORD PTR _components$[ebp]
  00116	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::push_back
$LN5@GetCompone:

; 227  : 	}

  0011b	e9 68 ff ff ff	 jmp	 $LN2@GetCompone
$LN3@GetCompone:
  00120	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00124	8d 4d ac	 lea	 ecx, DWORD PTR _<end>$L0$6[ebp]
  00127	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
  0012c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00130	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  00133	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ

; 228  : 
; 229  : 	return components;

  00138	8d 45 d8	 lea	 eax, DWORD PTR _components$[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0013f	e8 00 00 00 00	 call	 ??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
  00144	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0014a	83 c9 01	 or	 ecx, 1
  0014d	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00153	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015a	8d 4d d8	 lea	 ecx, DWORD PTR _components$[ebp]
  0015d	e8 00 00 00 00	 call	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
  00162	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 230  : }

  00165	52		 push	 edx
  00166	8b cd		 mov	 ecx, ebp
  00168	50		 push	 eax
  00169	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@GetCompone
  0016f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00174	58		 pop	 eax
  00175	5a		 pop	 edx
  00176	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00179	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00180	59		 pop	 ecx
  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  00193	3b ec		 cmp	 ebp, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c2 08 00	 ret	 8
$LN19@GetCompone:
  001a0	04 00 00 00	 DD	 4
  001a4	00 00 00 00	 DD	 $LN18@GetCompone
$LN18@GetCompone:
  001a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  001ac	10 00 00 00	 DD	 16			; 00000010H
  001b0	00 00 00 00	 DD	 $LN13@GetCompone
  001b4	c0 ff ff ff	 DD	 -64			; ffffffc0H
  001b8	0c 00 00 00	 DD	 12			; 0000000cH
  001bc	00 00 00 00	 DD	 $LN14@GetCompone
  001c0	ac ff ff ff	 DD	 -84			; ffffffacH
  001c4	0c 00 00 00	 DD	 12			; 0000000cH
  001c8	00 00 00 00	 DD	 $LN15@GetCompone
  001cc	a0 ff ff ff	 DD	 -96			; ffffffa0H
  001d0	04 00 00 00	 DD	 4
  001d4	00 00 00 00	 DD	 $LN16@GetCompone
$LN16@GetCompone:
  001d8	78		 DB	 120			; 00000078H
  001d9	00		 DB	 0
$LN15@GetCompone:
  001da	3c		 DB	 60			; 0000003cH
  001db	65		 DB	 101			; 00000065H
  001dc	6e		 DB	 110			; 0000006eH
  001dd	64		 DB	 100			; 00000064H
  001de	3e		 DB	 62			; 0000003eH
  001df	24		 DB	 36			; 00000024H
  001e0	4c		 DB	 76			; 0000004cH
  001e1	30		 DB	 48			; 00000030H
  001e2	00		 DB	 0
$LN14@GetCompone:
  001e3	3c		 DB	 60			; 0000003cH
  001e4	62		 DB	 98			; 00000062H
  001e5	65		 DB	 101			; 00000065H
  001e6	67		 DB	 103			; 00000067H
  001e7	69		 DB	 105			; 00000069H
  001e8	6e		 DB	 110			; 0000006eH
  001e9	3e		 DB	 62			; 0000003eH
  001ea	24		 DB	 36			; 00000024H
  001eb	4c		 DB	 76			; 0000004cH
  001ec	30		 DB	 48			; 00000030H
  001ed	00		 DB	 0
$LN13@GetCompone:
  001ee	63		 DB	 99			; 00000063H
  001ef	6f		 DB	 111			; 0000006fH
  001f0	6d		 DB	 109			; 0000006dH
  001f1	70		 DB	 112			; 00000070H
  001f2	6f		 DB	 111			; 0000006fH
  001f3	6e		 DB	 110			; 0000006eH
  001f4	65		 DB	 101			; 00000065H
  001f5	6e		 DB	 110			; 0000006eH
  001f6	74		 DB	 116			; 00000074H
  001f7	73		 DB	 115			; 00000073H
  001f8	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _components$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _<begin>$L0$7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$2:
  00010	8d 4d ac	 lea	 ecx, DWORD PTR _<end>$L0$6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$3:
  00018	8d 4d 80	 lea	 ecx, DWORD PTR $T4[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00037	33 c8		 xor	 ecx, eax
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
  00043	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetComponentsByType@Entity@@QAE?AV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; Entity::GetComponentsByType
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 231  : }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\entity.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 231  : }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_<_Args_0>$ = 8						; size = 4
??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z PROC ; std::_Func_class<void,RigidBody *>::operator(), COMDAT
; _this$ = ecx

; 270  : 		{	// call through stored object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		if (_Empty())

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ ; std::_Func_class<void,RigidBody *>::_Empty
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0f		 je	 SHORT $LN2@operator

; 272  : 			_Xbad_function_call();

  00027	8b f4		 mov	 esi, esp
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 273  : 		return (_Getimpl()->_Do_call(_STD forward<_Types>(_Args)...));

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ; std::_Func_class<void,RigidBody *>::_Getimpl
  0003e	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00041	8d 4d 08	 lea	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$forward@PAVRigidBody@@@std@@YA$$QAPAVRigidBody@@AAPAV1@@Z ; std::forward<RigidBody *>
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b f4		 mov	 esi, esp
  0004f	50		 push	 eax
  00050	8b 55 f8	 mov	 edx, DWORD PTR tv71[ebp]
  00053	8b 02		 mov	 eax, DWORD PTR [edx]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR tv71[ebp]
  00058	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005b	ff d2		 call	 edx
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:

; 274  : 		}

  00064	5e		 pop	 esi
  00065	83 c4 08	 add	 esp, 8
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
??R?$_Func_class@XPAVRigidBody@@@std@@QBEXPAVRigidBody@@@Z ENDP ; std::_Func_class<void,RigidBody *>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 		return (!(*this == _Right));

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator==
  00023	0f b6 c8	 movzx	 ecx, al
  00026	85 c9		 test	 ecx, ecx
  00028	75 09		 jne	 SHORT $LN3@operator
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0003a	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 212  : 		}

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++, COMDAT
; _this$ = ecx

; 334  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		++*(_Mybase *)this;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++

; 336  : 		return (*this);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 337  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 		return ((reference)**(_Mybase *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEABU?$pair@PAVRigidBody@@H@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*

; 326  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVRigidBody@@H@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::end, COMDAT
; _this$ = ecx

; 1066 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1068 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?end@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::end
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::begin, COMDAT
; _this$ = ecx

; 1056 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1058 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::begin
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::~vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 975  : 		_Tidy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Tidy

; 976  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::~_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::~vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >, COMDAT
; _this$ = ecx

; 706  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 705  : 		: _Mybase()

  00036	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@XZ ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >

; 707  : 		}

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ PROC	; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>, COMDAT
; _this$ = ecx

; 509  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 510  : 		}

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ ; std::_Func_class<void,RigidBody *>::~_Func_class<void,RigidBody *>
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ENDP	; std::function<void __cdecl(RigidBody *)>::~function<void __cdecl(RigidBody *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ PROC	; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>, COMDAT
; _this$ = ecx

; 466  : 	function() _NOEXCEPT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 467  : 		{	// construct empty function wrapper

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ ; std::_Func_class<void,RigidBody *>::_Func_class<void,RigidBody *>

; 468  : 		}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$function@$$A6AXPAVRigidBody@@@Z@std@@QAE@XZ ENDP	; std::function<void __cdecl(RigidBody *)>::function<void __cdecl(RigidBody *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 		return (!(*this == _Right));

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator==
  00023	0f b6 c8	 movzx	 ecx, al
  00026	85 c9		 test	 ecx, ecx
  00028	75 09		 jne	 SHORT $LN3@operator
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0003a	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 212  : 		}

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++, COMDAT
; _this$ = ecx

; 334  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		++*(_Mybase *)this;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++

; 336  : 		return (*this);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 337  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEAAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEAAPAVEntityComponent@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 		return ((reference)**(_Mybase *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAVEntityComponent@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*

; 326  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEAAPAVEntityComponent@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z
_TEXT	SEGMENT
tv225 = -16						; size = 4
tv172 = -12						; size = 4
__Idx$1 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		if (_Inside(_STD addressof(_Val)))

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z ; std::addressof<Entity * const>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Inside@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBE_NPBQAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Inside
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	0f 84 a3 00 00
	00		 je	 $LN2@push_back

; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  0003b	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z ; std::addressof<Entity * const>
  00044	83 c4 04	 add	 esp, 4
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00051	2b 30		 sub	 esi, DWORD PTR [eax]
  00053	c1 fe 02	 sar	 esi, 2
  00056	89 75 f8	 mov	 DWORD PTR __Idx$1[ebp], esi

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00061	8b f0		 mov	 esi, eax
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  0006b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 0a		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00071	6a 01		 push	 1
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Reserve
$LN4@push_back:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00083	8b 10		 mov	 edx, DWORD PTR [eax]
  00085	52		 push	 edx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR __Idx$1[ebp]
  000a6	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	51		 push	 ecx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * &>

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  000cc	89 45 f4	 mov	 DWORD PTR tv172[ebp], eax
  000cf	8b 55 f4	 mov	 edx, DWORD PTR tv172[ebp]
  000d2	8b 02		 mov	 eax, DWORD PTR [edx]
  000d4	83 c0 04	 add	 eax, 4
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR tv172[ebp]
  000da	89 01		 mov	 DWORD PTR [ecx], eax

; 1284 : 			}
; 1285 : 		else

  000dc	eb 76		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  000e6	8b f0		 mov	 esi, eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000f4	75 0a		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  000f6	6a 01		 push	 1
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Reserve
$LN5@push_back:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00100	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	51		 push	 ecx
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range

; 1290 : 			this->_Getal().construct(this->_Mylast(),

  0011e	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00121	52		 push	 edx
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0012a	8b 00		 mov	 eax, DWORD PTR [eax]
  0012c	50		 push	 eax
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00135	8b c8		 mov	 ecx, eax
  00137	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * const &>

; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00144	89 45 f0	 mov	 DWORD PTR tv225[ebp], eax
  00147	8b 4d f0	 mov	 ecx, DWORD PTR tv225[ebp]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	83 c2 04	 add	 edx, 4
  0014f	8b 45 f0	 mov	 eax, DWORD PTR tv225[ebp]
  00152	89 10		 mov	 DWORD PTR [eax], edx
$LN1@push_back:

; 1293 : 			}
; 1294 : 		}

  00154	5e		 pop	 esi
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	3b ec		 cmp	 ebp, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXABQAVEntity@@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  0001a	0f 87 86 00 00
	00		 ja	 $LN2@operator

; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");

  00020	8b f4		 mov	 esi, esp
  00022	68 d0 04 00 00	 push	 1232			; 000004d0H
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN4@operator
  0004a	33 c9		 xor	 ecx, ecx
  0004c	75 30		 jne	 SHORT $LN5@operator
$LN4@operator:
  0004e	8b f4		 mov	 esi, esp
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0005a	6a 00		 push	 0
  0005c	68 d1 04 00 00	 push	 1233			; 000004d1H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00066	6a 02		 push	 2
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	83 f8 01	 cmp	 eax, 1
  0007b	75 01		 jne	 SHORT $LN5@operator
  0007d	cc		 int	 3
$LN5@operator:
  0007e	8b f4		 mov	 esi, esp
  00080	6a 00		 push	 0
  00082	68 d1 04 00 00	 push	 1233			; 000004d1H
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@KJPPJIKP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000ae	8b 00		 mov	 eax, DWORD PTR [eax]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  000b3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1241 : 		}

  000b6	5e		 pop	 esi
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEAAPAVEntity@@I@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::operator[], COMDAT
; _this$ = ecx

; 1212 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  0001a	0f 87 86 00 00
	00		 ja	 $LN2@operator

; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");

  00020	8b f4		 mov	 esi, esp
  00022	68 c0 04 00 00	 push	 1216			; 000004c0H
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN4@operator
  0004a	33 c9		 xor	 ecx, ecx
  0004c	75 30		 jne	 SHORT $LN5@operator
$LN4@operator:
  0004e	8b f4		 mov	 esi, esp
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0005a	6a 00		 push	 0
  0005c	68 c1 04 00 00	 push	 1217			; 000004c1H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00066	6a 02		 push	 2
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	83 f8 01	 cmp	 eax, 1
  0007b	75 01		 jne	 SHORT $LN5@operator
  0007d	cc		 int	 3
$LN5@operator:
  0007e	8b f4		 mov	 esi, esp
  00080	6a 00		 push	 0
  00082	68 c1 04 00 00	 push	 1217			; 000004c1H
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1JO@KJPPJIKP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000ae	8b 00		 mov	 eax, DWORD PTR [eax]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  000b3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1225 : 		}

  000b6	5e		 pop	 esi
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??A?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEABQAVEntity@@I@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::size, COMDAT
; _this$ = ecx

; 1178 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1180 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::end, COMDAT
; _this$ = ecx

; 1066 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1068 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::end
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::begin, COMDAT
; _this$ = ecx

; 1056 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1058 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::begin
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 975  : 		_Tidy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy

; 976  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::~_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 840  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 839  : 		: _Mybase(_STD move(_Right._Getal()))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<Entity *> > &>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >

; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());

  00050	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$forward@V?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@0@AAV10@@Z ; std::forward<std::vector<Entity *,std::allocator<Entity *> > >
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Assign_rv@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Assign_rv

; 842  : 		}

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 706  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 705  : 		: _Mybase()

  00036	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$allocator@PAVEntity@@@std@@QAE@XZ ; std::allocator<Entity *>::allocator<Entity *>
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >

; 707  : 		}

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z
_TEXT	SEGMENT
tv225 = -16						; size = 4
tv172 = -12						; size = 4
__Idx$1 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		if (_Inside(_STD addressof(_Val)))

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z ; std::addressof<EntityComponent * const>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Inside@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBE_NPBQAVEntityComponent@@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Inside
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	0f 84 a3 00 00
	00		 je	 $LN2@push_back

; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  0003b	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z ; std::addressof<EntityComponent * const>
  00044	83 c4 04	 add	 esp, 4
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00051	2b 30		 sub	 esi, DWORD PTR [eax]
  00053	c1 fe 02	 sar	 esi, 2
  00056	89 75 f8	 mov	 DWORD PTR __Idx$1[ebp], esi

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00061	8b f0		 mov	 esi, eax
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  0006b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 0a		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00071	6a 01		 push	 1
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reserve
$LN4@push_back:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00083	8b 10		 mov	 edx, DWORD PTR [eax]
  00085	52		 push	 edx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Orphan_range

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR __Idx$1[ebp]
  000a6	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	51		 push	 ecx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  000cc	89 45 f4	 mov	 DWORD PTR tv172[ebp], eax
  000cf	8b 55 f4	 mov	 edx, DWORD PTR tv172[ebp]
  000d2	8b 02		 mov	 eax, DWORD PTR [edx]
  000d4	83 c0 04	 add	 eax, 4
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR tv172[ebp]
  000da	89 01		 mov	 DWORD PTR [ecx], eax

; 1284 : 			}
; 1285 : 		else

  000dc	eb 76		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  000e6	8b f0		 mov	 esi, eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000f4	75 0a		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  000f6	6a 01		 push	 1
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reserve
$LN5@push_back:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00100	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	51		 push	 ecx
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Orphan_range

; 1290 : 			this->_Getal().construct(this->_Mylast(),

  0011e	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00121	52		 push	 edx
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  0012a	8b 00		 mov	 eax, DWORD PTR [eax]
  0012c	50		 push	 eax
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00135	8b c8		 mov	 ecx, eax
  00137	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>

; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00144	89 45 f0	 mov	 DWORD PTR tv225[ebp], eax
  00147	8b 4d f0	 mov	 ecx, DWORD PTR tv225[ebp]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	83 c2 04	 add	 edx, 4
  0014f	8b 45 f0	 mov	 eax, DWORD PTR tv225[ebp]
  00152	89 10		 mov	 DWORD PTR [eax], edx
$LN1@push_back:

; 1293 : 			}
; 1294 : 		}

  00154	5e		 pop	 esi
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	3b ec		 cmp	 ebp, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
?push_back@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXABQAVEntityComponent@@@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  0001a	0f 87 86 00 00
	00		 ja	 $LN2@operator

; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");

  00020	8b f4		 mov	 esi, esp
  00022	68 d0 04 00 00	 push	 1232			; 000004d0H
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN4@operator
  0004a	33 c9		 xor	 ecx, ecx
  0004c	75 30		 jne	 SHORT $LN5@operator
$LN4@operator:
  0004e	8b f4		 mov	 esi, esp
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0005a	6a 00		 push	 0
  0005c	68 d1 04 00 00	 push	 1233			; 000004d1H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00066	6a 02		 push	 2
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	83 f8 01	 cmp	 eax, 1
  0007b	75 01		 jne	 SHORT $LN5@operator
  0007d	cc		 int	 3
$LN5@operator:
  0007e	8b f4		 mov	 esi, esp
  00080	6a 00		 push	 0
  00082	68 d1 04 00 00	 push	 1233			; 000004d1H
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1MC@NHEIOOEP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000ae	8b 00		 mov	 eax, DWORD PTR [eax]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  000b3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1241 : 		}

  000b6	5e		 pop	 esi
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[], COMDAT
; _this$ = ecx

; 1212 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  0001a	0f 87 86 00 00
	00		 ja	 $LN2@operator

; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");

  00020	8b f4		 mov	 esi, esp
  00022	68 c0 04 00 00	 push	 1216			; 000004c0H
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN4@operator
  0004a	33 c9		 xor	 ecx, ecx
  0004c	75 30		 jne	 SHORT $LN5@operator
$LN4@operator:
  0004e	8b f4		 mov	 esi, esp
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0005a	6a 00		 push	 0
  0005c	68 c1 04 00 00	 push	 1217			; 000004c1H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00066	6a 02		 push	 2
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	83 f8 01	 cmp	 eax, 1
  0007b	75 01		 jne	 SHORT $LN5@operator
  0007d	cc		 int	 3
$LN5@operator:
  0007e	8b f4		 mov	 esi, esp
  00080	6a 00		 push	 0
  00082	68 c1 04 00 00	 push	 1217			; 000004c1H
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1MC@NHEIOOEP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAt?$AAi?$AAt?$AAy?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000ae	8b 00		 mov	 eax, DWORD PTR [eax]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  000b3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1225 : 		}

  000b6	5e		 pop	 esi
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??A?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEABQAVEntityComponent@@I@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?at@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::at, COMDAT
; _this$ = ecx

; 1205 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1206 : 		if (size() <= _Pos)

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00016	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00019	77 08		 ja	 SHORT $LN2@at

; 1207 : 			_Xran();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Xran@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xran
$LN2@at:

; 1208 : 		return (*(this->_Myfirst() + _Pos));

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00030	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$LN3@at:

; 1209 : 		}

  00033	83 c4 04	 add	 esp, 4
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?at@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEAAPAVEntityComponent@@I@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size, COMDAT
; _this$ = ecx

; 1178 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1180 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::end, COMDAT
; _this$ = ecx

; 1066 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1068 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?end@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::end
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::begin, COMDAT
; _this$ = ecx

; 1056 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00035	50		 push	 eax
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1058 : 		}

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@2@XZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::begin
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 975  : 		_Tidy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Tidy

; 976  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::~_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::~vector<EntityComponent *,std::allocator<EntityComponent *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >, COMDAT
; _this$ = ecx

; 840  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 839  : 		: _Mybase(_STD move(_Right._Getal()))

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<EntityComponent *> > &>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >

; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());

  00050	0f b6 45 ef	 movzx	 eax, BYTE PTR $T2[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$forward@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@0@AAV10@@Z ; std::forward<std::vector<EntityComponent *,std::allocator<EntityComponent *> > >
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Assign_rv@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Assign_rv

; 842  : 		}

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >, COMDAT
; _this$ = ecx

; 706  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 705  : 		: _Mybase()

  00036	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$allocator@PAVEntityComponent@@@std@@QAE@XZ ; std::allocator<EntityComponent *>::allocator<EntityComponent *>
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >

; 707  : 		}

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@XZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::vector<EntityComponent *,std::allocator<EntityComponent *> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  0001a	0f 87 86 00 00
	00		 ja	 $LN2@operator

; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");

  00020	8b f4		 mov	 esi, esp
  00022	68 d0 04 00 00	 push	 1232			; 000004d0H
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN4@operator
  0004a	33 c9		 xor	 ecx, ecx
  0004c	75 30		 jne	 SHORT $LN5@operator
$LN4@operator:
  0004e	8b f4		 mov	 esi, esp
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0005a	6a 00		 push	 0
  0005c	68 d1 04 00 00	 push	 1233			; 000004d1H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00066	6a 02		 push	 2
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	83 f8 01	 cmp	 eax, 1
  0007b	75 01		 jne	 SHORT $LN5@operator
  0007d	cc		 int	 3
$LN5@operator:
  0007e	8b f4		 mov	 esi, esp
  00080	6a 00		 push	 0
  00082	68 d1 04 00 00	 push	 1233			; 000004d1H
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1BME@NCIPHHDN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  000ae	6b 4d 08 1c	 imul	 ecx, DWORD PTR __Pos$[ebp], 28
  000b2	03 08		 add	 ecx, DWORD PTR [eax]
  000b4	8b c1		 mov	 eax, ecx

; 1241 : 		}

  000b6	5e		 pop	 esi
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 1178 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	8b c1		 mov	 eax, ecx
  00027	99		 cdq
  00028	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0002d	f7 f9		 idiv	 ecx

; 1180 : 		}

  0002f	5e		 pop	 esi
  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 975  : 		_Tidy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 976  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Matrix@M$03@@QBEPBMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Matrix@M$03@@QBEPBMH@Z PROC			; Matrix<float,4>::operator[], COMDAT
; _this$ = ecx

; 560  : 	inline const T* operator[](int index) const { return m[index]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00011	c1 e0 04	 shl	 eax, 4
  00014	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Matrix@M$03@@QBEPBMH@Z ENDP			; Matrix<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ
_TEXT	SEGMENT
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ PROC		; Matrix<float,4>::InitIdentity, COMDAT
; _this$ = ecx

; 358  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000f	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00016	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 359  : 		for(unsigned int i = 0; i < D; i++)

  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@InitIdenti
$LN2@InitIdenti:
  00029	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@InitIdenti:
  00032	83 7d f8 04	 cmp	 DWORD PTR _i$2[ebp], 4
  00036	73 58		 jae	 SHORT $LN3@InitIdenti

; 360  : 		{
; 361  : 			for(unsigned int j = 0; j < D; j++)

  00038	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$1[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN7@InitIdenti
$LN5@InitIdenti:
  00041	8b 4d f4	 mov	 ecx, DWORD PTR _j$1[ebp]
  00044	83 c1 01	 add	 ecx, 1
  00047	89 4d f4	 mov	 DWORD PTR _j$1[ebp], ecx
$LN7@InitIdenti:
  0004a	83 7d f4 04	 cmp	 DWORD PTR _j$1[ebp], 4
  0004e	73 3e		 jae	 SHORT $LN6@InitIdenti

; 362  : 			{
; 363  : 				if(i == j)

  00050	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00053	3b 55 f4	 cmp	 edx, DWORD PTR _j$1[ebp]
  00056	75 1b		 jne	 SHORT $LN8@InitIdenti

; 364  : 					m[i][j] = T(1);

  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _j$1[ebp]
  00064	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006c	f3 0f 11 04 88	 movss	 DWORD PTR [eax+ecx*4], xmm0

; 365  : 				else

  00071	eb 19		 jmp	 SHORT $LN9@InitIdenti
$LN8@InitIdenti:

; 366  : 					m[i][j] = T(0);

  00073	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00076	c1 e2 04	 shl	 edx, 4
  00079	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00087	f3 0f 11 04 82	 movss	 DWORD PTR [edx+eax*4], xmm0
$LN9@InitIdenti:

; 367  : 			}

  0008c	eb b3		 jmp	 SHORT $LN5@InitIdenti
$LN6@InitIdenti:

; 368  : 		}

  0008e	eb 99		 jmp	 SHORT $LN2@InitIdenti
$LN3@InitIdenti:

; 369  : 		
; 370  : 		return *this;

  00090	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00095	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00098	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009b	f3 a5		 rep movsd
  0009d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 371  : 	}

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ ENDP		; Matrix<float,4>::InitIdentity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Vector@M$03@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$Vector@M$03@@QBEMI@Z PROC				; Vector<float,4>::operator[], COMDAT
; _this$ = ecx

; 166  : 	T operator [] (unsigned int i) const { return values[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Vector@M$03@@QBEMI@Z ENDP				; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Vector@M$03@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$Vector@M$03@@QAEAAMI@Z PROC			; Vector<float,4>::operator[], COMDAT
; _this$ = ecx

; 165  : 	T& operator [] (unsigned int i) { return values[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Vector@M$03@@QAEAAMI@Z ENDP			; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Matrix4@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Matrix4@M@@QAE@XZ PROC				; Matrix4<float>::Matrix4<float>, COMDAT
; _this$ = ecx

; 571  : 	Matrix4() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$Matrix4@M@@QAE@XZ ENDP				; Matrix4<float>::Matrix4<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetW@?$Vector4@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@?$Vector4@M@@QBEMXZ PROC				; Vector4<float>::GetW, COMDAT
; _this$ = ecx

; 327  : 	inline T GetW() const { return (*this)[3]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 03		 push	 3
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QBEMI@Z ; Vector<float,4>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetW@?$Vector4@M@@QBEMXZ ENDP				; Vector4<float>::GetW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetZ@?$Vector4@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetZ@?$Vector4@M@@QBEMXZ PROC				; Vector4<float>::GetZ, COMDAT
; _this$ = ecx

; 326  : 	inline T GetZ() const { return (*this)[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 02		 push	 2
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QBEMI@Z ; Vector<float,4>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetZ@?$Vector4@M@@QBEMXZ ENDP				; Vector4<float>::GetZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetY@?$Vector4@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@?$Vector4@M@@QBEMXZ PROC				; Vector4<float>::GetY, COMDAT
; _this$ = ecx

; 325  : 	inline T GetY() const { return (*this)[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 01		 push	 1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QBEMI@Z ; Vector<float,4>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetY@?$Vector4@M@@QBEMXZ ENDP				; Vector4<float>::GetY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetX@?$Vector4@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@?$Vector4@M@@QBEMXZ PROC				; Vector4<float>::GetX, COMDAT
; _this$ = ecx

; 324  : 	inline T GetX() const { return (*this)[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 00		 push	 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$03@@QBEMI@Z ; Vector<float,4>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetX@?$Vector4@M@@QBEMXZ ENDP				; Vector4<float>::GetX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Vector4@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Vector4@M@@QAE@XZ PROC				; Vector4<float>::Vector4<float>, COMDAT
; _this$ = ecx

; 298  : 	Vector4() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$Vector@M$03@@QAE@XZ ; Vector<float,4>::Vector<float,4>
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$Vector4@M@@QAE@XZ ENDP				; Vector4<float>::Vector4<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Vector@M$02@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$Vector@M$02@@QBEMI@Z PROC				; Vector<float,3>::operator[], COMDAT
; _this$ = ecx

; 166  : 	T operator [] (unsigned int i) const { return values[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Vector@M$02@@QBEMI@Z ENDP				; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Vector@M$02@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$Vector@M$02@@QAEAAMI@Z PROC			; Vector<float,3>::operator[], COMDAT
; _this$ = ecx

; 165  : 	T& operator [] (unsigned int i) { return values[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Vector@M$02@@QAEAAMI@Z ENDP			; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetFT@?$Vector3@M@@SA?AV1@ABVbtVector3@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_bt$ = 12						; size = 4
?GetFT@?$Vector3@M@@SA?AV1@ABVbtVector3@@@Z PROC	; Vector3<float>::GetFT, COMDAT

; 287  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		return Vector3<T>(bt.getX(), bt.getY(), bt.getZ());

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  00006	e8 00 00 00 00	 call	 ?getZ@btVector3@@QBEABMXZ ; btVector3::getZ
  0000b	51		 push	 ecx
  0000c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00010	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  00018	e8 00 00 00 00	 call	 ?getY@btVector3@@QBEABMXZ ; btVector3::getY
  0001d	51		 push	 ecx
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _bt$[ebp]
  0002a	e8 00 00 00 00	 call	 ?getX@btVector3@@QBEABMXZ ; btVector3::getX
  0002f	51		 push	 ecx
  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0?$Vector3@M@@QAE@MMM@Z ; Vector3<float>::Vector3<float>
  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 289  : 	}

  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GetFT@?$Vector3@M@@SA?AV1@ABVbtVector3@@@Z ENDP	; Vector3<float>::GetFT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ PROC		; Vector3<float>::GetBT, COMDAT
; _this$ = ecx

; 283  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 284  : 		return btVector3(GetX(), GetY(), GetZ());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?GetZ@?$Vector3@M@@QBEMXZ ; Vector3<float>::GetZ
  00022	d9 5d f8	 fstp	 DWORD PTR $T3[ebp]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?GetY@?$Vector3@M@@QBEMXZ ; Vector3<float>::GetY
  0002d	d9 5d f4	 fstp	 DWORD PTR $T2[ebp]
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetX@?$Vector3@M@@QBEMXZ ; Vector3<float>::GetX
  00038	d9 5d f0	 fstp	 DWORD PTR $T1[ebp]
  0003b	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  0003e	50		 push	 eax
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  00042	51		 push	 ecx
  00043	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00046	52		 push	 edx
  00047	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0btVector3@@QAE@ABM00@Z ; btVector3::btVector3
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 285  : 	}

  00052	83 c4 10	 add	 esp, 16			; 00000010H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?GetBT@?$Vector3@M@@QBE?AVbtVector3@@XZ ENDP		; Vector3<float>::GetBT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetZ@?$Vector3@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetZ@?$Vector3@M@@QBEMXZ PROC				; Vector3<float>::GetZ, COMDAT
; _this$ = ecx

; 274  : 	inline T GetZ() const { return (*this)[2]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 02		 push	 2
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetZ@?$Vector3@M@@QBEMXZ ENDP				; Vector3<float>::GetZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetY@?$Vector3@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@?$Vector3@M@@QBEMXZ PROC				; Vector3<float>::GetY, COMDAT
; _this$ = ecx

; 273  : 	inline T GetY() const { return (*this)[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 01		 push	 1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetY@?$Vector3@M@@QBEMXZ ENDP				; Vector3<float>::GetY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?GetX@?$Vector3@M@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@?$Vector3@M@@QBEMXZ PROC				; Vector3<float>::GetX, COMDAT
; _this$ = ecx

; 272  : 	inline T GetX() const { return (*this)[0]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a 00		 push	 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetX@?$Vector3@M@@QBEMXZ ENDP				; Vector3<float>::GetX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Vector3@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Vector3@M@@QAE@XZ PROC				; Vector3<float>::Vector3<float>, COMDAT
; _this$ = ecx

; 229  : 	Vector3() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$Vector@M$02@@QAE@XZ ; Vector<float,3>::Vector<float,3>
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$Vector3@M@@QAE@XZ ENDP				; Vector3<float>::Vector3<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2125 : 		_DEBUG_POINTER(_Ptr);

  0000e	68 4d 08 00 00	 push	 2125			; 0000084dH
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00018	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char const >
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2127 : 		}

  0004a	83 c4 04	 add	 esp, 4
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2102 : 		{	// compare [0, _Mysize()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00030	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	50		 push	 eax
  0004a	6a 00		 push	 0
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2104 : 		}

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1749 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1750 : 		return (this->_Mysize());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00016	8b 00		 mov	 eax, DWORD PTR [eax]

; 1751 : 		}

  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1734 : 		{	// return pointer to null-terminated nonmutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1735 : 		return (this->_Myptr());

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr

; 1736 : 		}

  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1005 : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1006 : 		_Tidy(true);

  0002d	6a 00		 push	 0
  0002f	6a 01		 push	 1
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1007 : 		}

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
  00041	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00044	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004b	59		 pop	 ecx
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 824  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 823  : 		: _Mybase()

  00036	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0003e	50		 push	 eax
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 825  : 		_Tidy();

  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 826  : 		assign(_Ptr);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 827  : 		}

  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	83 c4 14	 add	 esp, 20			; 00000014H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ PROC ; std::_Func_class<void,RigidBody *>::_Getimpl, COMDAT
; _this$ = ecx

; 423  : 		{	// get pointer to object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 424  : 		return (_Mystorage._Ptrs[_Num_ptrs - 1]);

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 09	 imul	 ecx, eax, 9
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]

; 425  : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ENDP ; std::_Func_class<void,RigidBody *>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ PROC	; std::_Func_class<void,RigidBody *>::_Empty, COMDAT
; _this$ = ecx

; 283  : 		{	// return true if no stored object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 284  : 		return (_Getimpl() == 0);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ; std::_Func_class<void,RigidBody *>::_Getimpl
  0001f	85 c0		 test	 eax, eax
  00021	75 09		 jne	 SHORT $LN3@Empty
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0002a	eb 07		 jmp	 SHORT $LN4@Empty
$LN3@Empty:
  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@Empty:
  00033	8a 45 f8	 mov	 al, BYTE PTR tv67[ebp]

; 285  : 		}

  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ ENDP	; std::_Func_class<void,RigidBody *>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??1?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ PROC	; std::_Func_class<void,RigidBody *>::~_Func_class<void,RigidBody *>, COMDAT
; _this$ = ecx

; 277  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ ; std::_Func_class<void,RigidBody *>::_Tidy

; 279  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ ENDP	; std::_Func_class<void,RigidBody *>::~_Func_class<void,RigidBody *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??0?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ PROC	; std::_Func_class<void,RigidBody *>::_Func_class<void,RigidBody *>, COMDAT
; _this$ = ecx

; 264  : 	_Func_class() _NOEXCEPT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  : 		{	// construct without stored object
; 266  : 		_Set(0);

  0000e	6a 00		 push	 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z ; std::_Func_class<void,RigidBody *>::_Set

; 267  : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_Func_class@XPAVRigidBody@@@std@@QAE@XZ ENDP	; std::_Func_class<void,RigidBody *>::_Func_class<void,RigidBody *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 		if (this->_Getcont() != _Right._Getcont())

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00020	8b f0		 mov	 esi, eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	3b f0		 cmp	 esi, eax
  0002c	74 0c		 je	 SHORT $LN2@operator

; 205  : 			_Compat(_Right);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Compat
$LN2@operator:

; 206  : 		return (this->_Ptr == _Right._Ptr);

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00040	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00043	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00046	75 09		 jne	 SHORT $LN4@operator
  00048	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  0004f	eb 07		 jmp	 SHORT $LN5@operator
$LN4@operator:
  00051	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN5@operator:
  00058	8a 45 f8	 mov	 al, BYTE PTR tv82[ebp]

; 207  : 		}

  0005b	5e		 pop	 esi
  0005c	83 c4 08	 add	 esp, 8
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 1c		 je	 SHORT $LN3@operator
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00022	74 13		 je	 SHORT $LN3@operator
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

  00037	8b f4		 mov	 esi, esp
  00039	6a 65		 push	 101			; 00000065H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

  00055	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0005a	85 c0		 test	 eax, eax
  0005c	74 04		 je	 SHORT $LN5@operator
  0005e	33 c9		 xor	 ecx, ecx
  00060	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00062	8b f4		 mov	 esi, esp
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0006e	6a 00		 push	 0
  00070	6a 66		 push	 102			; 00000066H
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00077	6a 02		 push	 2
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	83 f8 01	 cmp	 eax, 1
  0008c	75 01		 jne	 SHORT $LN6@operator
  0008e	cc		 int	 3
$LN6@operator:
  0008f	8b f4		 mov	 esi, esp
  00091	6a 00		 push	 0
  00093	6a 66		 push	 102			; 00000066H
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_1BBA@POHNFPDP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000aa	83 c4 14	 add	 esp, 20			; 00000014H
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ba	83 c1 08	 add	 ecx, 8
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 114  : 		}

  000c6	5e		 pop	 esi
  000c7	83 c4 04	 add	 esp, 4
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEABU?$pair@PAVRigidBody@@H@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEABU?$pair@PAVRigidBody@@H@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 2f		 je	 SHORT $LN3@operator
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00022	74 26		 je	 SHORT $LN3@operator
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00032	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00035	72 13		 jb	 SHORT $LN3@operator
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00045	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00048	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

  0004a	8b f4		 mov	 esi, esp
  0004c	6a 48		 push	 72			; 00000048H
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

  00068	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0006d	85 c0		 test	 eax, eax
  0006f	74 04		 je	 SHORT $LN5@operator
  00071	33 c9		 xor	 ecx, ecx
  00073	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00075	8b f4		 mov	 esi, esp
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00081	6a 00		 push	 0
  00083	6a 49		 push	 73			; 00000049H
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008a	6a 02		 push	 2
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00092	83 c4 18	 add	 esp, 24			; 00000018H
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	75 01		 jne	 SHORT $LN6@operator
  000a1	cc		 int	 3
$LN6@operator:
  000a2	8b f4		 mov	 esi, esp
  000a4	6a 00		 push	 0
  000a6	6a 49		 push	 73			; 00000049H
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1BAO@DGCLFBOA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000bd	83 c4 14	 add	 esp, 20			; 00000014H
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 87   : 		}

  000cd	5e		 pop	 esi
  000ce	83 c4 04	 add	 esp, 4
  000d1	3b ec		 cmp	 ebp, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEABU?$pair@PAVRigidBody@@H@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 306  : 		: _Mybase(_Parg, _Pvector)

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >

; 308  : 		}

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myend, COMDAT
; _this$ = ecx

; 661  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 663  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast, COMDAT
; _this$ = ecx

; 651  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 653  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 641  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 643  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data, COMDAT
; _this$ = ecx

; 631  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_second

; 633  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal, COMDAT
; _this$ = ecx

; 621  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_first

; 623  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::~_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx

; 551  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 552  : 		_Free_proxy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Free_proxy

; 553  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::~_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx

; 540  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1><std::allocator<std::pair<RigidBody *,int> > const &>
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 541  : 		_Alloc_proxy();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Alloc_proxy

; 542  : 		}

  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	83 c4 14	 add	 esp, 20			; 00000014H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	0f 84 84 00 00
	00		 je	 $LN1@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Orphan_all

; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	51		 push	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Destroy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXPAU?$pair@PAVRigidBody@@H@2@0@Z ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myend
  0004e	8b f0		 mov	 esi, eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	2b 10		 sub	 edx, DWORD PTR [eax]
  0005c	c1 fa 03	 sar	 edx, 3
  0005f	52		 push	 edx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myfirst
  00082	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1663 : 			this->_Mylast() = pointer();

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Mylast
  00090	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1664 : 			this->_Myend() = pointer();

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU?$pair@PAVRigidBody@@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myend
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1665 : 			}
; 1666 : 		}

  000a4	5e		 pop	 esi
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?_Tidy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >, COMDAT
; _this$ = ecx

; 617  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 		if (this->_Getcont() != _Right._Getcont())

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00020	8b f0		 mov	 esi, eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	3b f0		 cmp	 esi, eax
  0002c	74 0c		 je	 SHORT $LN2@operator

; 205  : 			_Compat(_Right);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Compat
$LN2@operator:

; 206  : 		return (this->_Ptr == _Right._Ptr);

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00040	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00043	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00046	75 09		 jne	 SHORT $LN4@operator
  00048	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  0004f	eb 07		 jmp	 SHORT $LN5@operator
$LN4@operator:
  00051	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN5@operator:
  00058	8a 45 f8	 mov	 al, BYTE PTR tv82[ebp]

; 207  : 		}

  0005b	5e		 pop	 esi
  0005c	83 c4 08	 add	 esp, 8
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 1c		 je	 SHORT $LN3@operator
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00022	74 13		 je	 SHORT $LN3@operator
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00032	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00035	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

  00037	8b f4		 mov	 esi, esp
  00039	6a 65		 push	 101			; 00000065H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

  00055	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0005a	85 c0		 test	 eax, eax
  0005c	74 04		 je	 SHORT $LN5@operator
  0005e	33 c9		 xor	 ecx, ecx
  00060	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00062	8b f4		 mov	 esi, esp
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0006e	6a 00		 push	 0
  00070	6a 66		 push	 102			; 00000066H
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00077	6a 02		 push	 2
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	83 f8 01	 cmp	 eax, 1
  0008c	75 01		 jne	 SHORT $LN6@operator
  0008e	cc		 int	 3
$LN6@operator:
  0008f	8b f4		 mov	 esi, esp
  00091	6a 00		 push	 0
  00093	6a 66		 push	 102			; 00000066H
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_1OO@HAKMEMBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000aa	83 c4 14	 add	 esp, 20			; 00000014H
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ba	83 c1 04	 add	 ecx, 4
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 114  : 		}

  000c6	5e		 pop	 esi
  000c7	83 c4 04	 add	 esp, 4
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAVEntityComponent@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 2f		 je	 SHORT $LN3@operator
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00022	74 26		 je	 SHORT $LN3@operator
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00032	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00035	72 13		 jb	 SHORT $LN3@operator
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00045	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00048	77 7d		 ja	 SHORT $LN2@operator
$LN3@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

  0004a	8b f4		 mov	 esi, esp
  0004c	6a 48		 push	 72			; 00000048H
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

  00068	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  0006d	85 c0		 test	 eax, eax
  0006f	74 04		 je	 SHORT $LN5@operator
  00071	33 c9		 xor	 ecx, ecx
  00073	75 2d		 jne	 SHORT $LN6@operator
$LN5@operator:
  00075	8b f4		 mov	 esi, esp
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00081	6a 00		 push	 0
  00083	6a 49		 push	 73			; 00000049H
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008a	6a 02		 push	 2
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00092	83 c4 18	 add	 esp, 24			; 00000018H
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	75 01		 jne	 SHORT $LN6@operator
  000a1	cc		 int	 3
$LN6@operator:
  000a2	8b f4		 mov	 esi, esp
  000a4	6a 00		 push	 0
  000a6	6a 49		 push	 73			; 00000049H
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1OM@HKICCNDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000bd	83 c4 14	 add	 esp, 20			; 00000014H
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 87   : 		}

  000cd	5e		 pop	 esi
  000ce	83 c4 04	 add	 esp, 4
  000d1	3b ec		 cmp	 ebp, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAVEntityComponent@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 306  : 		: _Mybase(_Parg, _Pvector)

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >

; 308  : 		}

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend, COMDAT
; _this$ = ecx

; 661  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 663  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast, COMDAT
; _this$ = ecx

; 656  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 657  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 658  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast, COMDAT
; _this$ = ecx

; 651  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 653  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 646  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 648  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 641  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 643  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data, COMDAT
; _this$ = ecx

; 631  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second

; 633  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal, COMDAT
; _this$ = ecx

; 621  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first

; 623  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::~_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 551  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 552  : 		_Free_proxy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Free_proxy

; 553  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::~_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 546  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ; std::move<std::allocator<EntityComponent *> &>
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  00047	51		 push	 ecx
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0V?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> >
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 547  : 		_Alloc_proxy();

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Alloc_proxy

; 548  : 		}

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	83 c4 14	 add	 esp, 20			; 00000014H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 540  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> const &>
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 541  : 		_Alloc_proxy();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Alloc_proxy

; 542  : 		}

  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	83 c4 14	 add	 esp, 20			; 00000014H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 306  : 		: _Mybase(_Parg, _Pvector)

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >

; 308  : 		}

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend, COMDAT
; _this$ = ecx

; 661  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 663  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast, COMDAT
; _this$ = ecx

; 656  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 657  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 658  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast, COMDAT
; _this$ = ecx

; 651  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 653  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 646  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 648  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 641  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 643  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data, COMDAT
; _this$ = ecx

; 631  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second

; 633  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal, COMDAT
; _this$ = ecx

; 621  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first

; 623  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::~_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >, COMDAT
; _this$ = ecx

; 551  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 552  : 		_Free_proxy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Free_proxy

; 553  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::~_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >, COMDAT
; _this$ = ecx

; 546  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ; std::move<std::allocator<Entity *> &>
  0003f	83 c4 04	 add	 esp, 4
  00042	50		 push	 eax
  00043	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  00047	51		 push	 ecx
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0V?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntity@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> >
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 547  : 		_Alloc_proxy();

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Alloc_proxy

; 548  : 		}

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	83 c4 14	 add	 esp, 20			; 00000014H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@$$QAV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >, COMDAT
; _this$ = ecx

; 540  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> const &>
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 541  : 		_Alloc_proxy();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Alloc_proxy

; 542  : 		}

  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	83 c4 14	 add	 esp, 20			; 00000014H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z
_TEXT	SEGMENT
__Pnext$ = -32						; size = 4
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1795 : 		_Lockit _Lock(_LOCK_DEBUG);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 03		 push	 3
  00041	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1796 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getpfirst
  00060	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1797 : 		if (_Pnext != 0)

  00063	83 7d e0 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  00067	74 4e		 je	 SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1798 : 			{	// test an iterator
; 1799 : 			while (*_Pnext != 0)

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0006c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006f	74 46		 je	 SHORT $LN4@Orphan_ran

; 1800 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

  00071	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00079	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0007c	72 0d		 jb	 SHORT $LN7@Orphan_ran
  0007e	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00086	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00089	73 0f		 jae	 SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1801 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

  0008b	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0008e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00090	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  00095	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1802 : 				else

  00098	eb 1b		 jmp	 SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1803 : 					{	// orphan the iterator
; 1804 : 					(*_Pnext)->_Clrcont();

  0009a	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0009d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009f	e8 00 00 00 00	 call	 ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont

; 1805 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000a4	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  000ae	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000b1	8b 10		 mov	 edx, DWORD PTR [eax]
  000b3	89 11		 mov	 DWORD PTR [ecx], edx
$LN6@Orphan_ran:

; 1806 : 					}

  000b5	eb b2		 jmp	 SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1807 : 			}
; 1808 : 		}

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8b f4		 mov	 esi, esp
  000c0	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	52		 push	 edx
  000d1	8b cd		 mov	 ecx, ebp
  000d3	50		 push	 eax
  000d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Orphan_ran
  000da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000df	58		 pop	 eax
  000e0	5a		 pop	 edx
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5e		 pop	 esi
  000ed	83 c4 20	 add	 esp, 32			; 00000020H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
  000fd	0f 1f 00	 npad	 3
$LN13@Orphan_ran:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN12@Orphan_ran
$LN12@Orphan_ran:
  00108	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0010c	04 00 00 00	 DD	 4
  00110	00 00 00 00	 DD	 $LN10@Orphan_ran
$LN10@Orphan_ran:
  00114	5f		 DB	 95			; 0000005fH
  00115	4c		 DB	 76			; 0000004cH
  00116	6f		 DB	 111			; 0000006fH
  00117	63		 DB	 99			; 00000063H
  00118	6b		 DB	 107			; 0000006bH
  00119	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	0f 84 84 00 00
	00		 je	 $LN1@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all

; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	51		 push	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  0004e	8b f0		 mov	 esi, eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	2b 10		 sub	 edx, DWORD PTR [eax]
  0005c	c1 fa 02	 sar	 edx, 2
  0005f	52		 push	 edx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00082	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1663 : 			this->_Mylast() = pointer();

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00090	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1664 : 			this->_Myend() = pointer();

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1665 : 			}
; 1666 : 		}

  000a4	5e		 pop	 esi
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1646 : 		if (_Unused_capacity() < _Count)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unused_capacity
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0001a	73 3e		 jae	 SHORT $LN4@Reserve

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
  00024	8b f0		 mov	 esi, eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  0002e	2b f0		 sub	 esi, eax
  00030	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00033	73 08		 jae	 SHORT $LN3@Reserve

; 1649 : 				_Xlen();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Xlen
$LN3@Reserve:

; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00045	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Grow_to
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Reallocate
$LN4@Reserve:

; 1651 : 			}
; 1652 : 		}

  0005a	5e		 pop	 esi
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?_Reserve@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBE_NPBQAVEntity@@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBE_NPBQAVEntity@@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00024	73 18		 jae	 SHORT $LN3@Inside
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	3b 55 08	 cmp	 edx, DWORD PTR __Ptr$[ebp]
  00033	77 09		 ja	 SHORT $LN3@Inside
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Inside:
  00045	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]

; 1617 : 		}

  00048	83 c4 08	 add	 esp, 8
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Inside@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBE_NPBQAVEntity@@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Assign_rv, COMDAT
; _this$ = ecx

; 867  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 868  : 		this->_Swap_all((_Myt&)_Right);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Swap_all

; 869  : 		this->_Myfirst() = _Right._Myfirst();

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0002d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002f	89 08		 mov	 DWORD PTR [eax], ecx

; 870  : 		this->_Mylast() = _Right._Mylast();

  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00039	8b f0		 mov	 esi, eax
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00043	8b 16		 mov	 edx, DWORD PTR [esi]
  00045	89 10		 mov	 DWORD PTR [eax], edx

; 871  : 		this->_Myend() = _Right._Myend();

  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  0004f	8b f0		 mov	 esi, eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005b	89 08		 mov	 DWORD PTR [eax], ecx

; 872  : 
; 873  : 		_Right._Myfirst() = pointer();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 874  : 		_Right._Mylast() = pointer();

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00073	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 875  : 		_Right._Myend() = pointer();

  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 876  : 		}

  00087	5e		 pop	 esi
  00088	83 c4 04	 add	 esp, 4
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?_Assign_rv@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEntity@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVEntity@@@std@@QAE@XZ PROC		; std::allocator<Entity *>::allocator<Entity *>, COMDAT
; _this$ = ecx

; 617  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@PAVEntity@@@std@@QAE@XZ ENDP		; std::allocator<Entity *>::allocator<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z
_TEXT	SEGMENT
__Pnext$ = -32						; size = 4
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1795 : 		_Lockit _Lock(_LOCK_DEBUG);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 03		 push	 3
  00041	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1796 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getpfirst
  00060	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1797 : 		if (_Pnext != 0)

  00063	83 7d e0 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  00067	74 4e		 je	 SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1798 : 			{	// test an iterator
; 1799 : 			while (*_Pnext != 0)

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0006c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006f	74 46		 je	 SHORT $LN4@Orphan_ran

; 1800 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

  00071	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00079	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0007c	72 0d		 jb	 SHORT $LN7@Orphan_ran
  0007e	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00086	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00089	73 0f		 jae	 SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1801 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

  0008b	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0008e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00090	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  00095	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1802 : 				else

  00098	eb 1b		 jmp	 SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1803 : 					{	// orphan the iterator
; 1804 : 					(*_Pnext)->_Clrcont();

  0009a	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0009d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009f	e8 00 00 00 00	 call	 ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont

; 1805 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000a4	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  000ae	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000b1	8b 10		 mov	 edx, DWORD PTR [eax]
  000b3	89 11		 mov	 DWORD PTR [ecx], edx
$LN6@Orphan_ran:

; 1806 : 					}

  000b5	eb b2		 jmp	 SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1807 : 			}
; 1808 : 		}

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8b f4		 mov	 esi, esp
  000c0	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	52		 push	 edx
  000d1	8b cd		 mov	 ecx, ebp
  000d3	50		 push	 eax
  000d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Orphan_ran
  000da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000df	58		 pop	 eax
  000e0	5a		 pop	 edx
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5e		 pop	 esi
  000ed	83 c4 20	 add	 esp, 32			; 00000020H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
  000fd	0f 1f 00	 npad	 3
$LN13@Orphan_ran:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN12@Orphan_ran
$LN12@Orphan_ran:
  00108	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0010c	04 00 00 00	 DD	 4
  00110	00 00 00 00	 DD	 $LN10@Orphan_ran
$LN10@Orphan_ran:
  00114	5f		 DB	 95			; 0000005fH
  00115	4c		 DB	 76			; 0000004cH
  00116	6f		 DB	 111			; 0000006fH
  00117	63		 DB	 99			; 00000063H
  00118	6b		 DB	 107			; 0000006bH
  00119	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXPAPAVEntityComponent@@0@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xran@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xran, COMDAT
; _this$ = ecx

; 1788 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		_Xout_of_range("invalid vector<T> subscript");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xran:

; 1790 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xran@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	0f 84 84 00 00
	00		 je	 $LN1@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all

; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	51		 push	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  0004e	8b f0		 mov	 esi, eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	2b 10		 sub	 edx, DWORD PTR [eax]
  0005c	c1 fa 02	 sar	 edx, 2
  0005f	52		 push	 edx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00082	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1663 : 			this->_Mylast() = pointer();

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00090	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1664 : 			this->_Myend() = pointer();

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1665 : 			}
; 1666 : 		}

  000a4	5e		 pop	 esi
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?_Tidy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1646 : 		if (_Unused_capacity() < _Count)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Unused_capacity
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0001a	73 3e		 jae	 SHORT $LN4@Reserve

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::max_size
  00024	8b f0		 mov	 esi, eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  0002e	2b f0		 sub	 esi, eax
  00030	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00033	73 08		 jae	 SHORT $LN3@Reserve

; 1649 : 				_Xlen();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xlen
$LN3@Reserve:

; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  00045	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEII@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Grow_to
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reallocate
$LN4@Reserve:

; 1651 : 			}
; 1652 : 		}

  0005a	5e		 pop	 esi
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?_Reserve@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBE_NPBQAVEntityComponent@@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBE_NPBQAVEntityComponent@@@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00024	73 18		 jae	 SHORT $LN3@Inside
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	3b 55 08	 cmp	 edx, DWORD PTR __Ptr$[ebp]
  00033	77 09		 ja	 SHORT $LN3@Inside
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Inside:
  00045	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]

; 1617 : 		}

  00048	83 c4 08	 add	 esp, 8
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Inside@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBE_NPBQAVEntityComponent@@@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Assign_rv, COMDAT
; _this$ = ecx

; 867  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 868  : 		this->_Swap_all((_Myt&)_Right);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Swap_all

; 869  : 		this->_Myfirst() = _Right._Myfirst();

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0002d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002f	89 08		 mov	 DWORD PTR [eax], ecx

; 870  : 		this->_Mylast() = _Right._Mylast();

  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00039	8b f0		 mov	 esi, eax
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00043	8b 16		 mov	 edx, DWORD PTR [esi]
  00045	89 10		 mov	 DWORD PTR [eax], edx

; 871  : 		this->_Myend() = _Right._Myend();

  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  0004f	8b f0		 mov	 esi, eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005b	89 08		 mov	 DWORD PTR [eax], ecx

; 872  : 
; 873  : 		_Right._Myfirst() = pointer();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 874  : 		_Right._Mylast() = pointer();

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00073	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 875  : 		_Right._Myend() = pointer();

  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 876  : 		}

  00087	5e		 pop	 esi
  00088	83 c4 04	 add	 esp, 4
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?_Assign_rv@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEntityComponent@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVEntityComponent@@@std@@QAE@XZ PROC	; std::allocator<EntityComponent *>::allocator<EntityComponent *>, COMDAT
; _this$ = ecx

; 617  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@PAVEntityComponent@@@std@@QAE@XZ ENDP	; std::allocator<EntityComponent *>::allocator<EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend, COMDAT
; _this$ = ecx

; 661  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 663  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 656  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 657  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 658  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 651  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 652  : 		return (_Get_data()._Mylast);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	83 c0 08	 add	 eax, 8

; 653  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 646  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 648  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 641  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Get_data()._Myfirst);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 643  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 631  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second

; 633  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 621  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first

; 623  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 551  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 552  : 		_Free_proxy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy

; 553  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  00017	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001a	0f 84 8b 00 00
	00		 je	 $LN1@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all

; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	51		 push	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
  0004e	8b f0		 mov	 esi, eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	2b 10		 sub	 edx, DWORD PTR [eax]
  0005c	8b c2		 mov	 eax, edx
  0005e	99		 cdq
  0005f	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00064	f7 f9		 idiv	 ecx
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	52		 push	 edx
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  0007a	8b c8		 mov	 ecx, eax
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myfirst
  00089	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1663 : 			this->_Mylast() = pointer();

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Mylast
  00097	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1664 : 			this->_Myend() = pointer();

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myend
  000a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1665 : 			}
; 1666 : 		}

  000ab	5e		 pop	 esi
  000ac	83 c4 04	 add	 esp, 4
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??A?$Matrix@M$03@@QAEPAMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Matrix@M$03@@QAEPAMH@Z PROC			; Matrix<float,4>::operator[], COMDAT
; _this$ = ecx

; 561  : 	inline T* operator[](int index) { return m[index]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00011	c1 e0 04	 shl	 eax, 4
  00014	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$Matrix@M$03@@QAEPAMH@Z ENDP			; Matrix<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Vector@M$03@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Vector@M$03@@QAE@XZ PROC				; Vector<float,4>::Vector<float,4>, COMDAT
; _this$ = ecx

; 53   : 	Vector() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$Vector@M$03@@QAE@XZ ENDP				; Vector<float,4>::Vector<float,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Vector@M$02@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Vector@M$02@@QAE@XZ PROC				; Vector<float,3>::Vector<float,3>, COMDAT
; _this$ = ecx

; 53   : 	Vector() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$Vector@M$02@@QAE@XZ ENDP				; Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??0?$Vector3@M@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
??0?$Vector3@M@@QAE@MMM@Z PROC				; Vector3<float>::Vector3<float>, COMDAT
; _this$ = ecx

; 238  : 	Vector3(T x, T y, T z)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	{

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$Vector@M$02@@QAE@XZ ; Vector<float,3>::Vector<float,3>

; 240  : 		(*this)[0] = x;

  00016	6a 00		 push	 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00020	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00025	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 241  : 		(*this)[1] = y;

  00029	6a 01		 push	 1
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00038	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 242  : 		(*this)[2] = z;

  0003c	6a 02		 push	 2
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QAEAAMI@Z ; Vector<float,3>::operator[]
  00046	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0004b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 243  : 	}

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
??0?$Vector3@M@@QAE@MMM@Z ENDP				; Vector3<float>::Vector3<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 716  : 		{	// return const reference to _Mysize

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  : 		return (_Get_data()._Mysize);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	83 c0 14	 add	 eax, 20			; 00000014H

; 718  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 711  : 		{	// return reference to _Mysize

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 712  : 		return (_Get_data()._Mysize);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	83 c0 14	 add	 eax, 20			; 00000014H

; 713  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 684  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 685  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 686  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 679  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 680  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 681  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 609  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 610  : 		_Free_proxy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 611  : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 598  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)

  00036	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00039	50		 push	 eax
  0003a	0f b6 4d ef	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 599  : 		_Alloc_proxy();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 600  : 		}

  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	83 c4 14	 add	 esp, 20			; 00000014H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 565  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		return (_Get_data()._Myptr());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 567  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 560  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 561  : 		return (_Get_data()._Myptr());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 562  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2251 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2252 : 		_Xout_of_range("invalid string position");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xran:

; 2253 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -8						; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2230 : 		if (!_Built)

  00017	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  0001b	85 c0		 test	 eax, eax
  0001d	75 02		 jne	 SHORT $LN2@Tidy
  0001f	eb 7b		 jmp	 SHORT $LN3@Tidy
$LN2@Tidy:

; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00029	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  0002c	72 6e		 jb	 SHORT $LN3@Tidy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 4d f8	 mov	 DWORD PTR __Ptr$1[ebp], ecx

; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2236 : 			if (0 < _Newsize)

  00053	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  00057	76 22		 jbe	 SHORT $LN5@Tidy

; 2237 : 				_Traits::copy(this->_Bx()._Buf,

  00059	8b 55 0c	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$1[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  00066	83 c4 04	 add	 esp, 4
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Tidy:

; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	83 c1 01	 add	 ecx, 1
  00088	51		 push	 ecx
  00089	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$1[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000a4	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 2242 : 		_Eos(_Newsize);

  000aa	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2243 : 		}

  000b6	83 c4 08	 add	 esp, 8
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
tv141 = -28						; size = 4
tv142 = -24						; size = 4
tv143 = -20						; size = 4
tv95 = -16						; size = 4
tv68 = -9						; size = 1
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);

  00023	83 7d 14 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00027	74 06		 je	 SHORT $LN5@compare
  00029	c6 45 f7 01	 mov	 BYTE PTR tv68[ebp], 1
  0002d	eb 04		 jmp	 SHORT $LN6@compare
$LN5@compare:
  0002f	c6 45 f7 00	 mov	 BYTE PTR tv68[ebp], 0
$LN6@compare:
  00033	68 5a 08 00 00	 push	 2138			; 0000085aH
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0003d	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00040	50		 push	 eax
  00041	0f b6 4d f7	 movzx	 ecx, BYTE PTR tv68[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z ; std::_Debug_pointer_if<char const >
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 2139 : 		if (this->_Mysize() < _Off)

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00056	8b 10		 mov	 edx, DWORD PTR [eax]
  00058	3b 55 08	 cmp	 edx, DWORD PTR __Off$[ebp]
  0005b	73 08		 jae	 SHORT $LN2@compare

; 2140 : 			_Xran();	// _Off off end

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN2@compare:

; 2141 : 		if (this->_Mysize() - _Off < _N0)

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00072	3b 45 0c	 cmp	 eax, DWORD PTR __N0$[ebp]
  00075	73 10		 jae	 SHORT $LN3@compare

; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0007f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00081	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00084	89 4d 0c	 mov	 DWORD PTR __N0$[ebp], ecx
$LN3@compare:

; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,

  00087	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0008a	3b 55 14	 cmp	 edx, DWORD PTR __Count$[ebp]
  0008d	73 08		 jae	 SHORT $LN7@compare
  0008f	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  00092	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  00095	eb 06		 jmp	 SHORT $LN8@compare
$LN7@compare:
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009a	89 4d f0	 mov	 DWORD PTR tv95[ebp], ecx
$LN8@compare:
  0009d	8b 55 f0	 mov	 edx, DWORD PTR tv95[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  000ad	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	89 45 f8	 mov	 DWORD PTR __Ans$[ebp], eax

; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1

  000bc	83 7d f8 00	 cmp	 DWORD PTR __Ans$[ebp], 0
  000c0	74 08		 je	 SHORT $LN13@compare
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR __Ans$[ebp]
  000c5	89 4d ec	 mov	 DWORD PTR tv143[ebp], ecx
  000c8	eb 35		 jmp	 SHORT $LN14@compare
$LN13@compare:
  000ca	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  000cd	3b 55 14	 cmp	 edx, DWORD PTR __Count$[ebp]
  000d0	73 09		 jae	 SHORT $LN11@compare
  000d2	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR tv142[ebp], -1
  000d9	eb 1e		 jmp	 SHORT $LN12@compare
$LN11@compare:
  000db	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  000de	3b 45 14	 cmp	 eax, DWORD PTR __Count$[ebp]
  000e1	75 09		 jne	 SHORT $LN9@compare
  000e3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  000ea	eb 07		 jmp	 SHORT $LN10@compare
$LN9@compare:
  000ec	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
$LN10@compare:
  000f3	8b 4d e4	 mov	 ecx, DWORD PTR tv141[ebp]
  000f6	89 4d e8	 mov	 DWORD PTR tv142[ebp], ecx
$LN12@compare:
  000f9	8b 55 e8	 mov	 edx, DWORD PTR tv142[ebp]
  000fc	89 55 ec	 mov	 DWORD PTR tv143[ebp], edx
$LN14@compare:
  000ff	8b 45 ec	 mov	 eax, DWORD PTR tv143[ebp]
$LN4@compare:

; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}

  00102	83 c4 1c	 add	 esp, 28			; 0000001cH
  00105	3b ec		 cmp	 ebp, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 10 00	 ret	 16			; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1174 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1175 : 		_DEBUG_POINTER(_Ptr);

  0000e	68 97 04 00 00	 push	 1175			; 00000497H
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00018	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char const >
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  0002d	83 c4 04	 add	 esp, 4
  00030	50		 push	 eax
  00031	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1177 : 		}

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);

  00017	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	74 06		 je	 SHORT $LN5@assign
  0001d	c6 45 fb 01	 mov	 BYTE PTR tv68[ebp], 1
  00021	eb 04		 jmp	 SHORT $LN6@assign
$LN5@assign:
  00023	c6 45 fb 00	 mov	 BYTE PTR tv68[ebp], 0
$LN6@assign:
  00027	68 88 04 00 00	 push	 1160			; 00000488H
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	50		 push	 eax
  00035	0f b6 4d fb	 movzx	 ecx, BYTE PTR tv68[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z ; std::_Debug_pointer_if<char const >
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 1161 : 		if (_Inside(_Ptr))

  00042	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00045	52		 push	 edx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  0004e	0f b6 c0	 movzx	 eax, al
  00051	85 c0		 test	 eax, eax
  00053	74 20		 je	 SHORT $LN2@assign

; 1162 : 			return (assign(*this,

  00055	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00058	51		 push	 ecx
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00064	2b d0		 sub	 edx, eax
  00066	52		 push	 edx
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00073	eb 3d		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))

  00075	6a 00		 push	 0
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00083	0f b6 d0	 movzx	 edx, al
  00086	85 d2		 test	 edx, edx
  00088	74 25		 je	 SHORT $LN3@assign

; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0008a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00091	51		 push	 ecx
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1168 : 			_Eos(_Count);

  000a3	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000a6	52		 push	 edx
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@assign:

; 1169 : 			}
; 1170 : 		return (*this);

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@assign:

; 1171 : 		}

  000b2	83 c4 08	 add	 esp, 8
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1141 : 		if (_Right.size() < _Roff)

  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001a	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0001f	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00022	73 08		 jae	 SHORT $LN2@assign

; 1142 : 			_Xran();	// _Roff off end

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN2@assign:

; 1143 : 		size_type _Num = _Right.size() - _Roff;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002f	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00034	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1144 : 		if (_Count < _Num)

  0003a	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0003d	3b 45 f8	 cmp	 eax, DWORD PTR __Num$[ebp]
  00040	73 06		 jae	 SHORT $LN3@assign

; 1145 : 			_Num = _Count;	// trim _Num to size

  00042	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00045	89 4d f8	 mov	 DWORD PTR __Num$[ebp], ecx
$LN3@assign:

; 1146 : 
; 1147 : 		if (this == &_Right)

  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	3b 55 08	 cmp	 edx, DWORD PTR __Right$[ebp]
  0004e	75 1f		 jne	 SHORT $LN4@assign

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00050	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  00053	03 45 f8	 add	 eax, DWORD PTR __Num$[ebp]
  00056	50		 push	 eax
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00062	51		 push	 ecx
  00063	6a 00		 push	 0
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0006d	eb 42		 jmp	 SHORT $LN5@assign
$LN4@assign:

; 1149 : 		else if (_Grow(_Num))

  0006f	6a 00		 push	 0
  00071	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  00074	52		 push	 edx
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	74 2d		 je	 SHORT $LN5@assign

; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),

  00084	8b 4d f8	 mov	 ecx, DWORD PTR __Num$[ebp]
  00087	51		 push	 ecx
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00090	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00093	50		 push	 eax
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);

  000a5	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  000a8	52		 push	 edx
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN5@assign:

; 1154 : 			}
; 1155 : 		return (*this);

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1156 : 		}

  000b4	83 c4 08	 add	 esp, 8
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	6a 01		 push	 1
  00010	6a 01		 push	 1
  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 01		 push	 1
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 621  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 617  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::~_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::~_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::~_Vector_val<std::_Simple_types<EntityComponent *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::~_Vector_val<std::_Simple_types<EntityComponent *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Entity *> >::~_Vector_val<std::_Simple_types<Entity *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Entity *> >::~_Vector_val<std::_Simple_types<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z PROC ; std::_Func_class<void,RigidBody *>::_Set, COMDAT
; _this$ = ecx

; 428  : 		{	// store pointer to object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 		_Mystorage._Ptrs[_Num_ptrs - 1] = _Ptr;

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	6b c8 09	 imul	 ecx, eax, 9
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 430  : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z ENDP ; std::_Func_class<void,RigidBody *>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ
_TEXT	SEGMENT
tv71 = -24						; size = 4
tv78 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ PROC	; std::_Func_class<void,RigidBody *>::_Tidy, COMDAT
; _this$ = ecx

; 372  : 		{	// clean up

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001c	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00023	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 373  : 		if (!_Empty())

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ ; std::_Func_class<void,RigidBody *>::_Empty
  00046	0f b6 c0	 movzx	 eax, al
  00049	85 c0		 test	 eax, eax
  0004b	75 49		 jne	 SHORT $LN3@Tidy

; 374  : 			{	// destroy callable object and maybe delete it
; 375  : 			_Getimpl()->_Delete_this(!_Local());

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Local@?$_Func_class@XPAVRigidBody@@@std@@ABE_NXZ ; std::_Func_class<void,RigidBody *>::_Local
  00055	0f b6 c8	 movzx	 ecx, al
  00058	85 c9		 test	 ecx, ecx
  0005a	75 06		 jne	 SHORT $LN4@Tidy
  0005c	c6 45 ef 01	 mov	 BYTE PTR tv78[ebp], 1
  00060	eb 04		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  00062	c6 45 ef 00	 mov	 BYTE PTR tv78[ebp], 0
$LN5@Tidy:
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ; std::_Func_class<void,RigidBody *>::_Getimpl
  0006e	89 45 e8	 mov	 DWORD PTR tv71[ebp], eax
  00071	8b f4		 mov	 esi, esp
  00073	0f b6 55 ef	 movzx	 edx, BYTE PTR tv78[ebp]
  00077	52		 push	 edx
  00078	8b 45 e8	 mov	 eax, DWORD PTR tv71[ebp]
  0007b	8b 10		 mov	 edx, DWORD PTR [eax]
  0007d	8b 4d e8	 mov	 ecx, DWORD PTR tv71[ebp]
  00080	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00083	ff d0		 call	 eax
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 376  : 			_Set(0);

  0008c	6a 00		 push	 0
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Set@?$_Func_class@XPAVRigidBody@@@std@@AAEXPAV?$_Func_base@XPAVRigidBody@@@2@@Z ; std::_Func_class<void,RigidBody *>::_Set
$LN3@Tidy:

; 377  : 			}
; 378  : 		}

  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5e		 pop	 esi
  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$_Func_class@XPAVRigidBody@@@std@@IAEXXZ ENDP	; std::_Func_class<void,RigidBody *>::_Tidy
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 315  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 295  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Compat, COMDAT
; _this$ = ecx

; 237  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 		if (this->_Getcont() == 0
; 239  : 			|| this->_Getcont() != _Right._Getcont())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 1a		 je	 SHORT $LN3@Compat
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002d	3b f0		 cmp	 esi, eax
  0002f	0f 84 86 00 00
	00		 je	 $LN1@Compat
$LN3@Compat:

; 240  : 			{	// report error
; 241  : 			_DEBUG_ERROR("vector iterators incompatible");

  00035	8b f4		 mov	 esi, esp
  00037	68 f1 00 00 00	 push	 241			; 000000f1H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 242  : 			_SCL_SECURE_INVALID_ARGUMENT;

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
  0005b	85 c0		 test	 eax, eax
  0005d	74 04		 je	 SHORT $LN5@Compat
  0005f	33 c9		 xor	 ecx, ecx
  00061	75 30		 jne	 SHORT $LN6@Compat
$LN5@Compat:
  00063	8b f4		 mov	 esi, esp
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0006f	6a 00		 push	 0
  00071	68 f2 00 00 00	 push	 242			; 000000f2H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0007b	6a 02		 push	 2
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	83 f8 01	 cmp	 eax, 1
  00090	75 01		 jne	 SHORT $LN6@Compat
  00092	cc		 int	 3
$LN6@Compat:
  00093	8b f4		 mov	 esi, esp
  00095	6a 00		 push	 0
  00097	68 f2 00 00 00	 push	 242			; 000000f2H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1BAI@MFPHLFHP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Compat:

; 243  : 			}
; 244  : 		}

  000bb	5e		 pop	 esi
  000bc	83 c4 04	 add	 esp, 4
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00042	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

  00045	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00048	52		 push	 edx
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVRigidBody@@H@1@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ; std::allocator<std::pair<RigidBody *,int> >::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 611  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		_Get_data()._Orphan_all();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 613  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Free_proxy, COMDAT
; _this$ = ecx

; 585  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
  00022	50		 push	 eax
  00023	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >

; 588  : 		_Orphan_all();

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Orphan_all

; 589  : 		_Alproxy.destroy(_Myproxy());

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);

  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 591  : 		_Myproxy() = 0;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 592  : 		}

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@Free_proxy:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00090	f7 ff ff ff	 DD	 -9			; fffffff7H
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	41		 DB	 65			; 00000041H
  0009e	6c		 DB	 108			; 0000006cH
  0009f	70		 DB	 112			; 00000070H
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	78		 DB	 120			; 00000078H
  000a3	79		 DB	 121			; 00000079H
  000a4	00		 DB	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 576  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
  00029	50		 push	 eax
  0002a	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >

; 579  : 		_Myproxy() = _Alproxy.allocate(1);

  00032	6a 01		 push	 1
  00034	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00037	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003c	8b f0		 mov	 esi, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  00046	89 30		 mov	 DWORD PTR [eax], esi

; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00048	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 581  : 		_Myproxy()->_Mycont = &_Get_data();

  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data
  0006c	8b f0		 mov	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 31		 mov	 DWORD PTR [ecx], esi

; 582  : 		}

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	5e		 pop	 esi
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN5@Alloc_prox:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000a4	f7 ff ff ff	 DD	 -9			; fffffff7H
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000b0	5f		 DB	 95			; 0000005fH
  000b1	41		 DB	 65			; 00000041H
  000b2	6c		 DB	 108			; 0000006cH
  000b3	70		 DB	 112			; 00000070H
  000b4	72		 DB	 114			; 00000072H
  000b5	6f		 DB	 111			; 0000006fH
  000b6	78		 DB	 120			; 00000078H
  000b7	79		 DB	 121			; 00000079H
  000b8	00		 DB	 0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXPAU?$pair@PAVRigidBody@@H@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXPAU?$pair@PAVRigidBody@@H@2@0@Z PROC ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1601 : 		}

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@IAEXPAU?$pair@PAVRigidBody@@H@2@0@Z ENDP ; std::vector<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 315  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 295  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Compat, COMDAT
; _this$ = ecx

; 237  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 		if (this->_Getcont() == 0
; 239  : 			|| this->_Getcont() != _Right._Getcont())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 1a		 je	 SHORT $LN3@Compat
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002d	3b f0		 cmp	 esi, eax
  0002f	0f 84 86 00 00
	00		 je	 $LN1@Compat
$LN3@Compat:

; 240  : 			{	// report error
; 241  : 			_DEBUG_ERROR("vector iterators incompatible");

  00035	8b f4		 mov	 esi, esp
  00037	68 f1 00 00 00	 push	 241			; 000000f1H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 242  : 			_SCL_SECURE_INVALID_ARGUMENT;

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
  0005b	85 c0		 test	 eax, eax
  0005d	74 04		 je	 SHORT $LN5@Compat
  0005f	33 c9		 xor	 ecx, ecx
  00061	75 30		 jne	 SHORT $LN6@Compat
$LN5@Compat:
  00063	8b f4		 mov	 esi, esp
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0006f	6a 00		 push	 0
  00071	68 f2 00 00 00	 push	 242			; 000000f2H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0007b	6a 02		 push	 2
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	83 f8 01	 cmp	 eax, 1
  00090	75 01		 jne	 SHORT $LN6@Compat
  00092	cc		 int	 3
$LN6@Compat:
  00093	8b f4		 mov	 esi, esp
  00095	6a 00		 push	 0
  00097	68 f2 00 00 00	 push	 242			; 000000f2H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1OG@NINHJLHM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Compat:

; 243  : 			}
; 244  : 		}

  000bb	5e		 pop	 esi
  000bc	83 c4 04	 add	 esp, 4
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00042	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

  00045	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00048	52		 push	 edx
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@@std@@QAE@PAPAVEntityComponent@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<EntityComponent *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::allocator<EntityComponent *>::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data, COMDAT
; _this$ = ecx

; 636  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second

; 638  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Swap_all, COMDAT
; _this$ = ecx

; 616  : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all

; 618  : 		}

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 611  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		_Get_data()._Orphan_all();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 613  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 595  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 596  : 		return (_Get_data()._Getpfirst());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 597  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 585  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00022	50		 push	 eax
  00023	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<EntityComponent *> > >

; 588  : 		_Orphan_all();

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all

; 589  : 		_Alproxy.destroy(_Myproxy());

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);

  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 591  : 		_Myproxy() = 0;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 592  : 		}

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@Free_proxy:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00090	f7 ff ff ff	 DD	 -9			; fffffff7H
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	41		 DB	 65			; 00000041H
  0009e	6c		 DB	 108			; 0000006cH
  0009f	70		 DB	 112			; 00000070H
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	78		 DB	 120			; 00000078H
  000a3	79		 DB	 121			; 00000079H
  000a4	00		 DB	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 576  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00029	50		 push	 eax
  0002a	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<EntityComponent *> > >

; 579  : 		_Myproxy() = _Alproxy.allocate(1);

  00032	6a 01		 push	 1
  00034	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00037	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003c	8b f0		 mov	 esi, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  00046	89 30		 mov	 DWORD PTR [eax], esi

; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00048	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 581  : 		_Myproxy()->_Mycont = &_Get_data();

  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  0006c	8b f0		 mov	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 31		 mov	 DWORD PTR [ecx], esi

; 582  : 		}

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	5e		 pop	 esi
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN5@Alloc_prox:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000a4	f7 ff ff ff	 DD	 -9			; fffffff7H
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000b0	5f		 DB	 95			; 0000005fH
  000b1	41		 DB	 65			; 00000041H
  000b2	6c		 DB	 108			; 0000006cH
  000b3	70		 DB	 112			; 00000070H
  000b4	72		 DB	 114			; 00000072H
  000b5	6f		 DB	 111			; 0000006fH
  000b6	78		 DB	 120			; 00000078H
  000b7	79		 DB	 121			; 00000079H
  000b8	00		 DB	 0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 315  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 295  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00042	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

  00045	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00048	52		 push	 edx
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data, COMDAT
; _this$ = ecx

; 636  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second

; 638  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Swap_all, COMDAT
; _this$ = ecx

; 616  : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all

; 618  : 		}

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 611  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		_Get_data()._Orphan_all();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 613  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 595  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 596  : 		return (_Get_data()._Getpfirst());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 597  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 585  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00022	50		 push	 eax
  00023	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Entity *> > >

; 588  : 		_Orphan_all();

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all

; 589  : 		_Alproxy.destroy(_Myproxy());

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);

  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 591  : 		_Myproxy() = 0;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 592  : 		}

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@Free_proxy:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00090	f7 ff ff ff	 DD	 -9			; fffffff7H
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	41		 DB	 65			; 00000041H
  0009e	6c		 DB	 108			; 0000006cH
  0009f	70		 DB	 112			; 00000070H
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	78		 DB	 120			; 00000078H
  000a3	79		 DB	 121			; 00000079H
  000a4	00		 DB	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 576  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00029	50		 push	 eax
  0002a	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Entity *> > >

; 579  : 		_Myproxy() = _Alproxy.allocate(1);

  00032	6a 01		 push	 1
  00034	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00037	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003c	8b f0		 mov	 esi, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  00046	89 30		 mov	 DWORD PTR [eax], esi

; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00048	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 581  : 		_Myproxy()->_Mycont = &_Get_data();

  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  0006c	8b f0		 mov	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 31		 mov	 DWORD PTR [ecx], esi

; 582  : 		}

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	5e		 pop	 esi
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN5@Alloc_prox:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000a4	f7 ff ff ff	 DD	 -9			; fffffff7H
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000b0	5f		 DB	 95			; 0000005fH
  000b1	41		 DB	 65			; 00000041H
  000b2	6c		 DB	 108			; 0000006cH
  000b3	70		 DB	 112			; 00000070H
  000b4	72		 DB	 114			; 00000072H
  000b5	6f		 DB	 111			; 0000006fH
  000b6	78		 DB	 120			; 00000078H
  000b7	79		 DB	 121			; 00000079H
  000b8	00		 DB	 0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Xlen, COMDAT
; _this$ = ecx

; 1783 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 1785 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	c7 45 e4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-28], -858993460 ; ccccccccH
  0001f	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00026	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00044	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00047	50		 push	 eax
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::allocate
  00057	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00061	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0006d	8b 10		 mov	 edx, DWORD PTR [eax]
  0006f	52		 push	 edx
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>
  00083	eb 26		 jmp	 SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$0:

; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);

  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate

; 1627 : 		_RERAISE;

  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1628 : 		_CATCH_END

  000a5	b8 00 00 00 00	 mov	 eax, $LN8@Reallocate
  000aa	c3		 ret	 0
$LN5@Reallocate:
  000ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b2	eb 07		 jmp	 SHORT __tryend$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z$1:

; 1629 : 
; 1630 : 		size_type _Size = size();

  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  000c3	89 45 e4	 mov	 DWORD PTR __Size$[ebp], eax

; 1631 : 		if (this->_Myfirst() != pointer())

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000ce	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d1	74 52		 je	 SHORT $LN3@Reallocate

; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  000d3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  000db	8b 00		 mov	 eax, DWORD PTR [eax]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	51		 push	 ecx
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  000f9	8b f0		 mov	 esi, eax
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	2b 16		 sub	 edx, DWORD PTR [esi]
  00107	c1 fa 02	 sar	 edx, 2
  0010a	52		 push	 edx
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	50		 push	 eax
  00116	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate
$LN3@Reallocate:

; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();

  00125	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all

; 1639 : 		this->_Myend() = _Ptr + _Count;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00130	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00133	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  0013e	89 30		 mov	 DWORD PTR [eax], esi

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  00140	8b 45 e4	 mov	 eax, DWORD PTR __Size$[ebp]
  00143	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00146	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00151	89 30		 mov	 DWORD PTR [eax], esi

; 1641 : 		this->_Myfirst() = _Ptr;

  00153	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0015b	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0015e	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Reallocate:

; 1642 : 		}

  00160	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016a	59		 pop	 ecx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1605 : 		size_type _Capacity = capacity();

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::capacity
  00026	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00034	d1 e9		 shr	 ecx, 1
  00036	2b c1		 sub	 eax, ecx
  00038	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003b	73 09		 jae	 SHORT $LN4@Grow_to
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00044	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00046	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00049	d1 ea		 shr	 edx, 1
  0004b	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00054	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0005a	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0005d	73 06		 jae	 SHORT $LN2@Grow_to

; 1610 : 			_Capacity = _Count;

  0005f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00062	89 55 f8	 mov	 DWORD PTR __Capacity$[ebp], edx
$LN2@Grow_to:

; 1611 : 		return (_Capacity);

  00065	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1612 : 		}

  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1601 : 		}

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::max_size, COMDAT
; _this$ = ecx

; 1183 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1184 : 		return (this->_Getal().max_size());

  00017	0f b6 45 fb	 movzx	 eax, BYTE PTR $T1[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::max_size

; 1185 : 		}

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1046 : 		{	// micro-optimization for capacity() - size()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1048 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xlen, COMDAT
; _this$ = ecx

; 1783 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 1785 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xlen@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEXXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	c7 45 e4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-28], -858993460 ; ccccccccH
  0001f	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00026	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00044	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00047	50		 push	 eax
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::allocate
  00057	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00061	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  0006d	8b 10		 mov	 edx, DWORD PTR [eax]
  0006f	52		 push	 edx
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ??$_Umove@PAPAVEntityComponent@@@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEPAPAVEntityComponent@@PAPAV2@00@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Umove<EntityComponent * *>
  00083	eb 26		 jmp	 SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$0:

; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);

  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate

; 1627 : 		_RERAISE;

  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1628 : 		_CATCH_END

  000a5	b8 00 00 00 00	 mov	 eax, $LN8@Reallocate
  000aa	c3		 ret	 0
$LN5@Reallocate:
  000ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b2	eb 07		 jmp	 SHORT __tryend$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z$1:

; 1629 : 
; 1630 : 		size_type _Size = size();

  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::size
  000c3	89 45 e4	 mov	 DWORD PTR __Size$[ebp], eax

; 1631 : 		if (this->_Myfirst() != pointer())

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000ce	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d1	74 52		 je	 SHORT $LN3@Reallocate

; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  000d3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  000db	8b 00		 mov	 eax, DWORD PTR [eax]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	51		 push	 ecx
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Destroy

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  000f9	8b f0		 mov	 esi, eax
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	2b 16		 sub	 edx, DWORD PTR [esi]
  00107	c1 fa 02	 sar	 edx, 2
  0010a	52		 push	 edx
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	50		 push	 eax
  00116	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@I@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::deallocate
$LN3@Reallocate:

; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();

  00125	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Orphan_all

; 1639 : 		this->_Myend() = _Ptr + _Count;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00130	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00133	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  0013e	89 30		 mov	 DWORD PTR [eax], esi

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  00140	8b 45 e4	 mov	 eax, DWORD PTR __Size$[ebp]
  00143	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00146	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00151	89 30		 mov	 DWORD PTR [eax], esi

; 1641 : 		this->_Myfirst() = _Ptr;

  00153	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  0015b	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0015e	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Reallocate:

; 1642 : 		}

  00160	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016a	59		 pop	 ecx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXI@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEII@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1605 : 		size_type _Capacity = capacity();

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::capacity
  00026	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::max_size
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00034	d1 e9		 shr	 ecx, 1
  00036	2b c1		 sub	 eax, ecx
  00038	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003b	73 09		 jae	 SHORT $LN4@Grow_to
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00044	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00046	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00049	d1 ea		 shr	 edx, 1
  0004b	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00054	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0005a	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0005d	73 06		 jae	 SHORT $LN2@Grow_to

; 1610 : 			_Capacity = _Count;

  0005f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00062	89 55 f8	 mov	 DWORD PTR __Capacity$[ebp], edx
$LN2@Grow_to:

; 1611 : 		return (_Capacity);

  00065	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1612 : 		}

  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IBEII@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1601 : 		}

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEXPAPAVEntityComponent@@0@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::max_size, COMDAT
; _this$ = ecx

; 1183 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1184 : 		return (this->_Getal().max_size());

  00017	0f b6 45 fb	 movzx	 eax, BYTE PTR $T1[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::max_size

; 1185 : 		}

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1046 : 		{	// micro-optimization for capacity() - size()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Mylast
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1048 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Unused_capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 315  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 295  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 636  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second

; 638  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 611  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 612  : 		_Get_data()._Orphan_all();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 613  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy, COMDAT
; _this$ = ecx

; 585  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00022	50		 push	 eax
  00023	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 588  : 		_Orphan_all();

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_all

; 589  : 		_Alproxy.destroy(_Myproxy());

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);

  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 591  : 		_Myproxy() = 0;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 592  : 		}

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@Free_proxy:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00090	f7 ff ff ff	 DD	 -9			; fffffff7H
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	41		 DB	 65			; 00000041H
  0009e	6c		 DB	 108			; 0000006cH
  0009f	70		 DB	 112			; 00000070H
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	78		 DB	 120			; 00000078H
  000a3	79		 DB	 121			; 00000079H
  000a4	00		 DB	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1601 : 		}

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 300  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 293  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 294  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 295  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0001e	72 14		 jb	 SHORT $LN3@Myptr
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00032	eb 09		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}

  00040	83 c4 08	 add	 esp, 8
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 504  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0001e	72 14		 jb	 SHORT $LN3@Myptr
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00032	eb 09		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  00040	83 c4 08	 add	 esp, 8
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 857  : 		{	// construct by copying base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 858  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 721  : 		{	// return reference to _Myres

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 722  : 		return (_Get_data()._Myres);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	83 c0 18	 add	 eax, 24			; 00000018H

; 723  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 701  : 		{	// return reference to _Bx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 702  : 		return (_Get_data()._Bx);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	83 c0 04	 add	 eax, 4

; 703  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 694  : 		{	// return const reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 695  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 696  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 689  : 		{	// return reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 690  : 		return (_Mypair._Get_second());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 691  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 643  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00022	50		 push	 eax
  00023	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > >

; 646  : 		_Orphan_all();

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 647  : 		_Alproxy.destroy(_Myproxy());

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00041	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);

  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 649  : 		_Myproxy() = 0;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 650  : 		}

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Free_proxy
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@Free_proxy:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@Free_proxy
$LN4@Free_proxy:
  00090	f7 ff ff ff	 DD	 -9			; fffffff7H
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN3@Free_proxy
$LN3@Free_proxy:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	41		 DB	 65			; 00000041H
  0009e	6c		 DB	 108			; 0000006cH
  0009f	70		 DB	 112			; 00000070H
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	78		 DB	 120			; 00000078H
  000a3	79		 DB	 121			; 00000079H
  000a4	00		 DB	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
__Alproxy$ = -9						; size = 1
_this$ = -4						; size = 4
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 634  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001e	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00029	50		 push	 eax
  0002a	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > >

; 637  : 		_Myproxy() = _Alproxy.allocate(1);

  00032	6a 01		 push	 1
  00034	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00037	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  0003c	8b f0		 mov	 esi, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00046	89 30		 mov	 DWORD PTR [eax], esi

; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

  00048	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	50		 push	 eax
  0005c	8d 4d f7	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 639  : 		_Myproxy()->_Mycont = &_Get_data();

  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  0006c	8b f0		 mov	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 31		 mov	 DWORD PTR [ecx], esi

; 640  : 		}

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Alloc_prox
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	5e		 pop	 esi
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN5@Alloc_prox:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@Alloc_prox
$LN4@Alloc_prox:
  000a4	f7 ff ff ff	 DD	 -9			; fffffff7H
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN3@Alloc_prox
$LN3@Alloc_prox:
  000b0	5f		 DB	 95			; 0000005fH
  000b1	41		 DB	 65			; 00000041H
  000b2	6c		 DB	 108			; 0000006cH
  000b3	70		 DB	 112			; 00000070H
  000b4	72		 DB	 114			; 00000072H
  000b5	6f		 DB	 111			; 0000006fH
  000b6	78		 DB	 120			; 00000078H
  000b7	79		 DB	 121			; 00000079H
  000b8	00		 DB	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2246 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2247 : 		_Xlength_error("string too long");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 2248 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2219 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0000f	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00013	74 26		 je	 SHORT $LN4@Inside
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0001d	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00020	72 19		 jb	 SHORT $LN4@Inside
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0002a	8b f0		 mov	 esi, eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00034	03 30		 add	 esi, DWORD PTR [eax]
  00036	3b 75 08	 cmp	 esi, DWORD PTR __Ptr$[ebp]
  00039	77 06		 ja	 SHORT $LN2@Inside
$LN4@Inside:

; 2222 : 			return (false);	// don't ask

  0003b	32 c0		 xor	 al, al
  0003d	eb 04		 jmp	 SHORT $LN1@Inside

; 2223 : 		else

  0003f	eb 02		 jmp	 SHORT $LN1@Inside
$LN2@Inside:

; 2224 : 			return (true);

  00041	b0 01		 mov	 al, 1
$LN1@Inside:

; 2225 : 		}

  00043	5e		 pop	 esi
  00044	83 c4 04	 add	 esp, 4
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv140 = -12						; size = 4
tv133 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2206 : 		if (max_size() < _Newsize)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00026	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00029	73 08		 jae	 SHORT $LN2@Grow

; 2207 : 			_Xlen();	// result too long

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Grow:

; 2208 : 		if (this->_Myres() < _Newsize)

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00040	73 19		 jae	 SHORT $LN3@Grow

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00050	52		 push	 edx
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00059	eb 52		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  0005b	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 3a		 je	 SHORT $LN5@Grow
  00063	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  00067	73 34		 jae	 SHORT $LN5@Grow

; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00071	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00074	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00076	73 08		 jae	 SHORT $LN9@Grow
  00078	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0007b	89 55 f8	 mov	 DWORD PTR tv133[ebp], edx
  0007e	eb 0d		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
$LN10@Grow:
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00090	51		 push	 ecx
  00091	6a 01		 push	 1
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0009b	eb 10		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0009d	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000a1	75 0a		 jne	 SHORT $LN4@Grow

; 2214 : 			_Eos(0);	// new size is zero, just null terminate

  000a3	6a 00		 push	 0
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  000ad	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  000b1	76 09		 jbe	 SHORT $LN11@Grow
  000b3	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
  000ba	eb 07		 jmp	 SHORT $LN12@Grow
$LN11@Grow:
  000bc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN12@Grow:
  000c3	8a 45 f4	 mov	 al, BYTE PTR tv140[ebp]
$LN8@Grow:

; 2216 : 		}

  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2199 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00017	c6 45 fb 00	 mov	 BYTE PTR $T1[ebp], 0
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8d 55 fb	 lea	 edx, DWORD PTR $T1[ebp]
  0002b	52		 push	 edx
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00034	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0003d	83 c4 08	 add	 esp, 8

; 2201 : 		}

  00040	83 c4 08	 add	 esp, 8
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1345 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1346 : 		if (this->_Mysize() < _Off)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  0002b	73 08		 jae	 SHORT $LN2@erase

; 1347 : 			_Xran();	// _Off off end

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN2@erase:

; 1348 : 		if (this->_Mysize() - _Off <= _Count)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00045	77 0e		 ja	 SHORT $LN3@erase

; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00047	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0004a	52		 push	 edx
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00053	eb 4a		 jmp	 SHORT $LN4@erase
$LN3@erase:

; 1350 : 		else if (0 < _Count)

  00055	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00059	76 44		 jbe	 SHORT $LN4@erase

; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00063	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00066	89 45 f8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  00076	89 45 f4	 mov	 DWORD PTR __Newsize$1[ebp], eax

; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00079	8b 4d f4	 mov	 ecx, DWORD PTR __Newsize$1[ebp]
  0007c	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$2[ebp]
  00083	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  00086	52		 push	 edx
  00087	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1355 : 			_Eos(_Newsize);

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __Newsize$1[ebp]
  00096	51		 push	 ecx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@erase:

; 1356 : 			}
; 1357 : 		return (*this);

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1358 : 		}

  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1337 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1338 : 		if (this->_Mysize() < _Off)

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  0001b	73 08		 jae	 SHORT $LN2@erase

; 1339 : 			_Xran();	// _Off off end

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN2@erase:

; 1340 : 		_Eos(_Off);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00028	51		 push	 ecx
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1341 : 		return (*this);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1342 : 		}

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@U?$pair@PAVRigidBody@@H@2@HPBU32@ABU32@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::pair<RigidBody *,int>,int,std::pair<RigidBody *,int> const *,std::pair<RigidBody *,int> const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntityComponent@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,EntityComponent *,int,EntityComponent * const *,EntityComponent * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 910  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		return (_Mybase::allocate(_Count));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 899  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Local@?$_Func_class@XPAVRigidBody@@@std@@ABE_NXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Local@?$_Func_class@XPAVRigidBody@@@std@@ABE_NXZ PROC	; std::_Func_class<void,RigidBody *>::_Local, COMDAT
; _this$ = ecx

; 409  : 		{	// test for locally stored copy of object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 410  : 		return (_Getimpl() == _Getspace());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getimpl@?$_Func_class@XPAVRigidBody@@@std@@ABEPAV?$_Func_base@XPAVRigidBody@@@2@XZ ; std::_Func_class<void,RigidBody *>::_Getimpl
  00020	8b f0		 mov	 esi, eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getspace@?$_Func_class@XPAVRigidBody@@@std@@ABEPBXXZ ; std::_Func_class<void,RigidBody *>::_Getspace
  0002a	3b f0		 cmp	 esi, eax
  0002c	75 09		 jne	 SHORT $LN3@Local
  0002e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@Local
$LN3@Local:
  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Local:
  0003e	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 411  : 		}

  00041	5e		 pop	 esi
  00042	83 c4 08	 add	 esp, 8
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?_Local@?$_Func_class@XPAVRigidBody@@@std@@ABE_NXZ ENDP	; std::_Func_class<void,RigidBody *>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy, COMDAT
; _this$ = ecx

; 600  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Get_data()._Myproxy);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Get_data

; 602  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@U?$pair@PAVRigidBody@@H@std@@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::pair<RigidBody *,int>,std::allocator<std::pair<RigidBody *,int> > > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z PROC ; std::allocator<std::pair<RigidBody *,int> >::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 08		 push	 8
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@2@I@Z ENDP ; std::allocator<std::pair<RigidBody *,int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 320  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::max_size, COMDAT
; _this$ = ecx

; 929  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		return (_Mytraits::max_size(*this));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAIABV?$allocator@PAVEntityComponent@@@2@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::max_size
  00017	83 c4 04	 add	 esp, 4

; 931  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEPAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEPAPAVEntityComponent@@I@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		return (_Mybase::allocate(_Count));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVEntityComponent@@@std@@QAEPAPAVEntityComponent@@I@Z ; std::allocator<EntityComponent *>::allocate

; 899  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEPAPAVEntityComponent@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend, COMDAT
; _this$ = ecx

; 666  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 668  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal, COMDAT
; _this$ = ecx

; 626  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 627  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first

; 628  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy, COMDAT
; _this$ = ecx

; 600  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Get_data()._Myproxy);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Get_data

; 602  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 320  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::max_size, COMDAT
; _this$ = ecx

; 929  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		return (_Mytraits::max_size(*this));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ; std::allocator_traits<std::allocator<Entity *> >::max_size
  00017	83 c4 04	 add	 esp, 4

; 931  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		return (_Mybase::allocate(_Count));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ; std::allocator<Entity *>::allocate

; 899  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend, COMDAT
; _this$ = ecx

; 666  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 668  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal, COMDAT
; _this$ = ecx

; 626  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 627  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first

; 628  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy, COMDAT
; _this$ = ecx

; 600  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Get_data()._Myproxy);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data

; 602  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::capacity, COMDAT
; _this$ = ecx

; 1041 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QBEABQAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1043 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@I@Z PROC ; std::allocator<Entity *>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 04		 push	 4
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@I@Z ENDP ; std::allocator<Entity *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::capacity, COMDAT
; _this$ = ecx

; 1041 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QBEABQAPAVEntityComponent@@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1043 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@QBEIXZ ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@I@Z PROC ; std::allocator<EntityComponent *>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 04		 push	 4
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@I@Z ENDP ; std::allocator<EntityComponent *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 320  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy, COMDAT
; _this$ = ecx

; 600  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Get_data()._Myproxy);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Get_data

; 602  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 1c		 push	 28			; 0000001cH
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 318  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 320  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 313  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		return (_Myval2);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 315  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 929  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		return (_Mytraits::max_size(*this));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  00017	83 c4 04	 add	 esp, 4

; 931  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		return (_Mybase::allocate(_Count));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 899  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 669  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 670  : 		_Get_data()._Orphan_all();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 671  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 658  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 659  : 		return (_Get_data()._Myproxy);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data

; 660  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv213 = -44						; size = 4
tv212 = -40						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  00020	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00023	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00026	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00029	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00037	33 c5		 xor	 eax, ebp
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00043	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00046	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00049	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0004c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0004f	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 2166 : 		if (max_size() < _Newres)

  00052	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0005a	3b 45 e8	 cmp	 eax, DWORD PTR __Newres$[ebp]
  0005d	73 08		 jae	 SHORT $LN2@Copy

; 2167 : 			_Newres = _Newsize;	// undo roundup if too big

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00062	89 4d e8	 mov	 DWORD PTR __Newres$[ebp], ecx
  00065	eb 6a		 jmp	 SHORT $LN3@Copy
$LN2@Copy:

; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00067	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  0006a	33 d2		 xor	 edx, edx
  0006c	b9 03 00 00 00	 mov	 ecx, 3
  00071	f7 f1		 div	 ecx
  00073	8b f0		 mov	 esi, eax
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0007d	8b 10		 mov	 edx, DWORD PTR [eax]
  0007f	d1 ea		 shr	 edx, 1
  00081	3b d6		 cmp	 edx, esi
  00083	77 02		 ja	 SHORT $LN4@Copy
  00085	eb 4a		 jmp	 SHORT $LN3@Copy
$LN4@Copy:

; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00087	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  0008f	8b 30		 mov	 esi, DWORD PTR [eax]
  00091	d1 ee		 shr	 esi, 1
  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0009b	8b f8		 mov	 edi, eax
  0009d	2b fe		 sub	 edi, esi
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000a7	39 38		 cmp	 DWORD PTR [eax], edi
  000a9	77 1b		 ja	 SHORT $LN6@Copy

; 2171 : 			_Newres = this->_Myres()

  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000b3	8b 30		 mov	 esi, DWORD PTR [eax]
  000b5	d1 ee		 shr	 esi, 1
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  000bf	03 30		 add	 esi, DWORD PTR [eax]
  000c1	89 75 e8	 mov	 DWORD PTR __Newres$[ebp], esi

; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else

  000c4	eb 0b		 jmp	 SHORT $LN3@Copy
$LN6@Copy:

; 2174 : 			_Newres = max_size();	// settle for max_size()

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000ce	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax
$LN3@Copy:

; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN

  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  000d8	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  000db	83 c0 01	 add	 eax, 1
  000de	50		 push	 eax
  000df	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  000e7	8b c8		 mov	 ecx, eax
  000e9	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000ee	89 45 d8	 mov	 DWORD PTR tv212[ebp], eax
  000f1	8b 4d d8	 mov	 ecx, DWORD PTR tv212[ebp]
  000f4	89 4d e0	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000f7	eb 5f		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2179 : 		_CATCH_ALL

  000f9	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000fc	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  000ff	89 55 e8	 mov	 DWORD PTR __Newres$[ebp], edx

; 2181 : 			_TRY_BEGIN

  00102	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00106	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  00109	83 c0 01	 add	 eax, 1
  0010c	50		 push	 eax
  0010d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00115	8b c8		 mov	 ecx, eax
  00117	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  0011c	89 45 d4	 mov	 DWORD PTR tv213[ebp], eax
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR tv213[ebp]
  00122	89 4d e0	 mov	 DWORD PTR __Ptr$[ebp], ecx
  00125	eb 1b		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise

  00127	6a 00		 push	 0
  00129	6a 01		 push	 1
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2185 : 			_RERAISE;

  00133	6a 00		 push	 0
  00135	6a 00		 push	 0
  00137	e8 00 00 00 00	 call	 __CxxThrowException@8

; 2186 : 			_CATCH_END

  0013c	b8 00 00 00 00	 mov	 eax, $LN17@Copy
  00141	c3		 ret	 0
$LN14@Copy:
  00142	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00149	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  0014b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2187 : 		_CATCH_END

  00152	b8 00 00 00 00	 mov	 eax, $LN19@Copy
  00157	c3		 ret	 0
$LN12@Copy:
  00158	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0015f	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  00161	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2188 : 
; 2189 : 		if (0 < _Oldlen)

  00168	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  0016c	76 19		 jbe	 SHORT $LN10@Copy

; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),

  0016e	8b 55 0c	 mov	 edx, DWORD PTR __Oldlen$[ebp]
  00171	52		 push	 edx
  00172	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00175	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0017a	50		 push	 eax
  0017b	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@Copy:

; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);

  00187	6a 00		 push	 0
  00189	6a 01		 push	 1
  0018b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);

  00193	8d 4d e0	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00196	51		 push	 ecx
  00197	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	e8 00 00 00 00	 call	 ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
  0019f	50		 push	 eax
  001a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  001a8	8b c8		 mov	 ecx, eax
  001aa	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2194 : 		this->_Myres() = _Newres;

  001af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
  001b7	8b 55 e8	 mov	 edx, DWORD PTR __Newres$[ebp]
  001ba	89 10		 mov	 DWORD PTR [eax], edx

; 2195 : 		_Eos(_Oldlen);

  001bc	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2196 : 		}

  001c8	52		 push	 edx
  001c9	8b cd		 mov	 ecx, ebp
  001cb	50		 push	 eax
  001cc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@Copy
  001d2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d7	58		 pop	 eax
  001d8	5a		 pop	 edx
  001d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e3	59		 pop	 ecx
  001e4	5f		 pop	 edi
  001e5	5e		 pop	 esi
  001e6	5b		 pop	 ebx
  001e7	83 c4 2c	 add	 esp, 44			; 0000002cH
  001ea	3b ec		 cmp	 ebp, esp
  001ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c2 08 00	 ret	 8
  001f7	90		 npad	 1
$LN23@Copy:
  001f8	01 00 00 00	 DD	 1
  001fc	00 00 00 00	 DD	 $LN22@Copy
$LN22@Copy:
  00200	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00204	04 00 00 00	 DD	 4
  00208	00 00 00 00	 DD	 $LN20@Copy
$LN20@Copy:
  0020c	5f		 DB	 95			; 0000005fH
  0020d	50		 DB	 80			; 00000050H
  0020e	74		 DB	 116			; 00000074H
  0020f	72		 DB	 114			; 00000072H
  00210	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -16						; size = 4
$T1 = -9						; size = 1
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1754 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1755 : 		size_type _Num = this->_Getal().max_size();

  0001a	0f b6 45 f7	 movzx	 eax, BYTE PTR $T1[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
  0002e	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00031	83 7d f8 01	 cmp	 DWORD PTR __Num$[ebp], 1
  00035	77 09		 ja	 SHORT $LN3@max_size
  00037	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0003e	eb 09		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00040	8b 4d f8	 mov	 ecx, DWORD PTR __Num$[ebp]
  00043	83 e9 01	 sub	 ecx, 1
  00046	89 4d f0	 mov	 DWORD PTR tv75[ebp], ecx
$LN4@max_size:
  00049	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]

; 1757 : 		}

  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	6a 01		 push	 1
  00010	6a 08		 push	 8
  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0000e	6a 08		 push	 8
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 639  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ?_Getspace@?$_Func_class@XPAVRigidBody@@@std@@ABEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getspace@?$_Func_class@XPAVRigidBody@@@std@@ABEPBXXZ PROC ; std::_Func_class<void,RigidBody *>::_Getspace, COMDAT
; _this$ = ecx

; 438  : 		{	// get pointer to storage space

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : 		return (&_Mystorage);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 440  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Getspace@?$_Func_class@XPAVRigidBody@@@std@@ABEPBXXZ ENDP ; std::_Func_class<void,RigidBody *>::_Getspace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 300  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAIABV?$allocator@PAVEntityComponent@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAIABV?$allocator@PAVEntityComponent@@@2@@Z PROC ; std::allocator_traits<std::allocator<EntityComponent *> >::max_size, COMDAT

; 784  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 785  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAVEntityComponent@@@std@@QBEIXZ ; std::allocator<EntityComponent *>::max_size

; 786  : 		}

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAIABV?$allocator@PAVEntityComponent@@@2@@Z ENDP ; std::allocator_traits<std::allocator<EntityComponent *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 300  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z PROC ; std::allocator_traits<std::allocator<Entity *> >::max_size, COMDAT

; 784  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 785  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAVEntity@@@std@@QBEIXZ ; std::allocator<Entity *>::max_size

; 786  : 		}

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Entity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z PROC ; std::allocator<Entity *>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	6a 01		 push	 1
  00010	6a 04		 push	 4
  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ENDP ; std::allocator<Entity *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVEntityComponent@@@std@@QAEPAPAVEntityComponent@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVEntityComponent@@@std@@QAEPAPAVEntityComponent@@I@Z PROC ; std::allocator<EntityComponent *>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	6a 01		 push	 1
  00010	6a 04		 push	 4
  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@PAVEntityComponent@@@std@@QAEPAPAVEntityComponent@@I@Z ENDP ; std::allocator<EntityComponent *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 784  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 785  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 786  : 		}

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVEntity@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAVEntity@@@std@@QBEIXZ PROC	; std::allocator<Entity *>::max_size, COMDAT
; _this$ = ecx

; 666  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  0000e	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 668  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?max_size@?$allocator@PAVEntity@@@std@@QBEIXZ ENDP	; std::allocator<Entity *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVEntityComponent@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAVEntityComponent@@@std@@QBEIXZ PROC ; std::allocator<EntityComponent *>::max_size, COMDAT
; _this$ = ecx

; 666  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  0000e	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 668  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?max_size@?$allocator@PAVEntityComponent@@@std@@QBEIXZ ENDP ; std::allocator<EntityComponent *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 666  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  0000e	83 c8 ff	 or	 eax, -1

; 668  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z
_TEXT	SEGMENT
_j$1 = -88						; size = 4
_i$2 = -84						; size = 4
_j$3 = -80						; size = 4
_i$4 = -76						; size = 4
$T5 = -72						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_r$ = 8							; size = 4
??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z PROC	; Matrix4<float>::Matrix4<float><4>, COMDAT
; _this$ = ecx

; 575  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000c	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 576  : 		if(D < 4)

  00026	33 c0		 xor	 eax, eax
  00028	74 68		 je	 SHORT $LN14@Matrix4

; 577  : 		{
; 578  : 			this->InitIdentity();

  0002a	8d 4d b8	 lea	 ecx, DWORD PTR $T5[ebp]
  0002d	51		 push	 ecx
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ ; Matrix<float,4>::InitIdentity

; 579  : 		
; 580  : 			for(unsigned int i = 0; i < D; i++)

  00036	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@Matrix4
$LN2@Matrix4:
  0003f	8b 55 b4	 mov	 edx, DWORD PTR _i$4[ebp]
  00042	83 c2 01	 add	 edx, 1
  00045	89 55 b4	 mov	 DWORD PTR _i$4[ebp], edx
$LN4@Matrix4:
  00048	83 7d b4 04	 cmp	 DWORD PTR _i$4[ebp], 4
  0004c	73 42		 jae	 SHORT $LN3@Matrix4

; 581  : 				for(unsigned int j = 0; j < D; j++)

  0004e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _j$3[ebp], 0
  00055	eb 09		 jmp	 SHORT $LN7@Matrix4
$LN5@Matrix4:
  00057	8b 45 b0	 mov	 eax, DWORD PTR _j$3[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 b0	 mov	 DWORD PTR _j$3[ebp], eax
$LN7@Matrix4:
  00060	83 7d b0 04	 cmp	 DWORD PTR _j$3[ebp], 4
  00064	73 28		 jae	 SHORT $LN6@Matrix4

; 582  : 					(*this)[i][j] = r[i][j];

  00066	8b 4d b4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00069	51		 push	 ecx
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0006d	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QBEPBMH@Z ; Matrix<float,4>::operator[]
  00072	8b f0		 mov	 esi, eax
  00074	8b 55 b4	 mov	 edx, DWORD PTR _i$4[ebp]
  00077	52		 push	 edx
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00080	8b 4d b0	 mov	 ecx, DWORD PTR _j$3[ebp]
  00083	8b 55 b0	 mov	 edx, DWORD PTR _j$3[ebp]
  00086	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00089	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  0008c	eb c9		 jmp	 SHORT $LN5@Matrix4
$LN6@Matrix4:
  0008e	eb af		 jmp	 SHORT $LN2@Matrix4
$LN3@Matrix4:

; 583  : 		}
; 584  : 		else

  00090	eb 5a		 jmp	 SHORT $LN9@Matrix4
$LN14@Matrix4:

; 585  : 		{
; 586  : 			for(unsigned int i = 0; i < 4; i++)

  00092	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00099	eb 09		 jmp	 SHORT $LN10@Matrix4
$LN8@Matrix4:
  0009b	8b 45 ac	 mov	 eax, DWORD PTR _i$2[ebp]
  0009e	83 c0 01	 add	 eax, 1
  000a1	89 45 ac	 mov	 DWORD PTR _i$2[ebp], eax
$LN10@Matrix4:
  000a4	83 7d ac 04	 cmp	 DWORD PTR _i$2[ebp], 4
  000a8	73 42		 jae	 SHORT $LN9@Matrix4

; 587  : 				for(unsigned int j = 0; j < 4; j++)

  000aa	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _j$1[ebp], 0
  000b1	eb 09		 jmp	 SHORT $LN13@Matrix4
$LN11@Matrix4:
  000b3	8b 4d a8	 mov	 ecx, DWORD PTR _j$1[ebp]
  000b6	83 c1 01	 add	 ecx, 1
  000b9	89 4d a8	 mov	 DWORD PTR _j$1[ebp], ecx
$LN13@Matrix4:
  000bc	83 7d a8 04	 cmp	 DWORD PTR _j$1[ebp], 4
  000c0	73 28		 jae	 SHORT $LN12@Matrix4

; 588  : 					(*this)[i][j] = r[i][j];

  000c2	8b 55 ac	 mov	 edx, DWORD PTR _i$2[ebp]
  000c5	52		 push	 edx
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  000c9	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QBEPBMH@Z ; Matrix<float,4>::operator[]
  000ce	8b f0		 mov	 esi, eax
  000d0	8b 45 ac	 mov	 eax, DWORD PTR _i$2[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000dc	8b 4d a8	 mov	 ecx, DWORD PTR _j$1[ebp]
  000df	8b 55 a8	 mov	 edx, DWORD PTR _j$1[ebp]
  000e2	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  000e5	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  000e8	eb c9		 jmp	 SHORT $LN11@Matrix4
$LN12@Matrix4:
  000ea	eb af		 jmp	 SHORT $LN8@Matrix4
$LN9@Matrix4:

; 589  : 		}
; 590  : 	}

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	33 cd		 xor	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	83 c4 58	 add	 esp, 88			; 00000058H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 04 00	 ret	 4
??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z ENDP	; Matrix4<float>::Matrix4<float><4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2428 : 	{	// test for string equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2429 : 	return (_Left.compare(_Right) == 0);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00012	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00017	85 c0		 test	 eax, eax
  00019	75 09		 jne	 SHORT $LN3@operator
  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  0002b	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 2430 : 	}

  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2448 : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2449 : 	return (_Left.compare(_Right) == 0);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00012	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00017	85 c0		 test	 eax, eax
  00019	75 09		 jne	 SHORT $LN3@operator
  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  0002b	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 2450 : 	}

  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv290 = -136						; size = 4
tv289 = -132						; size = 4
tv288 = -125						; size = 1
tv287 = -124						; size = 8
tv286 = -116						; size = 4
tv285 = -112						; size = 4
tv284 = -108						; size = 4
tv283 = -101						; size = 1
tv137 = -100						; size = 4
tv135 = -96						; size = 8
tv342 = -88						; size = 8
tv328 = -80						; size = 8
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
__Ok$ = -48						; size = 8
__Pad$ = -36						; size = 8
__Count$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 782  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 78	 sub	 esp, 120		; 00000078H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8d bd 78 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-136]
  0001e	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 783  : 	typedef char _Elem;
; 784  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 785  : 	ios_base::iostate _State = ios_base::goodbit;

  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 786  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  0004e	83 c4 04	 add	 esp, 4
  00051	33 c9		 xor	 ecx, ecx
  00053	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax
  00056	89 4d e8	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 787  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00059	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00061	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00064	8b f4		 mov	 esi, esp
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	89 45 b0	 mov	 DWORD PTR tv328[ebp], eax
  00076	89 55 b4	 mov	 DWORD PTR tv328[ebp+4], edx
  00079	83 7d b4 00	 cmp	 DWORD PTR tv328[ebp+4], 0
  0007d	7c 62		 jl	 SHORT $LN17@operator
  0007f	7f 06		 jg	 SHORT $LN24@operator
  00081	83 7d b0 00	 cmp	 DWORD PTR tv328[ebp], 0
  00085	76 5a		 jbe	 SHORT $LN17@operator
$LN24@operator:
  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00092	8b f4		 mov	 esi, esp
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	89 45 a8	 mov	 DWORD PTR tv342[ebp], eax
  000a4	89 55 ac	 mov	 DWORD PTR tv342[ebp+4], edx
  000a7	8b 45 ac	 mov	 eax, DWORD PTR tv342[ebp+4]
  000aa	3b 45 e8	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000ad	7c 32		 jl	 SHORT $LN17@operator
  000af	7f 08		 jg	 SHORT $LN25@operator
  000b1	8b 4d a8	 mov	 ecx, DWORD PTR tv342[ebp]
  000b4	3b 4d e4	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000b7	76 28		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000b9	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000bc	8b 02		 mov	 eax, DWORD PTR [edx]
  000be	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000c4	8b f4		 mov	 esi, esp
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	2b 45 e4	 sub	 eax, DWORD PTR __Count$[ebp]
  000d6	1b 55 e8	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  000d9	89 45 a0	 mov	 DWORD PTR tv135[ebp], eax
  000dc	89 55 a4	 mov	 DWORD PTR tv135[ebp+4], edx
  000df	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000e1	0f 57 c0	 xorps	 xmm0, xmm0
  000e4	66 0f 13 45 a0	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  000e9	8b 4d a0	 mov	 ecx, DWORD PTR tv135[ebp]
  000ec	89 4d dc	 mov	 DWORD PTR __Pad$[ebp], ecx
  000ef	8b 55 a4	 mov	 edx, DWORD PTR tv135[ebp+4]
  000f2	89 55 e0	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 788  : 		? 0 : _Ostr.width() - _Count;
; 789  : 	const typename _Myos::sentry _Ok(_Ostr);

  000f5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000f8	50		 push	 eax
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000fc	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00101	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 790  : 
; 791  : 	if (!_Ok)

  00108	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0010b	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00110	0f b6 c8	 movzx	 ecx, al
  00113	85 c9		 test	 ecx, ecx
  00115	75 0e		 jne	 SHORT $LN8@operator

; 792  : 		_State |= ios_base::badbit;

  00117	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0011a	83 ca 04	 or	 edx, 4
  0011d	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 793  : 	else

  00120	e9 6e 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 794  : 		{	// state okay, insert
; 795  : 		_TRY_IO_BEGIN

  00125	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 796  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00129	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00131	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00134	8b f4		 mov	 esi, esp
  00136	8b ca		 mov	 ecx, edx
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	89 45 9c	 mov	 DWORD PTR tv137[ebp], eax
  00148	8b 45 9c	 mov	 eax, DWORD PTR tv137[ebp]
  0014b	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00150	83 f8 40	 cmp	 eax, 64			; 00000040H
  00153	0f 84 b7 00 00
	00		 je	 $LN11@operator

; 797  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00159	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0015b	8b 4d dc	 mov	 ecx, DWORD PTR __Pad$[ebp]
  0015e	83 e9 01	 sub	 ecx, 1
  00161	8b 55 e0	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  00164	83 da 00	 sbb	 edx, 0
  00167	89 4d dc	 mov	 DWORD PTR __Pad$[ebp], ecx
  0016a	89 55 e0	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN4@operator:
  0016d	83 7d e0 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00171	0f 8c 99 00 00
	00		 jl	 $LN11@operator
  00177	7f 0a		 jg	 SHORT $LN26@operator
  00179	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  0017d	0f 86 8d 00 00
	00		 jbe	 $LN11@operator
$LN26@operator:

; 798  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00183	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00186	8b 08		 mov	 ecx, DWORD PTR [eax]
  00188	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0018b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0018e	8b f4		 mov	 esi, esp
  00190	8b ca		 mov	 ecx, edx
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00198	3b f4		 cmp	 esi, esp
  0019a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019f	88 45 9b	 mov	 BYTE PTR tv283[ebp], al
  001a2	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a7	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001aa	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001ad	8b f4		 mov	 esi, esp
  001af	8b ca		 mov	 ecx, edx
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001b7	3b f4		 cmp	 esi, esp
  001b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001be	89 45 94	 mov	 DWORD PTR tv284[ebp], eax
  001c1	8b f4		 mov	 esi, esp
  001c3	0f b6 45 9b	 movzx	 eax, BYTE PTR tv283[ebp]
  001c7	50		 push	 eax
  001c8	8b 4d 94	 mov	 ecx, DWORD PTR tv284[ebp]
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001d1	3b f4		 cmp	 esi, esp
  001d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d8	89 45 90	 mov	 DWORD PTR tv285[ebp], eax
  001db	8b 4d 90	 mov	 ecx, DWORD PTR tv285[ebp]
  001de	89 4d c8	 mov	 DWORD PTR $T6[ebp], ecx
  001e1	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  001e6	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax
  001e9	8d 55 c8	 lea	 edx, DWORD PTR $T6[ebp]
  001ec	52		 push	 edx
  001ed	8d 45 c4	 lea	 eax, DWORD PTR $T5[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  001f6	83 c4 08	 add	 esp, 8
  001f9	0f b6 c8	 movzx	 ecx, al
  001fc	85 c9		 test	 ecx, ecx
  001fe	74 0b		 je	 SHORT $LN12@operator

; 799  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 800  : 					{	// insertion failed, quit
; 801  : 					_State |= ios_base::badbit;

  00200	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00203	83 ca 04	 or	 edx, 4
  00206	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 802  : 					break;

  00209	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 803  : 					}
; 804  : 
; 805  : 		if (_State == ios_base::goodbit

  0020b	e9 4b ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 806  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00210	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00214	75 5c		 jne	 SHORT $LN13@operator
  00216	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00219	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0021e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00221	8b f4		 mov	 esi, esp
  00223	8b ca		 mov	 ecx, edx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0022b	3b f4		 cmp	 esi, esp
  0022d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00232	89 45 8c	 mov	 DWORD PTR tv286[ebp], eax
  00235	8b f4		 mov	 esi, esp
  00237	8b 45 e8	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0023a	50		 push	 eax
  0023b	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0023e	51		 push	 ecx
  0023f	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00242	52		 push	 edx
  00243	8b 4d 8c	 mov	 ecx, DWORD PTR tv286[ebp]
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0024c	3b f4		 cmp	 esi, esp
  0024e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00253	89 45 84	 mov	 DWORD PTR tv287[ebp], eax
  00256	89 55 88	 mov	 DWORD PTR tv287[ebp+4], edx
  00259	8b 45 84	 mov	 eax, DWORD PTR tv287[ebp]
  0025c	3b 45 e4	 cmp	 eax, DWORD PTR __Count$[ebp]
  0025f	75 08		 jne	 SHORT $LN27@operator
  00261	8b 4d 88	 mov	 ecx, DWORD PTR tv287[ebp+4]
  00264	3b 4d e8	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  00267	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 807  : 			_State |= ios_base::badbit;

  00269	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0026c	83 ca 04	 or	 edx, 4
  0026f	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx
$LN13@operator:

; 808  : 
; 809  : 		if (_State == ios_base::goodbit)

  00272	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  00276	0f 85 bf 00 00
	00		 jne	 $LN14@operator

; 810  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  0027c	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  0027e	8b 45 dc	 mov	 eax, DWORD PTR __Pad$[ebp]
  00281	83 e8 01	 sub	 eax, 1
  00284	8b 4d e0	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00287	83 d9 00	 sbb	 ecx, 0
  0028a	89 45 dc	 mov	 DWORD PTR __Pad$[ebp], eax
  0028d	89 4d e0	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  00290	83 7d e0 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00294	0f 8c a1 00 00
	00		 jl	 $LN14@operator
  0029a	7f 0a		 jg	 SHORT $LN28@operator
  0029c	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002a0	0f 86 95 00 00
	00		 jbe	 $LN14@operator
$LN28@operator:

; 811  : 				if (_Traits::eq_int_type(_Traits::eof(),

  002a6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002a9	8b 02		 mov	 eax, DWORD PTR [edx]
  002ab	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ae	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002b1	8b f4		 mov	 esi, esp
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002b9	3b f4		 cmp	 esi, esp
  002bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c0	88 45 83	 mov	 BYTE PTR tv288[ebp], al
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002ce	8b f4		 mov	 esi, esp
  002d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002d6	3b f4		 cmp	 esi, esp
  002d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002dd	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  002e3	8b f4		 mov	 esi, esp
  002e5	0f b6 45 83	 movzx	 eax, BYTE PTR tv288[ebp]
  002e9	50		 push	 eax
  002ea	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv289[ebp]
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  002f6	3b f4		 cmp	 esi, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fd	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
  00303	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv290[ebp]
  00309	89 4d c0	 mov	 DWORD PTR $T4[ebp], ecx
  0030c	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  00311	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
  00314	8d 55 c0	 lea	 edx, DWORD PTR $T4[ebp]
  00317	52		 push	 edx
  00318	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  0031b	50		 push	 eax
  0031c	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  00321	83 c4 08	 add	 esp, 8
  00324	0f b6 c8	 movzx	 ecx, al
  00327	85 c9		 test	 ecx, ecx
  00329	74 0b		 je	 SHORT $LN15@operator

; 812  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 813  : 					{	// insertion failed, quit
; 814  : 					_State |= ios_base::badbit;

  0032b	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0032e	83 ca 04	 or	 edx, 4
  00331	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 815  : 					break;

  00334	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 816  : 					}

  00336	e9 43 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 817  : 		_Ostr.width(0);

  0033b	8b f4		 mov	 esi, esp
  0033d	6a 00		 push	 0
  0033f	6a 00		 push	 0
  00341	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00344	8b 08		 mov	 ecx, DWORD PTR [eax]
  00346	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00349	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0034c	8b ca		 mov	 ecx, edx
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  00354	3b f4		 cmp	 esi, esp
  00356	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0035b	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 818  : 		_CATCH_IO_(_Ostr)

  0035d	8b f4		 mov	 esi, esp
  0035f	6a 01		 push	 1
  00361	6a 04		 push	 4
  00363	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00366	8b 08		 mov	 ecx, DWORD PTR [eax]
  00368	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0036b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0036e	8b ca		 mov	 ecx, edx
  00370	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00376	3b f4		 cmp	 esi, esp
  00378	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037d	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00382	c3		 ret	 0
$LN19@operator:
  00383	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0038a	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  0038c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 819  : 		}
; 820  : 
; 821  : 	_Ostr.setstate(_State);

  00393	8b f4		 mov	 esi, esp
  00395	6a 00		 push	 0
  00397	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0039a	50		 push	 eax
  0039b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0039e	8b 11		 mov	 edx, DWORD PTR [ecx]
  003a0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003a3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003ac	3b f4		 cmp	 esi, esp
  003ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 822  : 	return (_Ostr);

  003b3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003b6	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  003b9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003c0	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  003c3	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003c8	8b 45 b8	 mov	 eax, DWORD PTR $T2[ebp]

; 823  : 	}

  003cb	52		 push	 edx
  003cc	8b cd		 mov	 ecx, ebp
  003ce	50		 push	 eax
  003cf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  003d5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003da	58		 pop	 eax
  003db	5a		 pop	 edx
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003e6	59		 pop	 ecx
  003e7	5f		 pop	 edi
  003e8	5e		 pop	 esi
  003e9	5b		 pop	 ebx
  003ea	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  003f0	3b ec		 cmp	 ebp, esp
  003f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f7	8b e5		 mov	 esp, ebp
  003f9	5d		 pop	 ebp
  003fa	c3		 ret	 0
  003fb	90		 npad	 1
$LN32@operator:
  003fc	01 00 00 00	 DD	 1
  00400	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  00404	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00408	08 00 00 00	 DD	 8
  0040c	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  00410	5f		 DB	 95			; 0000005fH
  00411	4f		 DB	 79			; 0000004fH
  00412	6b		 DB	 107			; 0000006bH
  00413	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv294 = -124						; size = 4
tv293 = -120						; size = 4
tv292 = -113						; size = 1
tv411 = -112						; size = 8
tv291 = -104						; size = 8
tv290 = -96						; size = 4
tv289 = -92						; size = 4
tv288 = -88						; size = 4
tv287 = -81						; size = 1
tv138 = -80						; size = 4
tv136 = -76						; size = 4
tv329 = -72						; size = 8
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
__Ok$ = -40						; size = 8
__Pad$ = -28						; size = 4
__Size$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 170  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0001b	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00038	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 171  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 172  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 173  : 	typedef typename _Mystr::size_type _Mysizt;
; 174  : 
; 175  : 	ios_base::iostate _State = ios_base::goodbit;

  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 176  : 	_Mysizt _Size = _Str.size();

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00045	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0004a	89 45 e8	 mov	 DWORD PTR __Size$[ebp], eax

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00055	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00058	8b f4		 mov	 esi, esp
  0005a	8b ca		 mov	 ecx, edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	89 45 b8	 mov	 DWORD PTR tv329[ebp], eax
  0006c	89 55 bc	 mov	 DWORD PTR tv329[ebp+4], edx
  0006f	83 7d bc 00	 cmp	 DWORD PTR tv329[ebp+4], 0
  00073	7c 4d		 jl	 SHORT $LN17@operator
  00075	7f 06		 jg	 SHORT $LN24@operator
  00077	83 7d b8 00	 cmp	 DWORD PTR tv329[ebp], 0
  0007b	76 45		 jbe	 SHORT $LN17@operator
$LN24@operator:
  0007d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00085	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00088	8b f4		 mov	 esi, esp
  0008a	8b ca		 mov	 ecx, edx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	3b 45 e8	 cmp	 eax, DWORD PTR __Size$[ebp]
  0009c	76 24		 jbe	 SHORT $LN17@operator
  0009e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000a6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000a9	8b f4		 mov	 esi, esp
  000ab	8b ca		 mov	 ecx, edx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000b3	3b f4		 cmp	 esi, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	2b 45 e8	 sub	 eax, DWORD PTR __Size$[ebp]
  000bd	89 45 b4	 mov	 DWORD PTR tv136[ebp], eax
  000c0	eb 07		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000c2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$LN18@operator:
  000c9	8b 45 b4	 mov	 eax, DWORD PTR tv136[ebp]
  000cc	89 45 e4	 mov	 DWORD PTR __Pad$[ebp], eax

; 178  : 		? 0 : (_Mysizt)_Ostr.width() - _Size;
; 179  : 	const typename _Myos::sentry _Ok(_Ostr);

  000cf	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000d2	51		 push	 ecx
  000d3	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000d6	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 180  : 
; 181  : 	if (!_Ok)

  000e2	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000e5	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000ea	0f b6 d0	 movzx	 edx, al
  000ed	85 d2		 test	 edx, edx
  000ef	75 0e		 jne	 SHORT $LN8@operator

; 182  : 		_State |= ios_base::badbit;

  000f1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000f4	83 c8 04	 or	 eax, 4
  000f7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 183  : 	else

  000fa	e9 3c 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 184  : 		{	// state okay, insert characters
; 185  : 	_TRY_IO_BEGIN

  000ff	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 186  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00103	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00106	8b 11		 mov	 edx, DWORD PTR [ecx]
  00108	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0010b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0010e	8b f4		 mov	 esi, esp
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00116	3b f4		 cmp	 esi, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	89 45 b0	 mov	 DWORD PTR tv138[ebp], eax
  00120	8b 45 b0	 mov	 eax, DWORD PTR tv138[ebp]
  00123	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00128	83 f8 40	 cmp	 eax, 64			; 00000040H
  0012b	0f 84 9e 00 00
	00		 je	 $LN11@operator

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00131	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00133	8b 4d e4	 mov	 ecx, DWORD PTR __Pad$[ebp]
  00136	83 e9 01	 sub	 ecx, 1
  00139	89 4d e4	 mov	 DWORD PTR __Pad$[ebp], ecx
$LN4@operator:
  0013c	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00140	0f 86 89 00 00
	00		 jbe	 $LN11@operator

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00146	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00149	8b 02		 mov	 eax, DWORD PTR [edx]
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0014e	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00151	8b f4		 mov	 esi, esp
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00159	3b f4		 cmp	 esi, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	88 45 af	 mov	 BYTE PTR tv287[ebp], al
  00163	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00166	8b 11		 mov	 edx, DWORD PTR [ecx]
  00168	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0016b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0016e	8b f4		 mov	 esi, esp
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00176	3b f4		 cmp	 esi, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	89 45 a8	 mov	 DWORD PTR tv288[ebp], eax
  00180	8b f4		 mov	 esi, esp
  00182	0f b6 45 af	 movzx	 eax, BYTE PTR tv287[ebp]
  00186	50		 push	 eax
  00187	8b 4d a8	 mov	 ecx, DWORD PTR tv288[ebp]
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00190	3b f4		 cmp	 esi, esp
  00192	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00197	89 45 a4	 mov	 DWORD PTR tv289[ebp], eax
  0019a	8b 4d a4	 mov	 ecx, DWORD PTR tv289[ebp]
  0019d	89 4d d0	 mov	 DWORD PTR $T6[ebp], ecx
  001a0	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  001a5	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  001a8	8d 55 d0	 lea	 edx, DWORD PTR $T6[ebp]
  001ab	52		 push	 edx
  001ac	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  001b5	83 c4 08	 add	 esp, 8
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 0b		 je	 SHORT $LN12@operator

; 189  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 190  : 					{	// insertion failed, quit
; 191  : 					_State |= ios_base::badbit;

  001bf	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001c2	83 ca 04	 or	 edx, 4
  001c5	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 192  : 					break;

  001c8	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 193  : 					}
; 194  : 
; 195  : 		if (_State == ios_base::goodbit

  001ca	e9 64 ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

  001cf	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  001d3	75 70		 jne	 SHORT $LN13@operator
  001d5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001da	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001dd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e0	8b f4		 mov	 esi, esp
  001e2	8b ca		 mov	 ecx, edx
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001ea	3b f4		 cmp	 esi, esp
  001ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f1	89 45 a0	 mov	 DWORD PTR tv290[ebp], eax
  001f4	8b 45 e8	 mov	 eax, DWORD PTR __Size$[ebp]
  001f7	33 c9		 xor	 ecx, ecx
  001f9	8b f4		 mov	 esi, esp
  001fb	51		 push	 ecx
  001fc	50		 push	 eax
  001fd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00200	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00205	50		 push	 eax
  00206	8b 4d a0	 mov	 ecx, DWORD PTR tv290[ebp]
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0020f	3b f4		 cmp	 esi, esp
  00211	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00216	89 45 98	 mov	 DWORD PTR tv291[ebp], eax
  00219	89 55 9c	 mov	 DWORD PTR tv291[ebp+4], edx
  0021c	8b 55 e8	 mov	 edx, DWORD PTR __Size$[ebp]
  0021f	33 c0		 xor	 eax, eax
  00221	89 55 90	 mov	 DWORD PTR tv411[ebp], edx
  00224	89 45 94	 mov	 DWORD PTR tv411[ebp+4], eax
  00227	8b 4d 98	 mov	 ecx, DWORD PTR tv291[ebp]
  0022a	3b 4d 90	 cmp	 ecx, DWORD PTR tv411[ebp]
  0022d	75 08		 jne	 SHORT $LN25@operator
  0022f	8b 55 9c	 mov	 edx, DWORD PTR tv291[ebp+4]
  00232	3b 55 94	 cmp	 edx, DWORD PTR tv411[ebp+4]
  00235	74 0e		 je	 SHORT $LN13@operator
$LN25@operator:

; 197  : 				!= (streamsize)_Size)
; 198  : 				_State |= ios_base::badbit;

  00237	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0023a	83 c8 04	 or	 eax, 4
  0023d	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 199  : 		else

  00240	e9 9e 00 00 00	 jmp	 $LN14@operator
$LN13@operator:

; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00245	eb 09		 jmp	 SHORT $LN7@operator
$LN5@operator:
  00247	8b 4d e4	 mov	 ecx, DWORD PTR __Pad$[ebp]
  0024a	83 e9 01	 sub	 ecx, 1
  0024d	89 4d e4	 mov	 DWORD PTR __Pad$[ebp], ecx
$LN7@operator:
  00250	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00254	0f 86 89 00 00
	00		 jbe	 $LN14@operator

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0025a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0025d	8b 02		 mov	 eax, DWORD PTR [edx]
  0025f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00262	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00265	8b f4		 mov	 esi, esp
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0026d	3b f4		 cmp	 esi, esp
  0026f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00274	88 45 8f	 mov	 BYTE PTR tv292[ebp], al
  00277	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0027a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0027f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00282	8b f4		 mov	 esi, esp
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0028a	3b f4		 cmp	 esi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00291	89 45 88	 mov	 DWORD PTR tv293[ebp], eax
  00294	8b f4		 mov	 esi, esp
  00296	0f b6 45 8f	 movzx	 eax, BYTE PTR tv292[ebp]
  0029a	50		 push	 eax
  0029b	8b 4d 88	 mov	 ecx, DWORD PTR tv293[ebp]
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  002a4	3b f4		 cmp	 esi, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ab	89 45 84	 mov	 DWORD PTR tv294[ebp], eax
  002ae	8b 4d 84	 mov	 ecx, DWORD PTR tv294[ebp]
  002b1	89 4d c8	 mov	 DWORD PTR $T4[ebp], ecx
  002b4	e8 00 00 00 00	 call	 ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof
  002b9	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  002bc	8d 55 c8	 lea	 edx, DWORD PTR $T4[ebp]
  002bf	52		 push	 edx
  002c0	8d 45 c4	 lea	 eax, DWORD PTR $T3[ebp]
  002c3	50		 push	 eax
  002c4	e8 00 00 00 00	 call	 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
  002c9	83 c4 08	 add	 esp, 8
  002cc	0f b6 c8	 movzx	 ecx, al
  002cf	85 c9		 test	 ecx, ecx
  002d1	74 0b		 je	 SHORT $LN15@operator

; 202  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 203  : 					{	// insertion failed, quit
; 204  : 					_State |= ios_base::badbit;

  002d3	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  002d6	83 ca 04	 or	 edx, 4
  002d9	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 205  : 					break;

  002dc	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 206  : 					}

  002de	e9 64 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 207  : 		_Ostr.width(0);

  002e3	8b f4		 mov	 esi, esp
  002e5	6a 00		 push	 0
  002e7	6a 00		 push	 0
  002e9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ee	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002f1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002f4	8b ca		 mov	 ecx, edx
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  002fc	3b f4		 cmp	 esi, esp
  002fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00303	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 208  : 		_CATCH_IO_(_Ostr)

  00305	8b f4		 mov	 esi, esp
  00307	6a 01		 push	 1
  00309	6a 04		 push	 4
  0030b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0030e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00310	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00313	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00316	8b ca		 mov	 ecx, edx
  00318	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0031e	3b f4		 cmp	 esi, esp
  00320	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00325	b8 00 00 00 00	 mov	 eax, $LN23@operator
  0032a	c3		 ret	 0
$LN19@operator:
  0032b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00332	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  00334	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 209  : 		}
; 210  : 
; 211  : 	_Ostr.setstate(_State);

  0033b	8b f4		 mov	 esi, esp
  0033d	6a 00		 push	 0
  0033f	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00342	50		 push	 eax
  00343	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00346	8b 11		 mov	 edx, DWORD PTR [ecx]
  00348	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0034b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00354	3b f4		 cmp	 esi, esp
  00356	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 212  : 	return (_Ostr);

  0035b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0035e	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  00361	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00368	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0036b	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00370	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]

; 213  : 	}

  00373	52		 push	 edx
  00374	8b cd		 mov	 ecx, ebp
  00376	50		 push	 eax
  00377	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN29@operator
  0037d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00382	58		 pop	 eax
  00383	5a		 pop	 edx
  00384	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00387	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0038e	59		 pop	 ecx
  0038f	5f		 pop	 edi
  00390	5e		 pop	 esi
  00391	5b		 pop	 ebx
  00392	83 c4 7c	 add	 esp, 124		; 0000007cH
  00395	3b ec		 cmp	 ebp, esp
  00397	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039c	8b e5		 mov	 esp, ebp
  0039e	5d		 pop	 ebp
  0039f	c3		 ret	 0
$LN29@operator:
  003a0	01 00 00 00	 DD	 1
  003a4	00 00 00 00	 DD	 $LN28@operator
$LN28@operator:
  003a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  003ac	08 00 00 00	 DD	 8
  003b0	00 00 00 00	 DD	 $LN26@operator
$LN26@operator:
  003b4	5f		 DB	 95			; 0000005fH
  003b5	4f		 DB	 79			; 0000004fH
  003b6	6b		 DB	 107			; 0000006bH
  003b7	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 993  : 	{	// insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 994  : 	_Ostr.put(_Ostr.widen('\n'));

  00004	8b f4		 mov	 esi, esp
  00006	6a 0a		 push	 10			; 0000000aH
  00008	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00010	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00013	8b ca		 mov	 ecx, edx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b f4		 mov	 esi, esp
  00024	0f b6 c0	 movzx	 eax, al
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 995  : 	_Ostr.flush();

  00038	8b f4		 mov	 esi, esp
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 996  : 	return (_Ostr);

  0004a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 997  : 	}

  0004d	5e		 pop	 esi
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z PROC ; std::operator!=<void __cdecl(RigidBody *)>, COMDAT

; 621  : 	{	// compare to null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 	return (static_cast<bool>(_Other));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00006	e8 00 00 00 00	 call	 ??B?$function@$$A6AXPAVRigidBody@@@Z@std@@QBE_NXZ ; std::function<void __cdecl(RigidBody *)>::operator bool

; 623  : 	}

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$?9$$A6AXPAVRigidBody@@@Z@std@@YA_NABV?$function@$$A6AXPAVRigidBody@@@Z@0@$$T@Z ENDP ; std::operator!=<void __cdecl(RigidBody *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z
_TEXT	SEGMENT
tv180 = -80						; size = 4
tv190 = -76						; size = 4
tv178 = -72						; size = 4
tv175 = -68						; size = 4
tv188 = -64						; size = 4
tv172 = -60						; size = 4
tv163 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 12
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -22						; size = 1
$T8 = -21						; size = 1
__Off$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__First$ = 24						; size = 12
__Last$ = 36						; size = 12
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT
; _this$ = ecx

; 1371 : 		{	// insert [_First, _Last) at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  00019	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00041	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();

  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00050	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+8]
  00053	2b 08		 sub	 ecx, DWORD PTR [eax]
  00055	c1 f9 02	 sar	 ecx, 2
  00058	89 4d ec	 mov	 DWORD PTR __Off$[ebp], ecx

; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

  0005b	8d 55 18	 lea	 edx, DWORD PTR __First$[ebp]
  0005e	52		 push	 edx
  0005f	8d 45 ea	 lea	 eax, DWORD PTR $T7[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00068	83 c4 08	 add	 esp, 8
  0006b	8a 08		 mov	 cl, BYTE PTR [eax]
  0006d	88 4d eb	 mov	 BYTE PTR $T8[ebp], cl
  00070	0f b6 55 eb	 movzx	 edx, BYTE PTR $T8[ebp]
  00074	52		 push	 edx
  00075	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00078	8b cc		 mov	 ecx, esp
  0007a	89 65 e4	 mov	 DWORD PTR $T6[ebp], esp
  0007d	8d 45 24	 lea	 eax, DWORD PTR __Last$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00086	89 45 c8	 mov	 DWORD PTR tv163[ebp], eax
  00089	8b 4d c8	 mov	 ecx, DWORD PTR tv163[ebp]
  0008c	89 4d c4	 mov	 DWORD PTR tv172[ebp], ecx
  0008f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00093	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00096	8b cc		 mov	 ecx, esp
  00098	89 65 e0	 mov	 DWORD PTR $T5[ebp], esp
  0009b	8d 55 18	 lea	 edx, DWORD PTR __First$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  000a4	89 45 c0	 mov	 DWORD PTR tv188[ebp], eax
  000a7	8b 45 c0	 mov	 eax, DWORD PTR tv188[ebp]
  000aa	89 45 bc	 mov	 DWORD PTR tv175[ebp], eax
  000ad	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000b1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b4	8b cc		 mov	 ecx, esp
  000b6	89 65 dc	 mov	 DWORD PTR $T4[ebp], esp
  000b9	8d 55 0c	 lea	 edx, DWORD PTR __Where$[ebp]
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  000c2	89 45 b8	 mov	 DWORD PTR tv178[ebp], eax
  000c5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >

; 1374 : 		return (begin() + _Off);

  000d1	8d 45 d0	 lea	 eax, DWORD PTR $T3[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::begin
  000dd	89 45 b4	 mov	 DWORD PTR tv190[ebp], eax
  000e0	8b 4d b4	 mov	 ecx, DWORD PTR tv190[ebp]
  000e3	89 4d b0	 mov	 DWORD PTR tv180[ebp], ecx
  000e6	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000ea	8b 55 ec	 mov	 edx, DWORD PTR __Off$[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d b0	 mov	 ecx, DWORD PTR tv180[ebp]
  000f5	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+
  000fa	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
  000fd	83 c9 01	 or	 ecx, 1
  00100	89 4d cc	 mov	 DWORD PTR $T2[ebp], ecx
  00103	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00107	8d 4d d0	 lea	 ecx, DWORD PTR $T3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  0010f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00113	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00116	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  0011b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0011f	8d 4d 18	 lea	 ecx, DWORD PTR __First$[ebp]
  00122	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00127	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012e	8d 4d 24	 lea	 ecx, DWORD PTR __Last$[ebp]
  00131	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00136	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1375 : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	83 c4 50	 add	 esp, 80			; 00000050H
  00148	3b ec		 cmp	 ebp, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 28 00	 ret	 40			; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$0:
  00000	8d 4d 24	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$1:
  00008	8d 4d 18	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$2:
  00010	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$3:
  00018	8b 4d e4	 mov	 ecx, DWORD PTR $T6[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$4:
  00020	8b 4d e0	 mov	 ecx, DWORD PTR $T5[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z$6:
  00028	8d 4d d0	 lea	 ecx, DWORD PTR $T3[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V21@1@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<char>
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@PAVRigidBody@@@std@@YA$$QAPAVRigidBody@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVRigidBody@@@std@@YA$$QAPAVRigidBody@@AAPAV1@@Z PROC ; std::forward<RigidBody *>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAVRigidBody@@@std@@YA$$QAPAVRigidBody@@AAPAV1@@Z ENDP ; std::forward<RigidBody *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@@Z PROC ; std::addressof<std::pair<RigidBody *,int> >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<std::pair<RigidBody *,int> >
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@@Z ENDP ; std::addressof<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z PROC ; std::addressof<Entity * const>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<Entity * const>
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@@Z ENDP ; std::addressof<Entity * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z ; std::forward<Entity * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z ; std::forward<Entity * const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * const &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::construct<Entity *,Entity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<Entity *> > &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<Entity *> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<Entity *,std::allocator<Entity *> > >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<Entity *,std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z PROC ; std::addressof<EntityComponent * const>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<EntityComponent * const>
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@@Z ENDP ; std::addressof<EntityComponent * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntityComponent@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z ; std::forward<EntityComponent * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@AAPAV3@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVEntityComponent@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntityComponent@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z ; std::forward<EntityComponent * const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@ABQAV3@@Z ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVEntityComponent@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<EntityComponent *> > &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<EntityComponent *> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<EntityComponent *,std::allocator<EntityComponent *> > >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<EntityComponent *,std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char const >, COMDAT

; 760  : 	{	// test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 761  : 	if (_Ptr == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00008	75 1f		 jne	 SHORT $LN1@Debug_poin

; 762  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  0000a	8b f4		 mov	 esi, esp
  0000c	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 763  : 	}

  00029	5e		 pop	 esi
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Debug_pointer@$$CBD@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1><std::allocator<std::pair<RigidBody *,int> > const &>, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@YAABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<RigidBody *,int> > const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >,std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >,1><std::allocator<std::pair<RigidBody *,int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z PROC ; std::move<std::allocator<EntityComponent *> &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ENDP ; std::move<std::allocator<EntityComponent *> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0V?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> >, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@V?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ; std::forward<std::allocator<EntityComponent *> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::_Wrap_alloc<std::allocator<EntityComponent *> >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::_Vector_val<std::_Simple_types<EntityComponent *> >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0V?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> const &>, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@PAVEntityComponent@@@std@@@std@@YAABV?$allocator@PAVEntityComponent@@@0@ABV10@@Z ; std::forward<std::allocator<EntityComponent *> const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::_Wrap_alloc<std::allocator<EntityComponent *> >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::_Vector_val<std::_Simple_types<EntityComponent *> >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0ABV?$allocator@PAVEntityComponent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<EntityComponent *> >,std::_Vector_val<std::_Simple_types<EntityComponent *> >,1><std::allocator<EntityComponent *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z PROC ; std::move<std::allocator<Entity *> &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ENDP ; std::move<std::allocator<Entity *> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0V?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@V?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ; std::forward<std::allocator<Entity *> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::_Wrap_alloc<std::allocator<Entity *> >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0V?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> const &>, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@PAVEntity@@@std@@@std@@YAABV?$allocator@PAVEntity@@@0@ABV10@@Z ; std::forward<std::allocator<Entity *> const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::_Wrap_alloc<std::allocator<Entity *> >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0ABV?$allocator@PAVEntity@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Entity *> >,std::_Vector_val<std::_Simple_types<Entity *> >,1><std::allocator<Entity *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 288  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 287  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 289  : 		}

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  0001b	83 c4 08	 add	 esp, 8

; 926  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z
_TEXT	SEGMENT
__Test$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z PROC	; std::_Debug_pointer_if<char const >, COMDAT

; 774  : 	{	// conditionally test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 775  : 	if (_Test && _Ptr == 0)

  00004	0f b6 45 08	 movzx	 eax, BYTE PTR __Test$[ebp]
  00008	85 c0		 test	 eax, eax
  0000a	74 25		 je	 SHORT $LN1@Debug_poin
  0000c	83 7d 0c 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00010	75 1f		 jne	 SHORT $LN1@Debug_poin

; 776  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  00012	8b f4		 mov	 esi, esp
  00014	8b 4d 14	 mov	 ecx, DWORD PTR __Line$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 10	 mov	 edx, DWORD PTR __File$[ebp]
  0001b	52		 push	 edx
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 777  : 	}

  00031	5e		 pop	 esi
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Debug_pointer_if@$$CBD@std@@YAX_NPBDPB_WI@Z ENDP	; std::_Debug_pointer_if<char const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
  0001b	83 c4 08	 add	 esp, 8

; 926  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 874  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 875  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >, COMDAT
; _this$ = ecx

; 874  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0U?$pair@PAVRigidBody@@H@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<RigidBody *,int> >

; 875  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@U?$pair@PAVRigidBody@@H@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@PAVRigidBody@@H@0@0@Z ; std::_Ptr_cat<std::pair<RigidBody *,int>,std::pair<RigidBody *,int> >
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	}

  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<EntityComponent *> > >, COMDAT
; _this$ = ecx

; 874  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0PAVEntityComponent@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><EntityComponent *>

; 875  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT
; _this$ = ecx

; 874  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>

; 875  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1678 : 		return (_Uninitialized_move(_First, _Last,

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninitialized_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z ; std::_Ptr_cat<Entity *,Entity *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	}

  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVEntityComponent@@@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEPAPAVEntityComponent@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVEntityComponent@@@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEPAPAVEntityComponent@@PAPAV2@00@Z PROC ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Umove<EntityComponent * *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1678 : 		return (_Uninitialized_move(_First, _Last,

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<EntityComponent *,std::allocator<EntityComponent *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Uninitialized_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVEntityComponent@@@?$vector@PAVEntityComponent@@V?$allocator@PAVEntityComponent@@@std@@@std@@IAEPAPAVEntityComponent@@PAPAV2@00@Z ENDP ; std::vector<EntityComponent *,std::allocator<EntityComponent *> >::_Umove<EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z ; std::_Ptr_cat<EntityComponent *,EntityComponent *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	}

  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 874  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 873  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 875  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	}

  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Entity *,int,Entity * const *,Entity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >, COMDAT
; _this$ = ecx

; 478  : 	_Vector_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 		{	// initialize values

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12

; 480  : 		_Myfirst = pointer();

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 481  : 		_Mylast = pointer();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 482  : 		_Myend = pointer();

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 483  : 		}

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >::_Vector_val<std::_Simple_types<std::pair<RigidBody *,int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >, COMDAT
; _this$ = ecx

; 857  : 		{	// construct by copying base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >

; 858  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\functional
;	COMDAT ??B?$function@$$A6AXPAVRigidBody@@@Z@std@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
??B?$function@$$A6AXPAVRigidBody@@@Z@std@@QBE_NXZ PROC	; std::function<void __cdecl(RigidBody *)>::operator bool, COMDAT
; _this$ = ecx

; 573  : 		{	// test if wrapper holds function object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 574  : 		return (!this->_Empty());

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Empty@?$_Func_class@XPAVRigidBody@@@std@@IBE_NXZ ; std::_Func_class<void,RigidBody *>::_Empty
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 09		 jne	 SHORT $LN3@operator
  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  0002d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN4@operator:
  00036	8a 45 f8	 mov	 al, BYTE PTR tv72[ebp]

; 575  : 		}

  00039	83 c4 08	 add	 esp, 8
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??B?$function@$$A6AXPAVRigidBody@@@Z@std@@QBE_NXZ ENDP	; std::function<void __cdecl(RigidBody *)>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::_Vector_val<std::_Simple_types<EntityComponent *> >, COMDAT
; _this$ = ecx

; 478  : 	_Vector_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 		{	// initialize values

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12

; 480  : 		_Myfirst = pointer();

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 481  : 		_Mylast = pointer();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 482  : 		_Myend = pointer();

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 483  : 		}

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVEntityComponent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<EntityComponent *> >::_Vector_val<std::_Simple_types<EntityComponent *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::_Wrap_alloc<std::allocator<EntityComponent *> >, COMDAT
; _this$ = ecx

; 857  : 		{	// construct by copying base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@PAVEntityComponent@@@std@@QAE@ABV01@@Z ; std::allocator<EntityComponent *>::allocator<EntityComponent *>

; 858  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<EntityComponent *> >::_Wrap_alloc<std::allocator<EntityComponent *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
__Tmp$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+, COMDAT
; _this$ = ecx

; 366  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00022	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00025	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00028	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 367  : 		_Myiter _Tmp = *this;

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 368  : 		return (_Tmp += _Off);

  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  0005f	51		 push	 ecx
  00060	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00063	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006c	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00071	8b 55 d8	 mov	 edx, DWORD PTR $T2[ebp]
  00074	83 ca 01	 or	 edx, 1
  00077	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00081	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00084	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00089	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 369  : 		}

  0008c	52		 push	 edx
  0008d	8b cd		 mov	 ecx, ebp
  0008f	50		 push	 eax
  00090	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@operator
  00096	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009b	58		 pop	 eax
  0009c	5a		 pop	 edx
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	83 c4 28	 add	 esp, 40			; 00000028H
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
$LN9@operator:
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN8@operator
$LN8@operator:
  000c0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000c4	0c 00 00 00	 DD	 12			; 0000000cH
  000c8	00 00 00 00	 DD	 $LN6@operator
$LN6@operator:
  000cc	5f		 DB	 95			; 0000005fH
  000cd	54		 DB	 84			; 00000054H
  000ce	6d		 DB	 109			; 0000006dH
  000cf	70		 DB	 112			; 00000070H
  000d0	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >, COMDAT
; _this$ = ecx

; 478  : 	_Vector_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 		{	// initialize values

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12

; 480  : 		_Myfirst = pointer();

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 481  : 		_Mylast = pointer();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 482  : 		_Myend = pointer();

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 483  : 		}

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Entity *> >::_Wrap_alloc<std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 857  : 		{	// construct by copying base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  : 		: _Mybase(_Right)

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@PAVEntity@@@std@@QAE@ABV01@@Z ; std::allocator<Entity *>::allocator<Entity *>

; 858  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Entity *> >::_Wrap_alloc<std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 			return (_Ok);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 143  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  0002e	8b f4		 mov	 esi, esp
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	75 14		 jne	 SHORT $LN1@sentry

; 133  : 				this->_Myostr._Osfx();

  00044	8b f4		 mov	 esi, esp
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	5e		 pop	 esi
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 			: _Sentry_base(_Ostr)

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00049	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0004c	8b f4		 mov	 esi, esp
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	74 6c		 je	 SHORT $LN2@sentry
  00062	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0006a	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0006d	8b f4		 mov	 esi, esp
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	85 c0		 test	 eax, eax
  0007e	74 4e		 je	 SHORT $LN2@sentry
  00080	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00088	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008b	8b f4		 mov	 esi, esp
  0008d	8b ca		 mov	 ecx, edx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	3b 45 08	 cmp	 eax, DWORD PTR __Ostr$[ebp]
  0009f	74 2d		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  000a1	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000a9	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ac	8b f4		 mov	 esi, esp
  000ae	8b ca		 mov	 ecx, edx
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b f4		 mov	 esi, esp
  000bf	8b c8		 mov	 ecx, eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000d6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000d9	8b f4		 mov	 esi, esp
  000db	8b ca		 mov	 ecx, edx
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000e3	3b f4		 cmp	 esi, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 127  : 			}

  000f0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5e		 pop	 esi
  00106	83 c4 10	 add	 esp, 16			; 00000010H
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 486  : 	_String_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 487  : 		{	// initialize values

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12

; 488  : 		_Mysize = 0;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 489  : 		_Myres = 0;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 490  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >, COMDAT
; _this$ = ecx

; 621  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<RigidBody *,int> >::allocator<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=, COMDAT
; _this$ = ecx

; 360  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 		*(_Mybase *)this += _Off;

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=

; 362  : 		return (*this);

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 363  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEntity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVEntity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Entity *>::allocator<Entity *>, COMDAT
; _this$ = ecx

; 621  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@PAVEntity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Entity *>::allocator<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEntityComponent@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVEntityComponent@@@std@@QAE@ABV01@@Z PROC ; std::allocator<EntityComponent *>::allocator<EntityComponent *>, COMDAT
; _this$ = ecx

; 621  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@PAVEntityComponent@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<EntityComponent *>::allocator<EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -28						; size = 4
tv86 = -24						; size = 4
tv72 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00020	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00023	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 107  : 			if (_Myostr.rdbuf() != 0)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  0004a	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004d	8b f4		 mov	 esi, esp
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	85 c0		 test	 eax, eax
  0005e	74 3d		 je	 SHORT $LN3@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00060	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	89 55 e8	 mov	 DWORD PTR tv86[ebp], edx
  00068	8b 45 e8	 mov	 eax, DWORD PTR tv86[ebp]
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	8b 55 e8	 mov	 edx, DWORD PTR tv86[ebp]
  00070	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00073	8b f4		 mov	 esi, esp
  00075	8b ca		 mov	 ecx, edx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	89 45 e4	 mov	 DWORD PTR tv92[ebp], eax
  00087	8b 45 e4	 mov	 eax, DWORD PTR tv92[ebp]
  0008a	8b 10		 mov	 edx, DWORD PTR [eax]
  0008c	8b f4		 mov	 esi, esp
  0008e	8b 4d e4	 mov	 ecx, DWORD PTR tv92[ebp]
  00091	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00094	ff d0		 call	 eax
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Sentry_bas:

; 109  : 			}

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	5e		 pop	 esi
  000a9	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv87 = -12						; size = 4
tv73 = -8						; size = 4
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 			: _Myostr(_Ostr)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 101  : 			if (_Myostr.rdbuf() != 0)

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  00033	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00036	8b f4		 mov	 esi, esp
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	85 c0		 test	 eax, eax
  00047	74 3b		 je	 SHORT $LN1@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 4d f4	 mov	 DWORD PTR tv87[ebp], ecx
  00051	8b 55 f4	 mov	 edx, DWORD PTR tv87[ebp]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	8b 4d f4	 mov	 ecx, DWORD PTR tv87[ebp]
  00059	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0005c	8b f4		 mov	 esi, esp
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	89 45 f0	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR tv93[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	8b f4		 mov	 esi, esp
  00075	8b 4d f0	 mov	 ecx, DWORD PTR tv93[ebp]
  00078	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007b	ff d0		 call	 eax
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Sentry_bas:

; 103  : 			}

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	5e		 pop	 esi
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 36		 je	 SHORT $LN3@operator
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00024	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002f	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00032	72 1d		 jb	 SHORT $LN3@operator
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00045	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00048	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0004b	0f 83 86 00 00
	00		 jae	 $LN2@operator
$LN3@operator:

; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");

  00051	8b f4		 mov	 esi, esp
  00053	68 9f 00 00 00	 push	 159			; 0000009fH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 160  : 			_SCL_SECURE_OUT_OF_RANGE;

  00072	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
  00077	85 c0		 test	 eax, eax
  00079	74 04		 je	 SHORT $LN5@operator
  0007b	33 c9		 xor	 ecx, ecx
  0007d	75 30		 jne	 SHORT $LN6@operator
$LN5@operator:
  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0008b	6a 00		 push	 0
  0008d	68 a0 00 00 00	 push	 160			; 000000a0H
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00097	6a 02		 push	 2
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	3b f4		 cmp	 esi, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	75 01		 jne	 SHORT $LN6@operator
  000ae	cc		 int	 3
$LN6@operator:
  000af	8b f4		 mov	 esi, esp
  000b1	6a 00		 push	 0
  000b3	68 a0 00 00 00	 push	 160			; 000000a0H
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_1NM@MILGICEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@operator:

; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000dd	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000e0	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 171  : 		return (*this);

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 172  : 		}

  000ec	5e		 pop	 esi
  000ed	83 c4 04	 add	 esp, 4
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 627  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$pair@PAVRigidBody@@H@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@PAVRigidBody@@H@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<RigidBody *,int> >, COMDAT
; _this$ = ecx

; 627  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0U?$pair@PAVRigidBody@@H@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVEntityComponent@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVEntityComponent@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><EntityComponent *>, COMDAT
; _this$ = ecx

; 627  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0PAVEntityComponent@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntityComponent@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>, COMDAT
; _this$ = ecx

; 627  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 627  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 601  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 602  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 603  : 	return (_Cat);

  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8a 4d fb	 mov	 cl, BYTE PTR __Cat$[ebp]
  00021	88 08		 mov	 BYTE PTR [eax], cl
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 604  : 	}

  00026	52		 push	 edx
  00027	8b cd		 mov	 ecx, ebp
  00029	50		 push	 eax
  0002a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Iter_cat
  00030	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00035	58		 pop	 eax
  00036	5a		 pop	 edx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
  0003b	90		 npad	 1
$LN5@Iter_cat:
  0003c	01 00 00 00	 DD	 1
  00040	00 00 00 00	 DD	 $LN4@Iter_cat
$LN4@Iter_cat:
  00044	fb ff ff ff	 DD	 -5			; fffffffbH
  00048	01 00 00 00	 DD	 1
  0004c	00 00 00 00	 DD	 $LN3@Iter_cat
$LN3@Iter_cat:
  00050	5f		 DB	 95			; 0000005fH
  00051	43		 DB	 67			; 00000043H
  00052	61		 DB	 97			; 00000061H
  00053	74		 DB	 116			; 00000074H
  00054	00		 DB	 0
??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
tv424 = -136						; size = 4
tv463 = -132						; size = 4
tv460 = -128						; size = 4
tv474 = -124						; size = 4
tv231 = -120						; size = 4
tv456 = -116						; size = 4
tv453 = -112						; size = 4
tv472 = -108						; size = 4
tv471 = -104						; size = 4
tv450 = -100						; size = 4
tv447 = -96						; size = 4
tv469 = -92						; size = 4
tv444 = -88						; size = 4
tv441 = -84						; size = 4
tv467 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
__Ptr$10 = -44						; size = 4
__Newvec$11 = -40					; size = 4
__Capacity$12 = -36					; size = 4
__Count$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 12
__First$ = 20						; size = 12
__Last$ = 32						; size = 12
___formal$ = 44						; size = 1
??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT
; _this$ = ecx

; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 78	 sub	 esp, 120		; 00000078H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 78 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-136]
  0001f	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00043	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Get_data
  00052	8b f0		 mov	 esi, eax
  00054	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0005c	3b c6		 cmp	 eax, esi
  0005e	75 1e		 jne	 SHORT $LN3@Insert
  00060	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00068	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+8]
  0006b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006d	72 0f		 jb	 SHORT $LN3@Insert
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00077	8b 10		 mov	 edx, DWORD PTR [eax]
  00079	3b 55 10	 cmp	 edx, DWORD PTR __Where$[ebp+8]
  0007c	73 21		 jae	 SHORT $LN2@Insert
$LN3@Insert:

; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");

  0007e	8b f4		 mov	 esi, esp
  00080	68 87 05 00 00	 push	 1415			; 00000587H
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Insert:

; 1416 : 		_DEBUG_RANGE(_First, _Last);

  0009f	68 88 05 00 00	 push	 1416			; 00000588H
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a9	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000ac	8b cc		 mov	 ecx, esp
  000ae	89 65 d0	 mov	 DWORD PTR $T9[ebp], esp
  000b1	8d 45 20	 lea	 eax, DWORD PTR __Last$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  000ba	89 45 b0	 mov	 DWORD PTR tv467[ebp], eax
  000bd	8b 4d b0	 mov	 ecx, DWORD PTR tv467[ebp]
  000c0	89 4d ac	 mov	 DWORD PTR tv441[ebp], ecx
  000c3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000c7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000ca	8b cc		 mov	 ecx, esp
  000cc	89 65 cc	 mov	 DWORD PTR $T8[ebp], esp
  000cf	8d 55 14	 lea	 edx, DWORD PTR __First$[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  000d8	89 45 a8	 mov	 DWORD PTR tv444[ebp], eax
  000db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000df	e8 00 00 00 00	 call	 ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  000e4	83 c4 20	 add	 esp, 32			; 00000020H

; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;

  000e7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 1420 : 		_Distance(_First, _Last, _Count);

  000ee	8d 45 e4	 lea	 eax, DWORD PTR __Count$[ebp]
  000f1	50		 push	 eax
  000f2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000f5	8b cc		 mov	 ecx, esp
  000f7	89 65 c8	 mov	 DWORD PTR $T7[ebp], esp
  000fa	8d 55 20	 lea	 edx, DWORD PTR __Last$[ebp]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00103	89 45 a4	 mov	 DWORD PTR tv469[ebp], eax
  00106	8b 45 a4	 mov	 eax, DWORD PTR tv469[ebp]
  00109	89 45 a0	 mov	 DWORD PTR tv447[ebp], eax
  0010c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00110	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00113	8b cc		 mov	 ecx, esp
  00115	89 65 c4	 mov	 DWORD PTR $T6[ebp], esp
  00118	8d 55 14	 lea	 edx, DWORD PTR __First$[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00121	89 45 9c	 mov	 DWORD PTR tv450[ebp], eax
  00124	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00128	e8 00 00 00 00	 call	 ??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
  0012d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1421 : 
; 1422 : 		if (_Count == 0)

  00130	83 7d e4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00134	75 05		 jne	 SHORT $LN4@Insert
  00136	e9 97 02 00 00	 jmp	 $LN5@Insert
$LN4@Insert:

; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)

  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unused_capacity
  00143	3b 45 e4	 cmp	 eax, DWORD PTR __Count$[ebp]
  00146	0f 83 d7 01 00
	00		 jae	 $LN6@Insert

; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)

  0014c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00154	8b f0		 mov	 esi, eax
  00156	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
  0015e	2b c6		 sub	 eax, esi
  00160	3b 45 e4	 cmp	 eax, DWORD PTR __Count$[ebp]
  00163	73 08		 jae	 SHORT $LN8@Insert

; 1427 : 				_Xlen();	// result too long

  00165	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Xlen
$LN8@Insert:

; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);

  0016d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  00175	03 45 e4	 add	 eax, DWORD PTR __Count$[ebp]
  00178	50		 push	 eax
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEII@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Grow_to
  00181	89 45 dc	 mov	 DWORD PTR __Capacity$12[ebp], eax

; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);

  00184	8b 45 dc	 mov	 eax, DWORD PTR __Capacity$12[ebp]
  00187	50		 push	 eax
  00188	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00190	8b c8		 mov	 ecx, eax
  00192	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::allocate
  00197	89 45 d8	 mov	 DWORD PTR __Newvec$11[ebp], eax

; 1431 : 			pointer _Ptr = _Newvec;

  0019a	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$11[ebp]
  0019d	89 4d d4	 mov	 DWORD PTR __Ptr$10[ebp], ecx

; 1432 : 
; 1433 : 			_TRY_BEGIN

  001a0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),

  001a4	8b 55 d8	 mov	 edx, DWORD PTR __Newvec$11[ebp]
  001a7	52		 push	 edx
  001a8	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+8]
  001ab	50		 push	 eax
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  001b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b6	51		 push	 ecx
  001b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	e8 00 00 00 00	 call	 ??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>
  001bf	89 45 98	 mov	 DWORD PTR tv471[ebp], eax
  001c2	8b 55 98	 mov	 edx, DWORD PTR tv471[ebp]
  001c5	89 55 d4	 mov	 DWORD PTR __Ptr$10[ebp], edx

; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff

  001c8	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$10[ebp]
  001cb	50		 push	 eax
  001cc	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001cf	8b cc		 mov	 ecx, esp
  001d1	89 65 c0	 mov	 DWORD PTR $T5[ebp], esp
  001d4	8d 55 20	 lea	 edx, DWORD PTR __Last$[ebp]
  001d7	52		 push	 edx
  001d8	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  001dd	89 45 94	 mov	 DWORD PTR tv472[ebp], eax
  001e0	8b 45 94	 mov	 eax, DWORD PTR tv472[ebp]
  001e3	89 45 90	 mov	 DWORD PTR tv453[ebp], eax
  001e6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  001ea	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001ed	8b cc		 mov	 ecx, esp
  001ef	89 65 bc	 mov	 DWORD PTR $T4[ebp], esp
  001f2	8d 55 14	 lea	 edx, DWORD PTR __First$[ebp]
  001f5	52		 push	 edx
  001f6	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  001fb	89 45 8c	 mov	 DWORD PTR tv456[ebp], eax
  001fe	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00202	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	e8 00 00 00 00	 call	 ??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Ucopy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  0020a	89 45 88	 mov	 DWORD PTR tv231[ebp], eax
  0020d	8b 45 88	 mov	 eax, DWORD PTR tv231[ebp]
  00210	89 45 d4	 mov	 DWORD PTR __Ptr$10[ebp], eax

; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),

  00213	8b 4d d4	 mov	 ecx, DWORD PTR __Ptr$10[ebp]
  00216	51		 push	 ecx
  00217	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0021f	8b 10		 mov	 edx, DWORD PTR [eax]
  00221	52		 push	 edx
  00222	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+8]
  00225	50		 push	 eax
  00226	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	e8 00 00 00 00	 call	 ??$_Umove@PAPAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@PAPAV2@00@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Umove<Entity * *>
  0022e	eb 36		 jmp	 SHORT $LN12@Insert
__catch$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);

  00230	8b 4d d4	 mov	 ecx, DWORD PTR __Ptr$10[ebp]
  00233	51		 push	 ecx
  00234	8b 55 d8	 mov	 edx, DWORD PTR __Newvec$11[ebp]
  00237	52		 push	 edx
  00238	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy

; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);

  00240	8b 45 dc	 mov	 eax, DWORD PTR __Capacity$12[ebp]
  00243	50		 push	 eax
  00244	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$11[ebp]
  00247	51		 push	 ecx
  00248	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0024b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00250	8b c8		 mov	 ecx, eax
  00252	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate

; 1442 : 			_RERAISE;

  00257	6a 00		 push	 0
  00259	6a 00		 push	 0
  0025b	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1443 : 			_CATCH_END

  00260	b8 00 00 00 00	 mov	 eax, $LN26@Insert
  00265	c3		 ret	 0
$LN12@Insert:
  00266	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0026d	eb 07		 jmp	 SHORT __tryend$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$1
$LN26@Insert:
  0026f	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
__tryend$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$1:

; 1444 : 
; 1445 : 			_Count += size();

  00276	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ?size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::size
  0027e	03 45 e4	 add	 eax, DWORD PTR __Count$[ebp]
  00281	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax

; 1446 : 			if (this->_Myfirst() != pointer())

  00284	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00287	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  0028c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0028f	74 52		 je	 SHORT $LN10@Insert

; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());

  00291	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00294	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00299	8b 10		 mov	 edx, DWORD PTR [eax]
  0029b	52		 push	 edx
  0029c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0029f	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  002a4	8b 00		 mov	 eax, DWORD PTR [eax]
  002a6	50		 push	 eax
  002a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002aa	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Destroy

; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),

  002af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002b2	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  002b7	8b f0		 mov	 esi, eax
  002b9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  002c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c3	2b 0e		 sub	 ecx, DWORD PTR [esi]
  002c5	c1 f9 02	 sar	 ecx, 2
  002c8	51		 push	 ecx
  002c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002cc	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  002d1	8b 10		 mov	 edx, DWORD PTR [eax]
  002d3	52		 push	 edx
  002d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  002dc	8b c8		 mov	 ecx, eax
  002de	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@QAEXPAPAVEntity@@I@Z ; std::_Wrap_alloc<std::allocator<Entity *> >::deallocate
$LN10@Insert:

; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();

  002e3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002e6	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Orphan_all

; 1454 : 			this->_Myend() = _Newvec + _Capacity;

  002eb	8b 45 dc	 mov	 eax, DWORD PTR __Capacity$12[ebp]
  002ee	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$11[ebp]
  002f1	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  002f4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myend
  002fc	89 30		 mov	 DWORD PTR [eax], esi

; 1455 : 			this->_Mylast() = _Newvec + _Count;

  002fe	8b 55 e4	 mov	 edx, DWORD PTR __Count$[ebp]
  00301	8b 45 d8	 mov	 eax, DWORD PTR __Newvec$11[ebp]
  00304	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  00307	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0030a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0030f	89 30		 mov	 DWORD PTR [eax], esi

; 1456 : 			this->_Myfirst() = _Newvec;

  00311	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00314	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Myfirst
  00319	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$11[ebp]
  0031c	89 08		 mov	 DWORD PTR [eax], ecx

; 1457 : 			}
; 1458 : 		else

  0031e	e9 af 00 00 00	 jmp	 $LN5@Insert
$LN6@Insert:

; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());

  00323	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0032b	8b 10		 mov	 edx, DWORD PTR [eax]
  0032d	52		 push	 edx
  0032e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00331	8b cc		 mov	 ecx, esp
  00333	89 65 b8	 mov	 DWORD PTR $T3[ebp], esp
  00336	8d 45 20	 lea	 eax, DWORD PTR __Last$[ebp]
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0033f	89 45 84	 mov	 DWORD PTR tv474[ebp], eax
  00342	8b 4d 84	 mov	 ecx, DWORD PTR tv474[ebp]
  00345	89 4d 80	 mov	 DWORD PTR tv460[ebp], ecx
  00348	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  0034c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0034f	8b cc		 mov	 ecx, esp
  00351	89 65 b4	 mov	 DWORD PTR $T2[ebp], esp
  00354	8d 55 14	 lea	 edx, DWORD PTR __First$[ebp]
  00357	52		 push	 edx
  00358	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0035d	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv463[ebp], eax
  00363	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00367	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0036a	e8 00 00 00 00	 call	 ??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Ucopy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >

; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),

  0036f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00377	8b 00		 mov	 eax, DWORD PTR [eax]
  00379	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0037c	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0037f	52		 push	 edx
  00380	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00383	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  00388	8b 00		 mov	 eax, DWORD PTR [eax]
  0038a	50		 push	 eax
  0038b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+8]
  0038e	51		 push	 ecx
  0038f	e8 00 00 00 00	 call	 ??$rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00@Z ; std::rotate<Entity * *>
  00394	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;

  00397	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  0039f	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  003a5	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv424[ebp]
  003ab	8b 02		 mov	 eax, DWORD PTR [edx]
  003ad	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  003b0	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  003b3	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv424[ebp]
  003b9	89 10		 mov	 DWORD PTR [eax], edx

; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());

  003bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003be	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAPAPAVEntity@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Mylast
  003c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c5	51		 push	 ecx
  003c6	8b 55 10	 mov	 edx, DWORD PTR __Where$[ebp+8]
  003c9	52		 push	 edx
  003ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003cd	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IBEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range
$LN5@Insert:

; 1465 : 			}
; 1466 : 		}

  003d2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  003d6	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  003d9	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  003de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  003e2	8d 4d 14	 lea	 ecx, DWORD PTR __First$[ebp]
  003e5	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  003ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003f1	8d 4d 20	 lea	 ecx, DWORD PTR __Last$[ebp]
  003f4	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
$LN11@Insert:
  003f9	52		 push	 edx
  003fa	8b cd		 mov	 ecx, ebp
  003fc	50		 push	 eax
  003fd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN30@Insert
  00403	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00408	58		 pop	 eax
  00409	5a		 pop	 edx
  0040a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0040d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00414	59		 pop	 ecx
  00415	5f		 pop	 edi
  00416	5e		 pop	 esi
  00417	5b		 pop	 ebx
  00418	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0041e	3b ec		 cmp	 ebp, esp
  00420	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00425	8b e5		 mov	 esp, ebp
  00427	5d		 pop	 ebp
  00428	c2 28 00	 ret	 40			; 00000028H
  0042b	90		 npad	 1
$LN30@Insert:
  0042c	01 00 00 00	 DD	 1
  00430	00 00 00 00	 DD	 $LN29@Insert
$LN29@Insert:
  00434	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00438	04 00 00 00	 DD	 4
  0043c	00 00 00 00	 DD	 $LN27@Insert
$LN27@Insert:
  00440	5f		 DB	 95			; 0000005fH
  00441	43		 DB	 67			; 00000043H
  00442	6f		 DB	 111			; 0000006fH
  00443	75		 DB	 117			; 00000075H
  00444	6e		 DB	 110			; 0000006eH
  00445	74		 DB	 116			; 00000074H
  00446	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$2:
  00000	8d 4d 20	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$3:
  00008	8d 4d 14	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$4:
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$5:
  00018	8b 4d d0	 mov	 ecx, DWORD PTR $T9[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$7:
  00020	8b 4d c8	 mov	 ecx, DWORD PTR $T7[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$9:
  00028	8b 4d c0	 mov	 ecx, DWORD PTR $T5[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$11:
  00030	8b 4d b8	 mov	 ecx, DWORD PTR $T3[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z:
  00038	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003f	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  00051	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<std::pair<RigidBody *,int> >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<Entity * const>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@QAVEntity@@@std@@YAPBQAVEntity@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<Entity * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z PROC ; std::forward<Entity * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z ENDP ; std::forward<Entity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z ; std::forward<Entity * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@AAPAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ; std::allocator<Entity *>::construct<Entity *,Entity * &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z PROC ; std::forward<Entity * const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z ENDP ; std::forward<Entity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z ; std::forward<Entity * const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVEntity@@ABQAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ; std::allocator<Entity *>::construct<Entity *,Entity * const &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@PAPAVEntity@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<EntityComponent * const>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@QAVEntityComponent@@@std@@YAPBQAVEntityComponent@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<EntityComponent * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z PROC ; std::forward<EntityComponent * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z ENDP ; std::forward<EntityComponent * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVEntityComponent@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z ; std::forward<EntityComponent * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@AAPAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVEntityComponent@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z PROC ; std::forward<EntityComponent * const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z ENDP ; std::forward<EntityComponent * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVEntityComponent@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z ; std::forward<EntityComponent * const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVEntityComponent@@ABQAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * const &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVEntityComponent@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEntityComponent@@@std@@@std@@SAXAAV?$allocator@PAVEntityComponent@@@1@PAPAVEntityComponent@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<EntityComponent *> >::construct<EntityComponent *,EntityComponent * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@YAABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@YAABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::pair<RigidBody *,int> > const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@YAABV?$allocator@U?$pair@PAVRigidBody@@H@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::pair<RigidBody *,int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z PROC ; std::forward<std::allocator<EntityComponent *> >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@PAVEntityComponent@@@std@@@std@@YA$$QAV?$allocator@PAVEntityComponent@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<EntityComponent *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PAVEntityComponent@@@std@@@std@@YAABV?$allocator@PAVEntityComponent@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@PAVEntityComponent@@@std@@@std@@YAABV?$allocator@PAVEntityComponent@@@0@ABV10@@Z PROC ; std::forward<std::allocator<EntityComponent *> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@PAVEntityComponent@@@std@@@std@@YAABV?$allocator@PAVEntityComponent@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<EntityComponent *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z PROC ; std::forward<std::allocator<Entity *> >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@PAVEntity@@@std@@@std@@YA$$QAV?$allocator@PAVEntity@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PAVEntity@@@std@@@std@@YAABV?$allocator@PAVEntity@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@PAVEntity@@@std@@@std@@YAABV?$allocator@PAVEntity@@@0@ABV10@@Z PROC ; std::forward<std::allocator<Entity *> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@PAVEntity@@@std@@@std@@YAABV?$allocator@PAVEntity@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<Entity *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 780  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 781  : 		}

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 780  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 781  : 		}

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U?$pair@PAVRigidBody@@H@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@PAVRigidBody@@H@0@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U?$pair@PAVRigidBody@@H@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@PAVRigidBody@@H@0@0@Z PROC ; std::_Ptr_cat<std::pair<RigidBody *,int>,std::pair<RigidBody *,int> >, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Ptr_cat
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
  00033	90		 npad	 1
$LN5@Ptr_cat:
  00034	01 00 00 00	 DD	 1
  00038	00 00 00 00	 DD	 $LN4@Ptr_cat
$LN4@Ptr_cat:
  0003c	fb ff ff ff	 DD	 -5			; fffffffbH
  00040	01 00 00 00	 DD	 1
  00044	00 00 00 00	 DD	 $LN3@Ptr_cat
$LN3@Ptr_cat:
  00048	5f		 DB	 95			; 0000005fH
  00049	43		 DB	 67			; 00000043H
  0004a	61		 DB	 97			; 00000061H
  0004b	74		 DB	 116			; 00000074H
  0004c	00		 DB	 0
??$_Ptr_cat@U?$pair@PAVRigidBody@@H@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@PAVRigidBody@@H@0@0@Z ENDP ; std::_Ptr_cat<std::pair<RigidBody *,int>,std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >, COMDAT

; 170  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 08	 add	 eax, 8
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 17		 je	 SHORT $LN1@Destroy_ra

; 172  : 		_Al.destroy(_STD addressof(*_First));

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$addressof@U?$pair@PAVRigidBody@@H@std@@@std@@YAPAU?$pair@PAVRigidBody@@H@0@AAU10@@Z ; std::addressof<std::pair<RigidBody *,int> >
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00026	e8 00 00 00 00	 call	 ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
  0002b	eb d8		 jmp	 SHORT $LN2@Destroy_ra
$LN1@Destroy_ra:

; 173  : 	}

  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@@std@@YAXPAU?$pair@PAVRigidBody@@H@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 	return (_Rechecked(_Dest,

  00003	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninit_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<Entity * *,Entity * *>
  00040	83 c4 08	 add	 esp, 8
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Uninitialized_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z PROC ; std::_Ptr_cat<Entity *,Entity *>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Ptr_cat
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
  00033	90		 npad	 1
$LN5@Ptr_cat:
  00034	01 00 00 00	 DD	 1
  00038	00 00 00 00	 DD	 $LN4@Ptr_cat
$LN4@Ptr_cat:
  0003c	fb ff ff ff	 DD	 -5			; fffffffbH
  00040	01 00 00 00	 DD	 1
  00044	00 00 00 00	 DD	 $LN3@Ptr_cat
$LN3@Ptr_cat:
  00048	5f		 DB	 95			; 0000005fH
  00049	43		 DB	 67			; 00000043H
  0004a	61		 DB	 97			; 00000061H
  0004b	74		 DB	 116			; 00000074H
  0004c	00		 DB	 0
??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z ENDP ; std::_Ptr_cat<Entity *,Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAXPAPAVEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z PROC ; std::_Uninitialized_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 	return (_Rechecked(_Dest,

  00003	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Unchecked<EntityComponent * *>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Unchecked<EntityComponent * *>
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Unchecked<EntityComponent * *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ; std::_Uninit_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Rechecked@PAPAVEntityComponent@@PAPAV1@@std@@YAAAPAPAVEntityComponent@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<EntityComponent * *,EntityComponent * *>
  00040	83 c4 08	 add	 esp, 8
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Uninitialized_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z PROC ; std::_Ptr_cat<EntityComponent *,EntityComponent *>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Ptr_cat
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
  00033	90		 npad	 1
$LN5@Ptr_cat:
  00034	01 00 00 00	 DD	 1
  00038	00 00 00 00	 DD	 $LN4@Ptr_cat
$LN4@Ptr_cat:
  0003c	fb ff ff ff	 DD	 -5			; fffffffbH
  00040	01 00 00 00	 DD	 1
  00044	00 00 00 00	 DD	 $LN3@Ptr_cat
$LN3@Ptr_cat:
  00048	5f		 DB	 95			; 0000005fH
  00049	43		 DB	 67			; 00000043H
  0004a	61		 DB	 97			; 00000061H
  0004b	74		 DB	 116			; 00000074H
  0004c	00		 DB	 0
??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z ENDP ; std::_Ptr_cat<EntityComponent *,EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >, COMDAT

; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAXPAPAVEntityComponent@@0AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Ptr_cat
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
  00033	90		 npad	 1
$LN5@Ptr_cat:
  00034	01 00 00 00	 DD	 1
  00038	00 00 00 00	 DD	 $LN4@Ptr_cat
$LN4@Ptr_cat:
  0003c	fb ff ff ff	 DD	 -5			; fffffffbH
  00040	01 00 00 00	 DD	 1
  00044	00 00 00 00	 DD	 $LN3@Ptr_cat
$LN3@Ptr_cat:
  00048	5f		 DB	 95			; 0000005fH
  00049	43		 DB	 67			; 00000043H
  0004a	61		 DB	 97			; 00000061H
  0004b	74		 DB	 116			; 00000074H
  0004c	00		 DB	 0
??$_Ptr_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 170  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 17		 je	 SHORT $LN1@Destroy_ra

; 172  : 		_Al.destroy(_STD addressof(*_First));

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00026	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0002b	eb d8		 jmp	 SHORT $LN2@Destroy_ra
$LN1@Destroy_ra:

; 173  : 	}

  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -36						; size = 4
tv137 = -32						; size = 4
tv143 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 804  : 	{	// test iterator pair for valid range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 805  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

  00043	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00046	50		 push	 eax
  00047	8d 4d f3	 lea	 ecx, DWORD PTR $T4[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00050	83 c4 08	 add	 esp, 8
  00053	8a 10		 mov	 dl, BYTE PTR [eax]
  00055	0f b6 c2	 movzx	 eax, dl
  00058	50		 push	 eax
  00059	8b 4d 24	 mov	 ecx, DWORD PTR __Line$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 20	 mov	 edx, DWORD PTR __File$[ebp]
  00060	52		 push	 edx
  00061	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00064	8b cc		 mov	 ecx, esp
  00066	89 65 ec	 mov	 DWORD PTR $T3[ebp], esp
  00069	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00072	89 45 e4	 mov	 DWORD PTR tv143[ebp], eax
  00075	8b 4d e4	 mov	 ecx, DWORD PTR tv143[ebp]
  00078	89 4d e0	 mov	 DWORD PTR tv137[ebp], ecx
  0007b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00082	8b cc		 mov	 ecx, esp
  00084	89 65 e8	 mov	 DWORD PTR $T2[ebp], esp
  00087	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00090	89 45 dc	 mov	 DWORD PTR tv140[ebp], eax
  00093	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00097	e8 00 00 00 00	 call	 ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  0009c	83 c4 24	 add	 esp, 36			; 00000024H

; 806  : 	}

  0009f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000a3	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a6	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b2	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000b5	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	83 c4 24	 add	 esp, 36			; 00000024H
  000c8	3b ec		 cmp	 ebp, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z$2:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z
_TEXT	SEGMENT
tv138 = -36						; size = 4
tv135 = -32						; size = 4
tv141 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Off$ = 32						; size = 4
??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>, COMDAT

; 994  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 995  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00043	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00046	50		 push	 eax
  00047	8d 4d f3	 lea	 ecx, DWORD PTR $T4[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ??$_Iter_cat@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00050	83 c4 08	 add	 esp, 8
  00053	8a 10		 mov	 dl, BYTE PTR [eax]
  00055	0f b6 c2	 movzx	 eax, dl
  00058	50		 push	 eax
  00059	8b 4d 20	 mov	 ecx, DWORD PTR __Off$[ebp]
  0005c	51		 push	 ecx
  0005d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00060	8b cc		 mov	 ecx, esp
  00062	89 65 ec	 mov	 DWORD PTR $T3[ebp], esp
  00065	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0006e	89 45 e4	 mov	 DWORD PTR tv141[ebp], eax
  00071	8b 45 e4	 mov	 eax, DWORD PTR tv141[ebp]
  00074	89 45 e0	 mov	 DWORD PTR tv135[ebp], eax
  00077	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007e	8b cc		 mov	 ecx, esp
  00080	89 65 e8	 mov	 DWORD PTR $T2[ebp], esp
  00083	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0008c	89 45 dc	 mov	 DWORD PTR tv138[ebp], eax
  0008f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00093	e8 00 00 00 00	 call	 ??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
  00098	83 c4 20	 add	 esp, 32			; 00000020H

; 996  : 	}

  0009b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0009f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a2	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ae	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000b1	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c0	59		 pop	 ecx
  000c1	83 c4 24	 add	 esp, 36			; 00000024H
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z$2:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
tv66 = -44						; size = 4
tv142 = -40						; size = 4
tv139 = -36						; size = 4
tv145 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Ptr$ = 32						; size = 4
??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Ucopy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT
; _this$ = ecx

; 1670 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00045	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1671 : 		return (_Uninitialized_copy(_First, _Last,

  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Entity *,std::allocator<Entity *> > >::_Getal
  00054	50		 push	 eax
  00055	8b 45 20	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00058	50		 push	 eax
  00059	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005c	8b cc		 mov	 ecx, esp
  0005e	89 65 e8	 mov	 DWORD PTR $T3[ebp], esp
  00061	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0006a	89 45 e0	 mov	 DWORD PTR tv145[ebp], eax
  0006d	8b 45 e0	 mov	 eax, DWORD PTR tv145[ebp]
  00070	89 45 dc	 mov	 DWORD PTR tv139[ebp], eax
  00073	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00077	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007a	8b cc		 mov	 ecx, esp
  0007c	89 65 e4	 mov	 DWORD PTR $T2[ebp], esp
  0007f	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  00088	89 45 d8	 mov	 DWORD PTR tv142[ebp], eax
  0008b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
  00094	83 c4 20	 add	 esp, 32			; 00000020H
  00097	89 45 d4	 mov	 DWORD PTR tv66[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR tv66[ebp]
  0009d	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  000a0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000a4	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a7	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000b6	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000bb	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]

; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}

  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	83 c4 2c	 add	 esp, 44			; 0000002cH
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z$2:
  00010	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@IAEPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Ucopy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00@Z PROC ; std::rotate<Entity * *>, COMDAT

; 3495 : 	{	// rotate [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3496 : 	_DEBUG_RANGE(_First, _Mid);

  0000b	68 a8 0d 00 00	 push	 3496			; 00000da8H
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z ; std::_Debug_range<Entity * *>
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 3497 : 	_DEBUG_RANGE(_Mid, _Last);

  00025	68 a9 0d 00 00	 push	 3497			; 00000da9H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00032	52		 push	 edx
  00033	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z ; std::_Debug_range<Entity * *>
  0003c	83 c4 10	 add	 esp, 16			; 00000010H

; 3498 : 	if (_First == _Mid)

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Mid$[ebp]
  00045	75 05		 jne	 SHORT $LN2@rotate

; 3499 : 		return (_Last);

  00047	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0004a	eb 62		 jmp	 SHORT $LN1@rotate
$LN2@rotate:

; 3500 : 	if (_Mid == _Last)

  0004c	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  0004f	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  00052	75 05		 jne	 SHORT $LN3@rotate

; 3501 : 		return (_First);

  00054	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00057	eb 55		 jmp	 SHORT $LN1@rotate
$LN3@rotate:

; 3502 : 	_Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),

  00059	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0005c	50		 push	 eax
  0005d	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ; std::_Iter_cat<Entity * *>
  00066	83 c4 08	 add	 esp, 8
  00069	8a 10		 mov	 dl, BYTE PTR [eax]
  0006b	0f b6 c2	 movzx	 eax, dl
  0006e	50		 push	 eax
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00078	83 c4 04	 add	 esp, 4
  0007b	50		 push	 eax
  0007c	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00092	83 c4 04	 add	 esp, 4
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ??$_Rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<Entity * *>
  0009b	83 c4 10	 add	 esp, 16			; 00000010H
  0009e	50		 push	 eax
  0009f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<Entity * *,Entity * *>
  000a8	83 c4 08	 add	 esp, 8

; 3503 : 		_Unchecked(_Last), _Iter_cat(_First)));
; 3504 : 	return (_First);

  000ab	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
$LN1@rotate:

; 3505 : 	}

  000ae	83 c4 04	 add	 esp, 4
  000b1	3b ec		 cmp	 ebp, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
??$rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00@Z ENDP ; std::rotate<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@AAPAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntity@@AAPAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z PROC ; std::allocator<Entity *>::construct<Entity *,Entity * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@AAPAVEntity@@@std@@YAAAPAVEntity@@AAPAV1@@Z ; std::forward<Entity * &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVEntity@@AAPAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@AAPAV2@@Z ENDP ; std::allocator<Entity *>::construct<Entity *,Entity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntity@@ABQAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntity@@ABQAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z PROC ; std::allocator<Entity *>::construct<Entity *,Entity * const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@ABQAVEntity@@@std@@YAABQAVEntity@@ABQAV1@@Z ; std::forward<Entity * const &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVEntity@@ABQAV1@@?$allocator@PAVEntity@@@std@@QAEXPAPAVEntity@@ABQAV2@@Z ENDP ; std::allocator<Entity *>::construct<Entity *,Entity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@AAPAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntityComponent@@AAPAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z PROC ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@AAPAVEntityComponent@@@std@@YAAAPAVEntityComponent@@AAPAV1@@Z ; std::forward<EntityComponent * &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVEntityComponent@@AAPAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@AAPAV2@@Z ENDP ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEntityComponent@@ABQAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVEntityComponent@@ABQAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z PROC ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@ABQAVEntityComponent@@@std@@YAABQAVEntityComponent@@ABQAV1@@Z ; std::forward<EntityComponent * const &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVEntityComponent@@ABQAV1@@?$allocator@PAVEntityComponent@@@std@@QAEXPAPAVEntityComponent@@ABQAV2@@Z ENDP ; std::allocator<EntityComponent *>::construct<EntityComponent *,EntityComponent * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 08		 push	 8
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 21		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 10		 mov	 edx, DWORD PTR [eax]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00049	89 11		 mov	 DWORD PTR [ecx], edx
  0004b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0004e	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00051	89 55 f4	 mov	 DWORD PTR tv74[ebp], edx
  00054	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00056	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN1@construct:

; 656  : 		}

  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator_traits@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@PAU?$pair@PAVRigidBody@@H@1@@Z ; std::allocator_traits<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
  0001b	83 c4 08	 add	 esp, 8

; 926  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z PROC ; std::_Unchecked<Entity * *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ENDP ; std::_Unchecked<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z PROC ; std::_Uninit_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z ; std::_Ptr_cat<Entity *,Entity *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Val_type@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Val_type<Entity * *>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00037	52		 push	 edx
  00038	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ??$_Uninit_move@PAVEntity@@PAV1@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Entity *,Entity *,Entity *>
  00045	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Uninit_move@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ENDP ; std::_Uninit_move<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<Entity * *,Entity * *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 449  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z PROC ; std::_Unchecked<EntityComponent * *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ENDP ; std::_Unchecked<EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z PROC ; std::_Uninit_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVEntityComponent@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntityComponent@@0@Z ; std::_Ptr_cat<EntityComponent *,EntityComponent *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Val_type@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ; std::_Val_type<EntityComponent * *>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00037	52		 push	 edx
  00038	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ??$_Uninit_move@PAVEntityComponent@@PAV1@PAV1@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EntityComponent *,EntityComponent *,EntityComponent *>
  00045	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Uninit_move@PAPAVEntityComponent@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@std@@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@@Z ENDP ; std::_Uninit_move<EntityComponent * *,EntityComponent * *,std::_Wrap_alloc<std::allocator<EntityComponent *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVEntityComponent@@PAPAV1@@std@@YAAAPAPAVEntityComponent@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVEntityComponent@@PAPAV1@@std@@YAAAPAPAVEntityComponent@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<EntityComponent * *,EntityComponent * *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 449  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Rechecked@PAPAVEntityComponent@@PAPAV1@@std@@YAAAPAPAVEntityComponent@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<EntityComponent * *,EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0001b	83 c4 08	 add	 esp, 8

; 926  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 1c		 push	 28			; 0000001cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 791  : 	{	// test iterator pair for valid range, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 792  : 	if (_First != _Last)

  0002a	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00031	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator!=
  00036	0f b6 c8	 movzx	 ecx, al
  00039	85 c9		 test	 ecx, ecx
  0003b	74 5a		 je	 SHORT $LN2@Debug_rang

; 793  : 		{	// check for non-null pointers, valid range
; 794  : 		_DEBUG_POINTER2(_First, _File, _Line);

  0003d	8b 55 24	 mov	 edx, DWORD PTR __Line$[ebp]
  00040	52		 push	 edx
  00041	8b 45 20	 mov	 eax, DWORD PTR __File$[ebp]
  00044	50		 push	 eax
  00045	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 795  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  00051	8b 55 24	 mov	 edx, DWORD PTR __Line$[ebp]
  00054	52		 push	 edx
  00055	8b 45 20	 mov	 eax, DWORD PTR __File$[ebp]
  00058	50		 push	 eax
  00059	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 796  : 		if (_Last < _First)

  00065	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00068	52		 push	 edx
  00069	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  0006c	e8 00 00 00 00	 call	 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator<
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 1f		 je	 SHORT $LN2@Debug_rang

; 797  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  00078	8b f4		 mov	 esi, esp
  0007a	8b 4d 24	 mov	 ecx, DWORD PTR __Line$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 20	 mov	 edx, DWORD PTR __File$[ebp]
  00081	52		 push	 edx
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	3b f4		 cmp	 esi, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Debug_rang:

; 798  : 		}
; 799  : 	}

  00097	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0009b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0009e	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000aa	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000ad	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5e		 pop	 esi
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Off$ = 32						; size = 4
___formal$ = 36						; size = 1
??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>, COMDAT

; 970  : 	{	// add to _Off distance between random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 971  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 972  : 	if (_First != _Last)

  00029	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00030	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator!=
  00035	0f b6 c8	 movzx	 ecx, al
  00038	85 c9		 test	 ecx, ecx
  0003a	74 2c		 je	 SHORT $LN2@Distance2

; 973  : 		{	// check for null pointers
; 974  : 		_DEBUG_POINTER(_First);

  0003c	68 ce 03 00 00	 push	 974			; 000003ceH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00046	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 975  : 		_DEBUG_POINTER(_Last);

  00052	68 cf 03 00 00	 push	 975			; 000003cfH
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0005c	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Distance2:

; 976  : 		}
; 977  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 978  : 
; 979  : 	_Off += _Last - _First;

  00068	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0006b	51		 push	 ecx
  0006c	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  0006f	e8 00 00 00 00	 call	 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-
  00074	8b 55 20	 mov	 edx, DWORD PTR __Off$[ebp]
  00077	03 02		 add	 eax, DWORD PTR [edx]
  00079	8b 4d 20	 mov	 ecx, DWORD PTR __Off$[ebp]
  0007c	89 01		 mov	 DWORD PTR [ecx], eax

; 980  : 	}

  0007e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00082	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00085	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  0008a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00091	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00094	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Distance2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@I@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,unsigned int>
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
_TEXT	SEGMENT
tv67 = -44						; size = 4
tv148 = -40						; size = 4
tv147 = -36						; size = 4
tv144 = -32						; size = 4
tv143 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 425  : 	return (_Rechecked(_Dest,

  00049	8b 45 24	 mov	 eax, DWORD PTR __Al$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 20	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00056	83 c4 04	 add	 esp, 4
  00059	50		 push	 eax
  0005a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005d	8b cc		 mov	 ecx, esp
  0005f	89 65 ec	 mov	 DWORD PTR $T3[ebp], esp
  00062	8d 55 14	 lea	 edx, DWORD PTR __Last$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0006b	89 45 e4	 mov	 DWORD PTR tv143[ebp], eax
  0006e	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Entity *> > >
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
  00079	8b 45 e0	 mov	 eax, DWORD PTR tv144[ebp]
  0007c	50		 push	 eax
  0007d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00080	8b cc		 mov	 ecx, esp
  00082	89 65 e8	 mov	 DWORD PTR $T2[ebp], esp
  00085	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
  0008e	89 45 dc	 mov	 DWORD PTR tv147[ebp], eax
  00091	e8 00 00 00 00	 call	 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Entity *> > >
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	89 45 d8	 mov	 DWORD PTR tv148[ebp], eax
  0009c	8b 45 d8	 mov	 eax, DWORD PTR tv148[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ; std::_Uninit_copy<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	89 45 d4	 mov	 DWORD PTR tv67[ebp], eax
  000ab	8b 4d d4	 mov	 ecx, DWORD PTR tv67[ebp]
  000ae	51		 push	 ecx
  000af	8d 55 20	 lea	 edx, DWORD PTR __Dest$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ??$_Rechecked@PAPAVEntity@@PAPAV1@@std@@YAAAPAPAVEntity@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<Entity * *,Entity * *>
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  000c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c4	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  000c7	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d3	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  000d6	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  000db	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  000de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e8	59		 pop	 ecx
  000e9	83 c4 2c	 add	 esp, 44			; 0000002cH
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@PAPAVEntity@@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@2@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z PROC ; std::_Debug_range<Entity * *>, COMDAT

; 804  : 	{	// test iterator pair for valid range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 805  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ; std::_Iter_cat<Entity * *>
  00018	83 c4 08	 add	 esp, 8
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	0f b6 c2	 movzx	 eax, dl
  00020	50		 push	 eax
  00021	8b 4d 14	 mov	 ecx, DWORD PTR __Line$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 10	 mov	 edx, DWORD PTR __File$[ebp]
  00028	52		 push	 edx
  00029	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$_Debug_range2@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Entity * *>
  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 806  : 	}

  00039	83 c4 04	 add	 esp, 4
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z ENDP ; std::_Debug_range<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z PROC ; std::_Iter_cat<Entity * *>, COMDAT

; 601  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 602  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 603  : 	return (_Cat);

  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8a 4d fb	 mov	 cl, BYTE PTR __Cat$[ebp]
  00021	88 08		 mov	 BYTE PTR [eax], cl
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 604  : 	}

  00026	52		 push	 edx
  00027	8b cd		 mov	 ecx, ebp
  00029	50		 push	 eax
  0002a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Iter_cat
  00030	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00035	58		 pop	 eax
  00036	5a		 pop	 edx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
  0003b	90		 npad	 1
$LN5@Iter_cat:
  0003c	01 00 00 00	 DD	 1
  00040	00 00 00 00	 DD	 $LN4@Iter_cat
$LN4@Iter_cat:
  00044	fb ff ff ff	 DD	 -5			; fffffffbH
  00048	01 00 00 00	 DD	 1
  0004c	00 00 00 00	 DD	 $LN3@Iter_cat
$LN3@Iter_cat:
  00050	5f		 DB	 95			; 0000005fH
  00051	43		 DB	 67			; 00000043H
  00052	61		 DB	 97			; 00000061H
  00053	74		 DB	 116			; 00000074H
  00054	00		 DB	 0
??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ENDP ; std::_Iter_cat<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<Entity * *>, COMDAT

; 3486 : 	{	// rotate [_First, _Last), random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3487 : 	_STD reverse(_First, _Mid);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z ; std::reverse<Entity * *>
  00010	83 c4 08	 add	 esp, 8

; 3488 : 	_STD reverse(_Mid, _Last);

  00013	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00016	52		 push	 edx
  00017	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z ; std::reverse<Entity * *>
  00020	83 c4 08	 add	 esp, 8

; 3489 : 	_STD reverse(_First, _Last);

  00023	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z ; std::reverse<Entity * *>
  00030	83 c4 08	 add	 esp, 8

; 3490 : 	return (_First + (_Last - _Mid));

  00033	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00036	2b 45 0c	 sub	 eax, DWORD PTR __Mid$[ebp]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 3491 : 	}

  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Rotate@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator_traits@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@PAU?$pair@PAVRigidBody@@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator_traits@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@PAU?$pair@PAVRigidBody@@H@1@@Z PROC ; std::allocator_traits<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 780  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ; std::allocator<std::pair<RigidBody *,int> >::destroy<std::pair<RigidBody *,int> >

; 781  : 		}

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator_traits@V?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@PAVRigidBody@@H@std@@@1@PAU?$pair@PAVRigidBody@@H@1@@Z ENDP ; std::allocator_traits<std::allocator<std::pair<RigidBody *,int> > >::destroy<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z PROC ; std::_Val_type<Entity * *>, COMDAT

; 874  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 	return (0);

  00003	33 c0		 xor	 eax, eax

; 876  : 	}

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
??$_Val_type@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ENDP ; std::_Val_type<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVEntity@@PAV1@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVEntity@@PAV1@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Entity *,Entity *,Entity *>, COMDAT

; 468  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 469  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);

  0000c	68 d5 01 00 00	 push	 469			; 000001d5H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00016	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<Entity * *,Entity * *>
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 470  : 	size_t _Count = (size_t)(_Last - _First);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00030	c1 f8 02	 sar	 eax, 2
  00033	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 471  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	c1 e1 02	 shl	 ecx, 2
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 472  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
; 473  : 	}

  0005d	5e		 pop	 esi
  0005e	83 c4 04	 add	 esp, 4
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Uninit_move@PAVEntity@@PAV1@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Entity *,Entity *,Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z PROC ; std::_Val_type<EntityComponent * *>, COMDAT

; 874  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 	return (0);

  00003	33 c0		 xor	 eax, eax

; 876  : 	}

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
??$_Val_type@PAPAVEntityComponent@@@std@@YAPAPAVEntityComponent@@PAPAV1@@Z ENDP ; std::_Val_type<EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVEntityComponent@@PAV1@PAV1@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVEntityComponent@@PAV1@PAV1@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<EntityComponent *,EntityComponent *,EntityComponent *>, COMDAT

; 468  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 469  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);

  0000c	68 d5 01 00 00	 push	 469			; 000001d5H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00016	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Debug_range_ptr@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<EntityComponent * *,EntityComponent * *>
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 470  : 	size_t _Count = (size_t)(_Last - _First);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00030	c1 f8 02	 sar	 eax, 2
  00033	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 471  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	c1 e1 02	 shl	 ecx, 2
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 472  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
; 473  : 	}

  0005d	5e		 pop	 esi
  0005e	83 c4 04	 add	 esp, 4
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Uninit_move@PAVEntityComponent@@PAV1@PAV1@@std@@YAPAPAVEntityComponent@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntityComponent@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<EntityComponent *,EntityComponent *,EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 780  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 781  : 		}

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator<, COMDAT
; _this$ = ecx

; 215  : 		{	// test if this < _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 		_Compat(_Right);

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat

; 217  : 		return (this->_Ptr < _Right._Ptr);

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00029	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0002c	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0002f	73 09		 jae	 SHORT $LN3@operator
  00031	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00038	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00041	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 218  : 		}

  00044	83 c4 08	 add	 esp, 8
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 211  : 		return (!(*this == _Right));

  00017	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator==
  00023	0f b6 c8	 movzx	 ecx, al
  00026	85 c9		 test	 ecx, ecx
  00028	75 09		 jne	 SHORT $LN3@operator
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0003a	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 212  : 		}

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-, COMDAT
; _this$ = ecx

; 383  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 384  : 		return (*(_Mybase *)this - _Right);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-

; 385  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat, COMDAT
; _this$ = ecx

; 237  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 		if (this->_Getcont() == 0
; 239  : 			|| this->_Getcont() != _Right._Getcont())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00017	85 c0		 test	 eax, eax
  00019	74 1a		 je	 SHORT $LN3@Compat
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00023	8b f0		 mov	 esi, eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002d	3b f0		 cmp	 esi, eax
  0002f	0f 84 86 00 00
	00		 je	 $LN1@Compat
$LN3@Compat:

; 240  : 			{	// report error
; 241  : 			_DEBUG_ERROR("vector iterators incompatible");

  00035	8b f4		 mov	 esi, esp
  00037	68 f1 00 00 00	 push	 241			; 000000f1H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 242  : 			_SCL_SECURE_INVALID_ARGUMENT;

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
  0005b	85 c0		 test	 eax, eax
  0005d	74 04		 je	 SHORT $LN5@Compat
  0005f	33 c9		 xor	 ecx, ecx
  00061	75 30		 jne	 SHORT $LN6@Compat
$LN5@Compat:
  00063	8b f4		 mov	 esi, esp
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0006f	6a 00		 push	 0
  00071	68 f2 00 00 00	 push	 242			; 000000f2H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0007b	6a 02		 push	 2
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	83 f8 01	 cmp	 eax, 1
  00090	75 01		 jne	 SHORT $LN6@Compat
  00092	cc		 int	 3
$LN6@Compat:
  00093	8b f4		 mov	 esi, esp
  00095	6a 00		 push	 0
  00097	68 f2 00 00 00	 push	 242			; 000000f2H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1IM@LECEOODI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@OMIDEADP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Compat:

; 243  : 			}
; 244  : 		}

  000bb	5e		 pop	 esi
  000bc	83 c4 04	 add	 esp, 4
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 		if (this->_Getcont() != _Right._Getcont())

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00020	8b f0		 mov	 esi, eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	3b f0		 cmp	 esi, eax
  0002c	74 0c		 je	 SHORT $LN2@operator

; 205  : 			_Compat(_Right);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat
$LN2@operator:

; 206  : 		return (this->_Ptr == _Right._Ptr);

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00040	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00043	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00046	75 09		 jne	 SHORT $LN4@operator
  00048	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  0004f	eb 07		 jmp	 SHORT $LN5@operator
$LN4@operator:
  00051	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN5@operator:
  00058	8a 45 f8	 mov	 al, BYTE PTR tv82[ebp]

; 207  : 		}

  0005b	5e		 pop	 esi
  0005c	83 c4 08	 add	 esp, 8
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  : 		_Compat(_Right);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Compat

; 194  : 		return (this->_Ptr - _Right._Ptr);

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00020	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00023	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00026	c1 f8 02	 sar	 eax, 2

; 195  : 		}

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 755  : 	{	// (don't) test non-pointer for non-singularity, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT

; 396  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 397  : 	return (_Iter._Unchecked());

  00031	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unchecked
  00039	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00046	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]

; 398  : 	}

  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Entity *> > >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z PROC ; std::_Uninit_copy<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEntity@@0@Z ; std::_Ptr_cat<Entity *,Entity *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVEntity@@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Entity *,Entity *>
  00038	83 c4 14	 add	 esp, 20			; 00000014H

; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  0003b	83 c4 04	 add	 esp, 4
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Uninit_copy@PAPAVEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@std@@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@@Z ENDP ; std::_Uninit_copy<Entity * *,Entity * *,std::_Wrap_alloc<std::allocator<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<Entity * *>, COMDAT

; 791  : 	{	// test iterator pair for valid range, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 792  : 	if (_First != _Last)

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000a	74 4f		 je	 SHORT $LN1@Debug_rang

; 793  : 		{	// check for non-null pointers, valid range
; 794  : 		_DEBUG_POINTER2(_First, _File, _Line);

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR __Line$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 10	 mov	 edx, DWORD PTR __File$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 795  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  00020	8b 4d 14	 mov	 ecx, DWORD PTR __Line$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 10	 mov	 edx, DWORD PTR __File$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 796  : 		if (_Last < _First)

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  0003a	73 1f		 jae	 SHORT $LN1@Debug_rang

; 797  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 55 14	 mov	 edx, DWORD PTR __Line$[ebp]
  00041	52		 push	 edx
  00042	8b 45 10	 mov	 eax, DWORD PTR __File$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_rang:

; 798  : 		}
; 799  : 	}

  0005b	5e		 pop	 esi
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$_Debug_range2@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z PROC	; std::reverse<Entity * *>, COMDAT

; 3434 : 	{	// reverse elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3435 : 	_DEBUG_RANGE(_First, _Last);

  0000b	68 6b 0d 00 00	 push	 3435			; 00000d6bH
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Debug_range@PAPAVEntity@@@std@@YAXPAPAVEntity@@0PB_WI@Z ; std::_Debug_range<Entity * *>
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 3436 : 	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));

  00025	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00028	52		 push	 edx
  00029	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ; std::_Iter_cat<Entity * *>
  00032	83 c4 08	 add	 esp, 8
  00035	8a 08		 mov	 cl, BYTE PTR [eax]
  00037	88 4d ff	 mov	 BYTE PTR $T2[ebp], cl
  0003a	0f b6 55 ff	 movzx	 edx, BYTE PTR $T2[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unchecked<Entity * *>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<Entity * *>
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3437 : 	}

  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??$reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0@Z ENDP	; std::reverse<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z PROC ; std::allocator<std::pair<RigidBody *,int> >::destroy<std::pair<RigidBody *,int> >, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??$destroy@U?$pair@PAVRigidBody@@H@std@@@?$allocator@U?$pair@PAVRigidBody@@H@std@@@std@@QAEXPAU?$pair@PAVRigidBody@@H@1@@Z ENDP ; std::allocator<std::pair<RigidBody *,int> >::destroy<std::pair<RigidBody *,int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z PROC ; std::_Debug_range_ptr<Entity * *,Entity * *>, COMDAT

; 837  : 	{	// test iterator pair for valid range/pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  : 	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat(_First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntity@@@Z ; std::_Iter_cat<Entity * *>
  00018	83 c4 08	 add	 esp, 8
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	0f b6 c2	 movzx	 eax, dl
  00020	50		 push	 eax
  00021	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$_Debug_range_ptr2@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<Entity * *,Entity * *>
  0003a	83 c4 18	 add	 esp, 24			; 00000018H

; 839  : 	}

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z ENDP ; std::_Debug_range_ptr<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WI@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
??$_Debug_range_ptr@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WI@Z PROC ; std::_Debug_range_ptr<EntityComponent * *,EntityComponent * *>, COMDAT

; 837  : 	{	// test iterator pair for valid range/pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  : 	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat(_First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVEntityComponent@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntityComponent@@@Z ; std::_Iter_cat<EntityComponent * *>
  00018	83 c4 08	 add	 esp, 8
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	0f b6 c2	 movzx	 eax, dl
  00020	50		 push	 eax
  00021	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$_Debug_range_ptr2@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<EntityComponent * *,EntityComponent * *>
  0003a	83 c4 18	 add	 esp, 24			; 00000018H

; 839  : 	}

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Debug_range_ptr@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WI@Z ENDP ; std::_Debug_range_ptr<EntityComponent * *,EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 		_Ptr->~_Uty();

  0000e	6a 00		 push	 0
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 663  : 		}

  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Unchecked_type(this->_Ptr));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 321  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAVEntity@@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVEntity@@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Entity *,Entity *>, COMDAT

; 402  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 403  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);

  0000c	68 93 01 00 00	 push	 403			; 00000193H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00016	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Debug_range_ptr@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<Entity * *,Entity * *>
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00030	c1 f8 02	 sar	 eax, 2
  00033	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	c1 e1 02	 shl	 ecx, 2
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
; 407  : 	}

  0005d	5e		 pop	 esi
  0005e	83 c4 04	 add	 esp, 4
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Uninit_copy@PAVEntity@@PAV1@@std@@YAPAPAVEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Entity *,Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z PROC ; std::_Debug_pointer<Entity *>, COMDAT

; 760  : 	{	// test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 761  : 	if (_Ptr == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00008	75 1f		 jne	 SHORT $LN1@Debug_poin

; 762  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  0000a	8b f4		 mov	 esi, esp
  0000c	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 763  : 	}

  00029	5e		 pop	 esi
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ENDP ; std::_Debug_pointer<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0Ubidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0Ubidirectional_iterator_tag@0@@Z PROC ; std::_Reverse<Entity * *>, COMDAT

; 3427 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3428 : 	for (; _First != _Last && _First != --_Last; ++_First)

  00003	eb 09		 jmp	 SHORT $LN4@Reverse
$LN2@Reverse:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 04	 add	 eax, 4
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Reverse:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 23		 je	 SHORT $LN1@Reverse
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00019	83 ea 04	 sub	 edx, 4
  0001c	89 55 0c	 mov	 DWORD PTR __Last$[ebp], edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00025	74 12		 je	 SHORT $LN1@Reverse

; 3429 : 		_STD iter_swap(_First, _Last);

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ; std::iter_swap<Entity * *,Entity * *>
  00034	83 c4 08	 add	 esp, 8
  00037	eb cc		 jmp	 SHORT $LN2@Reverse
$LN1@Reverse:

; 3430 : 	}

  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Reverse@PAPAVEntity@@@std@@YAXPAPAVEntity@@0Ubidirectional_iterator_tag@0@@Z ENDP ; std::_Reverse<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr2@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Debug_range_ptr2@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range_ptr2<Entity * *,Entity * *>, COMDAT

; 822  : 	{	// test iterator pair for valid range/pointer, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 	if (_First != _Last)

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000a	74 65		 je	 SHORT $LN1@Debug_rang

; 824  : 		{	// check for non-null pointers, valid range
; 825  : 		_DEBUG_POINTER2(_First, _File, _Line);

  0000c	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 826  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  00020	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 827  : 		if (_Last < _First)

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  0003a	73 1f		 jae	 SHORT $LN3@Debug_rang

; 828  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 55 18	 mov	 edx, DWORD PTR __Line$[ebp]
  00041	52		 push	 edx
  00042	8b 45 14	 mov	 eax, DWORD PTR __File$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Debug_rang:

; 829  : 		_DEBUG_POINTER2(_Ptr, _File, _Line);	// test only if used

  0005b	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00062	52		 push	 edx
  00063	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntity@@@std@@YAXPAPAVEntity@@PB_WI@Z ; std::_Debug_pointer<Entity *>
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Debug_rang:

; 830  : 		}
; 831  : 	}

  00071	5e		 pop	 esi
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$_Debug_range_ptr2@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range_ptr2<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVEntityComponent@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntityComponent@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVEntityComponent@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntityComponent@@@Z PROC ; std::_Iter_cat<EntityComponent * *>, COMDAT

; 601  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 602  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 603  : 	return (_Cat);

  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8a 4d fb	 mov	 cl, BYTE PTR __Cat$[ebp]
  00021	88 08		 mov	 BYTE PTR [eax], cl
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 604  : 	}

  00026	52		 push	 edx
  00027	8b cd		 mov	 ecx, ebp
  00029	50		 push	 eax
  0002a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Iter_cat
  00030	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00035	58		 pop	 eax
  00036	5a		 pop	 edx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
  0003b	90		 npad	 1
$LN5@Iter_cat:
  0003c	01 00 00 00	 DD	 1
  00040	00 00 00 00	 DD	 $LN4@Iter_cat
$LN4@Iter_cat:
  00044	fb ff ff ff	 DD	 -5			; fffffffbH
  00048	01 00 00 00	 DD	 1
  0004c	00 00 00 00	 DD	 $LN3@Iter_cat
$LN3@Iter_cat:
  00050	5f		 DB	 95			; 0000005fH
  00051	43		 DB	 67			; 00000043H
  00052	61		 DB	 97			; 00000061H
  00053	74		 DB	 116			; 00000074H
  00054	00		 DB	 0
??$_Iter_cat@PAPAVEntityComponent@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEntityComponent@@@Z ENDP ; std::_Iter_cat<EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr2@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Debug_range_ptr2@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range_ptr2<EntityComponent * *,EntityComponent * *>, COMDAT

; 822  : 	{	// test iterator pair for valid range/pointer, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 	if (_First != _Last)

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000a	74 65		 je	 SHORT $LN1@Debug_rang

; 824  : 		{	// check for non-null pointers, valid range
; 825  : 		_DEBUG_POINTER2(_First, _File, _Line);

  0000c	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z ; std::_Debug_pointer<EntityComponent *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 826  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  00020	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z ; std::_Debug_pointer<EntityComponent *>
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 827  : 		if (_Last < _First)

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  0003a	73 1f		 jae	 SHORT $LN3@Debug_rang

; 828  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 55 18	 mov	 edx, DWORD PTR __Line$[ebp]
  00041	52		 push	 edx
  00042	8b 45 14	 mov	 eax, DWORD PTR __File$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Debug_rang:

; 829  : 		_DEBUG_POINTER2(_Ptr, _File, _Line);	// test only if used

  0005b	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00062	52		 push	 edx
  00063	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z ; std::_Debug_pointer<EntityComponent *>
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Debug_rang:

; 830  : 		}
; 831  : 	}

  00071	5e		 pop	 esi
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$_Debug_range_ptr2@PAPAVEntityComponent@@PAPAV1@@std@@YAXPAPAVEntityComponent@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range_ptr2<EntityComponent * *,EntityComponent * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z PROC ; std::iter_swap<Entity * *,Entity * *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	swap(*_Left, *_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$swap@PAVEntity@@@std@@YAXAAPAVEntity@@0@Z ; std::swap<Entity *>
  00010	83 c4 08	 add	 esp, 8

; 29   : 	}

  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ENDP ; std::iter_swap<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z PROC ; std::_Debug_pointer<EntityComponent *>, COMDAT

; 760  : 	{	// test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 761  : 	if (_Ptr == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00008	75 1f		 jne	 SHORT $LN1@Debug_poin

; 762  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  0000a	8b f4		 mov	 esi, esp
  0000c	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 763  : 	}

  00029	5e		 pop	 esi
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Debug_pointer@PAVEntityComponent@@@std@@YAXPAPAVEntityComponent@@PB_WI@Z ENDP ; std::_Debug_pointer<EntityComponent *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAVEntity@@@std@@YAXAAPAVEntity@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVEntity@@@std@@YAXAAPAVEntity@@0@Z PROC	; std::swap<Entity *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 52   : 	_Ty _Tmp = _Move(_Left);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z ; std::_Move<Entity * &>
  00024	83 c4 04	 add	 esp, 4
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 53   : 	_Left = _Move(_Right);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z ; std::_Move<Entity * &>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 54   : 	_Right = _Move(_Tmp);

  0003f	8d 45 f8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z ; std::_Move<Entity * &>
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	89 11		 mov	 DWORD PTR [ecx], edx

; 55   : 	}

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@swap
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
  00071	0f 1f 00	 npad	 3
$LN5@swap:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@swap
$LN4@swap:
  0007c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00080	04 00 00 00	 DD	 4
  00084	00 00 00 00	 DD	 $LN3@swap
$LN3@swap:
  00088	5f		 DB	 95			; 0000005fH
  00089	54		 DB	 84			; 00000054H
  0008a	6d		 DB	 109			; 0000006dH
  0008b	70		 DB	 112			; 00000070H
  0008c	00		 DB	 0
??$swap@PAVEntity@@@std@@YAXAAPAVEntity@@0@Z ENDP	; std::swap<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z PROC ; std::_Move<Entity * &>, COMDAT

; 1257 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1258 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1259 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAVEntity@@@std@@YA$$QAPAVEntity@@AAPAV1@@Z ENDP ; std::_Move<Entity * &>
_TEXT	ENDS
END
