; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	e:\fusion3d_work\engine\src\rendering\lighting.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@EGOIFEHL@DirectionalLight?$AA@	; `string'
PUBLIC	??_C@_05PEENBMOG@color?$AA@			; `string'
PUBLIC	??_C@_09DDBFFAKC@intensity?$AA@			; `string'
PUBLIC	??_C@_06PAJLLHGJ@vAngle?$AA@			; `string'
PUBLIC	??_C@_0O@OHGEMPPD@shadowMapSize?$AA@		; `string'
PUBLIC	??_C@_0L@NDLHEOHF@shadowArea?$AA@		; `string'
PUBLIC	??_C@_08NJJJKCHP@softness?$AA@			; `string'
PUBLIC	??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@	; `string'
PUBLIC	??_C@_0M@LCNFPLBH@minVariance?$AA@		; `string'
PUBLIC	??_C@_0L@KGHCILHP@PointLight?$AA@		; `string'
PUBLIC	??_C@_0M@NKGAHMMH@attenuation?$AA@		; `string'
PUBLIC	??_C@_09OIMHBJMD@SpotLight?$AA@			; `string'
PUBLIC	??_R4SpotLight@@6B@				; SpotLight::`RTTI Complete Object Locator'
PUBLIC	??_R4PointLight@@6B@				; PointLight::`RTTI Complete Object Locator'
PUBLIC	??_R3DirectionalLight@@8			; DirectionalLight::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@PointLight@@8			; PointLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SpotLight@@8			; SpotLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3PointLight@@8				; PointLight::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SpotLight@@8				; SpotLight::`RTTI Base Class Array'
PUBLIC	??_R3SpotLight@@8				; SpotLight::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PointLight@@8				; PointLight::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DirectionalLight@@8		; DirectionalLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2DirectionalLight@@8			; DirectionalLight::`RTTI Base Class Array'
PUBLIC	??_R0?AVPointLight@@@8				; PointLight `RTTI Type Descriptor'
PUBLIC	??_7PointLight@@6B@				; PointLight::`vftable'
PUBLIC	??_7SpotLight@@6B@				; SpotLight::`vftable'
PUBLIC	??_R0?AVSpotLight@@@8				; SpotLight `RTTI Type Descriptor'
PUBLIC	??_R4DirectionalLight@@6B@			; DirectionalLight::`RTTI Complete Object Locator'
PUBLIC	??_7DirectionalLight@@6B@			; DirectionalLight::`vftable'
PUBLIC	??_R0?AVDirectionalLight@@@8			; DirectionalLight `RTTI Type Descriptor'
EXTRN	__imp__tan:PROC
EXTRN	__imp__floor:PROC
;	COMDAT ??_R0?AVDirectionalLight@@@8
data$r	SEGMENT
??_R0?AVDirectionalLight@@@8 DD FLAT:??_7type_info@@6B@	; DirectionalLight `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDirectionalLight@@', 00H
data$r	ENDS
;	COMDAT ??_7DirectionalLight@@6B@
CONST	SEGMENT
??_7DirectionalLight@@6B@ DD FLAT:??_R4DirectionalLight@@6B@ ; DirectionalLight::`vftable'
	DD	FLAT:?__ClassType__@DirectionalLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:??_EDirectionalLight@@UAEPAXI@Z
	DD	FLAT:?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Init@EntityComponent@@UAEXXZ
	DD	FLAT:?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
	DD	FLAT:?Update@EntityComponent@@UAEXM@Z
	DD	FLAT:?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?DataDeploy@DirectionalLight@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	FLAT:?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z
	DD	FLAT:?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
	DD	FLAT:?CalcShadowCameraTransform@DirectionalLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z
CONST	ENDS
;	COMDAT ??_R4DirectionalLight@@6B@
rdata$r	SEGMENT
??_R4DirectionalLight@@6B@ DD 00H			; DirectionalLight::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDirectionalLight@@@8
	DD	FLAT:??_R3DirectionalLight@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpotLight@@@8
data$r	SEGMENT
??_R0?AVSpotLight@@@8 DD FLAT:??_7type_info@@6B@	; SpotLight `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpotLight@@', 00H
data$r	ENDS
;	COMDAT ??_7SpotLight@@6B@
CONST	SEGMENT
??_7SpotLight@@6B@ DD FLAT:??_R4SpotLight@@6B@		; SpotLight::`vftable'
	DD	FLAT:?__ClassType__@SpotLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:??_ESpotLight@@UAEPAXI@Z
	DD	FLAT:?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Init@EntityComponent@@UAEXXZ
	DD	FLAT:?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
	DD	FLAT:?Update@EntityComponent@@UAEXM@Z
	DD	FLAT:?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?DataDeploy@SpotLight@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	FLAT:?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z
	DD	FLAT:?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
	DD	FLAT:?CalcShadowCameraTransform@BaseLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z
CONST	ENDS
;	COMDAT ??_7PointLight@@6B@
CONST	SEGMENT
??_7PointLight@@6B@ DD FLAT:??_R4PointLight@@6B@	; PointLight::`vftable'
	DD	FLAT:?__ClassType__@PointLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:??_EPointLight@@UAEPAXI@Z
	DD	FLAT:?_GetClassName_@EntityComponent@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Init@EntityComponent@@UAEXXZ
	DD	FLAT:?ProcessInput@EntityComponent@@UAEXABVInput@@M@Z
	DD	FLAT:?Update@EntityComponent@@UAEXM@Z
	DD	FLAT:?Render@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?PostRender@EntityComponent@@UBEXABVShader@@ABVRenderingEngine@@ABVCamera@@@Z
	DD	FLAT:?DataDeploy@PointLight@@UAEXPAVXMLElement@tinyxml2@@@Z
	DD	FLAT:?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z
	DD	FLAT:?SetParent@EntityComponent@@UAEXPAVEntity@@@Z
	DD	FLAT:?CalcShadowCameraTransform@BaseLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z
CONST	ENDS
;	COMDAT ??_R0?AVPointLight@@@8
data$r	SEGMENT
??_R0?AVPointLight@@@8 DD FLAT:??_7type_info@@6B@	; PointLight `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPointLight@@', 00H
data$r	ENDS
;	COMDAT ??_R2DirectionalLight@@8
rdata$r	SEGMENT
??_R2DirectionalLight@@8 DD FLAT:??_R1A@?0A@EA@DirectionalLight@@8 ; DirectionalLight::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseLight@@8
	DD	FLAT:??_R1A@?0A@EA@EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DirectionalLight@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DirectionalLight@@8 DD FLAT:??_R0?AVDirectionalLight@@@8 ; DirectionalLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DirectionalLight@@8
rdata$r	ENDS
;	COMDAT ??_R2PointLight@@8
rdata$r	SEGMENT
??_R2PointLight@@8 DD FLAT:??_R1A@?0A@EA@PointLight@@8	; PointLight::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseLight@@8
	DD	FLAT:??_R1A@?0A@EA@EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R3SpotLight@@8
rdata$r	SEGMENT
??_R3SpotLight@@8 DD 00H				; SpotLight::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2SpotLight@@8
rdata$r	ENDS
;	COMDAT ??_R2SpotLight@@8
rdata$r	SEGMENT
??_R2SpotLight@@8 DD FLAT:??_R1A@?0A@EA@SpotLight@@8	; SpotLight::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@PointLight@@8
	DD	FLAT:??_R1A@?0A@EA@BaseLight@@8
	DD	FLAT:??_R1A@?0A@EA@EntityComponent@@8
rdata$r	ENDS
;	COMDAT ??_R3PointLight@@8
rdata$r	SEGMENT
??_R3PointLight@@8 DD 00H				; PointLight::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2PointLight@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SpotLight@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpotLight@@8 DD FLAT:??_R0?AVSpotLight@@@8 ; SpotLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpotLight@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@PointLight@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PointLight@@8 DD FLAT:??_R0?AVPointLight@@@8 ; PointLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PointLight@@8
rdata$r	ENDS
;	COMDAT ??_R3DirectionalLight@@8
rdata$r	SEGMENT
??_R3DirectionalLight@@8 DD 00H				; DirectionalLight::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2DirectionalLight@@8
rdata$r	ENDS
;	COMDAT ??_R4PointLight@@6B@
rdata$r	SEGMENT
??_R4PointLight@@6B@ DD 00H				; PointLight::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPointLight@@@8
	DD	FLAT:??_R3PointLight@@8
rdata$r	ENDS
;	COMDAT ??_R4SpotLight@@6B@
rdata$r	SEGMENT
??_R4SpotLight@@6B@ DD 00H				; SpotLight::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpotLight@@@8
	DD	FLAT:??_R3SpotLight@@8
rdata$r	ENDS
;	COMDAT ??_C@_09OIMHBJMD@SpotLight?$AA@
CONST	SEGMENT
??_C@_09OIMHBJMD@SpotLight?$AA@ DB 'SpotLight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKGAHMMH@attenuation?$AA@
CONST	SEGMENT
??_C@_0M@NKGAHMMH@attenuation?$AA@ DB 'attenuation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KGHCILHP@PointLight?$AA@
CONST	SEGMENT
??_C@_0L@KGHCILHP@PointLight?$AA@ DB 'PointLight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCNFPLBH@minVariance?$AA@
CONST	SEGMENT
??_C@_0M@LCNFPLBH@minVariance?$AA@ DB 'minVariance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
CONST	SEGMENT
??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@ DB 'lightBleedReduction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NJJJKCHP@softness?$AA@
CONST	SEGMENT
??_C@_08NJJJKCHP@softness?$AA@ DB 'softness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDLHEOHF@shadowArea?$AA@
CONST	SEGMENT
??_C@_0L@NDLHEOHF@shadowArea?$AA@ DB 'shadowArea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
CONST	SEGMENT
??_C@_0O@OHGEMPPD@shadowMapSize?$AA@ DB 'shadowMapSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAJLLHGJ@vAngle?$AA@
CONST	SEGMENT
??_C@_06PAJLLHGJ@vAngle?$AA@ DB 'vAngle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DDBFFAKC@intensity?$AA@
CONST	SEGMENT
??_C@_09DDBFFAKC@intensity?$AA@ DB 'intensity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEENBMOG@color?$AA@
CONST	SEGMENT
??_C@_05PEENBMOG@color?$AA@ DB 'color', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EGOIFEHL@DirectionalLight?$AA@
CONST	SEGMENT
??_C@_0BB@EGOIFEHL@DirectionalLight?$AA@ DB 'DirectionalLight', 00H ; `string'
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
$SG4294847820 DB 'forward-directional', 00H
	ORG $+3
?btInfinityMask@@3HA DD 07f800000H			; btInfinityMask
	ORG $+3
?btNanMask@@3HA DD 07f800001H				; btNanMask
	ORG $+1
$SG4294847819 DB 'forward-spot', 00H
	ORG $+3
$SG4294847784 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (!pair.m_algorithm'
	DB	')', 0aH, 00H
	ORG $+1
$SG4294847782 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (m_firstFreeHandle'
	DB	')', 0aH, 00H
	ORG $+1
$SG4294847783 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (!pair.m_algorithm'
	DB	')', 0aH, 00H
	ORG $+1
$SG4294847780 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (m_firstFreeHandle'
	DB	')', 0aH, 00H
	ORG $+1
$SG4294847781 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (handle > 0 && han'
	DB	'dle < m_maxHandles)', 0aH, 00H
$SG4294847779 DB 'Assert e:\fusion3d_work\lib\bullet3\include\BulletColli'
	DB	'sion/BroadphaseCollision/btAxisSweep3.h:%u (handle > 0 && han'
	DB	'dle < m_maxHandles)', 0aH, 00H
PUBLIC	??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z ; std::_Debug_pointer<BaseLight *>
PUBLIC	??$_Debug_range_ptr2@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<BaseLight * *,BaseLight * *>
PUBLIC	??$_Iter_cat@PAPAVBaseLight@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBaseLight@@@Z ; std::_Iter_cat<BaseLight * *>
PUBLIC	??$_Debug_range_ptr@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<BaseLight * *,BaseLight * *>
PUBLIC	??$_Uninit_move@PAVBaseLight@@PAV1@PAV1@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BaseLight *,BaseLight *,BaseLight *>
PUBLIC	??$_Val_type@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Val_type<BaseLight * *>
PUBLIC	??$_Rechecked@PAPAVBaseLight@@PAPAV1@@std@@YAAAPAPAVBaseLight@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<BaseLight * *,BaseLight * *>
PUBLIC	??$_Uninit_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ; std::_Uninit_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
PUBLIC	??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Unchecked<BaseLight * *>
PUBLIC	??$construct@PAVBaseLight@@ABQAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * const &>
PUBLIC	??$construct@PAVBaseLight@@AAPAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * &>
PUBLIC	??$_Uninitialized_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ; std::_Uninitialized_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
PUBLIC	??$construct@PAVBaseLight@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@ABQAV3@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>
PUBLIC	??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z ; std::forward<BaseLight * const &>
PUBLIC	??$construct@PAVBaseLight@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@AAPAV3@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>
PUBLIC	??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z ; std::forward<BaseLight * &>
PUBLIC	??$_Addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<BaseLight * const>
PUBLIC	??$_Umove@PAPAVBaseLight@@@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEPAPAVBaseLight@@PAPAV2@00@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Umove<BaseLight * *>
PUBLIC	??$construct@PAVBaseLight@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>
PUBLIC	??$construct@PAVBaseLight@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>
PUBLIC	??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z ; std::addressof<BaseLight * const>
PUBLIC	?max_size@?$allocator@PAVBaseLight@@@std@@QBEIXZ ; std::allocator<BaseLight *>::max_size
PUBLIC	?allocate@?$allocator@PAVBaseLight@@@std@@QAEPAPAVBaseLight@@I@Z ; std::allocator<BaseLight *>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAIABV?$allocator@PAVBaseLight@@@2@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<BaseLight *> >,std::_Vector_val<std::_Simple_types<BaseLight *> >,1>::_Get_first
PUBLIC	?capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEPAPAVBaseLight@@I@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::max_size
PUBLIC	?_Unused_capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Unused_capacity
PUBLIC	?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::max_size
PUBLIC	?_Grow_to@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEII@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reallocate
PUBLIC	?_Xlen@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Xlen
PUBLIC	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getpfirst
PUBLIC	?_Inside@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBE_NPBQAVBaseLight@@@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Inside
PUBLIC	?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reserve
PUBLIC	?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Orphan_range
PUBLIC	?Max@?$Vector@M$02@@QBEMXZ			; Vector<float,3>::Max
PUBLIC	?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z	; Matrix4<float>::InitPerspective
PUBLIC	?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z	; Matrix4<float>::InitOrthographic
PUBLIC	?push_back@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXABQAVBaseLight@@@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::push_back
PUBLIC	??1SpotLight@@UAE@XZ				; SpotLight::~SpotLight
PUBLIC	??_GSpotLight@@UAEPAXI@Z			; SpotLight::`scalar deleting destructor'
PUBLIC	??1PointLight@@UAE@XZ				; PointLight::~PointLight
PUBLIC	??_GPointLight@@UAEPAXI@Z			; PointLight::`scalar deleting destructor'
PUBLIC	?CalcShadowCameraTransform@DirectionalLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z ; DirectionalLight::CalcShadowCameraTransform
PUBLIC	??1DirectionalLight@@UAE@XZ			; DirectionalLight::~DirectionalLight
PUBLIC	??_GDirectionalLight@@UAEPAXI@Z			; DirectionalLight::`scalar deleting destructor'
PUBLIC	?AddLight@RenderingEngine@@QAEXPAVBaseLight@@@Z	; RenderingEngine::AddLight
PUBLIC	?DataDeploy@SpotLight@@UAEXPAVXMLElement@tinyxml2@@@Z ; SpotLight::DataDeploy
PUBLIC	?__ClassType__@SpotLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; SpotLight::__ClassType__
PUBLIC	?DataDeploy@PointLight@@UAEXPAVXMLElement@tinyxml2@@@Z ; PointLight::DataDeploy
PUBLIC	?__ClassType__@PointLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; PointLight::__ClassType__
PUBLIC	?DataDeploy@DirectionalLight@@UAEXPAVXMLElement@tinyxml2@@@Z ; DirectionalLight::DataDeploy
PUBLIC	?GetHalfShadowArea@DirectionalLight@@QBEMXZ	; DirectionalLight::GetHalfShadowArea
PUBLIC	?__ClassType__@DirectionalLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; DirectionalLight::__ClassType__
PUBLIC	?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z	; BaseLight::SetShadowInfo
PUBLIC	?SetIntensity@BaseLight@@QAEPAV1@M@Z		; BaseLight::SetIntensity
PUBLIC	?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z	; BaseLight::SetColor
PUBLIC	??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z	; BaseLight::BaseLight
PUBLIC	??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z ; ShadowCameraTransform::ShadowCameraTransform
PUBLIC	?floor@@YAMM@Z					; floor
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	_tanf
PUBLIC	_floorf
PUBLIC	??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z	; DirectionalLight::DirectionalLight
PUBLIC	?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z	; BaseLight::AddToEngine
PUBLIC	?CalcShadowCameraTransform@BaseLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z ; BaseLight::CalcShadowCameraTransform
PUBLIC	??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z ; SpotLight::SpotLight
PUBLIC	??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z ; PointLight::PointLight
EXTRN	??_EDirectionalLight@@UAEPAXI@Z:PROC		; DirectionalLight::`vector deleting destructor'
EXTRN	??_ESpotLight@@UAEPAXI@Z:PROC			; SpotLight::`vector deleting destructor'
EXTRN	??_EPointLight@@UAEPAXI@Z:PROC			; PointLight::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$2
__catchsym$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$0
__ehfuncinfo$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$2
__ehfuncinfo$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$2
__ehfuncinfo$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z$0
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
tv214 = -268						; size = 4
tv245 = -264						; size = 4
tv206 = -260						; size = 4
tv243 = -256						; size = 4
tv241 = -252						; size = 4
tv201 = -248						; size = 4
$T2 = -244						; size = 84
$T3 = -160						; size = 64
$T4 = -96						; size = 64
_c$ = -32						; size = 4
_b$ = -28						; size = 4
_a$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_color$ = 8						; size = 4
_intensity$ = 12					; size = 4
_attenuation$ = 16					; size = 4
_viewAngle$ = 20					; size = 4
_shadowMapSizeAsPowerOf2$ = 24				; size = 4
_shadowSoftness$ = 28					; size = 4
_lightBleedReductionAmount$ = 32			; size = 4
_minVariance$ = 36					; size = 4
_shader$ = 40						; size = 4
??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z PROC ; PointLight::PointLight
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  0001f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 	BaseLight(color, intensity, shader),

  00043	8b 45 28	 mov	 eax, DWORD PTR _shader$[ebp]
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z ; BaseLight::BaseLight
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 66   : {

  00065	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00068	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7PointLight@@6B@

; 65   : 	m_attenuation(attenuation)

  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _attenuation$[ebp]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	89 10		 mov	 DWORD PTR [eax], edx
  0007d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00080	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00083	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 67   : 	float a = m_attenuation.GetExponent();

  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  00092	e8 00 00 00 00	 call	 ?GetExponent@Attenuation@@QBEMXZ ; Attenuation::GetExponent
  00097	d9 5d e8	 fstp	 DWORD PTR _a$[ebp]

; 68   : 	float b = m_attenuation.GetLinear();

  0009a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000a3	e8 00 00 00 00	 call	 ?GetLinear@Attenuation@@QBEMXZ ; Attenuation::GetLinear
  000a8	d9 5d e4	 fstp	 DWORD PTR _b$[ebp]

; 69   : 	float c = m_attenuation.GetConstant() - COLOR_DEPTH * intensity * color.Max();

  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  000b4	e8 00 00 00 00	 call	 ?GetConstant@Attenuation@@QBEMXZ ; Attenuation::GetConstant
  000b9	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv201[ebp]
  000bf	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv201[ebp]
  000c7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@43800000
  000cf	f3 0f 59 4d 0c	 mulss	 xmm1, DWORD PTR _intensity$[ebp]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  000d7	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv241[ebp], xmm0
  000df	f3 0f 11 8d 00
	ff ff ff	 movss	 DWORD PTR tv243[ebp], xmm1
  000e7	e8 00 00 00 00	 call	 ?Max@?$Vector@M$02@@QBEMXZ ; Vector<float,3>::Max
  000ec	d9 9d fc fe ff
	ff		 fstp	 DWORD PTR tv206[ebp]
  000f2	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv243[ebp]
  000fa	f3 0f 59 85 fc
	fe ff ff	 mulss	 xmm0, DWORD PTR tv206[ebp]
  00102	f3 0f 10 8d 04
	ff ff ff	 movss	 xmm1, DWORD PTR tv241[ebp]
  0010a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0010e	f3 0f 11 4d e0	 movss	 DWORD PTR _c$[ebp], xmm1

; 70   : 	
; 71   : 	m_range = (-b + sqrtf(b*b - 4*a*c))/(2*a);

  00113	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _b$[ebp]
  00118	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0011f	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _b$[ebp]
  00124	f3 0f 59 4d e4	 mulss	 xmm1, DWORD PTR _b$[ebp]
  00129	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40800000
  00131	f3 0f 59 55 e8	 mulss	 xmm2, DWORD PTR _a$[ebp]
  00136	f3 0f 59 55 e0	 mulss	 xmm2, DWORD PTR _c$[ebp]
  0013b	f3 0f 5c ca	 subss	 xmm1, xmm2
  0013f	51		 push	 ecx
  00140	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00145	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR tv245[ebp], xmm0
  0014d	e8 00 00 00 00	 call	 _sqrtf
  00152	83 c4 04	 add	 esp, 4
  00155	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR tv214[ebp]
  0015b	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR tv245[ebp]
  00163	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR tv214[ebp]
  0016b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00173	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _a$[ebp]
  00178	f3 0f 5e c1	 divss	 xmm0, xmm1
  0017c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0017f	f3 0f 11 82 9c
	00 00 00	 movss	 DWORD PTR [edx+156], xmm0

; 72   : 
; 73   :     if (shadowMapSizeAsPowerOf2 != 0)

  00187	83 7d 18 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  0018b	0f 84 85 00 00
	00		 je	 $LN2@PointLight

; 74   :     {
; 75   :         SetShadowInfo(ShadowInfo(Matrix4f().InitPerspective(viewAngle, 1.0f, 0.1f, GetRange()), false, shadowMapSizeAsPowerOf2,

  00191	51		 push	 ecx
  00192	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  00197	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019c	51		 push	 ecx
  0019d	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  001a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a7	51		 push	 ecx
  001a8	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  001ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b2	8b 45 18	 mov	 eax, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  001b5	50		 push	 eax
  001b6	6a 00		 push	 0
  001b8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ?GetRange@PointLight@@QBE?BMXZ ; PointLight::GetRange
  001c0	51		 push	 ecx
  001c1	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c4	51		 push	 ecx
  001c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  001cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d2	51		 push	 ecx
  001d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	51		 push	 ecx
  001e1	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  001e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001eb	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001f1	51		 push	 ecx
  001f2	8d 4d a0	 lea	 ecx, DWORD PTR $T4[ebp]
  001f5	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 ?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z ; Matrix4<float>::InitPerspective
  00201	50		 push	 eax
  00202	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00208	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  0020d	50		 push	 eax
  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00211	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN2@PointLight:

; 76   :             shadowSoftness, lightBleedReductionAmount, minVariance));
; 77   :     }
; 78   : }

  00216	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0021d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00220	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00223	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022a	59		 pop	 ecx
  0022b	5f		 pop	 edi
  0022c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022f	33 cd		 xor	 ecx, ebp
  00231	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00236	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  0023c	3b ec		 cmp	 ebp, esp
  0023e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c2 24 00	 ret	 36			; 00000024H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1BaseLight@@UAE@XZ
__ehhandler$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a f8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-264]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z ENDP ; PointLight::PointLight
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
tv166 = -304						; size = 4
tv73 = -300						; size = 4
$T2 = -296						; size = 84
$T3 = -212						; size = 64
$T4 = -148						; size = 64
$T5 = -84						; size = 28
$T6 = -56						; size = 36
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_color$ = 8						; size = 4
_intensity$ = 12					; size = 4
_attenuation$ = 16					; size = 4
_viewAngle$ = 20					; size = 4
_shadowMapSizeAsPowerOf2$ = 24				; size = 4
_shadowSoftness$ = 28					; size = 4
_lightBleedReductionAmount$ = 32			; size = 4
_minVariance$ = 36					; size = 4
??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z PROC ; SpotLight::SpotLight
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  0001f	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 82   : 	PointLight(color, intensity, attenuation, viewAngle, shadowMapSizeAsPowerOf2, shadowSoftness, lightBleedReductionAmount, minVariance, Shader("forward-spot")),

  00043	68 00 00 00 00	 push	 OFFSET $SG4294847819
  00048	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0005e	e8 00 00 00 00	 call	 ??0Shader@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::Shader
  00063	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00069	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0006f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv166[ebp], ecx
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00079	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv166[ebp]
  0007f	52		 push	 edx
  00080	51		 push	 ecx
  00081	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  00086	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008b	51		 push	 ecx
  0008c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	51		 push	 ecx
  00097	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	8b 45 18	 mov	 eax, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  000ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b0	8b 4d 10	 mov	 ecx, DWORD PTR _attenuation$[ebp]
  000b3	51		 push	 ecx
  000b4	51		 push	 ecx
  000b5	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  000ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bf	8b 55 08	 mov	 edx, DWORD PTR _color$[ebp]
  000c2	52		 push	 edx
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ??0PointLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMMABVShader@@@Z ; PointLight::PointLight
  000cb	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000cf	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  000d2	e8 00 00 00 00	 call	 ??1Shader@@UAE@XZ	; Shader::~Shader
  000d7	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000db	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  000de	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 84   : {

  000e3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpotLight@@6B@

; 83   : 	m_cutoff(cos(viewAngle/2))

  000ec	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  000f1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000f9	51		 push	 ecx
  000fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ff	e8 00 00 00 00	 call	 ?cos@@YAMM@Z		; cos
  00104	83 c4 04	 add	 esp, 4
  00107	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	d9 99 a0 00 00
	00		 fstp	 DWORD PTR [ecx+160]

; 85   :     if (shadowMapSizeAsPowerOf2 != 0)

  00110	83 7d 18 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  00114	0f 84 88 00 00
	00		 je	 $LN2@SpotLight

; 86   :     {
; 87   :         SetShadowInfo(ShadowInfo(Matrix4f().InitPerspective(viewAngle, 1.0f, 0.1f, GetRange()), false, shadowMapSizeAsPowerOf2,

  0011a	51		 push	 ecx
  0011b	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  00120	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00125	51		 push	 ecx
  00126	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	51		 push	 ecx
  00131	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	8b 55 18	 mov	 edx, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  0013e	52		 push	 edx
  0013f	6a 00		 push	 0
  00141	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?GetRange@PointLight@@QBE?BMXZ ; PointLight::GetRange
  00149	51		 push	 ecx
  0014a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0014d	51		 push	 ecx
  0014e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00156	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015b	51		 push	 ecx
  0015c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00164	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00169	51		 push	 ecx
  0016a	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0017a	50		 push	 eax
  0017b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00181	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  00186	8b c8		 mov	 ecx, eax
  00188	e8 00 00 00 00	 call	 ?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z ; Matrix4<float>::InitPerspective
  0018d	50		 push	 eax
  0018e	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00194	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  00199	50		 push	 eax
  0019a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN2@SpotLight:

; 88   :             shadowSoftness, lightBleedReductionAmount, minVariance));
; 89   :     }
; 90   : }

  001a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b6	59		 pop	 ecx
  001b7	5f		 pop	 edi
  001b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  001c8	3b ec		 cmp	 ebp, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$1:
  00008	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Shader@@UAE@XZ	; Shader::~Shader
__unwindfunclet$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z$2:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1PointLight@@UAE@XZ
__ehhandler$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 8a d4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-300]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SpotLight@@QAE@ABVVector3f@@MABVAttenuation@@MHMMM@Z ENDP ; SpotLight::SpotLight
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 16
$T2 = -20						; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_mainCameraPos$ = 12					; size = 4
_mainCameraRot$ = 16					; size = 4
?CalcShadowCameraTransform@BaseLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z PROC ; BaseLight::CalcShadowCameraTransform
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 	return ShadowCameraTransform(GetTransform().GetTransformedPos(), GetTransform().GetTransformedRot());

  00033	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  00036	50		 push	 eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QBEABVTransform@@XZ ; EntityComponent::GetTransform
  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ?GetTransformedRot@Transform@@QBE?AVQuaternion@@XZ ; Transform::GetTransformedRot
  00046	50		 push	 eax
  00047	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0004a	51		 push	 ecx
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QBEABVTransform@@XZ ; EntityComponent::GetTransform
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 ?GetTransformedPos@Transform@@QBE?AVVector3f@@XZ ; Transform::GetTransformedPos
  0005a	50		 push	 eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005e	e8 00 00 00 00	 call	 ??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z ; ShadowCameraTransform::ShadowCameraTransform
  00063	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 29   : }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	83 c4 24	 add	 esp, 36			; 00000024H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
?CalcShadowCameraTransform@BaseLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z ENDP ; BaseLight::CalcShadowCameraTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_engine$ = 8						; size = 4
?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z PROC	; BaseLight::AddToEngine
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 	engine->GetRenderingEngine()->AddLight(this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _engine$[ebp]
  00015	e8 00 00 00 00	 call	 ?GetRenderingEngine@CoreEngine@@QAEPAVRenderingEngine@@XZ ; CoreEngine::GetRenderingEngine
  0001a	8b c8		 mov	 ecx, eax
  0001c	e8 00 00 00 00	 call	 ?AddLight@RenderingEngine@@QAEXPAVBaseLight@@@Z ; RenderingEngine::AddLight

; 24   : }

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?AddToEngine@BaseLight@@UAEXPAVCoreEngine@@@Z ENDP	; BaseLight::AddToEngine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
tv163 = -304						; size = 4
tv73 = -300						; size = 4
$T2 = -296						; size = 84
$T3 = -212						; size = 64
$T4 = -148						; size = 64
$T5 = -84						; size = 28
$T6 = -56						; size = 36
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_color$ = 8						; size = 4
_intensity$ = 12					; size = 4
_shadowMapSizeAsPowerOf2$ = 16				; size = 4
_shadowArea$ = 20					; size = 4
_shadowSoftness$ = 24					; size = 4
_lightBleedReductionAmount$ = 28			; size = 4
_minVariance$ = 32					; size = 4
??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z PROC	; DirectionalLight::DirectionalLight
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  0001f	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	BaseLight(color, intensity, Shader("forward-directional")),

  00043	68 00 00 00 00	 push	 OFFSET $SG4294847820
  00048	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0005e	e8 00 00 00 00	 call	 ??0Shader@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::Shader
  00063	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00069	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0006f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv163[ebp], ecx
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00079	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv163[ebp]
  0007f	52		 push	 edx
  00080	51		 push	 ecx
  00081	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  00086	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008b	8b 45 08	 mov	 eax, DWORD PTR _color$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z ; BaseLight::BaseLight
  00097	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0009b	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0009e	e8 00 00 00 00	 call	 ??1Shader@@UAE@XZ	; Shader::~Shader
  000a3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000a7	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  000aa	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 35   : {

  000af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7DirectionalLight@@6B@

; 34   : 	m_halfShadowArea(shadowArea / 2.0f)

  000b8	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _shadowArea$[ebp]
  000bd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000c5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	f3 0f 11 82 90
	00 00 00	 movss	 DWORD PTR [edx+144], xmm0

; 36   : 	if(shadowMapSizeAsPowerOf2 != 0)

  000d0	83 7d 10 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  000d4	0f 84 d0 00 00
	00		 je	 $LN2@Directiona

; 37   : 	{
; 38   : 		SetShadowInfo(ShadowInfo(Matrix4f().InitOrthographic(-m_halfShadowArea, m_halfShadowArea, -m_halfShadowArea, 

  000da	51		 push	 ecx
  000db	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	51		 push	 ecx
  000e6	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  000eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f0	51		 push	 ecx
  000f1	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  000f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fb	8b 45 10	 mov	 eax, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  000fe	50		 push	 eax
  000ff	6a 01		 push	 1
  00101	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	51		 push	 ecx
  00105	f3 0f 10 81 90
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+144]
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00115	f3 0f 10 82 90
	00 00 00	 movss	 xmm0, DWORD PTR [edx+144]
  0011d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00124	51		 push	 ecx
  00125	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	51		 push	 ecx
  0012e	f3 0f 10 80 90
	00 00 00	 movss	 xmm0, DWORD PTR [eax+144]
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	f3 0f 10 81 90
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+144]
  00146	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0014d	51		 push	 ecx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00156	51		 push	 ecx
  00157	f3 0f 10 82 90
	00 00 00	 movss	 xmm0, DWORD PTR [edx+144]
  0015f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00164	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00167	f3 0f 10 80 90
	00 00 00	 movss	 xmm0, DWORD PTR [eax+144]
  0016f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00176	51		 push	 ecx
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00182	51		 push	 ecx
  00183	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00189	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  0018e	8b c8		 mov	 ecx, eax
  00190	e8 00 00 00 00	 call	 ?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z ; Matrix4<float>::InitOrthographic
  00195	50		 push	 eax
  00196	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0019c	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  001a1	50		 push	 eax
  001a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN2@Directiona:

; 39   : 		                                                      m_halfShadowArea, -m_halfShadowArea, m_halfShadowArea), 
; 40   : 								 true, shadowMapSizeAsPowerOf2, shadowSoftness, lightBleedReductionAmount, minVariance));
; 41   : 	}
; 42   : }

  001aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001be	59		 pop	 ecx
  001bf	5f		 pop	 edi
  001c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	33 cd		 xor	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  001d0	3b ec		 cmp	 ebp, esp
  001d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$1:
  00008	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Shader@@UAE@XZ	; Shader::~Shader
__unwindfunclet$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z$2:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1BaseLight@@UAE@XZ
__ehhandler$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 8a d4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-300]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0DirectionalLight@@QAE@ABVVector3f@@MHMMMM@Z ENDP	; DirectionalLight::DirectionalLight
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 671  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 672  :         return (float)floor(_X);

  0000c	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00011	8b f4		 mov	 esi, esp
  00013	83 ec 08	 sub	 esp, 8
  00016	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  00021	83 c4 08	 add	 esp, 8
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	d9 5d fc	 fstp	 DWORD PTR tv73[ebp]
  0002e	d9 45 fc	 fld	 DWORD PTR tv73[ebp]

; 673  :     }

  00031	5e		 pop	 esi
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 750  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 751  :         return (float)tan(_X);

  0000c	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00011	8b f4		 mov	 esi, esp
  00013	83 ec 08	 sub	 esp, 8
  00016	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__tan
  00021	83 c4 08	 add	 esp, 8
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	d9 5d fc	 fstp	 DWORD PTR tv73[ebp]
  0002e	d9 45 fc	 fld	 DWORD PTR tv73[ebp]

; 752  :     }

  00031	5e		 pop	 esi
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 102  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 	return (_CSTD cosf(_Xx));

  00003	51		 push	 ecx
  00004	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  00009	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0000e	e8 00 00 00 00	 call	 _cosf
  00013	83 c4 04	 add	 esp, 4

; 104  : 	}

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 147  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 148  : 	return (_CSTD floorf(_Xx));

  00003	51		 push	 ecx
  00004	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  00009	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0000e	e8 00 00 00 00	 call	 _floorf
  00013	83 c4 04	 add	 esp, 4

; 149  : 	}

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_rot$ = 12						; size = 4
??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z PROC ; ShadowCameraTransform::ShadowCameraTransform, COMDAT
; _this$ = ecx

; 35   : 		m_rot(rot) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 		m_pos(pos),

  0000e	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	89 11		 mov	 DWORD PTR [ecx], edx
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 35   : 		m_rot(rot) {}

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _rot$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax
  00031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00034	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00037	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003d	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00040	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z ENDP ; ShadowCameraTransform::ShadowCameraTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 64
$T3 = -148						; size = 64
$T4 = -84						; size = 64
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_color$ = 8						; size = 4
_intensity$ = 12					; size = 4
_shader$ = 16						; size = 4
??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z PROC	; BaseLight::BaseLight, COMDAT
; _this$ = ecx

; 80   : 		m_shadowInfo(ShadowInfo()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  0001f	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	59		 pop	 ecx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??0EntityComponent@@QAE@XZ ; EntityComponent::EntityComponent
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00055	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7BaseLight@@6B@

; 77   : 		m_color(color),

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 08	 add	 ecx, 8
  00061	8b 55 08	 mov	 edx, DWORD PTR _color$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	89 01		 mov	 DWORD PTR [ecx], eax
  00068	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0006e	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00071	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 78   : 		m_intensity(intensity),

  00074	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00077	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  0007c	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 79   : 		m_shader(shader),

  00081	8b 4d 10	 mov	 ecx, DWORD PTR _shader$[ebp]
  00084	51		 push	 ecx
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 18	 add	 ecx, 24			; 00000018H
  0008b	e8 00 00 00 00	 call	 ??0Shader@@QAE@ABV0@@Z	; Shader::Shader
  00090	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 80   : 		m_shadowInfo(ShadowInfo()) {}

  00094	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0009a	52		 push	 edx
  0009b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000a1	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  000a6	8b c8		 mov	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ?InitIdentity@?$Matrix@M$03@@QAE?AV1@XZ ; Matrix<float,4>::InitIdentity
  000ad	50		 push	 eax
  000ae	8d 4d ac	 lea	 ecx, DWORD PTR $T4[ebp]
  000b1	e8 00 00 00 00	 call	 ??$?0$03@?$Matrix4@M@@QAE@ABV?$Matrix@M$03@@@Z ; Matrix4<float>::Matrix4<float><4>
  000b6	51		 push	 ecx
  000b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@37a7c5ac
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	51		 push	 ecx
  000c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  000cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d2	51		 push	 ecx
  000d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	83 c1 3c	 add	 ecx, 60			; 0000003cH
  000ee	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  000f3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000fa	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	5f		 pop	 edi
  00109	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010c	33 cd		 xor	 ecx, ebp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00119	3b ec		 cmp	 ebp, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1EntityComponent@@UAE@XZ ; EntityComponent::~EntityComponent
__unwindfunclet$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1Shader@@UAE@XZ	; Shader::~Shader
__ehhandler$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0BaseLight@@QAE@ABVVector3f@@MABVShader@@@Z ENDP	; BaseLight::BaseLight
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 12
?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z PROC		; BaseLight::SetColor, COMDAT
; _this$ = ecx

; 91   : 	inline BaseLight* SetColor(Vector3f color) { m_color = color;  return this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 08	 add	 eax, 8
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR _color$[ebp+4]
  0001c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _color$[ebp+8]
  00022	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z ENDP		; BaseLight::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?SetIntensity@BaseLight@@QAEPAV1@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_intensity$ = 8						; size = 4
?SetIntensity@BaseLight@@QAEPAV1@M@Z PROC		; BaseLight::SetIntensity, COMDAT
; _this$ = ecx

; 92   : 	inline BaseLight* SetIntensity(float intensity) { m_intensity = intensity; return this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  00016	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SetIntensity@BaseLight@@QAEPAV1@M@Z ENDP		; BaseLight::SetIntensity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_shadowInfo$ = 8					; size = 4
?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z PROC	; BaseLight::SetShadowInfo, COMDAT
; _this$ = ecx

; 94   : 	inline void SetShadowInfo(const ShadowInfo& shadowInfo) { m_shadowInfo = shadowInfo; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00010	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00013	83 c7 3c	 add	 edi, 60			; 0000003cH
  00016	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0001b	8b 75 08	 mov	 esi, DWORD PTR _shadowInfo$[ebp]
  0001e	f3 a5		 rep movsd
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ENDP	; BaseLight::SetShadowInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?__ClassType__@DirectionalLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?__ClassType__@DirectionalLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; DirectionalLight::__ClassType__, COMDAT
; _this$ = ecx

; 105  : 	FCLASS (DirectionalLight);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EGOIFEHL@DirectionalLight?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?__ClassType__@DirectionalLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; DirectionalLight::__ClassType__
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?GetHalfShadowArea@DirectionalLight@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHalfShadowArea@DirectionalLight@@QBEMXZ PROC	; DirectionalLight::GetHalfShadowArea, COMDAT
; _this$ = ecx

; 111  : 	inline float GetHalfShadowArea() const { return m_halfShadowArea; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	d9 80 90 00 00
	00		 fld	 DWORD PTR [eax+144]
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?GetHalfShadowArea@DirectionalLight@@QBEMXZ ENDP	; DirectionalLight::GetHalfShadowArea
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?DataDeploy@DirectionalLight@@UAEXPAVXMLElement@tinyxml2@@@Z
_TEXT	SEGMENT
tv310 = -300						; size = 8
tv265 = -292						; size = 4
tv264 = -288						; size = 4
$T1 = -284						; size = 4
$T2 = -280						; size = 84
$T3 = -196						; size = 64
$T4 = -132						; size = 64
$T5 = -68						; size = 12
_minVariance$ = -56					; size = 4
_lightBleedReductionAmount$ = -52			; size = 4
_shadowArea$ = -48					; size = 4
_shadowSoftness$ = -44					; size = 4
_shadowMapSizeAsPowerOf2$ = -40				; size = 4
_viewAngle$ = -36					; size = 4
_intensity$ = -32					; size = 4
_color$ = -24						; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
?DataDeploy@DirectionalLight@@UAEXPAVXMLElement@tinyxml2@@@Z PROC ; DirectionalLight::DataDeploy, COMDAT
; _this$ = ecx

; 114  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 		Vector3f color = Vector3f(0, 0, 0);

  0002c	51		 push	 ecx
  0002d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00035	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003a	51		 push	 ecx
  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	51		 push	 ecx
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	8d 4d e8	 lea	 ecx, DWORD PTR _color$[ebp]
  00059	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f

; 116  : 		float intensity = 0;

  0005e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00066	f3 0f 11 45 e0	 movss	 DWORD PTR _intensity$[ebp], xmm0

; 117  : 		float viewAngle = ToRadians(170.0f);

  0006b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@403de44e
  00073	f3 0f 11 45 dc	 movss	 DWORD PTR _viewAngle$[ebp], xmm0

; 118  : 		int shadowMapSizeAsPowerOf2 = 0;

  00078	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0

; 119  : 		float shadowSoftness = 1.0f;

  0007f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00087	f3 0f 11 45 d4	 movss	 DWORD PTR _shadowSoftness$[ebp], xmm0

; 120  : 		float shadowArea = 80.0f;

  0008c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42a00000
  00094	f3 0f 11 45 d0	 movss	 DWORD PTR _shadowArea$[ebp], xmm0

; 121  : 		float lightBleedReductionAmount = 0.2f;

  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  000a1	f3 0f 11 45 cc	 movss	 DWORD PTR _lightBleedReductionAmount$[ebp], xmm0

; 122  : 		float minVariance = 0.00002f;

  000a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@37a7c5ac
  000ae	f3 0f 11 45 c8	 movss	 DWORD PTR _minVariance$[ebp], xmm0

; 123  : 
; 124  : 		if (data->Attribute("color"))

  000b3	6a 00		 push	 0
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000bd	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000c2	85 c0		 test	 eax, eax
  000c4	74 4f		 je	 SHORT $LN2@DataDeploy

; 125  : 		{
; 126  : 			color = Util::ParseVector3(data->Attribute("color"));

  000c6	6a 00		 push	 0
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000d0	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000d5	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000d8	8b cc		 mov	 ecx, esp
  000da	89 a5 e4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], esp
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv264[ebp], eax
  000ec	8d 45 bc	 lea	 eax, DWORD PTR $T5[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  000f5	83 c4 20	 add	 esp, 32			; 00000020H
  000f8	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv265[ebp], eax
  000fe	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv265[ebp]
  00104	8b 11		 mov	 edx, DWORD PTR [ecx]
  00106	89 55 e8	 mov	 DWORD PTR _color$[ebp], edx
  00109	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0010c	89 45 ec	 mov	 DWORD PTR _color$[ebp+4], eax
  0010f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00112	89 4d f0	 mov	 DWORD PTR _color$[ebp+8], ecx
$LN2@DataDeploy:

; 127  : 		}
; 128  : 
; 129  : 		if (data->Attribute("intensity"))

  00115	6a 00		 push	 0
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  0011c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0011f	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00124	85 c0		 test	 eax, eax
  00126	74 25		 je	 SHORT $LN3@DataDeploy

; 130  : 		{
; 131  : 			intensity = atof(data->Attribute("intensity"));

  00128	6a 00		 push	 0
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00132	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00137	8b f4		 mov	 esi, esp
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00140	83 c4 04	 add	 esp, 4
  00143	3b f4		 cmp	 esi, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	d9 5d e0	 fstp	 DWORD PTR _intensity$[ebp]
$LN3@DataDeploy:

; 132  : 		}
; 133  : 
; 134  : 		if (data->Attribute("vAngle"))

  0014d	6a 00		 push	 0
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00157	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0015c	85 c0		 test	 eax, eax
  0015e	74 49		 je	 SHORT $LN4@DataDeploy

; 135  : 		{
; 136  : 			viewAngle = ToRadians(atof(data->Attribute("vAngle")));

  00160	6a 00		 push	 0
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  00167	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0016a	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0016f	8b f4		 mov	 esi, esp
  00171	50		 push	 eax
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00178	83 c4 04	 add	 esp, 4
  0017b	3b f4		 cmp	 esi, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00182	dd 9d d4 fe ff
	ff		 fstp	 QWORD PTR tv310[ebp]
  00188	f2 0f 10 85 d4
	fe ff ff	 movsd	 xmm0, QWORD PTR tv310[ebp]
  00190	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18
  00198	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4066800000000000
  001a0	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001a4	f3 0f 11 45 dc	 movss	 DWORD PTR _viewAngle$[ebp], xmm0
$LN4@DataDeploy:

; 137  : 		}
; 138  : 
; 139  : 		if (data->Attribute("shadowMapSize"))

  001a9	6a 00		 push	 0
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001b3	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  001b8	85 c0		 test	 eax, eax
  001ba	74 2a		 je	 SHORT $LN5@DataDeploy

; 140  : 		{
; 141  : 			shadowMapSizeAsPowerOf2 = atof(data->Attribute("shadowMapSize"));

  001bc	6a 00		 push	 0
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001c6	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  001cb	8b f4		 mov	 esi, esp
  001cd	50		 push	 eax
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  001d4	83 c4 04	 add	 esp, 4
  001d7	3b f4		 cmp	 esi, esp
  001d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001de	e8 00 00 00 00	 call	 __ftol2_sse
  001e3	89 45 d8	 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], eax
$LN5@DataDeploy:

; 142  : 		}
; 143  : 
; 144  : 		if (data->Attribute("shadowArea"))

  001e6	6a 00		 push	 0
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDLHEOHF@shadowArea?$AA@
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001f0	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  001f5	85 c0		 test	 eax, eax
  001f7	74 25		 je	 SHORT $LN6@DataDeploy

; 145  : 		{
; 146  : 			shadowArea = atof(data->Attribute("shadowArea"));

  001f9	6a 00		 push	 0
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDLHEOHF@shadowArea?$AA@
  00200	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00203	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00208	8b f4		 mov	 esi, esp
  0020a	50		 push	 eax
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00211	83 c4 04	 add	 esp, 4
  00214	3b f4		 cmp	 esi, esp
  00216	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021b	d9 5d d0	 fstp	 DWORD PTR _shadowArea$[ebp]
$LN6@DataDeploy:

; 147  : 		}
; 148  : 
; 149  : 		if (data->Attribute("softness"))

  0021e	6a 00		 push	 0
  00220	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  00225	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00228	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0022d	85 c0		 test	 eax, eax
  0022f	74 25		 je	 SHORT $LN7@DataDeploy

; 150  : 		{
; 151  : 			shadowSoftness = atof(data->Attribute("softness"));

  00231	6a 00		 push	 0
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  00238	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0023b	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00240	8b f4		 mov	 esi, esp
  00242	50		 push	 eax
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00249	83 c4 04	 add	 esp, 4
  0024c	3b f4		 cmp	 esi, esp
  0024e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00253	d9 5d d4	 fstp	 DWORD PTR _shadowSoftness$[ebp]
$LN7@DataDeploy:

; 152  : 		}
; 153  : 
; 154  : 		if (data->Attribute("lightBleedReduction"))

  00256	6a 00		 push	 0
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  0025d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00260	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00265	85 c0		 test	 eax, eax
  00267	74 25		 je	 SHORT $LN8@DataDeploy

; 155  : 		{
; 156  : 			lightBleedReductionAmount = atof(data->Attribute("lightBleedReduction"));

  00269	6a 00		 push	 0
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  00270	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00273	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00278	8b f4		 mov	 esi, esp
  0027a	50		 push	 eax
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00281	83 c4 04	 add	 esp, 4
  00284	3b f4		 cmp	 esi, esp
  00286	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028b	d9 5d cc	 fstp	 DWORD PTR _lightBleedReductionAmount$[ebp]
$LN8@DataDeploy:

; 157  : 		}
; 158  : 
; 159  : 		if (data->Attribute("minVariance"))

  0028e	6a 00		 push	 0
  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  00295	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00298	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0029d	85 c0		 test	 eax, eax
  0029f	74 25		 je	 SHORT $LN9@DataDeploy

; 160  : 		{
; 161  : 			minVariance = atof(data->Attribute("minVariance"));

  002a1	6a 00		 push	 0
  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002ab	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002b0	8b f4		 mov	 esi, esp
  002b2	50		 push	 eax
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  002b9	83 c4 04	 add	 esp, 4
  002bc	3b f4		 cmp	 esi, esp
  002be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c3	d9 5d c8	 fstp	 DWORD PTR _minVariance$[ebp]
$LN9@DataDeploy:

; 162  : 		}
; 163  : 
; 164  : 		SetColor(color);

  002c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002c9	8b d4		 mov	 edx, esp
  002cb	8b 45 e8	 mov	 eax, DWORD PTR _color$[ebp]
  002ce	89 02		 mov	 DWORD PTR [edx], eax
  002d0	8b 4d ec	 mov	 ecx, DWORD PTR _color$[ebp+4]
  002d3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002d6	8b 45 f0	 mov	 eax, DWORD PTR _color$[ebp+8]
  002d9	89 42 08	 mov	 DWORD PTR [edx+8], eax
  002dc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002df	e8 00 00 00 00	 call	 ?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z ; BaseLight::SetColor

; 165  : 		SetIntensity(intensity);

  002e4	51		 push	 ecx
  002e5	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  002ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f2	e8 00 00 00 00	 call	 ?SetIntensity@BaseLight@@QAEPAV1@M@Z ; BaseLight::SetIntensity

; 166  : 		m_halfShadowArea = shadowArea / 2;

  002f7	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _shadowArea$[ebp]
  002fc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00304	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00307	f3 0f 11 81 90
	00 00 00	 movss	 DWORD PTR [ecx+144], xmm0

; 167  : 		
; 168  : 		if (shadowMapSizeAsPowerOf2 != 0)

  0030f	83 7d d8 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  00313	0f 84 d0 00 00
	00		 je	 $LN10@DataDeploy

; 169  : 		SetShadowInfo(ShadowInfo(Matrix4f().InitOrthographic(-m_halfShadowArea, m_halfShadowArea, -m_halfShadowArea,

  00319	51		 push	 ecx
  0031a	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  0031f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00324	51		 push	 ecx
  00325	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  0032a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032f	51		 push	 ecx
  00330	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  00335	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0033a	8b 55 d8	 mov	 edx, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  0033d	52		 push	 edx
  0033e	6a 01		 push	 1
  00340	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00343	51		 push	 ecx
  00344	f3 0f 10 80 90
	00 00 00	 movss	 xmm0, DWORD PTR [eax+144]
  0034c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00351	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00354	f3 0f 10 81 90
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+144]
  0035c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00363	51		 push	 ecx
  00364	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00369	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0036c	51		 push	 ecx
  0036d	f3 0f 10 82 90
	00 00 00	 movss	 xmm0, DWORD PTR [edx+144]
  00375	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0037d	f3 0f 10 80 90
	00 00 00	 movss	 xmm0, DWORD PTR [eax+144]
  00385	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0038c	51		 push	 ecx
  0038d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00392	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00395	51		 push	 ecx
  00396	f3 0f 10 81 90
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+144]
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003a6	f3 0f 10 82 90
	00 00 00	 movss	 xmm0, DWORD PTR [edx+144]
  003ae	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003b5	51		 push	 ecx
  003b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003bb	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003c1	50		 push	 eax
  003c2	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003c8	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  003cd	8b c8		 mov	 ecx, eax
  003cf	e8 00 00 00 00	 call	 ?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z ; Matrix4<float>::InitOrthographic
  003d4	50		 push	 eax
  003d5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003db	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  003e0	50		 push	 eax
  003e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e4	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN10@DataDeploy:

; 170  : 			m_halfShadowArea, -m_halfShadowArea, m_halfShadowArea)
; 171  : 			, true, shadowMapSizeAsPowerOf2, shadowSoftness, lightBleedReductionAmount, minVariance));
; 172  : 
; 173  : 	}

  003e9	52		 push	 edx
  003ea	8b cd		 mov	 ecx, ebp
  003ec	50		 push	 eax
  003ed	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@DataDeploy
  003f3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003f8	58		 pop	 eax
  003f9	5a		 pop	 edx
  003fa	5f		 pop	 edi
  003fb	5e		 pop	 esi
  003fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ff	33 cd		 xor	 ecx, ebp
  00401	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00406	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  0040c	3b ec		 cmp	 ebp, esp
  0040e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00413	8b e5		 mov	 esp, ebp
  00415	5d		 pop	 ebp
  00416	c2 04 00	 ret	 4
  00419	0f 1f 00	 npad	 3
$LN15@DataDeploy:
  0041c	01 00 00 00	 DD	 1
  00420	00 00 00 00	 DD	 $LN14@DataDeploy
$LN14@DataDeploy:
  00424	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00428	0c 00 00 00	 DD	 12			; 0000000cH
  0042c	00 00 00 00	 DD	 $LN13@DataDeploy
$LN13@DataDeploy:
  00430	63		 DB	 99			; 00000063H
  00431	6f		 DB	 111			; 0000006fH
  00432	6c		 DB	 108			; 0000006cH
  00433	6f		 DB	 111			; 0000006fH
  00434	72		 DB	 114			; 00000072H
  00435	00		 DB	 0
?DataDeploy@DirectionalLight@@UAEXPAVXMLElement@tinyxml2@@@Z ENDP ; DirectionalLight::DataDeploy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?__ClassType__@PointLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?__ClassType__@PointLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; PointLight::__ClassType__, COMDAT
; _this$ = ecx

; 198  : 	FCLASS (PointLight);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KGHCILHP@PointLight?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?__ClassType__@PointLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; PointLight::__ClassType__
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?DataDeploy@PointLight@@UAEXPAVXMLElement@tinyxml2@@@Z
_TEXT	SEGMENT
tv501 = -392						; size = 4
tv531 = -388						; size = 4
tv493 = -384						; size = 4
tv529 = -380						; size = 4
tv527 = -376						; size = 4
tv488 = -372						; size = 4
tv427 = -368						; size = 8
tv314 = -360						; size = 4
tv312 = -356						; size = 4
tv311 = -352						; size = 4
$T1 = -348						; size = 12
$T2 = -336						; size = 4
$T3 = -332						; size = 4
$T4 = -328						; size = 84
$T5 = -244						; size = 64
$T6 = -180						; size = 64
_c$ = -116						; size = 4
_b$ = -112						; size = 4
_a$ = -108						; size = 4
_att$7 = -100						; size = 12
$T8 = -84						; size = 12
_minVariance$ = -72					; size = 4
_lightBleedReductionAmount$ = -68			; size = 4
_shadowSoftness$ = -64					; size = 4
_shadowMapSizeAsPowerOf2$ = -60				; size = 4
_viewAngle$ = -56					; size = 4
_atten$ = -48						; size = 12
_intensity$ = -32					; size = 4
_color$ = -24						; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
?DataDeploy@PointLight@@UAEXPAVXMLElement@tinyxml2@@@Z PROC ; PointLight::DataDeploy, COMDAT
; _this$ = ecx

; 209  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd 78 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-392]
  00012	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 		Vector3f color = Vector3f(0, 0, 0); 

  0002c	51		 push	 ecx
  0002d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00035	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003a	51		 push	 ecx
  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	51		 push	 ecx
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	8d 4d e8	 lea	 ecx, DWORD PTR _color$[ebp]
  00059	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f

; 211  : 		float intensity = 0;

  0005e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00066	f3 0f 11 45 e0	 movss	 DWORD PTR _intensity$[ebp], xmm0

; 212  : 		Attenuation atten = Attenuation();

  0006b	51		 push	 ecx
  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	51		 push	 ecx
  0007a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00082	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00087	51		 push	 ecx
  00088	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	8d 4d d0	 lea	 ecx, DWORD PTR _atten$[ebp]
  00098	e8 00 00 00 00	 call	 ??0Attenuation@@QAE@MMM@Z ; Attenuation::Attenuation

; 213  : 		float viewAngle = ToRadians(170.0f);

  0009d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@403de44e
  000a5	f3 0f 11 45 c8	 movss	 DWORD PTR _viewAngle$[ebp], xmm0

; 214  : 		int shadowMapSizeAsPowerOf2 = 0;

  000aa	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0

; 215  : 		float shadowSoftness = 1.0f;

  000b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b9	f3 0f 11 45 c0	 movss	 DWORD PTR _shadowSoftness$[ebp], xmm0

; 216  : 		float lightBleedReductionAmount = 0.2f;

  000be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  000c6	f3 0f 11 45 bc	 movss	 DWORD PTR _lightBleedReductionAmount$[ebp], xmm0

; 217  : 		float minVariance = 0.00002f;

  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@37a7c5ac
  000d3	f3 0f 11 45 b8	 movss	 DWORD PTR _minVariance$[ebp], xmm0

; 218  : 
; 219  : 		if (data->Attribute("color"))

  000d8	6a 00		 push	 0
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000e2	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000e7	85 c0		 test	 eax, eax
  000e9	74 4f		 je	 SHORT $LN2@DataDeploy

; 220  : 		{
; 221  : 			color = Util::ParseVector3(data->Attribute("color"));

  000eb	6a 00		 push	 0
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000f5	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000fa	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000fd	8b cc		 mov	 ecx, esp
  000ff	89 a5 b4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010b	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv311[ebp], eax
  00111	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  0011a	83 c4 20	 add	 esp, 32			; 00000020H
  0011d	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv312[ebp], eax
  00123	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00129	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012b	89 55 e8	 mov	 DWORD PTR _color$[ebp], edx
  0012e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00131	89 45 ec	 mov	 DWORD PTR _color$[ebp+4], eax
  00134	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00137	89 4d f0	 mov	 DWORD PTR _color$[ebp+8], ecx
$LN2@DataDeploy:

; 222  : 		}
; 223  : 
; 224  : 		if (data->Attribute("intensity"))

  0013a	6a 00		 push	 0
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00144	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00149	85 c0		 test	 eax, eax
  0014b	74 25		 je	 SHORT $LN3@DataDeploy

; 225  : 		{
; 226  : 			intensity = atof(data->Attribute("intensity"));

  0014d	6a 00		 push	 0
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00157	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0015c	8b f4		 mov	 esi, esp
  0015e	50		 push	 eax
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00165	83 c4 04	 add	 esp, 4
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	d9 5d e0	 fstp	 DWORD PTR _intensity$[ebp]
$LN3@DataDeploy:

; 227  : 		}
; 228  : 
; 229  : 		if (data->Attribute("attenuation"))

  00172	6a 00		 push	 0
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NKGAHMMH@attenuation?$AA@
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0017c	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00181	85 c0		 test	 eax, eax
  00183	74 72		 je	 SHORT $LN4@DataDeploy

; 230  : 		{
; 231  : 			Vector3f att = Util::ParseVector3(data->Attribute("attenuation"));

  00185	6a 00		 push	 0
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NKGAHMMH@attenuation?$AA@
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0018f	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00194	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00197	8b cc		 mov	 ecx, esp
  00199	89 a5 b0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a5	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv314[ebp], eax
  001ab	8d 55 9c	 lea	 edx, DWORD PTR _att$7[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  001b4	83 c4 20	 add	 esp, 32			; 00000020H

; 232  : 			atten = Attenuation(att.GetX(), att.GetY(), att.GetZ());

  001b7	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001ba	e8 00 00 00 00	 call	 ?GetZ@Vector3f@@QBEMXZ	; Vector3f::GetZ
  001bf	51		 push	 ecx
  001c0	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c3	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001c6	e8 00 00 00 00	 call	 ?GetY@Vector3f@@QBEMXZ	; Vector3f::GetY
  001cb	51		 push	 ecx
  001cc	d9 1c 24	 fstp	 DWORD PTR [esp]
  001cf	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001d2	e8 00 00 00 00	 call	 ?GetX@Vector3f@@QBEMXZ	; Vector3f::GetX
  001d7	51		 push	 ecx
  001d8	d9 1c 24	 fstp	 DWORD PTR [esp]
  001db	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001e1	e8 00 00 00 00	 call	 ??0Attenuation@@QAE@MMM@Z ; Attenuation::Attenuation
  001e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e8	89 4d d0	 mov	 DWORD PTR _atten$[ebp], ecx
  001eb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ee	89 55 d4	 mov	 DWORD PTR _atten$[ebp+4], edx
  001f1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001f4	89 45 d8	 mov	 DWORD PTR _atten$[ebp+8], eax
$LN4@DataDeploy:

; 233  : 		}
; 234  : 
; 235  : 		if (data->Attribute("vAngle"))

  001f7	6a 00		 push	 0
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00201	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00206	85 c0		 test	 eax, eax
  00208	74 49		 je	 SHORT $LN5@DataDeploy

; 236  : 		{
; 237  : 			viewAngle = ToRadians(atof(data->Attribute("vAngle")));

  0020a	6a 00		 push	 0
  0020c	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  00211	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00214	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00219	8b f4		 mov	 esi, esp
  0021b	50		 push	 eax
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00222	83 c4 04	 add	 esp, 4
  00225	3b f4		 cmp	 esi, esp
  00227	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022c	dd 9d 90 fe ff
	ff		 fstp	 QWORD PTR tv427[ebp]
  00232	f2 0f 10 85 90
	fe ff ff	 movsd	 xmm0, QWORD PTR tv427[ebp]
  0023a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18
  00242	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4066800000000000
  0024a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0024e	f3 0f 11 45 c8	 movss	 DWORD PTR _viewAngle$[ebp], xmm0
$LN5@DataDeploy:

; 238  : 		}
; 239  : 
; 240  : 		if (data->Attribute("shadowMapSize"))

  00253	6a 00		 push	 0
  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  0025a	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0025d	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00262	85 c0		 test	 eax, eax
  00264	74 2a		 je	 SHORT $LN6@DataDeploy

; 241  : 		{
; 242  : 			shadowMapSizeAsPowerOf2 = atof(data->Attribute("shadowMapSize"));

  00266	6a 00		 push	 0
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00270	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00275	8b f4		 mov	 esi, esp
  00277	50		 push	 eax
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  0027e	83 c4 04	 add	 esp, 4
  00281	3b f4		 cmp	 esi, esp
  00283	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00288	e8 00 00 00 00	 call	 __ftol2_sse
  0028d	89 45 c4	 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], eax
$LN6@DataDeploy:

; 243  : 		}
; 244  : 
; 245  : 		if (data->Attribute("softness"))

  00290	6a 00		 push	 0
  00292	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  00297	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0029a	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0029f	85 c0		 test	 eax, eax
  002a1	74 25		 je	 SHORT $LN7@DataDeploy

; 246  : 		{
; 247  : 			shadowSoftness = atof(data->Attribute("softness"));

  002a3	6a 00		 push	 0
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002ad	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002b2	8b f4		 mov	 esi, esp
  002b4	50		 push	 eax
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  002bb	83 c4 04	 add	 esp, 4
  002be	3b f4		 cmp	 esi, esp
  002c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c5	d9 5d c0	 fstp	 DWORD PTR _shadowSoftness$[ebp]
$LN7@DataDeploy:

; 248  : 		}
; 249  : 
; 250  : 		if (data->Attribute("lightBleedReduction"))

  002c8	6a 00		 push	 0
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002d2	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002d7	85 c0		 test	 eax, eax
  002d9	74 25		 je	 SHORT $LN8@DataDeploy

; 251  : 		{
; 252  : 			lightBleedReductionAmount = atof(data->Attribute("lightBleedReduction"));

  002db	6a 00		 push	 0
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  002e2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002e5	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002ea	8b f4		 mov	 esi, esp
  002ec	50		 push	 eax
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  002f3	83 c4 04	 add	 esp, 4
  002f6	3b f4		 cmp	 esi, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fd	d9 5d bc	 fstp	 DWORD PTR _lightBleedReductionAmount$[ebp]
$LN8@DataDeploy:

; 253  : 		}
; 254  : 
; 255  : 		if (data->Attribute("minVariance"))

  00300	6a 00		 push	 0
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  00307	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0030a	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0030f	85 c0		 test	 eax, eax
  00311	74 25		 je	 SHORT $LN9@DataDeploy

; 256  : 		{
; 257  : 			minVariance = atof(data->Attribute("minVariance"));

  00313	6a 00		 push	 0
  00315	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  0031a	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0031d	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00322	8b f4		 mov	 esi, esp
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  0032b	83 c4 04	 add	 esp, 4
  0032e	3b f4		 cmp	 esi, esp
  00330	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00335	d9 5d b8	 fstp	 DWORD PTR _minVariance$[ebp]
$LN9@DataDeploy:

; 258  : 		}
; 259  : 
; 260  : 		SetColor(color);

  00338	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0033b	8b cc		 mov	 ecx, esp
  0033d	8b 55 e8	 mov	 edx, DWORD PTR _color$[ebp]
  00340	89 11		 mov	 DWORD PTR [ecx], edx
  00342	8b 45 ec	 mov	 eax, DWORD PTR _color$[ebp+4]
  00345	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00348	8b 55 f0	 mov	 edx, DWORD PTR _color$[ebp+8]
  0034b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0034e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00351	e8 00 00 00 00	 call	 ?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z ; BaseLight::SetColor

; 261  : 		SetIntensity(intensity);

  00356	51		 push	 ecx
  00357	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  0035c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00361	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	e8 00 00 00 00	 call	 ?SetIntensity@BaseLight@@QAEPAV1@M@Z ; BaseLight::SetIntensity

; 262  : 		m_attenuation = atten;

  00369	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0036c	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00371	8b 4d d0	 mov	 ecx, DWORD PTR _atten$[ebp]
  00374	89 08		 mov	 DWORD PTR [eax], ecx
  00376	8b 55 d4	 mov	 edx, DWORD PTR _atten$[ebp+4]
  00379	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0037c	8b 4d d8	 mov	 ecx, DWORD PTR _atten$[ebp+8]
  0037f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 263  : 
; 264  : 		float a = m_attenuation.GetExponent();

  00382	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0038b	e8 00 00 00 00	 call	 ?GetExponent@Attenuation@@QBEMXZ ; Attenuation::GetExponent
  00390	d9 5d 94	 fstp	 DWORD PTR _a$[ebp]

; 265  : 		float b = m_attenuation.GetLinear();

  00393	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00396	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0039c	e8 00 00 00 00	 call	 ?GetLinear@Attenuation@@QBEMXZ ; Attenuation::GetLinear
  003a1	d9 5d 90	 fstp	 DWORD PTR _b$[ebp]

; 266  : 		float c = m_attenuation.GetConstant() - COLOR_DEPTH * intensity * color.Max();

  003a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  003ad	e8 00 00 00 00	 call	 ?GetConstant@Attenuation@@QBEMXZ ; Attenuation::GetConstant
  003b2	d9 9d 8c fe ff
	ff		 fstp	 DWORD PTR tv488[ebp]
  003b8	f3 0f 10 85 8c
	fe ff ff	 movss	 xmm0, DWORD PTR tv488[ebp]
  003c0	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@43800000
  003c8	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR _intensity$[ebp]
  003cd	8d 4d e8	 lea	 ecx, DWORD PTR _color$[ebp]
  003d0	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv527[ebp], xmm0
  003d8	f3 0f 11 8d 84
	fe ff ff	 movss	 DWORD PTR tv529[ebp], xmm1
  003e0	e8 00 00 00 00	 call	 ?Max@?$Vector@M$02@@QBEMXZ ; Vector<float,3>::Max
  003e5	d9 9d 80 fe ff
	ff		 fstp	 DWORD PTR tv493[ebp]
  003eb	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv529[ebp]
  003f3	f3 0f 59 85 80
	fe ff ff	 mulss	 xmm0, DWORD PTR tv493[ebp]
  003fb	f3 0f 10 8d 88
	fe ff ff	 movss	 xmm1, DWORD PTR tv527[ebp]
  00403	f3 0f 5c c8	 subss	 xmm1, xmm0
  00407	f3 0f 11 4d 8c	 movss	 DWORD PTR _c$[ebp], xmm1

; 267  : 
; 268  : 		m_range = (-b + sqrtf(b*b - 4 * a*c)) / (2 * a);

  0040c	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _b$[ebp]
  00411	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00418	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _b$[ebp]
  0041d	f3 0f 59 4d 90	 mulss	 xmm1, DWORD PTR _b$[ebp]
  00422	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40800000
  0042a	f3 0f 59 55 94	 mulss	 xmm2, DWORD PTR _a$[ebp]
  0042f	f3 0f 59 55 8c	 mulss	 xmm2, DWORD PTR _c$[ebp]
  00434	f3 0f 5c ca	 subss	 xmm1, xmm2
  00438	51		 push	 ecx
  00439	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0043e	f3 0f 11 85 7c
	fe ff ff	 movss	 DWORD PTR tv531[ebp], xmm0
  00446	e8 00 00 00 00	 call	 _sqrtf
  0044b	83 c4 04	 add	 esp, 4
  0044e	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR tv501[ebp]
  00454	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR tv531[ebp]
  0045c	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR tv501[ebp]
  00464	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  0046c	f3 0f 59 4d 94	 mulss	 xmm1, DWORD PTR _a$[ebp]
  00471	f3 0f 5e c1	 divss	 xmm0, xmm1
  00475	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00478	f3 0f 11 82 9c
	00 00 00	 movss	 DWORD PTR [edx+156], xmm0

; 269  : 
; 270  : 		if (shadowMapSizeAsPowerOf2 != 0)

  00480	83 7d c4 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  00484	0f 84 88 00 00
	00		 je	 $LN10@DataDeploy

; 271  : 		SetShadowInfo(ShadowInfo(Matrix4f().InitPerspective(viewAngle, 1.0f, 0.1f, GetRange()), false, shadowMapSizeAsPowerOf2, shadowSoftness, lightBleedReductionAmount, minVariance));

  0048a	51		 push	 ecx
  0048b	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  00490	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00495	51		 push	 ecx
  00496	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  0049b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a0	51		 push	 ecx
  004a1	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  004a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ab	8b 45 c4	 mov	 eax, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  004ae	50		 push	 eax
  004af	6a 00		 push	 0
  004b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004b4	e8 00 00 00 00	 call	 ?GetRange@PointLight@@QBE?BMXZ ; PointLight::GetRange
  004b9	51		 push	 ecx
  004ba	d9 1c 24	 fstp	 DWORD PTR [esp]
  004bd	51		 push	 ecx
  004be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  004c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cb	51		 push	 ecx
  004cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d9	51		 push	 ecx
  004da	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  004df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e4	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  004ea	51		 push	 ecx
  004eb	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  004f1	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  004f6	8b c8		 mov	 ecx, eax
  004f8	e8 00 00 00 00	 call	 ?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z ; Matrix4<float>::InitPerspective
  004fd	50		 push	 eax
  004fe	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00504	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  00509	50		 push	 eax
  0050a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0050d	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN10@DataDeploy:

; 272  : 	}

  00512	52		 push	 edx
  00513	8b cd		 mov	 ecx, ebp
  00515	50		 push	 eax
  00516	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@DataDeploy
  0051c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00521	58		 pop	 eax
  00522	5a		 pop	 edx
  00523	5f		 pop	 edi
  00524	5e		 pop	 esi
  00525	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00528	33 cd		 xor	 ecx, ebp
  0052a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052f	81 c4 88 01 00
	00		 add	 esp, 392		; 00000188H
  00535	3b ec		 cmp	 ebp, esp
  00537	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c2 04 00	 ret	 4
  00542	66 90		 npad	 2
$LN18@DataDeploy:
  00544	03 00 00 00	 DD	 3
  00548	00 00 00 00	 DD	 $LN17@DataDeploy
$LN17@DataDeploy:
  0054c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00550	0c 00 00 00	 DD	 12			; 0000000cH
  00554	00 00 00 00	 DD	 $LN14@DataDeploy
  00558	d0 ff ff ff	 DD	 -48			; ffffffd0H
  0055c	0c 00 00 00	 DD	 12			; 0000000cH
  00560	00 00 00 00	 DD	 $LN15@DataDeploy
  00564	9c ff ff ff	 DD	 -100			; ffffff9cH
  00568	0c 00 00 00	 DD	 12			; 0000000cH
  0056c	00 00 00 00	 DD	 $LN16@DataDeploy
$LN16@DataDeploy:
  00570	61		 DB	 97			; 00000061H
  00571	74		 DB	 116			; 00000074H
  00572	74		 DB	 116			; 00000074H
  00573	00		 DB	 0
$LN15@DataDeploy:
  00574	61		 DB	 97			; 00000061H
  00575	74		 DB	 116			; 00000074H
  00576	74		 DB	 116			; 00000074H
  00577	65		 DB	 101			; 00000065H
  00578	6e		 DB	 110			; 0000006eH
  00579	00		 DB	 0
$LN14@DataDeploy:
  0057a	63		 DB	 99			; 00000063H
  0057b	6f		 DB	 111			; 0000006fH
  0057c	6c		 DB	 108			; 0000006cH
  0057d	6f		 DB	 111			; 0000006fH
  0057e	72		 DB	 114			; 00000072H
  0057f	00		 DB	 0
?DataDeploy@PointLight@@UAEXPAVXMLElement@tinyxml2@@@Z ENDP ; PointLight::DataDeploy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?__ClassType__@SpotLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?__ClassType__@SpotLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; SpotLight::__ClassType__, COMDAT
; _this$ = ecx

; 283  : 	FCLASS (SpotLight);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_09OIMHBJMD@SpotLight?$AA@
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	83 c8 01	 or	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00037	83 c4 08	 add	 esp, 8
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?__ClassType__@SpotLight@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; SpotLight::__ClassType__
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.h
;	COMDAT ?DataDeploy@SpotLight@@UAEXPAVXMLElement@tinyxml2@@@Z
_TEXT	SEGMENT
tv501 = -384						; size = 4
tv527 = -380						; size = 4
tv525 = -376						; size = 4
tv496 = -372						; size = 4
tv403 = -368						; size = 8
tv323 = -360						; size = 4
tv321 = -356						; size = 4
tv320 = -352						; size = 4
$T1 = -348						; size = 12
$T2 = -336						; size = 4
$T3 = -332						; size = 4
$T4 = -328						; size = 84
$T5 = -244						; size = 64
$T6 = -180						; size = 64
_c$ = -116						; size = 4
_b$ = -112						; size = 4
_a$ = -108						; size = 4
_att$7 = -100						; size = 12
$T8 = -84						; size = 12
_minVariance$ = -72					; size = 4
_lightBleedReductionAmount$ = -68			; size = 4
_shadowSoftness$ = -64					; size = 4
_shadowMapSizeAsPowerOf2$ = -60				; size = 4
_viewAngle$ = -56					; size = 4
_atten$ = -48						; size = 12
_intensity$ = -32					; size = 4
_color$ = -24						; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
?DataDeploy@SpotLight@@UAEXPAVXMLElement@tinyxml2@@@Z PROC ; SpotLight::DataDeploy, COMDAT
; _this$ = ecx

; 292  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd 80 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-384]
  00012	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 		Vector3f color = Vector3f(0, 0, 0);

  0002c	51		 push	 ecx
  0002d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00035	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003a	51		 push	 ecx
  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	51		 push	 ecx
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	8d 4d e8	 lea	 ecx, DWORD PTR _color$[ebp]
  00059	e8 00 00 00 00	 call	 ??0Vector3f@@QAE@MMM@Z	; Vector3f::Vector3f

; 294  : 		float intensity = 0;

  0005e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00066	f3 0f 11 45 e0	 movss	 DWORD PTR _intensity$[ebp], xmm0

; 295  : 		Attenuation atten = Attenuation();

  0006b	51		 push	 ecx
  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	51		 push	 ecx
  0007a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00082	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00087	51		 push	 ecx
  00088	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	8d 4d d0	 lea	 ecx, DWORD PTR _atten$[ebp]
  00098	e8 00 00 00 00	 call	 ??0Attenuation@@QAE@MMM@Z ; Attenuation::Attenuation

; 296  : 		float viewAngle = ToRadians(170.0f);

  0009d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@403de44e
  000a5	f3 0f 11 45 c8	 movss	 DWORD PTR _viewAngle$[ebp], xmm0

; 297  : 		int shadowMapSizeAsPowerOf2 = 0;

  000aa	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0

; 298  : 		float shadowSoftness = 1.0f;

  000b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b9	f3 0f 11 45 c0	 movss	 DWORD PTR _shadowSoftness$[ebp], xmm0

; 299  : 		float lightBleedReductionAmount = 0.2f;

  000be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  000c6	f3 0f 11 45 bc	 movss	 DWORD PTR _lightBleedReductionAmount$[ebp], xmm0

; 300  : 		float minVariance = 0.00002f;

  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@37a7c5ac
  000d3	f3 0f 11 45 b8	 movss	 DWORD PTR _minVariance$[ebp], xmm0

; 301  : 
; 302  : 		if (data->Attribute("color"))

  000d8	6a 00		 push	 0
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000e2	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000e7	85 c0		 test	 eax, eax
  000e9	74 4f		 je	 SHORT $LN2@DataDeploy

; 303  : 		{
; 304  : 			color = Util::ParseVector3(data->Attribute("color"));

  000eb	6a 00		 push	 0
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_05PEENBMOG@color?$AA@
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000f5	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  000fa	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000fd	8b cc		 mov	 ecx, esp
  000ff	89 a5 b4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010b	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv320[ebp], eax
  00111	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  0011a	83 c4 20	 add	 esp, 32			; 00000020H
  0011d	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv321[ebp], eax
  00123	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv321[ebp]
  00129	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012b	89 55 e8	 mov	 DWORD PTR _color$[ebp], edx
  0012e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00131	89 45 ec	 mov	 DWORD PTR _color$[ebp+4], eax
  00134	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00137	89 4d f0	 mov	 DWORD PTR _color$[ebp+8], ecx
$LN2@DataDeploy:

; 305  : 		}
; 306  : 
; 307  : 		if (data->Attribute("intensity"))

  0013a	6a 00		 push	 0
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00144	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00149	85 c0		 test	 eax, eax
  0014b	74 25		 je	 SHORT $LN3@DataDeploy

; 308  : 		{
; 309  : 			intensity = atof(data->Attribute("intensity"));

  0014d	6a 00		 push	 0
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_09DDBFFAKC@intensity?$AA@
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00157	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0015c	8b f4		 mov	 esi, esp
  0015e	50		 push	 eax
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00165	83 c4 04	 add	 esp, 4
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	d9 5d e0	 fstp	 DWORD PTR _intensity$[ebp]
$LN3@DataDeploy:

; 310  : 		}
; 311  : 
; 312  : 		if (data->Attribute("attenuation"))

  00172	6a 00		 push	 0
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NKGAHMMH@attenuation?$AA@
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0017c	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00181	85 c0		 test	 eax, eax
  00183	74 72		 je	 SHORT $LN4@DataDeploy

; 313  : 		{
; 314  : 			Vector3f att = Util::ParseVector3(data->Attribute("attenuation"));

  00185	6a 00		 push	 0
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NKGAHMMH@attenuation?$AA@
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0018f	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00194	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00197	8b cc		 mov	 ecx, esp
  00199	89 a5 b0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a5	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  001ab	8d 55 9c	 lea	 edx, DWORD PTR _att$7[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?ParseVector3@Util@@YA?AVVector3f@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::ParseVector3
  001b4	83 c4 20	 add	 esp, 32			; 00000020H

; 315  : 			atten = Attenuation(att.GetX(), att.GetY(), att.GetZ());

  001b7	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001ba	e8 00 00 00 00	 call	 ?GetZ@Vector3f@@QBEMXZ	; Vector3f::GetZ
  001bf	51		 push	 ecx
  001c0	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c3	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001c6	e8 00 00 00 00	 call	 ?GetY@Vector3f@@QBEMXZ	; Vector3f::GetY
  001cb	51		 push	 ecx
  001cc	d9 1c 24	 fstp	 DWORD PTR [esp]
  001cf	8d 4d 9c	 lea	 ecx, DWORD PTR _att$7[ebp]
  001d2	e8 00 00 00 00	 call	 ?GetX@Vector3f@@QBEMXZ	; Vector3f::GetX
  001d7	51		 push	 ecx
  001d8	d9 1c 24	 fstp	 DWORD PTR [esp]
  001db	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001e1	e8 00 00 00 00	 call	 ??0Attenuation@@QAE@MMM@Z ; Attenuation::Attenuation
  001e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e8	89 4d d0	 mov	 DWORD PTR _atten$[ebp], ecx
  001eb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ee	89 55 d4	 mov	 DWORD PTR _atten$[ebp+4], edx
  001f1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001f4	89 45 d8	 mov	 DWORD PTR _atten$[ebp+8], eax
$LN4@DataDeploy:

; 316  : 		}
; 317  : 
; 318  : 		if (data->Attribute("vAngle"))

  001f7	6a 00		 push	 0
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00201	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00206	85 c0		 test	 eax, eax
  00208	74 49		 je	 SHORT $LN5@DataDeploy

; 319  : 		{
; 320  : 			viewAngle = ToRadians(atof(data->Attribute("vAngle")));

  0020a	6a 00		 push	 0
  0020c	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJLLHGJ@vAngle?$AA@
  00211	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00214	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00219	8b f4		 mov	 esi, esp
  0021b	50		 push	 eax
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00222	83 c4 04	 add	 esp, 4
  00225	3b f4		 cmp	 esi, esp
  00227	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022c	dd 9d 90 fe ff
	ff		 fstp	 QWORD PTR tv403[ebp]
  00232	f2 0f 10 85 90
	fe ff ff	 movsd	 xmm0, QWORD PTR tv403[ebp]
  0023a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18
  00242	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4066800000000000
  0024a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0024e	f3 0f 11 45 c8	 movss	 DWORD PTR _viewAngle$[ebp], xmm0
$LN5@DataDeploy:

; 321  : 		}
; 322  : 
; 323  : 		if (data->Attribute("shadowMapSize"))

  00253	6a 00		 push	 0
  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  0025a	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0025d	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00262	85 c0		 test	 eax, eax
  00264	74 2a		 je	 SHORT $LN6@DataDeploy

; 324  : 		{
; 325  : 			shadowMapSizeAsPowerOf2 = atof(data->Attribute("shadowMapSize"));

  00266	6a 00		 push	 0
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OHGEMPPD@shadowMapSize?$AA@
  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00270	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00275	8b f4		 mov	 esi, esp
  00277	50		 push	 eax
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  0027e	83 c4 04	 add	 esp, 4
  00281	3b f4		 cmp	 esi, esp
  00283	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00288	e8 00 00 00 00	 call	 __ftol2_sse
  0028d	89 45 c4	 mov	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], eax
$LN6@DataDeploy:

; 326  : 		}
; 327  : 
; 328  : 		if (data->Attribute("softness"))

  00290	6a 00		 push	 0
  00292	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  00297	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0029a	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0029f	85 c0		 test	 eax, eax
  002a1	74 25		 je	 SHORT $LN7@DataDeploy

; 329  : 		{
; 330  : 			shadowSoftness = atof(data->Attribute("softness"));

  002a3	6a 00		 push	 0
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_08NJJJKCHP@softness?$AA@
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002ad	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002b2	8b f4		 mov	 esi, esp
  002b4	50		 push	 eax
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  002bb	83 c4 04	 add	 esp, 4
  002be	3b f4		 cmp	 esi, esp
  002c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c5	d9 5d c0	 fstp	 DWORD PTR _shadowSoftness$[ebp]
$LN7@DataDeploy:

; 331  : 		}
; 332  : 
; 333  : 		if (data->Attribute("lightBleedReduction"))

  002c8	6a 00		 push	 0
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002d2	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002d7	85 c0		 test	 eax, eax
  002d9	74 25		 je	 SHORT $LN8@DataDeploy

; 334  : 		{
; 335  : 			lightBleedReductionAmount = atof(data->Attribute("lightBleedReduction"));

  002db	6a 00		 push	 0
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLOIECEN@lightBleedReduction?$AA@
  002e2	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  002e5	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  002ea	8b f4		 mov	 esi, esp
  002ec	50		 push	 eax
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  002f3	83 c4 04	 add	 esp, 4
  002f6	3b f4		 cmp	 esi, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fd	d9 5d bc	 fstp	 DWORD PTR _lightBleedReductionAmount$[ebp]
$LN8@DataDeploy:

; 336  : 		}
; 337  : 
; 338  : 		if (data->Attribute("minVariance"))

  00300	6a 00		 push	 0
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  00307	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0030a	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  0030f	85 c0		 test	 eax, eax
  00311	74 25		 je	 SHORT $LN9@DataDeploy

; 339  : 		{
; 340  : 			minVariance = atof(data->Attribute("minVariance"));

  00313	6a 00		 push	 0
  00315	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCNFPLBH@minVariance?$AA@
  0031a	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0031d	e8 00 00 00 00	 call	 ?Attribute@XMLElement@tinyxml2@@QBEPBDPBD0@Z ; tinyxml2::XMLElement::Attribute
  00322	8b f4		 mov	 esi, esp
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  0032b	83 c4 04	 add	 esp, 4
  0032e	3b f4		 cmp	 esi, esp
  00330	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00335	d9 5d b8	 fstp	 DWORD PTR _minVariance$[ebp]
$LN9@DataDeploy:

; 341  : 		}
; 342  : 
; 343  : 		SetColor(color);

  00338	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0033b	8b cc		 mov	 ecx, esp
  0033d	8b 55 e8	 mov	 edx, DWORD PTR _color$[ebp]
  00340	89 11		 mov	 DWORD PTR [ecx], edx
  00342	8b 45 ec	 mov	 eax, DWORD PTR _color$[ebp+4]
  00345	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00348	8b 55 f0	 mov	 edx, DWORD PTR _color$[ebp+8]
  0034b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0034e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00351	e8 00 00 00 00	 call	 ?SetColor@BaseLight@@QAEPAV1@VVector3f@@@Z ; BaseLight::SetColor

; 344  : 		SetIntensity(intensity);

  00356	51		 push	 ecx
  00357	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _intensity$[ebp]
  0035c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00361	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	e8 00 00 00 00	 call	 ?SetIntensity@BaseLight@@QAEPAV1@M@Z ; BaseLight::SetIntensity

; 345  : 		m_attenuation = atten;

  00369	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0036c	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00371	8b 4d d0	 mov	 ecx, DWORD PTR _atten$[ebp]
  00374	89 08		 mov	 DWORD PTR [eax], ecx
  00376	8b 55 d4	 mov	 edx, DWORD PTR _atten$[ebp+4]
  00379	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0037c	8b 4d d8	 mov	 ecx, DWORD PTR _atten$[ebp+8]
  0037f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 346  : 
; 347  : 		float a = m_attenuation.GetExponent();

  00382	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0038b	e8 00 00 00 00	 call	 ?GetExponent@Attenuation@@QBEMXZ ; Attenuation::GetExponent
  00390	d9 5d 94	 fstp	 DWORD PTR _a$[ebp]

; 348  : 		float b = m_attenuation.GetLinear();

  00393	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00396	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  0039c	e8 00 00 00 00	 call	 ?GetLinear@Attenuation@@QBEMXZ ; Attenuation::GetLinear
  003a1	d9 5d 90	 fstp	 DWORD PTR _b$[ebp]

; 349  : 		float c = m_attenuation.GetConstant() - COLOR_DEPTH * intensity * color.Max();

  003a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  003ad	e8 00 00 00 00	 call	 ?GetConstant@Attenuation@@QBEMXZ ; Attenuation::GetConstant
  003b2	d9 9d 8c fe ff
	ff		 fstp	 DWORD PTR tv496[ebp]
  003b8	f3 0f 10 85 8c
	fe ff ff	 movss	 xmm0, DWORD PTR tv496[ebp]
  003c0	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@43800000
  003c8	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR _intensity$[ebp]
  003cd	8d 4d e8	 lea	 ecx, DWORD PTR _color$[ebp]
  003d0	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv525[ebp], xmm0
  003d8	f3 0f 11 8d 84
	fe ff ff	 movss	 DWORD PTR tv527[ebp], xmm1
  003e0	e8 00 00 00 00	 call	 ?Max@?$Vector@M$02@@QBEMXZ ; Vector<float,3>::Max
  003e5	d9 9d 80 fe ff
	ff		 fstp	 DWORD PTR tv501[ebp]
  003eb	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv527[ebp]
  003f3	f3 0f 59 85 80
	fe ff ff	 mulss	 xmm0, DWORD PTR tv501[ebp]
  003fb	f3 0f 10 8d 88
	fe ff ff	 movss	 xmm1, DWORD PTR tv525[ebp]
  00403	f3 0f 5c c8	 subss	 xmm1, xmm0
  00407	f3 0f 11 4d 8c	 movss	 DWORD PTR _c$[ebp], xmm1

; 350  : 
; 351  : 		if (shadowMapSizeAsPowerOf2 != 0)

  0040c	83 7d c4 00	 cmp	 DWORD PTR _shadowMapSizeAsPowerOf2$[ebp], 0
  00410	0f 84 88 00 00
	00		 je	 $LN10@DataDeploy

; 352  : 		SetShadowInfo(ShadowInfo(Matrix4f().InitPerspective(viewAngle, 1.0f, 0.1f, GetRange()), false, shadowMapSizeAsPowerOf2, shadowSoftness, lightBleedReductionAmount, minVariance));

  00416	51		 push	 ecx
  00417	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _minVariance$[ebp]
  0041c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00421	51		 push	 ecx
  00422	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _lightBleedReductionAmount$[ebp]
  00427	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0042c	51		 push	 ecx
  0042d	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _shadowSoftness$[ebp]
  00432	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00437	8b 55 c4	 mov	 edx, DWORD PTR _shadowMapSizeAsPowerOf2$[ebp]
  0043a	52		 push	 edx
  0043b	6a 00		 push	 0
  0043d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00440	e8 00 00 00 00	 call	 ?GetRange@PointLight@@QBE?BMXZ ; PointLight::GetRange
  00445	51		 push	 ecx
  00446	d9 1c 24	 fstp	 DWORD PTR [esp]
  00449	51		 push	 ecx
  0044a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00452	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00457	51		 push	 ecx
  00458	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00460	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00465	51		 push	 ecx
  00466	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _viewAngle$[ebp]
  0046b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00470	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00476	50		 push	 eax
  00477	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0047d	e8 00 00 00 00	 call	 ??0?$Matrix4@M@@QAE@XZ	; Matrix4<float>::Matrix4<float>
  00482	8b c8		 mov	 ecx, eax
  00484	e8 00 00 00 00	 call	 ?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z ; Matrix4<float>::InitPerspective
  00489	50		 push	 eax
  0048a	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00490	e8 00 00 00 00	 call	 ??0ShadowInfo@@QAE@ABV?$Matrix4@M@@_NHMMM@Z ; ShadowInfo::ShadowInfo
  00495	50		 push	 eax
  00496	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00499	e8 00 00 00 00	 call	 ?SetShadowInfo@BaseLight@@IAEXABVShadowInfo@@@Z ; BaseLight::SetShadowInfo
$LN10@DataDeploy:

; 353  : 	}

  0049e	52		 push	 edx
  0049f	8b cd		 mov	 ecx, ebp
  004a1	50		 push	 eax
  004a2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@DataDeploy
  004a8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ad	58		 pop	 eax
  004ae	5a		 pop	 edx
  004af	5f		 pop	 edi
  004b0	5e		 pop	 esi
  004b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b4	33 cd		 xor	 ecx, ebp
  004b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bb	81 c4 80 01 00
	00		 add	 esp, 384		; 00000180H
  004c1	3b ec		 cmp	 ebp, esp
  004c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c8	8b e5		 mov	 esp, ebp
  004ca	5d		 pop	 ebp
  004cb	c2 04 00	 ret	 4
  004ce	66 90		 npad	 2
$LN18@DataDeploy:
  004d0	03 00 00 00	 DD	 3
  004d4	00 00 00 00	 DD	 $LN17@DataDeploy
$LN17@DataDeploy:
  004d8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  004dc	0c 00 00 00	 DD	 12			; 0000000cH
  004e0	00 00 00 00	 DD	 $LN14@DataDeploy
  004e4	d0 ff ff ff	 DD	 -48			; ffffffd0H
  004e8	0c 00 00 00	 DD	 12			; 0000000cH
  004ec	00 00 00 00	 DD	 $LN15@DataDeploy
  004f0	9c ff ff ff	 DD	 -100			; ffffff9cH
  004f4	0c 00 00 00	 DD	 12			; 0000000cH
  004f8	00 00 00 00	 DD	 $LN16@DataDeploy
$LN16@DataDeploy:
  004fc	61		 DB	 97			; 00000061H
  004fd	74		 DB	 116			; 00000074H
  004fe	74		 DB	 116			; 00000074H
  004ff	00		 DB	 0
$LN15@DataDeploy:
  00500	61		 DB	 97			; 00000061H
  00501	74		 DB	 116			; 00000074H
  00502	74		 DB	 116			; 00000074H
  00503	65		 DB	 101			; 00000065H
  00504	6e		 DB	 110			; 0000006eH
  00505	00		 DB	 0
$LN14@DataDeploy:
  00506	63		 DB	 99			; 00000063H
  00507	6f		 DB	 111			; 0000006fH
  00508	6c		 DB	 108			; 0000006cH
  00509	6f		 DB	 111			; 0000006fH
  0050a	72		 DB	 114			; 00000072H
  0050b	00		 DB	 0
?DataDeploy@SpotLight@@UAEXPAVXMLElement@tinyxml2@@@Z ENDP ; SpotLight::DataDeploy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\renderingengine.h
;	COMDAT ?AddLight@RenderingEngine@@QAEXPAVBaseLight@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_light$ = 8						; size = 4
?AddLight@RenderingEngine@@QAEXPAVBaseLight@@@Z PROC	; RenderingEngine::AddLight, COMDAT
; _this$ = ecx

; 48   : 	inline void AddLight(BaseLight* light) { m_lights.push_back(light); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8d 45 08	 lea	 eax, DWORD PTR _light$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 30 06 00
	00		 add	 ecx, 1584		; 00000630H
  0001b	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXABQAVBaseLight@@@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::push_back
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?AddLight@RenderingEngine@@QAEXPAVBaseLight@@@Z ENDP	; RenderingEngine::AddLight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GDirectionalLight@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDirectionalLight@@UAEPAXI@Z PROC			; DirectionalLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1DirectionalLight@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 11		 je	 SHORT $LN2@scalar
  0001e	68 94 00 00 00	 push	 148			; 00000094H
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??_GDirectionalLight@@UAEPAXI@Z ENDP			; DirectionalLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1DirectionalLight@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DirectionalLight@@UAE@XZ PROC			; DirectionalLight::~DirectionalLight, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1BaseLight@@UAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1DirectionalLight@@UAE@XZ ENDP			; DirectionalLight::~DirectionalLight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\rendering\lighting.cpp
_TEXT	SEGMENT
tv206 = -152						; size = 4
tv201 = -148						; size = 4
tv195 = -144						; size = 4
tv190 = -140						; size = 4
tv225 = -136						; size = 4
tv178 = -132						; size = 4
$T1 = -128						; size = 12
$T2 = -116						; size = 16
_lightSpaceCameraPos$ = -96				; size = 12
_worldTexelSize$ = -80					; size = 4
_resultRot$ = -72					; size = 16
$T3 = -52						; size = 12
$T4 = -40						; size = 12
_resultPos$ = -24					; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_mainCameraPos$ = 12					; size = 4
_mainCameraRot$ = 16					; size = 4
?CalcShadowCameraTransform@DirectionalLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z PROC ; DirectionalLight::CalcShadowCameraTransform
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 68 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-152]
  00011	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : 	Vector3f resultPos = mainCameraPos + mainCameraRot.GetForward() * GetHalfShadowArea();

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetHalfShadowArea@DirectionalLight@@QBEMXZ ; DirectionalLight::GetHalfShadowArea
  00033	51		 push	 ecx
  00034	d9 1c 24	 fstp	 DWORD PTR [esp]
  00037	8d 45 cc	 lea	 eax, DWORD PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0003e	51		 push	 ecx
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _mainCameraRot$[ebp]
  00042	e8 00 00 00 00	 call	 ?GetForward@Quaternion@@QBE?AVVector3f@@XZ ; Quaternion::GetForward
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ??DVector3f@@QBE?AV0@M@Z ; Vector3f::operator*
  0004e	50		 push	 eax
  0004f	8d 55 e8	 lea	 edx, DWORD PTR _resultPos$[ebp]
  00052	52		 push	 edx
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _mainCameraPos$[ebp]
  00056	e8 00 00 00 00	 call	 ??HVector3f@@QBE?AV0@ABV0@@Z ; Vector3f::operator+

; 48   : 	Quaternion resultRot = GetTransform().GetTransformedRot();

  0005b	8d 45 b8	 lea	 eax, DWORD PTR _resultRot$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?GetTransform@EntityComponent@@QBEABVTransform@@XZ ; EntityComponent::GetTransform
  00067	8b c8		 mov	 ecx, eax
  00069	e8 00 00 00 00	 call	 ?GetTransformedRot@Transform@@QBE?AVQuaternion@@XZ ; Transform::GetTransformedRot

; 49   : 	
; 50   : 	float worldTexelSize = (GetHalfShadowArea()*2)/((float)(1 << GetShadowInfo().GetShadowMapSizeAsPowerOf2()));

  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?GetHalfShadowArea@DirectionalLight@@QBEMXZ ; DirectionalLight::GetHalfShadowArea
  00076	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR tv178[ebp]
  0007c	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR tv178[ebp]
  00084	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR tv225[ebp], xmm0
  00097	e8 00 00 00 00	 call	 ?GetShadowInfo@BaseLight@@QBEABVShadowInfo@@XZ ; BaseLight::GetShadowInfo
  0009c	8b c8		 mov	 ecx, eax
  0009e	e8 00 00 00 00	 call	 ?GetShadowMapSizeAsPowerOf2@ShadowInfo@@QBEHXZ ; ShadowInfo::GetShadowMapSizeAsPowerOf2
  000a3	ba 01 00 00 00	 mov	 edx, 1
  000a8	8b c8		 mov	 ecx, eax
  000aa	d3 e2		 shl	 edx, cl
  000ac	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000b0	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR tv225[ebp]
  000b8	f3 0f 5e c8	 divss	 xmm1, xmm0
  000bc	f3 0f 11 4d b0	 movss	 DWORD PTR _worldTexelSize$[ebp], xmm1

; 51   : 	
; 52   : 	Vector3f lightSpaceCameraPos = resultPos.Rotate(resultRot.Conjugate());

  000c1	8d 45 8c	 lea	 eax, DWORD PTR $T2[ebp]
  000c4	50		 push	 eax
  000c5	8d 4d b8	 lea	 ecx, DWORD PTR _resultRot$[ebp]
  000c8	e8 00 00 00 00	 call	 ?Conjugate@Quaternion@@QBE?AV1@XZ ; Quaternion::Conjugate
  000cd	50		 push	 eax
  000ce	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  000d1	51		 push	 ecx
  000d2	8d 4d e8	 lea	 ecx, DWORD PTR _resultPos$[ebp]
  000d5	e8 00 00 00 00	 call	 ?Rotate@Vector3f@@QBE?AV1@ABVQuaternion@@@Z ; Vector3f::Rotate

; 53   : 	
; 54   : 	lightSpaceCameraPos.SetX(worldTexelSize * floor(lightSpaceCameraPos.GetX() / worldTexelSize));

  000da	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  000dd	e8 00 00 00 00	 call	 ?GetX@Vector3f@@QBEMXZ	; Vector3f::GetX
  000e2	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR tv190[ebp]
  000e8	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv190[ebp]
  000f0	f3 0f 5e 45 b0	 divss	 xmm0, DWORD PTR _worldTexelSize$[ebp]
  000f5	51		 push	 ecx
  000f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fb	e8 00 00 00 00	 call	 ?floor@@YAMM@Z		; floor
  00100	83 c4 04	 add	 esp, 4
  00103	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR tv195[ebp]
  00109	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR tv195[ebp]
  00111	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _worldTexelSize$[ebp]
  00116	51		 push	 ecx
  00117	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011c	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  0011f	e8 00 00 00 00	 call	 ?SetX@Vector3f@@QAEXM@Z	; Vector3f::SetX

; 55   : 	lightSpaceCameraPos.SetY(worldTexelSize * floor(lightSpaceCameraPos.GetY() / worldTexelSize));

  00124	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  00127	e8 00 00 00 00	 call	 ?GetY@Vector3f@@QBEMXZ	; Vector3f::GetY
  0012c	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR tv201[ebp]
  00132	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR tv201[ebp]
  0013a	f3 0f 5e 45 b0	 divss	 xmm0, DWORD PTR _worldTexelSize$[ebp]
  0013f	51		 push	 ecx
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	e8 00 00 00 00	 call	 ?floor@@YAMM@Z		; floor
  0014a	83 c4 04	 add	 esp, 4
  0014d	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR tv206[ebp]
  00153	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR tv206[ebp]
  0015b	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _worldTexelSize$[ebp]
  00160	51		 push	 ecx
  00161	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00166	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  00169	e8 00 00 00 00	 call	 ?SetY@Vector3f@@QAEXM@Z	; Vector3f::SetY

; 56   : 	
; 57   : 	resultPos = lightSpaceCameraPos.Rotate(resultRot);

  0016e	8d 55 b8	 lea	 edx, DWORD PTR _resultRot$[ebp]
  00171	52		 push	 edx
  00172	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00175	50		 push	 eax
  00176	8d 4d a0	 lea	 ecx, DWORD PTR _lightSpaceCameraPos$[ebp]
  00179	e8 00 00 00 00	 call	 ?Rotate@Vector3f@@QBE?AV1@ABVQuaternion@@@Z ; Vector3f::Rotate
  0017e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00180	89 4d e8	 mov	 DWORD PTR _resultPos$[ebp], ecx
  00183	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00186	89 55 ec	 mov	 DWORD PTR _resultPos$[ebp+4], edx
  00189	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0018c	89 45 f0	 mov	 DWORD PTR _resultPos$[ebp+8], eax

; 58   : 	
; 59   : 	return ShadowCameraTransform(resultPos, resultRot);

  0018f	8d 4d b8	 lea	 ecx, DWORD PTR _resultRot$[ebp]
  00192	51		 push	 ecx
  00193	8d 55 e8	 lea	 edx, DWORD PTR _resultPos$[ebp]
  00196	52		 push	 edx
  00197	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0019a	e8 00 00 00 00	 call	 ??0ShadowCameraTransform@@QAE@ABVVector3f@@ABVQuaternion@@@Z ; ShadowCameraTransform::ShadowCameraTransform
  0019f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 60   : }

  001a2	52		 push	 edx
  001a3	8b cd		 mov	 ecx, ebp
  001a5	50		 push	 eax
  001a6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@CalcShadow
  001ac	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001b1	58		 pop	 eax
  001b2	5a		 pop	 edx
  001b3	5f		 pop	 edi
  001b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b7	33 cd		 xor	 ecx, ebp
  001b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001be	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  001c4	3b ec		 cmp	 ebp, esp
  001c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 0c 00	 ret	 12			; 0000000cH
  001d1	0f 1f 00	 npad	 3
$LN7@CalcShadow:
  001d4	03 00 00 00	 DD	 3
  001d8	00 00 00 00	 DD	 $LN6@CalcShadow
$LN6@CalcShadow:
  001dc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  001e0	0c 00 00 00	 DD	 12			; 0000000cH
  001e4	00 00 00 00	 DD	 $LN3@CalcShadow
  001e8	b8 ff ff ff	 DD	 -72			; ffffffb8H
  001ec	10 00 00 00	 DD	 16			; 00000010H
  001f0	00 00 00 00	 DD	 $LN4@CalcShadow
  001f4	a0 ff ff ff	 DD	 -96			; ffffffa0H
  001f8	0c 00 00 00	 DD	 12			; 0000000cH
  001fc	00 00 00 00	 DD	 $LN5@CalcShadow
$LN5@CalcShadow:
  00200	6c		 DB	 108			; 0000006cH
  00201	69		 DB	 105			; 00000069H
  00202	67		 DB	 103			; 00000067H
  00203	68		 DB	 104			; 00000068H
  00204	74		 DB	 116			; 00000074H
  00205	53		 DB	 83			; 00000053H
  00206	70		 DB	 112			; 00000070H
  00207	61		 DB	 97			; 00000061H
  00208	63		 DB	 99			; 00000063H
  00209	65		 DB	 101			; 00000065H
  0020a	43		 DB	 67			; 00000043H
  0020b	61		 DB	 97			; 00000061H
  0020c	6d		 DB	 109			; 0000006dH
  0020d	65		 DB	 101			; 00000065H
  0020e	72		 DB	 114			; 00000072H
  0020f	61		 DB	 97			; 00000061H
  00210	50		 DB	 80			; 00000050H
  00211	6f		 DB	 111			; 0000006fH
  00212	73		 DB	 115			; 00000073H
  00213	00		 DB	 0
$LN4@CalcShadow:
  00214	72		 DB	 114			; 00000072H
  00215	65		 DB	 101			; 00000065H
  00216	73		 DB	 115			; 00000073H
  00217	75		 DB	 117			; 00000075H
  00218	6c		 DB	 108			; 0000006cH
  00219	74		 DB	 116			; 00000074H
  0021a	52		 DB	 82			; 00000052H
  0021b	6f		 DB	 111			; 0000006fH
  0021c	74		 DB	 116			; 00000074H
  0021d	00		 DB	 0
$LN3@CalcShadow:
  0021e	72		 DB	 114			; 00000072H
  0021f	65		 DB	 101			; 00000065H
  00220	73		 DB	 115			; 00000073H
  00221	75		 DB	 117			; 00000075H
  00222	6c		 DB	 108			; 0000006cH
  00223	74		 DB	 116			; 00000074H
  00224	50		 DB	 80			; 00000050H
  00225	6f		 DB	 111			; 0000006fH
  00226	73		 DB	 115			; 00000073H
  00227	00		 DB	 0
?CalcShadowCameraTransform@DirectionalLight@@UBE?AVShadowCameraTransform@@ABVVector3f@@ABVQuaternion@@@Z ENDP ; DirectionalLight::CalcShadowCameraTransform
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GPointLight@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPointLight@@UAEPAXI@Z PROC				; PointLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1PointLight@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 11		 je	 SHORT $LN2@scalar
  0001e	68 a0 00 00 00	 push	 160			; 000000a0H
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??_GPointLight@@UAEPAXI@Z ENDP				; PointLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1PointLight@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PointLight@@UAE@XZ PROC				; PointLight::~PointLight, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1BaseLight@@UAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1PointLight@@UAE@XZ ENDP				; PointLight::~PointLight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GSpotLight@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSpotLight@@UAEPAXI@Z PROC				; SpotLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1SpotLight@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 11		 je	 SHORT $LN2@scalar
  0001e	68 a4 00 00 00	 push	 164			; 000000a4H
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??_GSpotLight@@UAEPAXI@Z ENDP				; SpotLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1SpotLight@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SpotLight@@UAE@XZ PROC				; SpotLight::~SpotLight, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1PointLight@@UAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1SpotLight@@UAE@XZ ENDP				; SpotLight::~SpotLight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXABQAVBaseLight@@@Z
_TEXT	SEGMENT
tv225 = -16						; size = 4
tv172 = -12						; size = 4
__Idx$1 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXABQAVBaseLight@@@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		if (_Inside(_STD addressof(_Val)))

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z ; std::addressof<BaseLight * const>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Inside@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBE_NPBQAVBaseLight@@@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Inside
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	0f 84 a3 00 00
	00		 je	 $LN2@push_back

; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  0003b	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z ; std::addressof<BaseLight * const>
  00044	83 c4 04	 add	 esp, 4
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  00051	2b 30		 sub	 esi, DWORD PTR [eax]
  00053	c1 fe 02	 sar	 esi, 2
  00056	89 75 f8	 mov	 DWORD PTR __Idx$1[ebp], esi

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00061	8b f0		 mov	 esi, eax
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  0006b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 0a		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00071	6a 01		 push	 1
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reserve
$LN4@push_back:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00083	8b 10		 mov	 edx, DWORD PTR [eax]
  00085	52		 push	 edx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Orphan_range

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR __Idx$1[ebp]
  000a6	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	51		 push	 ecx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  000cc	89 45 f4	 mov	 DWORD PTR tv172[ebp], eax
  000cf	8b 55 f4	 mov	 edx, DWORD PTR tv172[ebp]
  000d2	8b 02		 mov	 eax, DWORD PTR [edx]
  000d4	83 c0 04	 add	 eax, 4
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR tv172[ebp]
  000da	89 01		 mov	 DWORD PTR [ecx], eax

; 1284 : 			}
; 1285 : 		else

  000dc	eb 76		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  000e6	8b f0		 mov	 esi, eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000f4	75 0a		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  000f6	6a 01		 push	 1
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reserve
$LN5@push_back:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00100	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	51		 push	 ecx
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Orphan_range

; 1290 : 			this->_Getal().construct(this->_Mylast(),

  0011e	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00121	52		 push	 edx
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  0012a	8b 00		 mov	 eax, DWORD PTR [eax]
  0012c	50		 push	 eax
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  00135	8b c8		 mov	 ecx, eax
  00137	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>

; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00144	89 45 f0	 mov	 DWORD PTR tv225[ebp], eax
  00147	8b 4d f0	 mov	 ecx, DWORD PTR tv225[ebp]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	83 c2 04	 add	 edx, 4
  0014f	8b 45 f0	 mov	 eax, DWORD PTR tv225[ebp]
  00152	89 10		 mov	 DWORD PTR [eax], edx
$LN1@push_back:

; 1293 : 			}
; 1294 : 		}

  00154	5e		 pop	 esi
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	3b ec		 cmp	 ebp, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
?push_back@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXABQAVBaseLight@@@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z
_TEXT	SEGMENT
tv326 = -40						; size = 4
tv324 = -36						; size = 4
tv322 = -32						; size = 4
tv320 = -28						; size = 4
tv318 = -24						; size = 4
tv316 = -20						; size = 4
_depth$ = -16						; size = 4
_height$ = -12						; size = 4
_width$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_bottom$ = 20						; size = 4
_top$ = 24						; size = 4
_near$ = 28						; size = 4
_far$ = 32						; size = 4
?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z PROC	; Matrix4<float>::InitOrthographic, COMDAT
; _this$ = ecx

; 653  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0000c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 654  : 		const T width = (right - left);

  0001c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _right$[ebp]
  00021	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _left$[ebp]
  00026	f3 0f 11 45 f8	 movss	 DWORD PTR _width$[ebp], xmm0

; 655  : 		const T height = (top - bottom);

  0002b	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _top$[ebp]
  00030	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _bottom$[ebp]
  00035	f3 0f 11 45 f4	 movss	 DWORD PTR _height$[ebp], xmm0

; 656  : 		const T depth = (far - near);

  0003a	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _far$[ebp]
  0003f	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _near$[ebp]
  00044	f3 0f 11 45 f0	 movss	 DWORD PTR _depth$[ebp], xmm0

; 657  : 
; 658  : 		(*this)[0][0] = T(2)/width; (*this)[1][0] = T(0);        (*this)[2][0] = T(0);        (*this)[3][0] = -(right + left)/width;

  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00051	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _width$[ebp]
  00056	6a 00		 push	 0
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	f3 0f 11 45 ec	 movss	 DWORD PTR tv316[ebp], xmm0
  00060	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	6b d1 00	 imul	 edx, ecx, 0
  0006d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR tv316[ebp]
  00072	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00077	6a 01		 push	 1
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	6b d1 00	 imul	 edx, ecx, 0
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00091	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00096	6a 02		 push	 2
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000a0	b9 04 00 00 00	 mov	 ecx, 4
  000a5	6b d1 00	 imul	 edx, ecx, 0
  000a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000b0	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  000b5	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _right$[ebp]
  000ba	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _left$[ebp]
  000bf	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000c6	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _width$[ebp]
  000cb	6a 03		 push	 3
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	f3 0f 11 45 e8	 movss	 DWORD PTR tv318[ebp], xmm0
  000d5	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000da	b9 04 00 00 00	 mov	 ecx, 4
  000df	6b d1 00	 imul	 edx, ecx, 0
  000e2	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR tv318[ebp]
  000e7	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 659  : 		(*this)[0][1] = T(0);       (*this)[1][1] = T(2)/height; (*this)[2][1] = T(0);        (*this)[3][1] = -(top + bottom)/height;

  000ec	6a 00		 push	 0
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000f6	b9 04 00 00 00	 mov	 ecx, 4
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00106	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0010b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00113	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _height$[ebp]
  00118	6a 01		 push	 1
  0011a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	f3 0f 11 45 e4	 movss	 DWORD PTR tv320[ebp], xmm0
  00122	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00127	ba 04 00 00 00	 mov	 edx, 4
  0012c	c1 e2 00	 shl	 edx, 0
  0012f	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR tv320[ebp]
  00134	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00139	6a 02		 push	 2
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00143	b9 04 00 00 00	 mov	 ecx, 4
  00148	c1 e1 00	 shl	 ecx, 0
  0014b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00153	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00158	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _top$[ebp]
  0015d	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _bottom$[ebp]
  00162	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00169	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _height$[ebp]
  0016e	6a 03		 push	 3
  00170	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	f3 0f 11 45 e0	 movss	 DWORD PTR tv322[ebp], xmm0
  00178	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  0017d	ba 04 00 00 00	 mov	 edx, 4
  00182	c1 e2 00	 shl	 edx, 0
  00185	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR tv322[ebp]
  0018a	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 660  : 		(*this)[0][2] = T(0);       (*this)[1][2] = T(0);        (*this)[2][2] = T(-2)/depth; (*this)[3][2] = -(far + near)/depth;

  0018f	6a 00		 push	 0
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00199	b9 04 00 00 00	 mov	 ecx, 4
  0019e	d1 e1		 shl	 ecx, 1
  001a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001a8	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001ad	6a 01		 push	 1
  001af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  001b7	ba 04 00 00 00	 mov	 edx, 4
  001bc	d1 e2		 shl	 edx, 1
  001be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001c6	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  001cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0000000
  001d3	f3 0f 5e 45 f0	 divss	 xmm0, DWORD PTR _depth$[ebp]
  001d8	6a 02		 push	 2
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	f3 0f 11 45 dc	 movss	 DWORD PTR tv324[ebp], xmm0
  001e2	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  001e7	b9 04 00 00 00	 mov	 ecx, 4
  001ec	d1 e1		 shl	 ecx, 1
  001ee	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv324[ebp]
  001f3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001f8	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _far$[ebp]
  001fd	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _near$[ebp]
  00202	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00209	f3 0f 5e 45 f0	 divss	 xmm0, DWORD PTR _depth$[ebp]
  0020e	6a 03		 push	 3
  00210	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	f3 0f 11 45 d8	 movss	 DWORD PTR tv326[ebp], xmm0
  00218	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  0021d	ba 04 00 00 00	 mov	 edx, 4
  00222	d1 e2		 shl	 edx, 1
  00224	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv326[ebp]
  00229	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 661  : 		(*this)[0][3] = T(0);       (*this)[1][3] = T(0);        (*this)[2][3] = T(0);        (*this)[3][3] = T(1); 

  0022e	6a 00		 push	 0
  00230	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00233	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00238	b9 04 00 00 00	 mov	 ecx, 4
  0023d	6b d1 03	 imul	 edx, ecx, 3
  00240	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00248	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0024d	6a 01		 push	 1
  0024f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00257	b9 04 00 00 00	 mov	 ecx, 4
  0025c	6b d1 03	 imul	 edx, ecx, 3
  0025f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00267	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0026c	6a 02		 push	 2
  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00276	b9 04 00 00 00	 mov	 ecx, 4
  0027b	6b d1 03	 imul	 edx, ecx, 3
  0027e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00286	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0028b	6a 03		 push	 3
  0028d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00290	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00295	b9 04 00 00 00	 mov	 ecx, 4
  0029a	6b d1 03	 imul	 edx, ecx, 3
  0029d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002a5	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 662  : 		
; 663  : 		return *this;

  002aa	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002af	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  002b2	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  002b5	f3 a5		 rep movsd
  002b7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 664  : 	}

  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	83 c4 28	 add	 esp, 40			; 00000028H
  002bf	3b ec		 cmp	 ebp, esp
  002c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	c2 1c 00	 ret	 28			; 0000001cH
?InitOrthographic@?$Matrix4@M@@QAE?AV1@MMMMMM@Z ENDP	; Matrix4<float>::InitOrthographic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z
_TEXT	SEGMENT
tv320 = -28						; size = 4
tv318 = -24						; size = 4
tv316 = -20						; size = 4
tv314 = -16						; size = 4
_tanHalfFOV$ = -12					; size = 4
_zRange$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fov$ = 12						; size = 4
_aspectRatio$ = 16					; size = 4
_zNear$ = 20						; size = 4
_zFar$ = 24						; size = 4
?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z PROC	; Matrix4<float>::InitPerspective, COMDAT
; _this$ = ecx

; 640  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00010	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00013	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00016	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00019	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001c	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001f	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00022	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 641  : 		const T zRange     = zNear - zFar;

  00025	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _zNear$[ebp]
  0002a	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _zFar$[ebp]
  0002f	f3 0f 11 45 f8	 movss	 DWORD PTR _zRange$[ebp], xmm0

; 642  : 		const T tanHalfFOV = tanf(fov / T(2));

  00034	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fov$[ebp]
  00039	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00041	51		 push	 ecx
  00042	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00047	e8 00 00 00 00	 call	 _tanf
  0004c	83 c4 04	 add	 esp, 4
  0004f	d9 5d f4	 fstp	 DWORD PTR _tanHalfFOV$[ebp]

; 643  : 
; 644  : 		(*this)[0][0] = T(1)/(tanHalfFOV * aspectRatio); (*this)[1][0] = T(0);   (*this)[2][0] = T(0);            (*this)[3][0] = T(0);

  00052	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _tanHalfFOV$[ebp]
  00057	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _aspectRatio$[ebp]
  0005c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00064	f3 0f 5e c8	 divss	 xmm1, xmm0
  00068	6a 00		 push	 0
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	f3 0f 11 4d f0	 movss	 DWORD PTR tv314[ebp], xmm1
  00072	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00077	b9 04 00 00 00	 mov	 ecx, 4
  0007c	6b d1 00	 imul	 edx, ecx, 0
  0007f	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR tv314[ebp]
  00084	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00089	6a 01		 push	 1
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00093	b9 04 00 00 00	 mov	 ecx, 4
  00098	6b d1 00	 imul	 edx, ecx, 0
  0009b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000a3	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  000a8	6a 02		 push	 2
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000b2	b9 04 00 00 00	 mov	 ecx, 4
  000b7	6b d1 00	 imul	 edx, ecx, 0
  000ba	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000c2	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  000c7	6a 03		 push	 3
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000d1	b9 04 00 00 00	 mov	 ecx, 4
  000d6	6b d1 00	 imul	 edx, ecx, 0
  000d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  000e1	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 645  : 		(*this)[0][1] = T(0);                   (*this)[1][1] = T(1)/tanHalfFOV; (*this)[2][1] = T(0);            (*this)[3][1] = T(0);

  000e6	6a 00		 push	 0
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  000f0	b9 04 00 00 00	 mov	 ecx, 4
  000f5	c1 e1 00	 shl	 ecx, 0
  000f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00100	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00105	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0010d	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _tanHalfFOV$[ebp]
  00112	6a 01		 push	 1
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	f3 0f 11 45 ec	 movss	 DWORD PTR tv316[ebp], xmm0
  0011c	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00121	ba 04 00 00 00	 mov	 edx, 4
  00126	c1 e2 00	 shl	 edx, 0
  00129	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR tv316[ebp]
  0012e	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00133	6a 02		 push	 2
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  0013d	b9 04 00 00 00	 mov	 ecx, 4
  00142	c1 e1 00	 shl	 ecx, 0
  00145	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0014d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00152	6a 03		 push	 3
  00154	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  0015c	ba 04 00 00 00	 mov	 edx, 4
  00161	c1 e2 00	 shl	 edx, 0
  00164	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0016c	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 646  : 		(*this)[0][2] = T(0);                   (*this)[1][2] = T(0);            (*this)[2][2] = (-zNear - zFar)/zRange ; (*this)[3][2] = T(2)*zFar*zNear/zRange;

  00171	6a 00		 push	 0
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  0017b	b9 04 00 00 00	 mov	 ecx, 4
  00180	d1 e1		 shl	 ecx, 1
  00182	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0018a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0018f	6a 01		 push	 1
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00199	ba 04 00 00 00	 mov	 edx, 4
  0019e	d1 e2		 shl	 edx, 1
  001a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001a8	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  001ad	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _zNear$[ebp]
  001b2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001b9	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _zFar$[ebp]
  001be	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _zRange$[ebp]
  001c3	6a 02		 push	 2
  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	f3 0f 11 45 e8	 movss	 DWORD PTR tv318[ebp], xmm0
  001cd	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  001d2	b9 04 00 00 00	 mov	 ecx, 4
  001d7	d1 e1		 shl	 ecx, 1
  001d9	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR tv318[ebp]
  001de	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001eb	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _zFar$[ebp]
  001f0	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _zNear$[ebp]
  001f5	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _zRange$[ebp]
  001fa	6a 03		 push	 3
  001fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	f3 0f 11 45 e4	 movss	 DWORD PTR tv320[ebp], xmm0
  00204	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00209	ba 04 00 00 00	 mov	 edx, 4
  0020e	d1 e2		 shl	 edx, 1
  00210	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR tv320[ebp]
  00215	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 647  : 		(*this)[0][3] = T(0);                   (*this)[1][3] = T(0);            (*this)[2][3] = T(1);            (*this)[3][3] = T(0); 

  0021a	6a 00		 push	 0
  0021c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021f	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00224	b9 04 00 00 00	 mov	 ecx, 4
  00229	6b d1 03	 imul	 edx, ecx, 3
  0022c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00234	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00239	6a 01		 push	 1
  0023b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00243	b9 04 00 00 00	 mov	 ecx, 4
  00248	6b d1 03	 imul	 edx, ecx, 3
  0024b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00253	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00258	6a 02		 push	 2
  0025a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00262	b9 04 00 00 00	 mov	 ecx, 4
  00267	6b d1 03	 imul	 edx, ecx, 3
  0026a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00272	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00277	6a 03		 push	 3
  00279	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027c	e8 00 00 00 00	 call	 ??A?$Matrix@M$03@@QAEPAMH@Z ; Matrix<float,4>::operator[]
  00281	b9 04 00 00 00	 mov	 ecx, 4
  00286	6b d1 03	 imul	 edx, ecx, 3
  00289	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00291	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 648  : 		
; 649  : 		return *this;

  00296	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0029b	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0029e	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  002a1	f3 a5		 rep movsd
  002a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 650  : 	}

  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	83 c4 1c	 add	 esp, 28			; 0000001cH
  002ab	3b ec		 cmp	 ebp, esp
  002ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c2 14 00	 ret	 20			; 00000014H
?InitPerspective@?$Matrix4@M@@QAE?AV1@MMMM@Z ENDP	; Matrix4<float>::InitPerspective
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\core\math3d.h
;	COMDAT ?Max@?$Vector@M$02@@QBEMXZ
_TEXT	SEGMENT
tv83 = -16						; size = 4
_i$1 = -12						; size = 4
_maxVal$ = -8						; size = 4
_this$ = -4						; size = 4
?Max@?$Vector@M$02@@QBEMXZ PROC				; Vector<float,3>::Max, COMDAT
; _this$ = ecx

; 76   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 		T maxVal = (*this)[0];

  0001a	6a 00		 push	 0
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00024	d9 5d f8	 fstp	 DWORD PTR _maxVal$[ebp]

; 78   : 		
; 79   : 		for(int i = 0; i < D; i++)

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002e	eb 09		 jmp	 SHORT $LN4@Max
$LN2@Max:
  00030	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Max:
  00039	83 7d f4 03	 cmp	 DWORD PTR _i$1[ebp], 3
  0003d	73 2b		 jae	 SHORT $LN3@Max

; 80   : 			if((*this)[i] > maxVal)

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _i$1[ebp]
  00042	51		 push	 ecx
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  0004b	d9 5d f0	 fstp	 DWORD PTR tv83[ebp]
  0004e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR tv83[ebp]
  00053	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _maxVal$[ebp]
  00057	76 0f		 jbe	 SHORT $LN5@Max

; 81   : 				maxVal = (*this)[i];

  00059	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  0005c	52		 push	 edx
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ??A?$Vector@M$02@@QBEMI@Z ; Vector<float,3>::operator[]
  00065	d9 5d f8	 fstp	 DWORD PTR _maxVal$[ebp]
$LN5@Max:

; 82   : 		
; 83   : 		return maxVal;

  00068	eb c6		 jmp	 SHORT $LN2@Max
$LN3@Max:
  0006a	d9 45 f8	 fld	 DWORD PTR _maxVal$[ebp]

; 84   : 	}

  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?Max@?$Vector@M$02@@QBEMXZ ENDP				; Vector<float,3>::Max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z
_TEXT	SEGMENT
__Pnext$ = -32						; size = 4
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1795 : 		_Lockit _Lock(_LOCK_DEBUG);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 03		 push	 3
  00041	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1796 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getpfirst
  00060	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1797 : 		if (_Pnext != 0)

  00063	83 7d e0 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  00067	74 4e		 je	 SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1798 : 			{	// test an iterator
; 1799 : 			while (*_Pnext != 0)

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0006c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006f	74 46		 je	 SHORT $LN4@Orphan_ran

; 1800 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

  00071	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00079	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0007c	72 0d		 jb	 SHORT $LN7@Orphan_ran
  0007e	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00086	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00089	73 0f		 jae	 SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1801 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

  0008b	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0008e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00090	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  00095	89 45 e0	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1802 : 				else

  00098	eb 1b		 jmp	 SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1803 : 					{	// orphan the iterator
; 1804 : 					(*_Pnext)->_Clrcont();

  0009a	8b 55 e0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0009d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009f	e8 00 00 00 00	 call	 ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont

; 1805 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000a4	8b 45 e0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	e8 00 00 00 00	 call	 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
  000ae	8b 4d e0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000b1	8b 10		 mov	 edx, DWORD PTR [eax]
  000b3	89 11		 mov	 DWORD PTR [ecx], edx
$LN6@Orphan_ran:

; 1806 : 					}

  000b5	eb b2		 jmp	 SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1807 : 			}
; 1808 : 		}

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8b f4		 mov	 esi, esp
  000c0	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	52		 push	 edx
  000d1	8b cd		 mov	 ecx, ebp
  000d3	50		 push	 eax
  000d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Orphan_ran
  000da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000df	58		 pop	 eax
  000e0	5a		 pop	 edx
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5e		 pop	 esi
  000ed	83 c4 20	 add	 esp, 32			; 00000020H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
  000fd	0f 1f 00	 npad	 3
$LN13@Orphan_ran:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN12@Orphan_ran
$LN12@Orphan_ran:
  00108	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0010c	04 00 00 00	 DD	 4
  00110	00 00 00 00	 DD	 $LN10@Orphan_ran
$LN10@Orphan_ran:
  00114	5f		 DB	 95			; 0000005fH
  00115	4c		 DB	 76			; 0000004cH
  00116	6f		 DB	 111			; 0000006fH
  00117	63		 DB	 99			; 00000063H
  00118	6b		 DB	 107			; 0000006bH
  00119	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXPAPAVBaseLight@@0@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1646 : 		if (_Unused_capacity() < _Count)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Unused_capacity
  00017	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0001a	73 3e		 jae	 SHORT $LN4@Reserve

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::max_size
  00024	8b f0		 mov	 esi, eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::size
  0002e	2b f0		 sub	 esi, eax
  00030	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00033	73 08		 jae	 SHORT $LN3@Reserve

; 1649 : 				_Xlen();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Xlen
$LN3@Reserve:

; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::size
  00045	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEII@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Grow_to
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reallocate
$LN4@Reserve:

; 1651 : 			}
; 1652 : 		}

  0005a	5e		 pop	 esi
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?_Reserve@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBE_NPBQAVBaseLight@@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBE_NPBQAVBaseLight@@@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00024	73 18		 jae	 SHORT $LN3@Inside
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	3b 55 08	 cmp	 edx, DWORD PTR __Ptr$[ebp]
  00033	77 09		 ja	 SHORT $LN3@Inside
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0003c	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Inside:
  00045	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]

; 1617 : 		}

  00048	83 c4 08	 add	 esp, 8
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Inside@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBE_NPBQAVBaseLight@@@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 595  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 596  : 		return (_Get_data()._Getpfirst());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Get_data
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 597  : 		}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXXZ PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Xlen, COMDAT
; _this$ = ecx

; 1783 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  0000f	8b f4		 mov	 esi, esp
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Xlen:

; 1785 : 		}

  00023	5e		 pop	 esi
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Xlen@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEXXZ ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	c7 45 e4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-28], -858993460 ; ccccccccH
  0001f	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00026	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00044	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00047	50		 push	 eax
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEPAPAVBaseLight@@I@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::allocate
  00057	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00061	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00064	51		 push	 ecx
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  0006d	8b 10		 mov	 edx, DWORD PTR [eax]
  0006f	52		 push	 edx
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ??$_Umove@PAPAVBaseLight@@@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEPAPAVBaseLight@@PAPAV2@00@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Umove<BaseLight * *>
  00083	eb 26		 jmp	 SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$0:

; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);

  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@I@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::deallocate

; 1627 : 		_RERAISE;

  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1628 : 		_CATCH_END

  000a5	b8 00 00 00 00	 mov	 eax, $LN8@Reallocate
  000aa	c3		 ret	 0
$LN5@Reallocate:
  000ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b2	eb 07		 jmp	 SHORT __tryend$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z$1:

; 1629 : 
; 1630 : 		size_type _Size = size();

  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::size
  000c3	89 45 e4	 mov	 DWORD PTR __Size$[ebp], eax

; 1631 : 		if (this->_Myfirst() != pointer())

  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  000ce	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d1	74 52		 je	 SHORT $LN3@Reallocate

; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  000d3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  000db	8b 00		 mov	 eax, DWORD PTR [eax]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	51		 push	 ecx
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXPAPAVBaseLight@@0@Z ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Destroy

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  000f9	8b f0		 mov	 esi, eax
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	2b 16		 sub	 edx, DWORD PTR [esi]
  00107	c1 fa 02	 sar	 edx, 2
  0010a	52		 push	 edx
  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	50		 push	 eax
  00116	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@I@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::deallocate
$LN3@Reallocate:

; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();

  00125	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Orphan_all

; 1639 : 		this->_Myend() = _Ptr + _Count;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00130	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00133	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  0013e	89 30		 mov	 DWORD PTR [eax], esi

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  00140	8b 45 e4	 mov	 eax, DWORD PTR __Size$[ebp]
  00143	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00146	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00151	89 30		 mov	 DWORD PTR [eax], esi

; 1641 : 		this->_Myfirst() = _Ptr;

  00153	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAPAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  0015b	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0015e	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Reallocate:

; 1642 : 		}

  00160	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016a	59		 pop	 ecx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEXI@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEII@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1605 : 		size_type _Capacity = capacity();

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::capacity
  00026	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ; std::vector<BaseLight *,std::allocator<BaseLight *> >::max_size
  00031	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00034	d1 e9		 shr	 ecx, 1
  00036	2b c1		 sub	 eax, ecx
  00038	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003b	73 09		 jae	 SHORT $LN4@Grow_to
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00044	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00046	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00049	d1 ea		 shr	 edx, 1
  0004b	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00054	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00057	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0005a	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0005d	73 06		 jae	 SHORT $LN2@Grow_to

; 1610 : 			_Capacity = _Count;

  0005f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00062	89 55 f8	 mov	 DWORD PTR __Capacity$[ebp], edx
$LN2@Grow_to:

; 1611 : 		return (_Capacity);

  00065	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1612 : 		}

  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IBEII@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::max_size, COMDAT
; _this$ = ecx

; 1183 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1184 : 		return (this->_Getal().max_size());

  00017	0f b6 45 fb	 movzx	 eax, BYTE PTR $T1[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<BaseLight *> >::max_size

; 1185 : 		}

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1046 : 		{	// micro-optimization for capacity() - size()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Mylast
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1048 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Unused_capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<BaseLight *> >::max_size, COMDAT
; _this$ = ecx

; 929  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 930  : 		return (_Mytraits::max_size(*this));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAIABV?$allocator@PAVBaseLight@@@2@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::max_size
  00017	83 c4 04	 add	 esp, 4

; 931  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<BaseLight *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEPAPAVBaseLight@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEPAPAVBaseLight@@I@Z PROC ; std::_Wrap_alloc<std::allocator<BaseLight *> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		return (_Mybase::allocate(_Count));

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVBaseLight@@@std@@QAEPAPAVBaseLight@@I@Z ; std::allocator<BaseLight *>::allocate

; 899  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEPAPAVBaseLight@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<BaseLight *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend, COMDAT
; _this$ = ecx

; 666  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return (_Get_data()._Myend);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Get_data
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH

; 668  : 		}

  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal, COMDAT
; _this$ = ecx

; 626  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 627  : 		return (_Mypair._Get_first());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<BaseLight *> >,std::_Vector_val<std::_Simple_types<BaseLight *> >,1>::_Get_first

; 628  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::capacity, COMDAT
; _this$ = ecx

; 1041 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myend
  00017	8b f0		 mov	 esi, eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QBEABQAPAVBaseLight@@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Myfirst
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	2b 08		 sub	 ecx, DWORD PTR [eax]
  00025	c1 f9 02	 sar	 ecx, 2
  00028	8b c1		 mov	 eax, ecx

; 1043 : 		}

  0002a	5e		 pop	 esi
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?capacity@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@QBEIXZ ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<BaseLight *> >,std::_Vector_val<std::_Simple_types<BaseLight *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 298  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 		return (*this);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 300  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBaseLight@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<BaseLight *> >,std::_Vector_val<std::_Simple_types<BaseLight *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAIABV?$allocator@PAVBaseLight@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAIABV?$allocator@PAVBaseLight@@@2@@Z PROC ; std::allocator_traits<std::allocator<BaseLight *> >::max_size, COMDAT

; 784  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 785  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAVBaseLight@@@std@@QBEIXZ ; std::allocator<BaseLight *>::max_size

; 786  : 		}

  0000b	3b ec		 cmp	 ebp, esp
  0000d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAIABV?$allocator@PAVBaseLight@@@2@@Z ENDP ; std::allocator_traits<std::allocator<BaseLight *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVBaseLight@@@std@@QAEPAPAVBaseLight@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVBaseLight@@@std@@QAEPAPAVBaseLight@@I@Z PROC ; std::allocator<BaseLight *>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	6a 01		 push	 1
  00010	6a 04		 push	 4
  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@PAVBaseLight@@@std@@QAEPAPAVBaseLight@@I@Z ENDP ; std::allocator<BaseLight *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVBaseLight@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAVBaseLight@@@std@@QBEIXZ PROC	; std::allocator<BaseLight *>::max_size, COMDAT
; _this$ = ecx

; 666  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  0000e	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 668  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?max_size@?$allocator@PAVBaseLight@@@std@@QBEIXZ ENDP	; std::allocator<BaseLight *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
__Val$ = 8						; size = 4
??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z PROC ; std::addressof<BaseLight * const>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0000b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<BaseLight * const>
  00019	83 c4 08	 add	 esp, 8

; 698  : 	}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@@Z ENDP ; std::addressof<BaseLight * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVBaseLight@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z ; std::forward<BaseLight * &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@AAPAV3@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVBaseLight@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVBaseLight@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		_Mytraits::construct(*this, _Ptr,

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z ; std::forward<BaseLight * const &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@ABQAV3@@Z ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$construct@PAVBaseLight@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVBaseLight@@@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEPAPAVBaseLight@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVBaseLight@@@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEPAPAVBaseLight@@PAPAV2@00@Z PROC ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Umove<BaseLight * *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1678 : 		return (_Uninitialized_move(_First, _Last,

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<BaseLight *,std::allocator<BaseLight *> > >::_Getal
  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ; std::_Uninitialized_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
  00028	83 c4 10	 add	 esp, 16			; 00000010H

; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVBaseLight@@@?$vector@PAVBaseLight@@V?$allocator@PAVBaseLight@@@std@@@std@@IAEPAPAVBaseLight@@PAPAV2@00@Z ENDP ; std::vector<BaseLight *,std::allocator<BaseLight *> >::_Umove<BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<BaseLight * const>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@QAVBaseLight@@@std@@YAPBQAVBaseLight@@ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<BaseLight * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z PROC ; std::forward<BaseLight * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z ENDP ; std::forward<BaseLight * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVBaseLight@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z ; std::forward<BaseLight * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@AAPAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVBaseLight@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z PROC ; std::forward<BaseLight * const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z ENDP ; std::forward<BaseLight * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVBaseLight@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z ; std::forward<BaseLight * const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAVBaseLight@@ABQAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * const &>

; 774  : 		}

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$construct@PAVBaseLight@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBaseLight@@@std@@@std@@SAXAAV?$allocator@PAVBaseLight@@@1@PAPAVBaseLight@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<BaseLight *> >::construct<BaseLight *,BaseLight * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z PROC ; std::_Uninitialized_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 491  : 	return (_Rechecked(_Dest,

  00003	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Unchecked<BaseLight * *>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Unchecked<BaseLight * *>
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Unchecked<BaseLight * *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ; std::_Uninit_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Rechecked@PAPAVBaseLight@@PAPAV1@@std@@YAAAPAPAVBaseLight@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<BaseLight * *,BaseLight * *>
  00040	83 c4 08	 add	 esp, 8
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Uninitialized_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@AAPAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVBaseLight@@AAPAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z PROC ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@AAPAVBaseLight@@@std@@YAAAPAVBaseLight@@AAPAV1@@Z ; std::forward<BaseLight * &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVBaseLight@@AAPAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@AAPAV2@@Z ENDP ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBaseLight@@ABQAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVBaseLight@@ABQAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z PROC ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002f	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00033	74 1b		 je	 SHORT $LN3@construct
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$forward@ABQAVBaseLight@@@std@@YAABQAVBaseLight@@ABQAV1@@Z ; std::forward<BaseLight * const &>
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  0004e	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 656  : 		}

  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??$construct@PAVBaseLight@@ABQAV1@@?$allocator@PAVBaseLight@@@std@@QAEXPAPAVBaseLight@@ABQAV2@@Z ENDP ; std::allocator<BaseLight *>::construct<BaseLight *,BaseLight * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z PROC ; std::_Unchecked<BaseLight * *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ENDP ; std::_Unchecked<BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z PROC ; std::_Uninit_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAVBaseLight@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBaseLight@@0@Z ; std::_Ptr_cat<BaseLight *,BaseLight *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Val_type@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ; std::_Val_type<BaseLight * *>
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00037	52		 push	 edx
  00038	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ??$_Uninit_move@PAVBaseLight@@PAV1@PAV1@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BaseLight *,BaseLight *,BaseLight *>
  00045	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Uninit_move@PAPAVBaseLight@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@std@@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@@Z ENDP ; std::_Uninit_move<BaseLight * *,BaseLight * *,std::_Wrap_alloc<std::allocator<BaseLight *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVBaseLight@@PAPAV1@@std@@YAAAPAPAVBaseLight@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVBaseLight@@PAPAV1@@std@@YAAAPAPAVBaseLight@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<BaseLight * *,BaseLight * *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 449  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Rechecked@PAPAVBaseLight@@PAPAV1@@std@@YAAAPAPAVBaseLight@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<BaseLight * *,BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z PROC ; std::_Val_type<BaseLight * *>, COMDAT

; 874  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 	return (0);

  00003	33 c0		 xor	 eax, eax

; 876  : 	}

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
??$_Val_type@PAPAVBaseLight@@@std@@YAPAPAVBaseLight@@PAPAV1@@Z ENDP ; std::_Val_type<BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVBaseLight@@PAV1@PAV1@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVBaseLight@@PAV1@PAV1@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<BaseLight *,BaseLight *,BaseLight *>, COMDAT

; 468  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 469  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);

  0000c	68 d5 01 00 00	 push	 469			; 000001d5H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@GBEHMPOJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00016	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Debug_range_ptr@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WI@Z ; std::_Debug_range_ptr<BaseLight * *,BaseLight * *>
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 470  : 	size_t _Count = (size_t)(_Last - _First);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00030	c1 f8 02	 sar	 eax, 2
  00033	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 471  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	c1 e1 02	 shl	 ecx, 2
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 472  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
; 473  : 	}

  0005d	5e		 pop	 esi
  0005e	83 c4 04	 add	 esp, 4
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Uninit_move@PAVBaseLight@@PAV1@PAV1@@std@@YAPAPAVBaseLight@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBaseLight@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BaseLight *,BaseLight *,BaseLight *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WI@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
??$_Debug_range_ptr@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WI@Z PROC ; std::_Debug_range_ptr<BaseLight * *,BaseLight * *>, COMDAT

; 837  : 	{	// test iterator pair for valid range/pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  : 	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat(_First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Iter_cat@PAPAVBaseLight@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBaseLight@@@Z ; std::_Iter_cat<BaseLight * *>
  00018	83 c4 08	 add	 esp, 8
  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	0f b6 c2	 movzx	 eax, dl
  00020	50		 push	 eax
  00021	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00028	52		 push	 edx
  00029	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$_Debug_range_ptr2@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range_ptr2<BaseLight * *,BaseLight * *>
  0003a	83 c4 18	 add	 esp, 24			; 00000018H

; 839  : 	}

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Debug_range_ptr@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WI@Z ENDP ; std::_Debug_range_ptr<BaseLight * *,BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVBaseLight@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBaseLight@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVBaseLight@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBaseLight@@@Z PROC ; std::_Iter_cat<BaseLight * *>, COMDAT

; 601  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 602  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 603  : 	return (_Cat);

  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8a 4d fb	 mov	 cl, BYTE PTR __Cat$[ebp]
  00021	88 08		 mov	 BYTE PTR [eax], cl
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 604  : 	}

  00026	52		 push	 edx
  00027	8b cd		 mov	 ecx, ebp
  00029	50		 push	 eax
  0002a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Iter_cat
  00030	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00035	58		 pop	 eax
  00036	5a		 pop	 edx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
  0003b	90		 npad	 1
$LN5@Iter_cat:
  0003c	01 00 00 00	 DD	 1
  00040	00 00 00 00	 DD	 $LN4@Iter_cat
$LN4@Iter_cat:
  00044	fb ff ff ff	 DD	 -5			; fffffffbH
  00048	01 00 00 00	 DD	 1
  0004c	00 00 00 00	 DD	 $LN3@Iter_cat
$LN3@Iter_cat:
  00050	5f		 DB	 95			; 0000005fH
  00051	43		 DB	 67			; 00000043H
  00052	61		 DB	 97			; 00000061H
  00053	74		 DB	 116			; 00000074H
  00054	00		 DB	 0
??$_Iter_cat@PAPAVBaseLight@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBaseLight@@@Z ENDP ; std::_Iter_cat<BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range_ptr2@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__File$ = 20						; size = 4
__Line$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Debug_range_ptr2@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range_ptr2<BaseLight * *,BaseLight * *>, COMDAT

; 822  : 	{	// test iterator pair for valid range/pointer, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 	if (_First != _Last)

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000a	74 65		 je	 SHORT $LN1@Debug_rang

; 824  : 		{	// check for non-null pointers, valid range
; 825  : 		_DEBUG_POINTER2(_First, _File, _Line);

  0000c	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z ; std::_Debug_pointer<BaseLight *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 826  : 		_DEBUG_POINTER2(_Last, _File, _Line);

  00020	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z ; std::_Debug_pointer<BaseLight *>
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 827  : 		if (_Last < _First)

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00037	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  0003a	73 1f		 jae	 SHORT $LN3@Debug_rang

; 828  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 55 18	 mov	 edx, DWORD PTR __Line$[ebp]
  00041	52		 push	 edx
  00042	8b 45 14	 mov	 eax, DWORD PTR __File$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Debug_rang:

; 829  : 		_DEBUG_POINTER2(_Ptr, _File, _Line);	// test only if used

  0005b	8b 4d 18	 mov	 ecx, DWORD PTR __Line$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 14	 mov	 edx, DWORD PTR __File$[ebp]
  00062	52		 push	 edx
  00063	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z ; std::_Debug_pointer<BaseLight *>
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Debug_rang:

; 830  : 		}
; 831  : 	}

  00071	5e		 pop	 esi
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??$_Debug_range_ptr2@PAPAVBaseLight@@PAPAV1@@std@@YAXPAPAVBaseLight@@0AAPAPAV1@PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range_ptr2<BaseLight * *,BaseLight * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z PROC ; std::_Debug_pointer<BaseLight *>, COMDAT

; 760  : 	{	// test pointer for non-singularity, pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 761  : 	if (_Ptr == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00008	75 1f		 jne	 SHORT $LN1@Debug_poin

; 762  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

  0000a	8b f4		 mov	 esi, esp
  0000c	8b 45 10	 mov	 eax, DWORD PTR __Line$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __File$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Debug_poin:

; 763  : 	}

  00029	5e		 pop	 esi
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Debug_pointer@PAVBaseLight@@@std@@YAXPAPAVBaseLight@@PB_WI@Z ENDP ; std::_Debug_pointer<BaseLight *>
_TEXT	ENDS
END
