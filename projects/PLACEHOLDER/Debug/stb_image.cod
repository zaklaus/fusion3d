; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	e:\fusion3d_work\engine\src\staticlibs\stb_image.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?stbi_png_partial@@3HA				; stbi_png_partial
EXTRN	__imp__feof:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__ldexp:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strcmp:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__fopen:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__abs:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__pow:PROC
EXTRN	__imp___lrotl:PROC
?stbi_png_partial@@3HA DD 01H DUP (?)			; stbi_png_partial
?stbi_de_iphone_flag@@3HA DD 01H DUP (?)		; stbi_de_iphone_flag
?stbi_unpremultiply_on_load@@3HA DD 01H DUP (?)		; stbi_unpremultiply_on_load
_BSS	ENDS
;	COMDAT ?png_sig@?1??check_png_header@@YAHPAUstbi@@@Z@4PAEA
_DATA	SEGMENT
?png_sig@?1??check_png_header@@YAHPAUstbi@@@Z@4PAEA DB 089H ; `check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
_DATA	ENDS
;	COMDAT ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA
_DATA	SEGMENT
?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA DB 'XXXX chunk'
	DB	' not known', 00H				; `parse_png_file'[::B]::invalid_chunk
_DATA	ENDS
;	COMDAT ?length_dezigzag@?1??compute_huffman_codes@@YAHPAUzbuf@@@Z@4PAEA
_DATA	SEGMENT
?length_dezigzag@?1??compute_huffman_codes@@YAHPAUzbuf@@@Z@4PAEA DB 010H ; `compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+3
?h2l_gamma_i@@3MA DD 03ee8ba2er			; 0.454545 ; h2l_gamma_i
?stbi_stdio_callbacks@@3Ustbi_io_callbacks@@A DD FLAT:?stdio_read@@YAHPAXPADH@Z ; stbi_stdio_callbacks
	DD	FLAT:?stdio_skip@@YAXPAXI@Z
	DD	FLAT:?stdio_eof@@YAHPAX@Z
?l2h_scale@@3MA DD 03f800000r			; 1	; l2h_scale
?dist_base@@3PAHA DD 01H				; dist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?length_extra@@3PAHA DD 00H				; length_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
?h2l_scale_i@@3MA DD 03f800000r			; 1	; h2l_scale_i
?bmask@@3PAIA DD 00H					; bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
?l2h_gamma@@3MA DD 0400ccccdr			; 2.2	; l2h_gamma
?dist_extra@@3PAHA DD 00H				; dist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
?length_base@@3PAHA DD 03H				; length_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?dezigzag@@3PAEA DB 00H					; dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
$SG4294820121 DB 00H
	ORG $+3
$SG4294820277 DB 'rb', 00H
	ORG $+1
$SG4294820276 DB 'can''t fopen', 00H
$SG4294820278 DB 'unknown image type', 00H
	ORG $+1
$SG4294820273 DB 'can''t fopen', 00H
$SG4294820272 DB 'rb', 00H
	ORG $+1
$SG4294820275 DB 'unknown image type', 00H
	ORG $+1
$SG4294820274 DB 'rb', 00H
	ORG $+1
$SG4294820269 DB 'outofmem', 00H
	ORG $+3
$SG4294820268 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820271 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820270 DB 'r', 00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG4294820265 DB 'outofmem', 00H
	ORG $+3
$SG4294820264 DB 'bad code lengths', 00H
	ORG $+3
$SG4294820267 DB '0', 00H, 00H, 00H
$SG4294820266 DB 'outofmem', 00H
	ORG $+3
$SG4294820261 DB 'bad huffman code', 00H
	ORG $+3
$SG4294820260 DB 'bad huffman code', 00H
	ORG $+3
$SG4294820263 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820257 DB 'bad DRI len', 00H
$SG4294820262 DB '(', 00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u'
	DB	00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, '>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' '
	DB	00H, '-', 00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, '&', 00H, ' ', 00H, 'b', 00H, 'm', 00H
	DB	'a', 00H, 's', 00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H
	DB	']', 00H, ']', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'h', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '[', 00H, 'c', 00H, ']', 00H, 00H, 00H
$SG4294820256 DB 'bad DQT type', 00H
	ORG $+3
$SG4294820259 DB 'expected marker', 00H
$SG4294820258 DB 'progressive jpeg', 00H
	ORG $+3
$SG4294820253 DB 'bad SOS component count', 00H
$SG4294820252 DB 'bad SOS len', 00H
$SG4294820255 DB 'bad DQT table', 00H
	ORG $+2
$SG4294820254 DB 'bad DHT header', 00H
	ORG $+1
$SG4294820249 DB 'bad SOS', 00H
$SG4294820248 DB 'bad SOS', 00H
$SG4294820251 DB 'bad DC huff', 00H
$SG4294820250 DB 'bad AC huff', 00H
$SG4294820245 DB 'no header height', 00H
	ORG $+3
$SG4294820244 DB '0 width', 00H
$SG4294820247 DB 'bad SOF len', 00H
$SG4294820246 DB 'only 8-bit', 00H
	ORG $+1
$SG4294820241 DB 'bad component ID', 00H
	ORG $+3
$SG4294820240 DB 'bad H', 00H
	ORG $+2
$SG4294820243 DB 'bad component count', 00H
$SG4294820242 DB 'bad SOF len', 00H
$SG4294820237 DB 'too large', 00H
	ORG $+2
$SG4294820236 DB 'outofmem', 00H
	ORG $+3
$SG4294820239 DB 'bad V', 00H
	ORG $+2
$SG4294820238 DB 'bad TQ', 00H
	ORG $+1
$SG4294820233 DB 'bad req_comp', 00H
	ORG $+3
$SG4294820232 DB 'outofmem', 00H
	ORG $+3
$SG4294820235 DB 'no SOI', 00H
	ORG $+1
$SG4294820234 DB 'no SOF', 00H
	ORG $+1
$SG4294820229 DB 'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '1', 00H, '6', 00H, 00H, 00H
	ORG $+2
$SG4294820228 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820231 DB 'outofmem', 00H
	ORG $+3
$SG4294820230 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820225 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820224 DB 'z', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, '1', 00H
	DB	'U', 00H, ' ', 00H, '<', 00H, '<', 00H, ' ', 00H, 'z', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'u', 00H, 'm', 00H, '_', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294820227 DB 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '('
	DB	00H, '1', 00H, ' ', 00H, '<', 00H, '<', 00H, ' ', 00H, 'i', 00H
	DB	')', 00H, 00H, 00H
	ORG $+2
$SG4294820226 DB 'bad codelengths', 00H
$SG4294820221 DB 'output buffer limit', 00H
$SG4294820220 DB 'outofmem', 00H
	ORG $+3
$SG4294820223 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820222 DB 'z', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, '[', 00H, 'b', 00H, ']', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 's', 00H, 00H, 00H
$SG4294820217 DB 'bad dist', 00H
	ORG $+3
$SG4294820216 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820219 DB 'bad huffman code', 00H
	ORG $+3
$SG4294820218 DB 'bad huffman code', 00H
	ORG $+3
$SG4294820213 DB 'c', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	'8', 00H, 00H, 00H
$SG4294820212 DB 'bad codelengths', 00H
$SG4294820215 DB 'c', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, '1', 00H, '9', 00H, 00H, 00H
	ORG $+2
$SG4294820214 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820209 DB 'zlib corrupt', 00H
	ORG $+3
$SG4294820208 DB 'read past buffer', 00H
	ORG $+3
$SG4294820211 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820210 DB 'a', 00H, '-', 00H, '>', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	'_', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG4294820205 DB 'bad compression', 00H
$SG4294820204 DB 'bad png sig', 00H
$SG4294820207 DB 'bad zlib header', 00H
$SG4294820206 DB 'no preset dict', 00H
	ORG $+1
$SG4294820201 DB 'outofmem', 00H
	ORG $+3
$SG4294820200 DB 'not enough pixels', 00H
	ORG $+2
$SG4294820203 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820196 DB 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H
	DB	'1', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, '_', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294820202 DB 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+'
	DB	00H, '1', 00H, 00H, 00H
	ORG $+2
$SG4294820197 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820199 DB 'not enough pixels', 00H
	ORG $+2
$SG4294820198 DB 'invalid filter', 00H
	ORG $+1
$SG4294820193 DB 'outofmem', 00H
	ORG $+3
$SG4294820192 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820195 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820194 DB 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG4294820189 DB 'bad IHDR len', 00H
	ORG $+3
$SG4294820188 DB 'too large', 00H
	ORG $+2
$SG4294820191 DB 's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H
	DB	'_', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
$SG4294820190 DB 'multiple IHDR', 00H
	ORG $+2
$SG4294820185 DB 'bad ctype', 00H
	ORG $+2
$SG4294820184 DB 'bad ctype', 00H
	ORG $+2
$SG4294820187 DB 'too large', 00H
	ORG $+2
$SG4294820186 DB '8bit only', 00H
	ORG $+2
$SG4294820181 DB 'bad interlace method', 00H
	ORG $+3
$SG4294820180 DB '0-pixel image', 00H
	ORG $+2
$SG4294820183 DB 'bad comp method', 00H
$SG4294820182 DB 'bad filter method', 00H
	ORG $+2
$SG4294820177 DB 'first not IHDR', 00H
	ORG $+1
$SG4294820176 DB 'invalid PLTE', 00H
	ORG $+3
$SG4294820179 DB 'too large', 00H
	ORG $+2
$SG4294820178 DB 'too large', 00H
	ORG $+2
$SG4294820173 DB 'tRNS after IDAT', 00H
$SG4294820172 DB 'tRNS before PLTE', 00H
	ORG $+3
$SG4294820175 DB 'invalid PLTE', 00H
	ORG $+3
$SG4294820174 DB 'first not IHDR', 00H
	ORG $+1
$SG4294820169 DB 'bad tRNS len', 00H
	ORG $+3
$SG4294820168 DB 'first not IHDR', 00H
	ORG $+1
$SG4294820171 DB 'bad tRNS len', 00H
	ORG $+3
$SG4294820170 DB 'tRNS with alpha', 00H
$SG4294820165 DB 'outofdata', 00H
	ORG $+2
$SG4294820164 DB 'first not IHDR', 00H
	ORG $+1
$SG4294820167 DB 'no PLTE', 00H
$SG4294820166 DB 'outofmem', 00H
	ORG $+3
$SG4294820161 DB 'bad req_comp', 00H
	ORG $+3
$SG4294820160 DB 'not BMP', 00H
$SG4294820163 DB 'no IDAT', 00H
$SG4294820162 DB 'first not IHDR', 00H
	ORG $+1
$SG4294820157 DB 'monochrome', 00H
	ORG $+1
$SG4294820156 DB 'BMP RLE', 00H
$SG4294820159 DB 'unknown BMP', 00H
$SG4294820158 DB 'bad BMP', 00H
$SG4294820153 DB 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'L', 00H, 'i', 00H, 'b'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H
	DB	'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294820152 DB 'h', 00H, 's', 00H, 'z', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '0', 00H, '8', 00H, 00H, 00H
	ORG $+2
$SG4294820155 DB 'bad BMP', 00H
$SG4294820154 DB 'bad BMP', 00H
$SG4294820149 DB 'bad bpp', 00H
$SG4294820148 DB 'bad masks', 00H
	ORG $+2
$SG4294820151 DB 'outofmem', 00H
	ORG $+3
$SG4294820150 DB 'invalid', 00H
$SG4294820145 DB 'bad palette', 00H
$SG4294820144 DB 'not PSD', 00H
$SG4294820147 DB 'outofmem', 00H
	ORG $+3
$SG4294820146 DB 'outofmem', 00H
	ORG $+3
$SG4294820141 DB 'unsupported bit depth', 00H
	ORG $+2
$SG4294820140 DB 'wrong color format', 00H
	ORG $+1
$SG4294820143 DB 'wrong version', 00H
	ORG $+2
$SG4294820142 DB 'wrong channel count', 00H
$SG4294820137 DB 'S', 080H, 0f6H, '4', 00H
	ORG $+3
$SG4294820136 DB 'PICT', 00H
	ORG $+3
$SG4294820139 DB 'bad compression', 00H
$SG4294820138 DB 'outofmem', 00H
	ORG $+3
$SG4294820133 DB 'bad file', 00H
	ORG $+3
$SG4294820132 DB 'bad format', 00H
	ORG $+1
$SG4294820135 DB 'bad file', 00H
	ORG $+3
$SG4294820134 DB 'bad format', 00H
	ORG $+1
$SG4294820129 DB 'bad file', 00H
	ORG $+3
$SG4294820128 DB 'bad file', 00H
	ORG $+3
$SG4294820131 DB 'bad format', 00H
	ORG $+1
$SG4294820130 DB 'bad file', 00H
	ORG $+3
$SG4294820125 DB 'too large', 00H
	ORG $+2
$SG4294820124 DB 'not GIF', 00H
$SG4294820127 DB 'bad file', 00H
	ORG $+3
$SG4294820126 DB 'bad file', 00H
	ORG $+3
$SG4294820120 DB 'no clear code', 00H
	ORG $+2
$SG4294820123 DB 'not GIF', 00H
$SG4294820122 DB 'not GIF', 00H
$SG4294820117 DB 'illegal code in raster', 00H
	ORG $+1
$SG4294820116 DB 'outofmem', 00H
	ORG $+3
$SG4294820119 DB 'too many codes', 00H
	ORG $+1
$SG4294820118 DB 'illegal code in raster', 00H
	ORG $+1
$SG4294820113 DB 'missing color table', 00H
$SG4294820112 DB 'unknown code', 00H
	ORG $+3
$SG4294820115 DB 'outofmem', 00H
	ORG $+3
$SG4294820114 DB 'bad Image Descriptor', 00H
	ORG $+3
$SG4294820109 DB 'not HDR', 00H
$SG4294820108 DB 'FORMAT=32-bit_rle_rgbe', 00H
	ORG $+1
$SG4294820111 DB '#?RADIANCE', 0aH, 00H
$SG4294820110 DB '#?RADIANCE', 00H
	ORG $+1
$SG4294820105 DB 'unsupported data layout', 00H
$SG4294820104 DB '+X ', 00H
$SG4294820107 DB 'unsupported format', 00H
	ORG $+1
$SG4294820106 DB '-Y ', 00H
$SG4294820101 DB '#?RADIANCE', 00H
	ORG $+1
$SG4294820100 DB 'FORMAT=32-bit_rle_rgbe', 00H
	ORG $+1
$SG4294820103 DB 'unsupported data layout', 00H
$SG4294820102 DB 'invalid decoded scanline length', 00H
$SG4294820097 DB 'unknown image type', 00H
	ORG $+1
$SG4294820096 DB 'rb', 00H
	ORG $+1
$SG4294820099 DB '-Y ', 00H
$SG4294820098 DB '+X ', 00H
$SG4294820095 DB 'can''t fopen', 00H
PUBLIC	_stbi_info_from_callbacks
PUBLIC	_stbi_info_from_memory
PUBLIC	_stbi_info_from_file
PUBLIC	_stbi_info
PUBLIC	_stbi_convert_iphone_png_to_rgb
PUBLIC	_stbi_set_unpremultiply_on_load
PUBLIC	_stbi_zlib_decode_noheader_buffer
PUBLIC	_stbi_zlib_decode_noheader_malloc
PUBLIC	_stbi_zlib_decode_buffer
PUBLIC	?stbi_zlib_decode_malloc_guesssize_headerflag@@YAPADPBDHHPAHH@Z ; stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	_stbi_zlib_decode_malloc
PUBLIC	_stbi_zlib_decode_malloc_guesssize
PUBLIC	_stbi_ldr_to_hdr_scale
PUBLIC	_stbi_ldr_to_hdr_gamma
PUBLIC	_stbi_hdr_to_ldr_scale
PUBLIC	_stbi_hdr_to_ldr_gamma
PUBLIC	_stbi_is_hdr_from_callbacks
PUBLIC	_stbi_is_hdr_from_file
PUBLIC	_stbi_is_hdr
PUBLIC	_stbi_is_hdr_from_memory
PUBLIC	_stbi_loadf_from_file
PUBLIC	_stbi_loadf
PUBLIC	_stbi_loadf_from_callbacks
PUBLIC	_stbi_loadf_from_memory
PUBLIC	?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z	; stbi_loadf_main
PUBLIC	_stbi_load_from_callbacks
PUBLIC	_stbi_load_from_memory
PUBLIC	_stbi_load_from_file
PUBLIC	_stbi_failure_reason
PUBLIC	_stbi_load
PUBLIC	_stbi_image_free
?failure_reason@@3PBDB DD 01H DUP (?)			; failure_reason
?default_distance@@3PAEA DB 020H DUP (?)		; default_distance
?default_length@@3PAEA DB 0120H DUP (?)			; default_length
_BSS	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_retval_from_stbi_load$ = 8				; size = 4
_stbi_image_free PROC

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 287  :    free(retval_from_stbi_load);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _retval_from_stbi_load$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 288  : }

  0001a	5e		 pop	 esi
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv71 = -12						; size = 4
_result$ = -8						; size = 4
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load PROC

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 320  :    FILE *f = fopen(filename, "rb");

  0001c	8b f4		 mov	 esi, esp
  0001e	68 00 00 00 00	 push	 OFFSET $SG4294820277
  00023	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 321  :    unsigned char *result;
; 322  :    if (!f) return epuc("can't fopen", "Unable to open file");

  0003a	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  0003e	75 26		 jne	 SHORT $LN2@stbi_load
  00040	68 00 00 00 00	 push	 OFFSET $SG4294820276
  00045	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0004a	83 c4 04	 add	 esp, 4
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN4@stbi_load
  00051	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00058	eb 07		 jmp	 SHORT $LN5@stbi_load
$LN4@stbi_load:
  0005a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@stbi_load:
  00061	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00064	eb 38		 jmp	 SHORT $LN1@stbi_load
$LN2@stbi_load:

; 323  :    result = stbi_load_from_file(f,x,y,comp,req_comp);

  00066	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR _f$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _stbi_load_from_file
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 324  :    fclose(f);

  00085	8b f4		 mov	 esi, esp
  00087	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 325  :    return result;

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@stbi_load:

; 326  : }

  0009e	5e		 pop	 esi
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
_stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
?start_mem@@YAXPAUstbi@@PBEH@Z PROC			; start_mem

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 176  :    s->io.read = NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 177  :    s->read_from_callbacks = 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00010	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 178  :    s->img_buffer = s->img_buffer_original = (uint8 *) buffer;

  00017	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0001d	89 82 b0 00 00
	00		 mov	 DWORD PTR [edx+176], eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00026	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00029	89 91 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], edx

; 179  :    s->img_buffer_end = (uint8 *) buffer+len;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00032	03 45 10	 add	 eax, DWORD PTR _len$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00038	89 81 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], eax

; 180  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?start_mem@@YAXPAUstbi@@PBEH@Z ENDP			; start_mem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_user$ = 16						; size = 4
?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z PROC ; start_callbacks

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  :    s->io = *c;

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 186  :    s->io_user_data = user;

  0001c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0001f	8b 45 10	 mov	 eax, DWORD PTR _user$[ebp]
  00022	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 187  :    s->buflen = sizeof(s->buffer_start);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00028	c7 41 24 80 00
	00 00		 mov	 DWORD PTR [ecx+36], 128	; 00000080H

; 188  :    s->read_from_callbacks = 1;

  0002f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00032	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1

; 189  :    s->img_buffer_original = s->buffer_start;

  00039	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003c	83 c0 28	 add	 eax, 40			; 00000028H
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00042	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 190  :    refill_buffer(s);

  00048	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?refill_buffer@@YAXPAUstbi@@@Z ; refill_buffer
  00051	83 c4 04	 add	 esp, 4

; 191  : }

  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ENDP ; start_callbacks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_user$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
?stdio_read@@YAHPAXPADH@Z PROC				; stdio_read

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 197  :    return (int) fread(data,1,size,(FILE*) user);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _user$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	51		 push	 ecx
  0000e	6a 01		 push	 1
  00010	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 198  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?stdio_read@@YAHPAXPADH@Z ENDP				; stdio_read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_user$ = 8						; size = 4
_n$ = 12						; size = 4
?stdio_skip@@YAXPAXI@Z PROC				; stdio_skip

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 202  :    fseek((FILE*) user, n, SEEK_CUR);

  00004	8b f4		 mov	 esi, esp
  00006	6a 01		 push	 1
  00008	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _user$[ebp]
  0000f	51		 push	 ecx
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 203  : }

  00020	5e		 pop	 esi
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?stdio_skip@@YAXPAXI@Z ENDP				; stdio_skip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_user$ = 8						; size = 4
?stdio_eof@@YAHPAX@Z PROC				; stdio_eof

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 207  :    return feof((FILE*) user);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _user$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__feof
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 208  : }

  0001a	5e		 pop	 esi
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?stdio_eof@@YAHPAX@Z ENDP				; stdio_eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_f$ = 12						; size = 4
?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z PROC		; start_file

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  :    start_callbacks(s, &stbi_stdio_callbacks, (void *) f);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _f$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ?stbi_stdio_callbacks@@3Ustbi_io_callbacks@@A
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ; start_callbacks
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  : }

  00018	3b ec		 cmp	 ebp, esp
  0001a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z ENDP		; start_file
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
?stbi_rewind@@YAXPAUstbi@@@Z PROC			; stbi_rewind

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  :    // conceptually rewind SHOULD rewind to the beginning of the stream,
; 229  :    // but we just rewind to the beginning of the initial buffer, because
; 230  :    // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 231  :    s->img_buffer = s->img_buffer_original;

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00009	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0000f	89 90 a8 00 00
	00		 mov	 DWORD PTR [eax+168], edx

; 232  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?stbi_rewind@@YAXPAUstbi@@@Z ENDP			; stbi_rewind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_stbi_failure_reason PROC

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 261  :    return failure_reason;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?failure_reason@@3PBDB

; 262  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_str$ = 8						; size = 4
?e@@YAHPBD@Z PROC					; e

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  :    failure_reason = str;

  00003	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?failure_reason@@3PBDB, eax

; 267  :    return 0;

  0000b	33 c0		 xor	 eax, eax

; 268  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?e@@YAHPBD@Z ENDP					; e
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv178 = -12						; size = 4
tv161 = -8						; size = 4
_hdr$1 = -4						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_load_main

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 297  :    if (stbi_jpeg_test(s)) return stbi_jpeg_load(s,x,y,comp,req_comp);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?stbi_jpeg_test@@YAHPAUstbi@@@Z ; stbi_jpeg_test
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	74 21		 je	 SHORT $LN2@stbi_load_
  0002b	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00032	52		 push	 edx
  00033	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?stbi_jpeg_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_jpeg_load
  00044	83 c4 14	 add	 esp, 20			; 00000014H
  00047	e9 aa 01 00 00	 jmp	 $LN1@stbi_load_
$LN2@stbi_load_:

; 298  :    if (stbi_png_test(s))  return stbi_png_load(s,x,y,comp,req_comp);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?stbi_png_test@@YAHPAUstbi@@@Z ; stbi_png_test
  00055	83 c4 04	 add	 esp, 4
  00058	85 c0		 test	 eax, eax
  0005a	74 21		 je	 SHORT $LN3@stbi_load_
  0005c	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00063	52		 push	 edx
  00064	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?stbi_png_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_png_load
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	e9 79 01 00 00	 jmp	 $LN1@stbi_load_
$LN3@stbi_load_:

; 299  :    if (stbi_bmp_test(s))  return stbi_bmp_load(s,x,y,comp,req_comp);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?stbi_bmp_test@@YAHPAUstbi@@@Z ; stbi_bmp_test
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	74 21		 je	 SHORT $LN4@stbi_load_
  0008d	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00094	52		 push	 edx
  00095	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?stbi_bmp_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_bmp_load
  000a6	83 c4 14	 add	 esp, 20			; 00000014H
  000a9	e9 48 01 00 00	 jmp	 $LN1@stbi_load_
$LN4@stbi_load_:

; 300  :    if (stbi_gif_test(s))  return stbi_gif_load(s,x,y,comp,req_comp);

  000ae	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?stbi_gif_test@@YAHPAUstbi@@@Z ; stbi_gif_test
  000b7	83 c4 04	 add	 esp, 4
  000ba	85 c0		 test	 eax, eax
  000bc	74 21		 je	 SHORT $LN5@stbi_load_
  000be	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 ?stbi_gif_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_gif_load
  000d7	83 c4 14	 add	 esp, 20			; 00000014H
  000da	e9 17 01 00 00	 jmp	 $LN1@stbi_load_
$LN5@stbi_load_:

; 301  :    if (stbi_psd_test(s))  return stbi_psd_load(s,x,y,comp,req_comp);

  000df	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?stbi_psd_test@@YAHPAUstbi@@@Z ; stbi_psd_test
  000e8	83 c4 04	 add	 esp, 4
  000eb	85 c0		 test	 eax, eax
  000ed	74 21		 je	 SHORT $LN6@stbi_load_
  000ef	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  000f2	51		 push	 ecx
  000f3	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  000f6	52		 push	 edx
  000f7	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 ?stbi_psd_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_psd_load
  00108	83 c4 14	 add	 esp, 20			; 00000014H
  0010b	e9 e6 00 00 00	 jmp	 $LN1@stbi_load_
$LN6@stbi_load_:

; 302  :    if (stbi_pic_test(s))  return stbi_pic_load(s,x,y,comp,req_comp);

  00110	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?stbi_pic_test@@YAHPAUstbi@@@Z ; stbi_pic_test
  00119	83 c4 04	 add	 esp, 4
  0011c	85 c0		 test	 eax, eax
  0011e	74 21		 je	 SHORT $LN7@stbi_load_
  00120	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00123	51		 push	 ecx
  00124	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00127	52		 push	 edx
  00128	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0012b	50		 push	 eax
  0012c	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0012f	51		 push	 ecx
  00130	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 ?stbi_pic_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_pic_load
  00139	83 c4 14	 add	 esp, 20			; 00000014H
  0013c	e9 b5 00 00 00	 jmp	 $LN1@stbi_load_
$LN7@stbi_load_:

; 303  : 
; 304  :    #ifndef STBI_NO_HDR
; 305  :    if (stbi_hdr_test(s)) {

  00141	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?stbi_hdr_test@@YAHPAUstbi@@@Z ; stbi_hdr_test
  0014a	83 c4 04	 add	 esp, 4
  0014d	85 c0		 test	 eax, eax
  0014f	74 53		 je	 SHORT $LN8@stbi_load_

; 306  :       float *hdr = stbi_hdr_load(s, x,y,comp,req_comp);

  00151	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00158	52		 push	 edx
  00159	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00160	51		 push	 ecx
  00161	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 ?stbi_hdr_load@@YAPAMPAUstbi@@PAH11H@Z ; stbi_hdr_load
  0016a	83 c4 14	 add	 esp, 20			; 00000014H
  0016d	89 45 fc	 mov	 DWORD PTR _hdr$1[ebp], eax

; 307  :       return hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

  00170	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00174	74 08		 je	 SHORT $LN11@stbi_load_
  00176	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00179	89 45 f8	 mov	 DWORD PTR tv161[ebp], eax
  0017c	eb 08		 jmp	 SHORT $LN12@stbi_load_
$LN11@stbi_load_:
  0017e	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00181	8b 11		 mov	 edx, DWORD PTR [ecx]
  00183	89 55 f8	 mov	 DWORD PTR tv161[ebp], edx
$LN12@stbi_load_:
  00186	8b 45 f8	 mov	 eax, DWORD PTR tv161[ebp]
  00189	50		 push	 eax
  0018a	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0018d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018f	52		 push	 edx
  00190	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00193	8b 08		 mov	 ecx, DWORD PTR [eax]
  00195	51		 push	 ecx
  00196	8b 55 fc	 mov	 edx, DWORD PTR _hdr$1[ebp]
  00199	52		 push	 edx
  0019a	e8 00 00 00 00	 call	 ?hdr_to_ldr@@YAPAEPAMHHH@Z ; hdr_to_ldr
  0019f	83 c4 10	 add	 esp, 16			; 00000010H
  001a2	eb 52		 jmp	 SHORT $LN1@stbi_load_
$LN8@stbi_load_:

; 308  :    }
; 309  :    #endif
; 310  : 
; 311  :    // test tga last because it's a crappy test!
; 312  :    if (stbi_tga_test(s))

  001a4	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?stbi_tga_test@@YAHPAUstbi@@@Z ; stbi_tga_test
  001ad	83 c4 04	 add	 esp, 4
  001b0	85 c0		 test	 eax, eax
  001b2	74 1e		 je	 SHORT $LN9@stbi_load_

; 313  :       return stbi_tga_load(s,x,y,comp,req_comp);

  001b4	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  001bb	52		 push	 edx
  001bc	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  001c3	51		 push	 ecx
  001c4	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  001c7	52		 push	 edx
  001c8	e8 00 00 00 00	 call	 ?stbi_tga_load@@YAPAEPAUstbi@@PAH11H@Z ; stbi_tga_load
  001cd	83 c4 14	 add	 esp, 20			; 00000014H
  001d0	eb 24		 jmp	 SHORT $LN1@stbi_load_
$LN9@stbi_load_:

; 314  :    return epuc("unknown image type", "Image not of any known type, or corrupt");

  001d2	68 00 00 00 00	 push	 OFFSET $SG4294820278
  001d7	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001dc	83 c4 04	 add	 esp, 4
  001df	85 c0		 test	 eax, eax
  001e1	74 09		 je	 SHORT $LN13@stbi_load_
  001e3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
  001ea	eb 07		 jmp	 SHORT $LN14@stbi_load_
$LN13@stbi_load_:
  001ec	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
$LN14@stbi_load_:
  001f3	8b 45 f4	 mov	 eax, DWORD PTR tv178[ebp]
$LN1@stbi_load_:

; 315  : }

  001f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f9	3b ec		 cmp	 ebp, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_load_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_load_from_file PROC

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 330  :    stbi s;
; 331  :    start_file(&s,f);

  00026	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00029	50		 push	 eax
  0002a	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z ; start_file
  00036	83 c4 08	 add	 esp, 8

; 332  :    return stbi_load_main(&s,x,y,comp,req_comp);

  00039	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  0003c	52		 push	 edx
  0003d	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00048	52		 push	 edx
  00049	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z ; stbi_load_main
  00055	83 c4 14	 add	 esp, 20			; 00000014H

; 333  : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_load_
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@stbi_load_:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@stbi_load_
$LN4@stbi_load_:
  00090	44 ff ff ff	 DD	 -188			; ffffff44H
  00094	b4 00 00 00	 DD	 180			; 000000b4H
  00098	00 00 00 00	 DD	 $LN3@stbi_load_
$LN3@stbi_load_:
  0009c	73		 DB	 115			; 00000073H
  0009d	00		 DB	 0
_stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_memory PROC

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 338  :    stbi s;
; 339  :    start_mem(&s,buffer,len);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_mem@@YAXPAUstbi@@PBEH@Z ; start_mem
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 340  :    return stbi_load_main(&s,x,y,comp,req_comp);

  0003d	8b 45 1c	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 18	 mov	 ecx, DWORD PTR _comp$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0004c	50		 push	 eax
  0004d	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z ; stbi_load_main
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 341  : }

  0005c	52		 push	 edx
  0005d	8b cd		 mov	 ecx, ebp
  0005f	50		 push	 eax
  00060	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_load_
  00066	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006b	58		 pop	 eax
  0006c	5a		 pop	 edx
  0006d	5f		 pop	 edi
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	0f 1f 00	 npad	 3
$LN5@stbi_load_:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@stbi_load_
$LN4@stbi_load_:
  00094	44 ff ff ff	 DD	 -188			; ffffff44H
  00098	b4 00 00 00	 DD	 180			; 000000b4H
  0009c	00 00 00 00	 DD	 $LN3@stbi_load_
$LN3@stbi_load_:
  000a0	73		 DB	 115			; 00000073H
  000a1	00		 DB	 0
_stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_load_from_callbacks PROC

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 345  :    stbi s;
; 346  :    start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _user$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _clbk$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ; start_callbacks
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 347  :    return stbi_load_main(&s,x,y,comp,req_comp);

  0003d	8b 45 1c	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 18	 mov	 ecx, DWORD PTR _comp$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0004c	50		 push	 eax
  0004d	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z ; stbi_load_main
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 348  : }

  0005c	52		 push	 edx
  0005d	8b cd		 mov	 ecx, ebp
  0005f	50		 push	 eax
  00060	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_load_
  00066	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006b	58		 pop	 eax
  0006c	5a		 pop	 edx
  0006d	5f		 pop	 edi
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	0f 1f 00	 npad	 3
$LN5@stbi_load_:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@stbi_load_
$LN4@stbi_load_:
  00094	44 ff ff ff	 DD	 -188			; ffffff44H
  00098	b4 00 00 00	 DD	 180			; 000000b4H
  0009c	00 00 00 00	 DD	 $LN3@stbi_load_
$LN3@stbi_load_:
  000a0	73		 DB	 115			; 00000073H
  000a1	00		 DB	 0
_stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv90 = -12						; size = 4
tv82 = -8						; size = 4
_data$ = -4						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z PROC		; stbi_loadf_main

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 354  :    unsigned char *data;
; 355  :    #ifndef STBI_NO_HDR
; 356  :    if (stbi_hdr_test(s))

  0001b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?stbi_hdr_test@@YAHPAUstbi@@@Z ; stbi_hdr_test
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	74 1e		 je	 SHORT $LN2@stbi_loadf

; 357  :       return stbi_hdr_load(s,x,y,comp,req_comp);

  0002b	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00032	52		 push	 edx
  00033	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?stbi_hdr_load@@YAPAMPAUstbi@@PAH11H@Z ; stbi_hdr_load
  00044	83 c4 14	 add	 esp, 20			; 00000014H
  00047	eb 7d		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 358  :    #endif
; 359  :    data = stbi_load_main(s, x, y, comp, req_comp);

  00049	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00054	52		 push	 edx
  00055	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ?stbi_load_main@@YAPAEPAUstbi@@PAH11H@Z ; stbi_load_main
  00062	83 c4 14	 add	 esp, 20			; 00000014H
  00065	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 360  :    if (data)

  00068	83 7d fc 00	 cmp	 DWORD PTR _data$[ebp], 0
  0006c	74 34		 je	 SHORT $LN3@stbi_loadf

; 361  :       return ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

  0006e	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00072	74 08		 je	 SHORT $LN5@stbi_loadf
  00074	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  00077	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0007a	eb 08		 jmp	 SHORT $LN6@stbi_loadf
$LN5@stbi_loadf:
  0007c	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  0007f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00081	89 4d f8	 mov	 DWORD PTR tv82[ebp], ecx
$LN6@stbi_loadf:
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv82[ebp]
  00087	52		 push	 edx
  00088	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	51		 push	 ecx
  0008e	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	50		 push	 eax
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?ldr_to_hdr@@YAPAMPAEHHH@Z ; ldr_to_hdr
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	eb 24		 jmp	 SHORT $LN1@stbi_loadf
$LN3@stbi_loadf:

; 362  :    return epf("unknown image type", "Image not of any known type, or corrupt");

  000a2	68 00 00 00 00	 push	 OFFSET $SG4294820275
  000a7	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	74 09		 je	 SHORT $LN7@stbi_loadf
  000b3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  000ba	eb 07		 jmp	 SHORT $LN8@stbi_loadf
$LN7@stbi_loadf:
  000bc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN8@stbi_loadf:
  000c3	8b 45 f4	 mov	 eax, DWORD PTR tv90[ebp]
$LN1@stbi_loadf:

; 363  : }

  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z ENDP		; stbi_loadf_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_memory PROC

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 367  :    stbi s;
; 368  :    start_mem(&s,buffer,len);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_mem@@YAXPAUstbi@@PBEH@Z ; start_mem
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 369  :    return stbi_loadf_main(&s,x,y,comp,req_comp);

  0003d	8b 45 1c	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 18	 mov	 ecx, DWORD PTR _comp$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0004c	50		 push	 eax
  0004d	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z ; stbi_loadf_main
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 370  : }

  0005c	52		 push	 edx
  0005d	8b cd		 mov	 ecx, ebp
  0005f	50		 push	 eax
  00060	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_loadf
  00066	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006b	58		 pop	 eax
  0006c	5a		 pop	 edx
  0006d	5f		 pop	 edi
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	0f 1f 00	 npad	 3
$LN5@stbi_loadf:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@stbi_loadf
$LN4@stbi_loadf:
  00094	44 ff ff ff	 DD	 -188			; ffffff44H
  00098	b4 00 00 00	 DD	 180			; 000000b4H
  0009c	00 00 00 00	 DD	 $LN3@stbi_loadf
$LN3@stbi_loadf:
  000a0	73		 DB	 115			; 00000073H
  000a1	00		 DB	 0
_stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_req_comp$ = 28						; size = 4
_stbi_loadf_from_callbacks PROC

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 374  :    stbi s;
; 375  :    start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _user$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _clbk$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ; start_callbacks
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  :    return stbi_loadf_main(&s,x,y,comp,req_comp);

  0003d	8b 45 1c	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 18	 mov	 ecx, DWORD PTR _comp$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  00048	52		 push	 edx
  00049	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0004c	50		 push	 eax
  0004d	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z ; stbi_loadf_main
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 377  : }

  0005c	52		 push	 edx
  0005d	8b cd		 mov	 ecx, ebp
  0005f	50		 push	 eax
  00060	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_loadf
  00066	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006b	58		 pop	 eax
  0006c	5a		 pop	 edx
  0006d	5f		 pop	 edi
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	0f 1f 00	 npad	 3
$LN5@stbi_loadf:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@stbi_loadf
$LN4@stbi_loadf:
  00094	44 ff ff ff	 DD	 -188			; ffffff44H
  00098	b4 00 00 00	 DD	 180			; 000000b4H
  0009c	00 00 00 00	 DD	 $LN3@stbi_loadf
$LN3@stbi_loadf:
  000a0	73		 DB	 115			; 00000073H
  000a1	00		 DB	 0
_stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv71 = -12						; size = 4
_result$ = -8						; size = 4
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf PROC

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 382  :    FILE *f = fopen(filename, "rb");

  0001c	8b f4		 mov	 esi, esp
  0001e	68 00 00 00 00	 push	 OFFSET $SG4294820274
  00023	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 383  :    float *result;
; 384  :    if (!f) return epf("can't fopen", "Unable to open file");

  0003a	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  0003e	75 26		 jne	 SHORT $LN2@stbi_loadf
  00040	68 00 00 00 00	 push	 OFFSET $SG4294820273
  00045	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0004a	83 c4 04	 add	 esp, 4
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN4@stbi_loadf
  00051	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00058	eb 07		 jmp	 SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
  0005a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@stbi_loadf:
  00061	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00064	eb 38		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 385  :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);

  00066	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR _f$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _stbi_loadf_from_file
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 386  :    fclose(f);

  00085	8b f4		 mov	 esi, esp
  00087	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 387  :    return result;

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@stbi_loadf:

; 388  : }

  0009e	5e		 pop	 esi
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
_stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
_stbi_loadf_from_file PROC

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 392  :    stbi s;
; 393  :    start_file(&s,f);

  00026	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00029	50		 push	 eax
  0002a	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z ; start_file
  00036	83 c4 08	 add	 esp, 8

; 394  :    return stbi_loadf_main(&s,x,y,comp,req_comp);

  00039	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  0003c	52		 push	 edx
  0003d	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00048	52		 push	 edx
  00049	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?stbi_loadf_main@@YAPAMPAUstbi@@PAH11H@Z ; stbi_loadf_main
  00055	83 c4 14	 add	 esp, 20			; 00000014H

; 395  : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_loadf
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@stbi_loadf:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@stbi_loadf
$LN4@stbi_loadf:
  00090	44 ff ff ff	 DD	 -188			; ffffff44H
  00094	b4 00 00 00	 DD	 180			; 000000b4H
  00098	00 00 00 00	 DD	 $LN3@stbi_loadf
$LN3@stbi_loadf:
  0009c	73		 DB	 115			; 00000073H
  0009d	00		 DB	 0
_stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_stbi_is_hdr_from_memory PROC

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 406  :    #ifndef STBI_NO_HDR
; 407  :    stbi s;
; 408  :    start_mem(&s,buffer,len);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_mem@@YAXPAUstbi@@PBEH@Z ; start_mem
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  :    return stbi_hdr_test(&s);

  0003d	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?stbi_hdr_test@@YAHPAUstbi@@@Z ; stbi_hdr_test
  00049	83 c4 04	 add	 esp, 4

; 410  :    #else
; 411  :    STBI_NOTUSED(buffer);
; 412  :    STBI_NOTUSED(len);
; 413  :    return 0;
; 414  :    #endif
; 415  : }

  0004c	52		 push	 edx
  0004d	8b cd		 mov	 ecx, ebp
  0004f	50		 push	 eax
  00050	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_is_hd
  00056	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005b	58		 pop	 eax
  0005c	5a		 pop	 edx
  0005d	5f		 pop	 edi
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
  00079	0f 1f 00	 npad	 3
$LN5@stbi_is_hd:
  0007c	01 00 00 00	 DD	 1
  00080	00 00 00 00	 DD	 $LN4@stbi_is_hd
$LN4@stbi_is_hd:
  00084	44 ff ff ff	 DD	 -188			; ffffff44H
  00088	b4 00 00 00	 DD	 180			; 000000b4H
  0008c	00 00 00 00	 DD	 $LN3@stbi_is_hd
$LN3@stbi_is_hd:
  00090	73		 DB	 115			; 00000073H
  00091	00		 DB	 0
_stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_result$ = -8						; size = 4
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_stbi_is_hdr PROC

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 420  :    FILE *f = fopen(filename, "rb");

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG4294820272
  0001c	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 421  :    int result=0;

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 422  :    if (f) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  0003e	74 25		 je	 SHORT $LN2@stbi_is_hd

; 423  :       result = stbi_is_hdr_from_file(f);

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _f$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _stbi_is_hdr_from_file
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 424  :       fclose(f);

  0004f	8b f4		 mov	 esi, esp
  00051	8b 55 fc	 mov	 edx, DWORD PTR _f$[ebp]
  00054	52		 push	 edx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@stbi_is_hd:

; 425  :    }
; 426  :    return result;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]

; 427  : }

  00068	5e		 pop	 esi
  00069	83 c4 08	 add	 esp, 8
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_stbi_is_hdr_from_file PROC

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 431  :    #ifndef STBI_NO_HDR
; 432  :    stbi s;
; 433  :    start_file(&s,f);

  00026	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00029	50		 push	 eax
  0002a	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z ; start_file
  00036	83 c4 08	 add	 esp, 8

; 434  :    return stbi_hdr_test(&s);

  00039	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?stbi_hdr_test@@YAHPAUstbi@@@Z ; stbi_hdr_test
  00045	83 c4 04	 add	 esp, 4

; 435  :    #else
; 436  :    return 0;
; 437  :    #endif
; 438  : }

  00048	52		 push	 edx
  00049	8b cd		 mov	 ecx, ebp
  0004b	50		 push	 eax
  0004c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_is_hd
  00052	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00057	58		 pop	 eax
  00058	5a		 pop	 edx
  00059	5f		 pop	 edi
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
  00075	0f 1f 00	 npad	 3
$LN5@stbi_is_hd:
  00078	01 00 00 00	 DD	 1
  0007c	00 00 00 00	 DD	 $LN4@stbi_is_hd
$LN4@stbi_is_hd:
  00080	44 ff ff ff	 DD	 -188			; ffffff44H
  00084	b4 00 00 00	 DD	 180			; 000000b4H
  00088	00 00 00 00	 DD	 $LN3@stbi_is_hd
$LN3@stbi_is_hd:
  0008c	73		 DB	 115			; 00000073H
  0008d	00		 DB	 0
_stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_clbk$ = 8						; size = 4
_user$ = 12						; size = 4
_stbi_is_hdr_from_callbacks PROC

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 443  :    #ifndef STBI_NO_HDR
; 444  :    stbi s;
; 445  :    start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _user$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _clbk$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ; start_callbacks
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 446  :    return stbi_hdr_test(&s);

  0003d	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?stbi_hdr_test@@YAHPAUstbi@@@Z ; stbi_hdr_test
  00049	83 c4 04	 add	 esp, 4

; 447  :    #else
; 448  :    return 0;
; 449  :    #endif
; 450  : }

  0004c	52		 push	 edx
  0004d	8b cd		 mov	 ecx, ebp
  0004f	50		 push	 eax
  00050	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_is_hd
  00056	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005b	58		 pop	 eax
  0005c	5a		 pop	 edx
  0005d	5f		 pop	 edi
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
  00079	0f 1f 00	 npad	 3
$LN5@stbi_is_hd:
  0007c	01 00 00 00	 DD	 1
  00080	00 00 00 00	 DD	 $LN4@stbi_is_hd
$LN4@stbi_is_hd:
  00084	44 ff ff ff	 DD	 -188			; ffffff44H
  00088	b4 00 00 00	 DD	 180			; 000000b4H
  0008c	00 00 00 00	 DD	 $LN3@stbi_is_hd
$LN3@stbi_is_hd:
  00090	73		 DB	 115			; 00000073H
  00091	00		 DB	 0
_stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_hdr_to_ldr_gamma PROC

; 456  : void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1/gamma; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000b	f3 0f 5e 45 08	 divss	 xmm0, DWORD PTR _gamma$[ebp]
  00010	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?h2l_gamma_i@@3MA, xmm0
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_hdr_to_ldr_scale PROC

; 457  : void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1/scale; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000b	f3 0f 5e 45 08	 divss	 xmm0, DWORD PTR _scale$[ebp]
  00010	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?h2l_scale_i@@3MA, xmm0
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_gamma$ = 8						; size = 4
_stbi_ldr_to_hdr_gamma PROC

; 459  : void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _gamma$[ebp]
  00008	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?l2h_gamma@@3MA, xmm0
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_scale$ = 8						; size = 4
_stbi_ldr_to_hdr_scale PROC

; 460  : void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _scale$[ebp]
  00008	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?l2h_scale@@3MA, xmm0
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_s$ = 8							; size = 4
?refill_buffer@@YAXPAUstbi@@@Z PROC			; refill_buffer

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 478  :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00011	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00018	83 c2 28	 add	 edx, 40			; 00000028H
  0001b	52		 push	 edx
  0001c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00026	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00029	ff d0		 call	 eax
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 479  :    if (n == 0) {

  00038	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  0003c	75 2d		 jne	 SHORT $LN2@refill_buf

; 480  :       // at end of file, treat same as if from memory
; 481  :       s->read_from_callbacks = 0;

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00041	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 482  :       s->img_buffer = s->img_buffer_end-1;

  00048	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0004b	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00051	83 e8 01	 sub	 eax, 1
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00057	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 483  :       *s->img_buffer = 0;

  0005d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00060	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00066	c6 00 00	 mov	 BYTE PTR [eax], 0

; 484  :    } else {

  00069	eb 22		 jmp	 SHORT $LN1@refill_buf
$LN2@refill_buf:

; 485  :       s->img_buffer = s->buffer_start;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0006e	83 c1 28	 add	 ecx, 40			; 00000028H
  00071	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00074	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 486  :       s->img_buffer_end = s->buffer_start + n;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00080	8d 54 01 28	 lea	 edx, DWORD PTR [ecx+eax+40]
  00084	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00087	89 90 ac 00 00
	00		 mov	 DWORD PTR [eax+172], edx
$LN1@refill_buf:

; 487  :    }
; 488  : }

  0008d	5e		 pop	 esi
  0008e	83 c4 04	 add	 esp, 4
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?refill_buffer@@YAXPAUstbi@@@Z ENDP			; refill_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv83 = -8						; size = 4
tv73 = -4						; size = 4
_s$ = 8							; size = 4
?get8@@YAHPAUstbi@@@Z PROC				; get8

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 492  :    if (s->img_buffer < s->img_buffer_end)

  00014	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001a	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00020	3b 91 ac 00 00
	00		 cmp	 edx, DWORD PTR [ecx+172]
  00026	73 29		 jae	 SHORT $LN2@get8

; 493  :       return *s->img_buffer++;

  00028	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002b	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00031	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00034	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003a	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00040	83 c1 01	 add	 ecx, 1
  00043	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00046	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx
  0004c	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  0004f	eb 40		 jmp	 SHORT $LN1@get8
$LN2@get8:

; 494  :    if (s->read_from_callbacks) {

  00051	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00054	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00058	74 35		 je	 SHORT $LN3@get8

; 495  :       refill_buffer(s);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?refill_buffer@@YAXPAUstbi@@@Z ; refill_buffer
  00063	83 c4 04	 add	 esp, 4

; 496  :       return *s->img_buffer++;

  00066	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00069	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0006f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00072	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00078	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0007e	83 c0 01	 add	 eax, 1
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00084	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax
  0008a	8b 45 f8	 mov	 eax, DWORD PTR tv83[ebp]
  0008d	eb 02		 jmp	 SHORT $LN1@get8
$LN3@get8:

; 497  :    }
; 498  :    return 0;

  0008f	33 c0		 xor	 eax, eax
$LN1@get8:

; 499  : }

  00091	83 c4 08	 add	 esp, 8
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?get8@@YAHPAUstbi@@@Z ENDP				; get8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv78 = -4						; size = 4
_s$ = 8							; size = 4
?at_eof@@YAHPAUstbi@@@Z PROC				; at_eof

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 503  :    if (s->io.read) {

  0000c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00013	74 33		 je	 SHORT $LN2@at_eof

; 504  :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00015	8b f4		 mov	 esi, esp
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00024	ff d1		 call	 ecx
  00026	83 c4 04	 add	 esp, 4
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $LN3@at_eof
  00034	33 c0		 xor	 eax, eax
  00036	eb 37		 jmp	 SHORT $LN1@at_eof
$LN3@at_eof:

; 505  :       // if feof() is true, check if buffer = end
; 506  :       // special case: we've only got the special 0 character at the end
; 507  :       if (s->read_from_callbacks == 0) return 1;

  00038	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0003b	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0003f	75 07		 jne	 SHORT $LN2@at_eof
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	eb 27		 jmp	 SHORT $LN1@at_eof
$LN2@at_eof:

; 508  :    }
; 509  : 
; 510  :    return s->img_buffer >= s->img_buffer_end;   

  00048	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0004e	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00054	3b 91 ac 00 00
	00		 cmp	 edx, DWORD PTR [ecx+172]
  0005a	72 09		 jb	 SHORT $LN6@at_eof
  0005c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00063	eb 07		 jmp	 SHORT $LN7@at_eof
$LN6@at_eof:
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN7@at_eof:
  0006c	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
$LN1@at_eof:

; 511  : }

  0006f	5e		 pop	 esi
  00070	83 c4 04	 add	 esp, 4
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?at_eof@@YAHPAUstbi@@@Z ENDP				; at_eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
?get8u@@YAEPAUstbi@@@Z PROC				; get8u

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 515  :    return (uint8) get8(s);

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0000c	83 c4 04	 add	 esp, 4

; 516  : }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?get8u@@YAEPAUstbi@@@Z ENDP				; get8u
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_blen$1 = -4						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
?skip@@YAXPAUstbi@@H@Z PROC				; skip

; 519  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 520  :    if (s->io.read) {

  0000c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00013	74 53		 je	 SHORT $LN2@skip

; 521  :       int blen = s->img_buffer_end - s->img_buffer;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00018	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0001b	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00021	2b 82 a8 00 00
	00		 sub	 eax, DWORD PTR [edx+168]
  00027	89 45 fc	 mov	 DWORD PTR _blen$1[ebp], eax

; 522  :       if (blen < n) {

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _blen$1[ebp]
  0002d	3b 4d 0c	 cmp	 ecx, DWORD PTR _n$[ebp]
  00030	7d 36		 jge	 SHORT $LN2@skip

; 523  :          s->img_buffer = s->img_buffer_end;

  00032	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00035	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00038	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0003e	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 524  :          (s->io.skip)(s->io_user_data, n - blen);

  00044	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  00047	2b 55 fc	 sub	 edx, DWORD PTR _blen$1[ebp]
  0004a	8b f4		 mov	 esi, esp
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00050	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00057	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0005a	ff d0		 call	 eax
  0005c	83 c4 08	 add	 esp, 8
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 525  :          return;

  00066	eb 15		 jmp	 SHORT $LN1@skip
$LN2@skip:

; 526  :       }
; 527  :    }
; 528  :    s->img_buffer += n;

  00068	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0006b	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00071	03 55 0c	 add	 edx, DWORD PTR _n$[ebp]
  00074	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00077	89 90 a8 00 00
	00		 mov	 DWORD PTR [eax+168], edx
$LN1@skip:

; 529  : }

  0007d	5e		 pop	 esi
  0007e	83 c4 04	 add	 esp, 4
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?skip@@YAXPAUstbi@@H@Z ENDP				; skip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv86 = -16						; size = 4
_count$1 = -12						; size = 4
_res$2 = -8						; size = 4
_blen$3 = -4						; size = 4
_s$ = 8							; size = 4
_buffer$ = 12						; size = 4
_n$ = 16						; size = 4
?getn@@YAHPAUstbi@@PAEH@Z PROC				; getn

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 533  :    if (s->io.read) {

  00018	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0001f	0f 84 a9 00 00
	00		 je	 $LN2@getn

; 534  :       int blen = s->img_buffer_end - s->img_buffer;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00028	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0002b	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00031	2b 82 a8 00 00
	00		 sub	 eax, DWORD PTR [edx+168]
  00037	89 45 fc	 mov	 DWORD PTR _blen$3[ebp], eax

; 535  :       if (blen < n) {

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _blen$3[ebp]
  0003d	3b 4d 10	 cmp	 ecx, DWORD PTR _n$[ebp]
  00040	0f 8d 88 00 00
	00		 jge	 $LN2@getn

; 536  :          int res, count;
; 537  : 
; 538  :          memcpy(buffer, s->img_buffer, blen);

  00046	8b f4		 mov	 esi, esp
  00048	8b 55 fc	 mov	 edx, DWORD PTR _blen$3[ebp]
  0004b	52		 push	 edx
  0004c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004f	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00055	51		 push	 ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00059	52		 push	 edx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 539  :          
; 540  :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

  0006a	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  0006d	2b 45 fc	 sub	 eax, DWORD PTR _blen$3[ebp]
  00070	8b f4		 mov	 esi, esp
  00072	50		 push	 eax
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00076	03 4d fc	 add	 ecx, DWORD PTR _blen$3[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0007d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00084	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00087	ff d2		 call	 edx
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	89 45 f4	 mov	 DWORD PTR _count$1[ebp], eax

; 541  :          res = (count == (n-blen));

  00096	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00099	2b 45 fc	 sub	 eax, DWORD PTR _blen$3[ebp]
  0009c	39 45 f4	 cmp	 DWORD PTR _count$1[ebp], eax
  0009f	75 09		 jne	 SHORT $LN7@getn
  000a1	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  000a8	eb 07		 jmp	 SHORT $LN8@getn
$LN7@getn:
  000aa	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN8@getn:
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  000b4	89 4d f8	 mov	 DWORD PTR _res$2[ebp], ecx

; 542  :          s->img_buffer = s->img_buffer_end;

  000b7	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000ba	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000bd	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  000c3	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 543  :          return res;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _res$2[ebp]
  000cc	eb 5b		 jmp	 SHORT $LN1@getn
$LN2@getn:

; 544  :       }
; 545  :    }
; 546  : 
; 547  :    if (s->img_buffer+n <= s->img_buffer_end) {

  000ce	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d1	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000d7	03 45 10	 add	 eax, DWORD PTR _n$[ebp]
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000dd	3b 81 ac 00 00
	00		 cmp	 eax, DWORD PTR [ecx+172]
  000e3	77 42		 ja	 SHORT $LN4@getn

; 548  :       memcpy(buffer, s->img_buffer, n);

  000e5	8b f4		 mov	 esi, esp
  000e7	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000ee	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000f4	51		 push	 ecx
  000f5	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	3b f4		 cmp	 esi, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 549  :       s->img_buffer += n;

  00109	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0010c	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00112	03 4d 10	 add	 ecx, DWORD PTR _n$[ebp]
  00115	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00118	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 550  :       return 1;

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	eb 04		 jmp	 SHORT $LN1@getn

; 551  :    } else

  00125	eb 02		 jmp	 SHORT $LN1@getn
$LN4@getn:

; 552  :       return 0;

  00127	33 c0		 xor	 eax, eax
$LN1@getn:

; 553  : }

  00129	5e		 pop	 esi
  0012a	83 c4 10	 add	 esp, 16			; 00000010H
  0012d	3b ec		 cmp	 ebp, esp
  0012f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
?getn@@YAHPAUstbi@@PAEH@Z ENDP				; getn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = -4						; size = 4
_s$ = 8							; size = 4
?get16@@YAHPAUstbi@@@Z PROC				; get16

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 557  :    int z = get8(s);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _z$[ebp], eax

; 558  :    return (z << 8) + get8(s);

  0001b	8b 75 fc	 mov	 esi, DWORD PTR _z$[ebp]
  0001e	c1 e6 08	 shl	 esi, 8
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0002a	83 c4 04	 add	 esp, 4
  0002d	03 c6		 add	 eax, esi

; 559  : }

  0002f	5e		 pop	 esi
  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?get16@@YAHPAUstbi@@@Z ENDP				; get16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = -4						; size = 4
_s$ = 8							; size = 4
?get32@@YAIPAUstbi@@@Z PROC				; get32

; 562  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 563  :    uint32 z = get16(s);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _z$[ebp], eax

; 564  :    return (z << 16) + get16(s);

  0001b	8b 75 fc	 mov	 esi, DWORD PTR _z$[ebp]
  0001e	c1 e6 10	 shl	 esi, 16			; 00000010H
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0002a	83 c4 04	 add	 esp, 4
  0002d	03 c6		 add	 eax, esi

; 565  : }

  0002f	5e		 pop	 esi
  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?get32@@YAIPAUstbi@@@Z ENDP				; get32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = -4						; size = 4
_s$ = 8							; size = 4
?get16le@@YAHPAUstbi@@@Z PROC				; get16le

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 569  :    int z = get8(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _z$[ebp], eax

; 570  :    return z + (get8(s) << 8);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00023	83 c4 04	 add	 esp, 4
  00026	c1 e0 08	 shl	 eax, 8
  00029	03 45 fc	 add	 eax, DWORD PTR _z$[ebp]

; 571  : }

  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?get16le@@YAHPAUstbi@@@Z ENDP				; get16le
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = -4						; size = 4
_s$ = 8							; size = 4
?get32le@@YAIPAUstbi@@@Z PROC				; get32le

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 575  :    uint32 z = get16le(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _z$[ebp], eax

; 576  :    return z + (get16le(s) << 16);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00023	83 c4 04	 add	 esp, 4
  00026	c1 e0 10	 shl	 eax, 16			; 00000010H
  00029	03 45 fc	 add	 eax, DWORD PTR _z$[ebp]

; 577  : }

  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?get32le@@YAIPAUstbi@@@Z ENDP				; get32le
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?compute_y@@YAEHHH@Z PROC				; compute_y

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 592  :    return (uint8) (((r*77) + (g*150) +  (29*b)) >> 8);

  00003	6b 45 08 4d	 imul	 eax, DWORD PTR _r$[ebp], 77
  00007	69 4d 0c 96 00
	00 00		 imul	 ecx, DWORD PTR _g$[ebp], 150
  0000e	03 c1		 add	 eax, ecx
  00010	6b 55 10 1d	 imul	 edx, DWORD PTR _b$[ebp], 29
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 08	 sar	 eax, 8

; 593  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?compute_y@@YAEHHH@Z ENDP				; compute_y
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv94 = -28						; size = 4
tv83 = -24						; size = 4
_dest$1 = -20						; size = 4
_src$2 = -16						; size = 4
_good$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_data$ = 8						; size = 4
_img_n$ = 12						; size = 4
_req_comp$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?convert_format@@YAPAEPAEHHII@Z PROC			; convert_format

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 597  :    int i,j;
; 598  :    unsigned char *good;
; 599  : 
; 600  :    if (req_comp == img_n) return data;

  00021	8b 45 10	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR _img_n$[ebp]
  00027	75 08		 jne	 SHORT $LN43@convert_fo
  00029	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002c	e9 5f 07 00 00	 jmp	 $LN1@convert_fo
$LN43@convert_fo:

; 601  :    assert(req_comp >= 1 && req_comp <= 4);

  00031	83 7d 10 01	 cmp	 DWORD PTR _req_comp$[ebp], 1
  00035	7c 06		 jl	 SHORT $LN59@convert_fo
  00037	83 7d 10 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  0003b	7e 21		 jle	 SHORT $LN60@convert_fo
$LN59@convert_fo:
  0003d	8b f4		 mov	 esi, esp
  0003f	68 59 02 00 00	 push	 601			; 00000259H
  00044	68 00 00 00 00	 push	 OFFSET $SG4294820271
  00049	68 00 00 00 00	 push	 OFFSET $SG4294820270
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN60@convert_fo:

; 602  : 
; 603  :    good = (unsigned char *) malloc(req_comp * x * y);

  0005e	8b 55 10	 mov	 edx, DWORD PTR _req_comp$[ebp]
  00061	0f af 55 14	 imul	 edx, DWORD PTR _x$[ebp]
  00065	0f af 55 18	 imul	 edx, DWORD PTR _y$[ebp]
  00069	8b f4		 mov	 esi, esp
  0006b	52		 push	 edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 f4	 mov	 DWORD PTR _good$[ebp], eax

; 604  :    if (good == NULL) {

  0007f	83 7d f4 00	 cmp	 DWORD PTR _good$[ebp], 0
  00083	75 3f		 jne	 SHORT $LN44@convert_fo

; 605  :       free(data);

  00085	8b f4		 mov	 esi, esp
  00087	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 606  :       return epuc("outofmem", "Out of memory");

  0009b	68 00 00 00 00	 push	 OFFSET $SG4294820269
  000a0	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000a5	83 c4 04	 add	 esp, 4
  000a8	85 c0		 test	 eax, eax
  000aa	74 09		 je	 SHORT $LN61@convert_fo
  000ac	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  000b3	eb 07		 jmp	 SHORT $LN62@convert_fo
$LN61@convert_fo:
  000b5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN62@convert_fo:
  000bc	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  000bf	e9 cc 06 00 00	 jmp	 $LN1@convert_fo
$LN44@convert_fo:

; 607  :    }
; 608  : 
; 609  :    for (j=0; j < (int) y; ++j) {

  000c4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000cb	eb 09		 jmp	 SHORT $LN4@convert_fo
$LN2@convert_fo:
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN4@convert_fo:
  000d6	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000d9	3b 55 18	 cmp	 edx, DWORD PTR _y$[ebp]
  000dc	0f 8d 95 06 00
	00		 jge	 $LN3@convert_fo

; 610  :       unsigned char *src  = data + j * x * img_n   ;

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000e5	0f af 45 14	 imul	 eax, DWORD PTR _x$[ebp]
  000e9	0f af 45 0c	 imul	 eax, DWORD PTR _img_n$[ebp]
  000ed	03 45 08	 add	 eax, DWORD PTR _data$[ebp]
  000f0	89 45 f0	 mov	 DWORD PTR _src$2[ebp], eax

; 611  :       unsigned char *dest = good + j * x * req_comp;

  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  000f6	0f af 4d 14	 imul	 ecx, DWORD PTR _x$[ebp]
  000fa	0f af 4d 10	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  000fe	03 4d f4	 add	 ecx, DWORD PTR _good$[ebp]
  00101	89 4d ec	 mov	 DWORD PTR _dest$1[ebp], ecx

; 612  : 
; 613  :       #define COMBO(a,b)  ((a)*8+(b))
; 614  :       #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 615  :       // convert source image with img_n components to one with req_comp components;
; 616  :       // avoid switch per pixel, so use switch per scanline and massive macros
; 617  :       switch (COMBO(img_n, req_comp)) {

  00104	8b 55 0c	 mov	 edx, DWORD PTR _img_n$[ebp]
  00107	8b 45 10	 mov	 eax, DWORD PTR _req_comp$[ebp]
  0010a	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0010d	89 4d e4	 mov	 DWORD PTR tv94[ebp], ecx
  00110	8b 55 e4	 mov	 edx, DWORD PTR tv94[ebp]
  00113	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00116	89 55 e4	 mov	 DWORD PTR tv94[ebp], edx
  00119	83 7d e4 19	 cmp	 DWORD PTR tv94[ebp], 25	; 00000019H
  0011d	0f 87 2a 06 00
	00		 ja	 $LN57@convert_fo
  00123	8b 45 e4	 mov	 eax, DWORD PTR tv94[ebp]
  00126	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN64@convert_fo[eax]
  0012d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN65@convert_fo[ecx*4]
$LN45@convert_fo:

; 618  :          CASE(1,2) dest[0]=src[0], dest[1]=255; break;

  00134	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  00137	83 ea 01	 sub	 edx, 1
  0013a	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0013d	eb 1b		 jmp	 SHORT $LN9@convert_fo
$LN7@convert_fo:
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00142	83 e8 01	 sub	 eax, 1
  00145	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00148	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  0014b	83 c1 01	 add	 ecx, 1
  0014e	89 4d f0	 mov	 DWORD PTR _src$2[ebp], ecx
  00151	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  00154	83 c2 02	 add	 edx, 2
  00157	89 55 ec	 mov	 DWORD PTR _dest$1[ebp], edx
$LN9@convert_fo:
  0015a	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0015e	7c 2d		 jl	 SHORT $LN8@convert_fo
  00160	b8 01 00 00 00	 mov	 eax, 1
  00165	6b c8 00	 imul	 ecx, eax, 0
  00168	ba 01 00 00 00	 mov	 edx, 1
  0016d	6b c2 00	 imul	 eax, edx, 0
  00170	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  00173	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00176	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00179	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0017c	ba 01 00 00 00	 mov	 edx, 1
  00181	c1 e2 00	 shl	 edx, 0
  00184	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00187	c6 04 10 ff	 mov	 BYTE PTR [eax+edx], 255	; 000000ffH
  0018b	eb b2		 jmp	 SHORT $LN7@convert_fo
$LN8@convert_fo:
  0018d	e9 e0 05 00 00	 jmp	 $LN5@convert_fo
$LN46@convert_fo:

; 619  :          CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;

  00192	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  00195	83 e9 01	 sub	 ecx, 1
  00198	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0019b	eb 1b		 jmp	 SHORT $LN12@convert_fo
$LN10@convert_fo:
  0019d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001a0	83 ea 01	 sub	 edx, 1
  001a3	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  001a6	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  001a9	83 c0 01	 add	 eax, 1
  001ac	89 45 f0	 mov	 DWORD PTR _src$2[ebp], eax
  001af	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  001b2	83 c1 03	 add	 ecx, 3
  001b5	89 4d ec	 mov	 DWORD PTR _dest$1[ebp], ecx
$LN12@convert_fo:
  001b8	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  001bc	7c 54		 jl	 SHORT $LN11@convert_fo
  001be	ba 01 00 00 00	 mov	 edx, 1
  001c3	6b c2 00	 imul	 eax, edx, 0
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	d1 e1		 shl	 ecx, 1
  001cd	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  001d0	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  001d3	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  001d6	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001d9	b9 01 00 00 00	 mov	 ecx, 1
  001de	d1 e1		 shl	 ecx, 1
  001e0	ba 01 00 00 00	 mov	 edx, 1
  001e5	c1 e2 00	 shl	 edx, 0
  001e8	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  001eb	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  001ee	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  001f1	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  001f4	ba 01 00 00 00	 mov	 edx, 1
  001f9	c1 e2 00	 shl	 edx, 0
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	6b c8 00	 imul	 ecx, eax, 0
  00204	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00207	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  0020a	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0020d	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00210	eb 8b		 jmp	 SHORT $LN10@convert_fo
$LN11@convert_fo:
  00212	e9 5b 05 00 00	 jmp	 $LN5@convert_fo
$LN47@convert_fo:

; 620  :          CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;

  00217	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  0021a	83 e8 01	 sub	 eax, 1
  0021d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00220	eb 1b		 jmp	 SHORT $LN15@convert_fo
$LN13@convert_fo:
  00222	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00225	83 e9 01	 sub	 ecx, 1
  00228	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0022b	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  0022e	83 c2 01	 add	 edx, 1
  00231	89 55 f0	 mov	 DWORD PTR _src$2[ebp], edx
  00234	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00237	83 c0 04	 add	 eax, 4
  0023a	89 45 ec	 mov	 DWORD PTR _dest$1[ebp], eax
$LN15@convert_fo:
  0023d	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00241	7c 66		 jl	 SHORT $LN14@convert_fo
  00243	b9 01 00 00 00	 mov	 ecx, 1
  00248	6b d1 00	 imul	 edx, ecx, 0
  0024b	b8 01 00 00 00	 mov	 eax, 1
  00250	d1 e0		 shl	 eax, 1
  00252	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00255	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00258	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0025b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0025e	b8 01 00 00 00	 mov	 eax, 1
  00263	d1 e0		 shl	 eax, 1
  00265	b9 01 00 00 00	 mov	 ecx, 1
  0026a	c1 e1 00	 shl	 ecx, 0
  0026d	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  00270	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  00273	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00276	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00279	b9 01 00 00 00	 mov	 ecx, 1
  0027e	c1 e1 00	 shl	 ecx, 0
  00281	ba 01 00 00 00	 mov	 edx, 1
  00286	6b c2 00	 imul	 eax, edx, 0
  00289	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  0028c	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  0028f	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00292	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	6b c2 03	 imul	 eax, edx, 3
  0029d	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  002a0	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH
  002a4	e9 79 ff ff ff	 jmp	 $LN13@convert_fo
$LN14@convert_fo:
  002a9	e9 c4 04 00 00	 jmp	 $LN5@convert_fo
$LN48@convert_fo:

; 621  :          CASE(2,1) dest[0]=src[0]; break;

  002ae	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  002b1	83 ea 01	 sub	 edx, 1
  002b4	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  002b7	eb 1b		 jmp	 SHORT $LN18@convert_fo
$LN16@convert_fo:
  002b9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002bc	83 e8 01	 sub	 eax, 1
  002bf	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  002c2	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  002c5	83 c1 02	 add	 ecx, 2
  002c8	89 4d f0	 mov	 DWORD PTR _src$2[ebp], ecx
  002cb	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  002ce	83 c2 01	 add	 edx, 1
  002d1	89 55 ec	 mov	 DWORD PTR _dest$1[ebp], edx
$LN18@convert_fo:
  002d4	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  002d8	7c 1e		 jl	 SHORT $LN17@convert_fo
  002da	b8 01 00 00 00	 mov	 eax, 1
  002df	6b c8 00	 imul	 ecx, eax, 0
  002e2	ba 01 00 00 00	 mov	 edx, 1
  002e7	6b c2 00	 imul	 eax, edx, 0
  002ea	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  002ed	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  002f0	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  002f3	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  002f6	eb c1		 jmp	 SHORT $LN16@convert_fo
$LN17@convert_fo:
  002f8	e9 75 04 00 00	 jmp	 $LN5@convert_fo
$LN49@convert_fo:

; 622  :          CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;

  002fd	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  00300	83 ea 01	 sub	 edx, 1
  00303	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00306	eb 1b		 jmp	 SHORT $LN21@convert_fo
$LN19@convert_fo:
  00308	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0030b	83 e8 01	 sub	 eax, 1
  0030e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00311	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  00314	83 c1 02	 add	 ecx, 2
  00317	89 4d f0	 mov	 DWORD PTR _src$2[ebp], ecx
  0031a	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  0031d	83 c2 03	 add	 edx, 3
  00320	89 55 ec	 mov	 DWORD PTR _dest$1[ebp], edx
$LN21@convert_fo:
  00323	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00327	7c 54		 jl	 SHORT $LN20@convert_fo
  00329	b8 01 00 00 00	 mov	 eax, 1
  0032e	6b c8 00	 imul	 ecx, eax, 0
  00331	ba 01 00 00 00	 mov	 edx, 1
  00336	d1 e2		 shl	 edx, 1
  00338	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  0033b	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  0033e	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00341	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00344	ba 01 00 00 00	 mov	 edx, 1
  00349	d1 e2		 shl	 edx, 1
  0034b	b8 01 00 00 00	 mov	 eax, 1
  00350	c1 e0 00	 shl	 eax, 0
  00353	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00356	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  00359	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0035c	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0035f	b8 01 00 00 00	 mov	 eax, 1
  00364	c1 e0 00	 shl	 eax, 0
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	6b d1 00	 imul	 edx, ecx, 0
  0036f	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00372	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  00375	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00378	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0037b	eb 8b		 jmp	 SHORT $LN19@convert_fo
$LN20@convert_fo:
  0037d	e9 f0 03 00 00	 jmp	 $LN5@convert_fo
$LN50@convert_fo:

; 623  :          CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;

  00382	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  00385	83 e9 01	 sub	 ecx, 1
  00388	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0038b	eb 1b		 jmp	 SHORT $LN24@convert_fo
$LN22@convert_fo:
  0038d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00390	83 ea 01	 sub	 edx, 1
  00393	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00396	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  00399	83 c0 02	 add	 eax, 2
  0039c	89 45 f0	 mov	 DWORD PTR _src$2[ebp], eax
  0039f	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  003a2	83 c1 04	 add	 ecx, 4
  003a5	89 4d ec	 mov	 DWORD PTR _dest$1[ebp], ecx
$LN24@convert_fo:
  003a8	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  003ac	7c 73		 jl	 SHORT $LN23@convert_fo
  003ae	ba 01 00 00 00	 mov	 edx, 1
  003b3	6b c2 00	 imul	 eax, edx, 0
  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	d1 e1		 shl	 ecx, 1
  003bd	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  003c0	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  003c3	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  003c6	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  003c9	b9 01 00 00 00	 mov	 ecx, 1
  003ce	d1 e1		 shl	 ecx, 1
  003d0	ba 01 00 00 00	 mov	 edx, 1
  003d5	c1 e2 00	 shl	 edx, 0
  003d8	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  003db	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  003de	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  003e1	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  003e4	ba 01 00 00 00	 mov	 edx, 1
  003e9	c1 e2 00	 shl	 edx, 0
  003ec	b8 01 00 00 00	 mov	 eax, 1
  003f1	6b c8 00	 imul	 ecx, eax, 0
  003f4	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  003f7	8b 75 ec	 mov	 esi, DWORD PTR _dest$1[ebp]
  003fa	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  003fd	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00400	b8 01 00 00 00	 mov	 eax, 1
  00405	c1 e0 00	 shl	 eax, 0
  00408	b9 01 00 00 00	 mov	 ecx, 1
  0040d	6b d1 03	 imul	 edx, ecx, 3
  00410	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00413	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00416	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00419	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0041c	e9 6c ff ff ff	 jmp	 $LN22@convert_fo
$LN23@convert_fo:
  00421	e9 4c 03 00 00	 jmp	 $LN5@convert_fo
$LN51@convert_fo:

; 624  :          CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;

  00426	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  00429	83 e9 01	 sub	 ecx, 1
  0042c	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  0042f	eb 1b		 jmp	 SHORT $LN27@convert_fo
$LN25@convert_fo:
  00431	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00434	83 ea 01	 sub	 edx, 1
  00437	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0043a	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  0043d	83 c0 03	 add	 eax, 3
  00440	89 45 f0	 mov	 DWORD PTR _src$2[ebp], eax
  00443	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00446	83 c1 04	 add	 ecx, 4
  00449	89 4d ec	 mov	 DWORD PTR _dest$1[ebp], ecx
$LN27@convert_fo:
  0044c	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00450	7c 66		 jl	 SHORT $LN26@convert_fo
  00452	ba 01 00 00 00	 mov	 edx, 1
  00457	6b c2 00	 imul	 eax, edx, 0
  0045a	b9 01 00 00 00	 mov	 ecx, 1
  0045f	6b d1 00	 imul	 edx, ecx, 0
  00462	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00465	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00468	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0046b	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0046e	b9 01 00 00 00	 mov	 ecx, 1
  00473	c1 e1 00	 shl	 ecx, 0
  00476	ba 01 00 00 00	 mov	 edx, 1
  0047b	c1 e2 00	 shl	 edx, 0
  0047e	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00481	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00484	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00487	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0048a	ba 01 00 00 00	 mov	 edx, 1
  0048f	d1 e2		 shl	 edx, 1
  00491	b8 01 00 00 00	 mov	 eax, 1
  00496	d1 e0		 shl	 eax, 1
  00498	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  0049b	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  0049e	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  004a1	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  004a4	b8 01 00 00 00	 mov	 eax, 1
  004a9	6b c8 03	 imul	 ecx, eax, 3
  004ac	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  004af	c6 04 0a ff	 mov	 BYTE PTR [edx+ecx], 255	; 000000ffH
  004b3	e9 79 ff ff ff	 jmp	 $LN25@convert_fo
$LN26@convert_fo:
  004b8	e9 b5 02 00 00	 jmp	 $LN5@convert_fo
$LN52@convert_fo:

; 625  :          CASE(3,1) dest[0]=compute_y(src[0],src[1],src[2]); break;

  004bd	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  004c0	83 e8 01	 sub	 eax, 1
  004c3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  004c6	eb 1b		 jmp	 SHORT $LN30@convert_fo
$LN28@convert_fo:
  004c8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  004cb	83 e9 01	 sub	 ecx, 1
  004ce	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  004d1	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  004d4	83 c2 03	 add	 edx, 3
  004d7	89 55 f0	 mov	 DWORD PTR _src$2[ebp], edx
  004da	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  004dd	83 c0 01	 add	 eax, 1
  004e0	89 45 ec	 mov	 DWORD PTR _dest$1[ebp], eax
$LN30@convert_fo:
  004e3	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  004e7	7c 47		 jl	 SHORT $LN29@convert_fo
  004e9	b9 01 00 00 00	 mov	 ecx, 1
  004ee	d1 e1		 shl	 ecx, 1
  004f0	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  004f3	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  004f7	50		 push	 eax
  004f8	b9 01 00 00 00	 mov	 ecx, 1
  004fd	c1 e1 00	 shl	 ecx, 0
  00500	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  00503	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00507	50		 push	 eax
  00508	b9 01 00 00 00	 mov	 ecx, 1
  0050d	6b d1 00	 imul	 edx, ecx, 0
  00510	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  00513	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00517	51		 push	 ecx
  00518	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  0051d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00520	ba 01 00 00 00	 mov	 edx, 1
  00525	6b ca 00	 imul	 ecx, edx, 0
  00528	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  0052b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0052e	eb 98		 jmp	 SHORT $LN28@convert_fo
$LN29@convert_fo:
  00530	e9 3d 02 00 00	 jmp	 $LN5@convert_fo
$LN53@convert_fo:

; 626  :          CASE(3,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = 255; break;

  00535	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  00538	83 e8 01	 sub	 eax, 1
  0053b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0053e	eb 1b		 jmp	 SHORT $LN33@convert_fo
$LN31@convert_fo:
  00540	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00543	83 e9 01	 sub	 ecx, 1
  00546	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00549	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  0054c	83 c2 03	 add	 edx, 3
  0054f	89 55 f0	 mov	 DWORD PTR _src$2[ebp], edx
  00552	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00555	83 c0 02	 add	 eax, 2
  00558	89 45 ec	 mov	 DWORD PTR _dest$1[ebp], eax
$LN33@convert_fo:
  0055b	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0055f	7c 56		 jl	 SHORT $LN32@convert_fo
  00561	b9 01 00 00 00	 mov	 ecx, 1
  00566	d1 e1		 shl	 ecx, 1
  00568	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  0056b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0056f	50		 push	 eax
  00570	b9 01 00 00 00	 mov	 ecx, 1
  00575	c1 e1 00	 shl	 ecx, 0
  00578	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  0057b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0057f	50		 push	 eax
  00580	b9 01 00 00 00	 mov	 ecx, 1
  00585	6b d1 00	 imul	 edx, ecx, 0
  00588	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  0058b	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0058f	51		 push	 ecx
  00590	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  00595	83 c4 0c	 add	 esp, 12			; 0000000cH
  00598	ba 01 00 00 00	 mov	 edx, 1
  0059d	6b ca 00	 imul	 ecx, edx, 0
  005a0	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  005a3	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005a6	b8 01 00 00 00	 mov	 eax, 1
  005ab	c1 e0 00	 shl	 eax, 0
  005ae	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  005b1	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH
  005b5	eb 89		 jmp	 SHORT $LN31@convert_fo
$LN32@convert_fo:
  005b7	e9 b6 01 00 00	 jmp	 $LN5@convert_fo
$LN54@convert_fo:

; 627  :          CASE(4,1) dest[0]=compute_y(src[0],src[1],src[2]); break;

  005bc	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  005bf	83 ea 01	 sub	 edx, 1
  005c2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  005c5	eb 1b		 jmp	 SHORT $LN36@convert_fo
$LN34@convert_fo:
  005c7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  005ca	83 e8 01	 sub	 eax, 1
  005cd	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  005d0	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  005d3	83 c1 04	 add	 ecx, 4
  005d6	89 4d f0	 mov	 DWORD PTR _src$2[ebp], ecx
  005d9	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  005dc	83 c2 01	 add	 edx, 1
  005df	89 55 ec	 mov	 DWORD PTR _dest$1[ebp], edx
$LN36@convert_fo:
  005e2	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  005e6	7c 47		 jl	 SHORT $LN35@convert_fo
  005e8	b8 01 00 00 00	 mov	 eax, 1
  005ed	d1 e0		 shl	 eax, 1
  005ef	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  005f2	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005f6	52		 push	 edx
  005f7	b8 01 00 00 00	 mov	 eax, 1
  005fc	c1 e0 00	 shl	 eax, 0
  005ff	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  00602	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00606	52		 push	 edx
  00607	b8 01 00 00 00	 mov	 eax, 1
  0060c	6b c8 00	 imul	 ecx, eax, 0
  0060f	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  00612	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  0061c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061f	b9 01 00 00 00	 mov	 ecx, 1
  00624	6b d1 00	 imul	 edx, ecx, 0
  00627	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  0062a	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0062d	eb 98		 jmp	 SHORT $LN34@convert_fo
$LN35@convert_fo:
  0062f	e9 3e 01 00 00	 jmp	 $LN5@convert_fo
$LN55@convert_fo:

; 628  :          CASE(4,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;

  00634	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  00637	83 ea 01	 sub	 edx, 1
  0063a	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0063d	eb 1b		 jmp	 SHORT $LN39@convert_fo
$LN37@convert_fo:
  0063f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00642	83 e8 01	 sub	 eax, 1
  00645	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00648	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  0064b	83 c1 04	 add	 ecx, 4
  0064e	89 4d f0	 mov	 DWORD PTR _src$2[ebp], ecx
  00651	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  00654	83 c2 02	 add	 edx, 2
  00657	89 55 ec	 mov	 DWORD PTR _dest$1[ebp], edx
$LN39@convert_fo:
  0065a	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0065e	7c 66		 jl	 SHORT $LN38@convert_fo
  00660	b8 01 00 00 00	 mov	 eax, 1
  00665	d1 e0		 shl	 eax, 1
  00667	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  0066a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0066e	52		 push	 edx
  0066f	b8 01 00 00 00	 mov	 eax, 1
  00674	c1 e0 00	 shl	 eax, 0
  00677	8b 4d f0	 mov	 ecx, DWORD PTR _src$2[ebp]
  0067a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0067e	52		 push	 edx
  0067f	b8 01 00 00 00	 mov	 eax, 1
  00684	6b c8 00	 imul	 ecx, eax, 0
  00687	8b 55 f0	 mov	 edx, DWORD PTR _src$2[ebp]
  0068a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0068e	50		 push	 eax
  0068f	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  00694	83 c4 0c	 add	 esp, 12			; 0000000cH
  00697	b9 01 00 00 00	 mov	 ecx, 1
  0069c	6b d1 00	 imul	 edx, ecx, 0
  0069f	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  006a2	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  006a5	ba 01 00 00 00	 mov	 edx, 1
  006aa	6b c2 03	 imul	 eax, edx, 3
  006ad	b9 01 00 00 00	 mov	 ecx, 1
  006b2	c1 e1 00	 shl	 ecx, 0
  006b5	8b 55 ec	 mov	 edx, DWORD PTR _dest$1[ebp]
  006b8	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  006bb	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  006be	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  006c1	e9 79 ff ff ff	 jmp	 $LN37@convert_fo
$LN38@convert_fo:
  006c6	e9 a7 00 00 00	 jmp	 $LN5@convert_fo
$LN56@convert_fo:

; 629  :          CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;

  006cb	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  006ce	83 e9 01	 sub	 ecx, 1
  006d1	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  006d4	eb 1b		 jmp	 SHORT $LN42@convert_fo
$LN40@convert_fo:
  006d6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  006d9	83 ea 01	 sub	 edx, 1
  006dc	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  006df	8b 45 f0	 mov	 eax, DWORD PTR _src$2[ebp]
  006e2	83 c0 04	 add	 eax, 4
  006e5	89 45 f0	 mov	 DWORD PTR _src$2[ebp], eax
  006e8	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  006eb	83 c1 03	 add	 ecx, 3
  006ee	89 4d ec	 mov	 DWORD PTR _dest$1[ebp], ecx
$LN42@convert_fo:
  006f1	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  006f5	7c 54		 jl	 SHORT $LN41@convert_fo
  006f7	ba 01 00 00 00	 mov	 edx, 1
  006fc	6b c2 00	 imul	 eax, edx, 0
  006ff	b9 01 00 00 00	 mov	 ecx, 1
  00704	6b d1 00	 imul	 edx, ecx, 0
  00707	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  0070a	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  0070d	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00710	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00713	b9 01 00 00 00	 mov	 ecx, 1
  00718	c1 e1 00	 shl	 ecx, 0
  0071b	ba 01 00 00 00	 mov	 edx, 1
  00720	c1 e2 00	 shl	 edx, 0
  00723	8b 45 ec	 mov	 eax, DWORD PTR _dest$1[ebp]
  00726	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00729	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  0072c	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0072f	ba 01 00 00 00	 mov	 edx, 1
  00734	d1 e2		 shl	 edx, 1
  00736	b8 01 00 00 00	 mov	 eax, 1
  0073b	d1 e0		 shl	 eax, 1
  0073d	8b 4d ec	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00740	8b 75 f0	 mov	 esi, DWORD PTR _src$2[ebp]
  00743	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00746	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00749	eb 8b		 jmp	 SHORT $LN40@convert_fo
$LN41@convert_fo:
  0074b	eb 25		 jmp	 SHORT $LN5@convert_fo
$LN57@convert_fo:

; 630  :          default: assert(0);

  0074d	33 c0		 xor	 eax, eax
  0074f	75 21		 jne	 SHORT $LN5@convert_fo
  00751	8b f4		 mov	 esi, esp
  00753	68 76 02 00 00	 push	 630			; 00000276H
  00758	68 00 00 00 00	 push	 OFFSET $SG4294820268
  0075d	68 00 00 00 00	 push	 OFFSET $SG4294820267
  00762	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00768	83 c4 0c	 add	 esp, 12			; 0000000cH
  0076b	3b f4		 cmp	 esi, esp
  0076d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@convert_fo:

; 631  :       }
; 632  :       #undef CASE
; 633  :    }

  00772	e9 56 f9 ff ff	 jmp	 $LN2@convert_fo
$LN3@convert_fo:

; 634  : 
; 635  :    free(data);

  00777	8b f4		 mov	 esi, esp
  00779	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0077c	52		 push	 edx
  0077d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00783	83 c4 04	 add	 esp, 4
  00786	3b f4		 cmp	 esi, esp
  00788	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 636  :    return good;

  0078d	8b 45 f4	 mov	 eax, DWORD PTR _good$[ebp]
$LN1@convert_fo:

; 637  : }

  00790	5e		 pop	 esi
  00791	83 c4 1c	 add	 esp, 28			; 0000001cH
  00794	3b ec		 cmp	 ebp, esp
  00796	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0079b	8b e5		 mov	 esp, ebp
  0079d	5d		 pop	 ebp
  0079e	c3		 ret	 0
  0079f	90		 npad	 1
$LN65@convert_fo:
  007a0	00 00 00 00	 DD	 $LN45@convert_fo
  007a4	00 00 00 00	 DD	 $LN46@convert_fo
  007a8	00 00 00 00	 DD	 $LN47@convert_fo
  007ac	00 00 00 00	 DD	 $LN48@convert_fo
  007b0	00 00 00 00	 DD	 $LN49@convert_fo
  007b4	00 00 00 00	 DD	 $LN50@convert_fo
  007b8	00 00 00 00	 DD	 $LN52@convert_fo
  007bc	00 00 00 00	 DD	 $LN53@convert_fo
  007c0	00 00 00 00	 DD	 $LN51@convert_fo
  007c4	00 00 00 00	 DD	 $LN54@convert_fo
  007c8	00 00 00 00	 DD	 $LN55@convert_fo
  007cc	00 00 00 00	 DD	 $LN56@convert_fo
  007d0	00 00 00 00	 DD	 $LN57@convert_fo
$LN64@convert_fo:
  007d4	00		 DB	 0
  007d5	01		 DB	 1
  007d6	02		 DB	 2
  007d7	0c		 DB	 12			; 0000000cH
  007d8	0c		 DB	 12			; 0000000cH
  007d9	0c		 DB	 12			; 0000000cH
  007da	0c		 DB	 12			; 0000000cH
  007db	03		 DB	 3
  007dc	0c		 DB	 12			; 0000000cH
  007dd	04		 DB	 4
  007de	05		 DB	 5
  007df	0c		 DB	 12			; 0000000cH
  007e0	0c		 DB	 12			; 0000000cH
  007e1	0c		 DB	 12			; 0000000cH
  007e2	0c		 DB	 12			; 0000000cH
  007e3	06		 DB	 6
  007e4	07		 DB	 7
  007e5	0c		 DB	 12			; 0000000cH
  007e6	08		 DB	 8
  007e7	0c		 DB	 12			; 0000000cH
  007e8	0c		 DB	 12			; 0000000cH
  007e9	0c		 DB	 12			; 0000000cH
  007ea	0c		 DB	 12			; 0000000cH
  007eb	09		 DB	 9
  007ec	0a		 DB	 10			; 0000000aH
  007ed	0b		 DB	 11			; 0000000bH
?convert_format@@YAPAEPAEHHII@Z ENDP			; convert_format
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv175 = -28						; size = 4
tv174 = -24						; size = 4
tv77 = -20						; size = 4
_output$ = -16						; size = 4
_n$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_data$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?ldr_to_hdr@@YAPAMPAEHHH@Z PROC				; ldr_to_hdr

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 642  :    int i,k,n;
; 643  :    float *output = (float *) malloc(x * y * comp * sizeof(float));

  00021	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00024	0f af 45 10	 imul	 eax, DWORD PTR _y$[ebp]
  00028	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  0002c	c1 e0 02	 shl	 eax, 2
  0002f	8b f4		 mov	 esi, esp
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	89 45 f0	 mov	 DWORD PTR _output$[ebp], eax

; 644  :    if (output == NULL) { free(data); return epf("outofmem", "Out of memory"); }

  00045	83 7d f0 00	 cmp	 DWORD PTR _output$[ebp], 0
  00049	75 3f		 jne	 SHORT $LN8@ldr_to_hdr
  0004b	8b f4		 mov	 esi, esp
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00050	51		 push	 ecx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00057	83 c4 04	 add	 esp, 4
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	68 00 00 00 00	 push	 OFFSET $SG4294820266
  00066	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 09		 je	 SHORT $LN13@ldr_to_hdr
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00079	eb 07		 jmp	 SHORT $LN14@ldr_to_hdr
$LN13@ldr_to_hdr:
  0007b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN14@ldr_to_hdr:
  00082	8b 45 ec	 mov	 eax, DWORD PTR tv77[ebp]
  00085	e9 22 01 00 00	 jmp	 $LN1@ldr_to_hdr
$LN8@ldr_to_hdr:

; 645  :    // compute number of non-alpha components
; 646  :    if (comp & 1) n = comp; else n = comp-1;

  0008a	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0008d	83 e2 01	 and	 edx, 1
  00090	74 08		 je	 SHORT $LN9@ldr_to_hdr
  00092	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00095	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00098	eb 09		 jmp	 SHORT $LN10@ldr_to_hdr
$LN9@ldr_to_hdr:
  0009a	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0009d	83 e9 01	 sub	 ecx, 1
  000a0	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx
$LN10@ldr_to_hdr:

; 647  :    for (i=0; i < x*y; ++i) {

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN4@ldr_to_hdr
$LN2@ldr_to_hdr:
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000af	83 c2 01	 add	 edx, 1
  000b2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN4@ldr_to_hdr:
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  000b8	0f af 45 10	 imul	 eax, DWORD PTR _y$[ebp]
  000bc	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000bf	0f 8d ce 00 00
	00		 jge	 $LN3@ldr_to_hdr

; 648  :       for (k=0; k < n; ++k) {

  000c5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000cc	eb 09		 jmp	 SHORT $LN7@ldr_to_hdr
$LN5@ldr_to_hdr:
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000d1	83 c1 01	 add	 ecx, 1
  000d4	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$LN7@ldr_to_hdr:
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000da	3b 55 f4	 cmp	 edx, DWORD PTR _n$[ebp]
  000dd	7d 78		 jge	 SHORT $LN6@ldr_to_hdr

; 649  :          output[i*comp + k] = (float) pow(data[i*comp+k]/255.0f, l2h_gamma) * l2h_scale;

  000df	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR ?l2h_gamma@@3MA
  000e7	8b f4		 mov	 esi, esp
  000e9	83 ec 08	 sub	 esp, 8
  000ec	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  000f8	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000fe	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00102	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00106	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  0010e	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00112	83 ec 08	 sub	 esp, 8
  00115	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__pow
  00120	83 c4 10	 add	 esp, 16			; 00000010H
  00123	3b f4		 cmp	 esi, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	d9 5d e8	 fstp	 DWORD PTR tv174[ebp]
  0012d	d9 45 e8	 fld	 DWORD PTR tv174[ebp]
  00130	d9 5d e4	 fstp	 DWORD PTR tv175[ebp]
  00133	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR tv175[ebp]
  00138	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?l2h_scale@@3MA
  00140	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00143	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00147	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  0014a	8b 4d f0	 mov	 ecx, DWORD PTR _output$[ebp]
  0014d	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 650  :       }

  00152	e9 77 ff ff ff	 jmp	 $LN5@ldr_to_hdr
$LN6@ldr_to_hdr:

; 651  :       if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;

  00157	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  0015a	3b 55 14	 cmp	 edx, DWORD PTR _comp$[ebp]
  0015d	7d 2f		 jge	 SHORT $LN11@ldr_to_hdr
  0015f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00162	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00166	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0016c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00170	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00174	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  0017c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0017f	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00183	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  00186	8b 4d f0	 mov	 ecx, DWORD PTR _output$[ebp]
  00189	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0
$LN11@ldr_to_hdr:

; 652  :    }

  0018e	e9 19 ff ff ff	 jmp	 $LN2@ldr_to_hdr
$LN3@ldr_to_hdr:

; 653  :    free(data);

  00193	8b f4		 mov	 esi, esp
  00195	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00198	52		 push	 edx
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0019f	83 c4 04	 add	 esp, 4
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 654  :    return output;

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _output$[ebp]
$LN1@ldr_to_hdr:

; 655  : }

  001ac	5e		 pop	 esi
  001ad	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b0	3b ec		 cmp	 ebp, esp
  001b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
?ldr_to_hdr@@YAPAMPAEHHH@Z ENDP				; ldr_to_hdr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv181 = -36						; size = 4
tv180 = -32						; size = 4
tv76 = -28						; size = 4
_z$1 = -24						; size = 4
_z$2 = -20						; size = 4
_output$ = -16						; size = 4
_n$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_data$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?hdr_to_ldr@@YAPAEPAMHHH@Z PROC				; hdr_to_ldr

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00012	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00015	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00018	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00021	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00024	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 660  :    int i,k,n;
; 661  :    stbi_uc *output = (stbi_uc *) malloc(x * y * comp);

  00027	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0002a	0f af 45 10	 imul	 eax, DWORD PTR _y$[ebp]
  0002e	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00032	8b f4		 mov	 esi, esp
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	89 45 f0	 mov	 DWORD PTR _output$[ebp], eax

; 662  :    if (output == NULL) { free(data); return epuc("outofmem", "Out of memory"); }

  00048	83 7d f0 00	 cmp	 DWORD PTR _output$[ebp], 0
  0004c	75 3f		 jne	 SHORT $LN8@hdr_to_ldr
  0004e	8b f4		 mov	 esi, esp
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00053	51		 push	 ecx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005a	83 c4 04	 add	 esp, 4
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	68 00 00 00 00	 push	 OFFSET $SG4294820265
  00069	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006e	83 c4 04	 add	 esp, 4
  00071	85 c0		 test	 eax, eax
  00073	74 09		 je	 SHORT $LN17@hdr_to_ldr
  00075	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  0007c	eb 07		 jmp	 SHORT $LN18@hdr_to_ldr
$LN17@hdr_to_ldr:
  0007e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN18@hdr_to_ldr:
  00085	8b 45 e4	 mov	 eax, DWORD PTR tv76[ebp]
  00088	e9 ac 01 00 00	 jmp	 $LN1@hdr_to_ldr
$LN8@hdr_to_ldr:

; 663  :    // compute number of non-alpha components
; 664  :    if (comp & 1) n = comp; else n = comp-1;

  0008d	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00090	83 e2 01	 and	 edx, 1
  00093	74 08		 je	 SHORT $LN9@hdr_to_ldr
  00095	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00098	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  0009b	eb 09		 jmp	 SHORT $LN10@hdr_to_ldr
$LN9@hdr_to_ldr:
  0009d	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  000a0	83 e9 01	 sub	 ecx, 1
  000a3	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx
$LN10@hdr_to_ldr:

; 665  :    for (i=0; i < x*y; ++i) {

  000a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ad	eb 09		 jmp	 SHORT $LN4@hdr_to_ldr
$LN2@hdr_to_ldr:
  000af	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b2	83 c2 01	 add	 edx, 1
  000b5	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN4@hdr_to_ldr:
  000b8	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  000bb	0f af 45 10	 imul	 eax, DWORD PTR _y$[ebp]
  000bf	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000c2	0f 8d 58 01 00
	00		 jge	 $LN3@hdr_to_ldr

; 666  :       for (k=0; k < n; ++k) {

  000c8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000cf	eb 09		 jmp	 SHORT $LN7@hdr_to_ldr
$LN5@hdr_to_ldr:
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000d4	83 c1 01	 add	 ecx, 1
  000d7	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$LN7@hdr_to_ldr:
  000da	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000dd	3b 55 f4	 cmp	 edx, DWORD PTR _n$[ebp]
  000e0	0f 8d bb 00 00
	00		 jge	 $LN6@hdr_to_ldr

; 667  :          float z = (float) pow(data[i*comp+k]*h2l_scale_i, h2l_gamma_i) * 255 + 0.5f;

  000e6	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR ?h2l_gamma_i@@3MA
  000ee	8b f4		 mov	 esi, esp
  000f0	83 ec 08	 sub	 esp, 8
  000f3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  000ff	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00105	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [ecx+eax*4]
  0010a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?h2l_scale_i@@3MA
  00112	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00116	83 ec 08	 sub	 esp, 8
  00119	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__pow
  00124	83 c4 10	 add	 esp, 16			; 00000010H
  00127	3b f4		 cmp	 esi, esp
  00129	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012e	d9 5d e0	 fstp	 DWORD PTR tv180[ebp]
  00131	d9 45 e0	 fld	 DWORD PTR tv180[ebp]
  00134	d9 5d dc	 fstp	 DWORD PTR tv181[ebp]
  00137	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv181[ebp]
  0013c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00144	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0014c	f3 0f 11 45 ec	 movss	 DWORD PTR _z$2[ebp], xmm0

; 668  :          if (z < 0) z = 0;

  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00159	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _z$2[ebp]
  0015d	76 0d		 jbe	 SHORT $LN11@hdr_to_ldr
  0015f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00167	f3 0f 11 45 ec	 movss	 DWORD PTR _z$2[ebp], xmm0
$LN11@hdr_to_ldr:

; 669  :          if (z > 255) z = 255;

  0016c	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _z$2[ebp]
  00171	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00178	76 0d		 jbe	 SHORT $LN12@hdr_to_ldr
  0017a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00182	f3 0f 11 45 ec	 movss	 DWORD PTR _z$2[ebp], xmm0
$LN12@hdr_to_ldr:

; 670  :          output[i*comp + k] = (uint8) float2int(z);

  00187	f3 0f 2c 55 ec	 cvttss2si edx, DWORD PTR _z$2[ebp]
  0018c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0018f	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00193	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  00196	8b 4d f0	 mov	 ecx, DWORD PTR _output$[ebp]
  00199	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 671  :       }

  0019c	e9 30 ff ff ff	 jmp	 $LN5@hdr_to_ldr
$LN6@hdr_to_ldr:

; 672  :       if (k < comp) {

  001a1	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  001a4	3b 55 14	 cmp	 edx, DWORD PTR _comp$[ebp]
  001a7	7d 72		 jge	 SHORT $LN13@hdr_to_ldr

; 673  :          float z = data[i*comp+k] * 255 + 0.5f;

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001ac	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  001b0	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  001b6	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [ecx+eax*4]
  001bb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001c3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001cb	f3 0f 11 45 e8	 movss	 DWORD PTR _z$1[ebp], xmm0

; 674  :          if (z < 0) z = 0;

  001d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001d8	0f 2f 45 e8	 comiss	 xmm0, DWORD PTR _z$1[ebp]
  001dc	76 0d		 jbe	 SHORT $LN14@hdr_to_ldr
  001de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001e6	f3 0f 11 45 e8	 movss	 DWORD PTR _z$1[ebp], xmm0
$LN14@hdr_to_ldr:

; 675  :          if (z > 255) z = 255;

  001eb	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _z$1[ebp]
  001f0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  001f7	76 0d		 jbe	 SHORT $LN15@hdr_to_ldr
  001f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00201	f3 0f 11 45 e8	 movss	 DWORD PTR _z$1[ebp], xmm0
$LN15@hdr_to_ldr:

; 676  :          output[i*comp + k] = (uint8) float2int(z);

  00206	f3 0f 2c 55 e8	 cvttss2si edx, DWORD PTR _z$1[ebp]
  0020b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0020e	0f af 45 14	 imul	 eax, DWORD PTR _comp$[ebp]
  00212	03 45 f8	 add	 eax, DWORD PTR _k$[ebp]
  00215	8b 4d f0	 mov	 ecx, DWORD PTR _output$[ebp]
  00218	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
$LN13@hdr_to_ldr:

; 677  :       }
; 678  :    }

  0021b	e9 8f fe ff ff	 jmp	 $LN2@hdr_to_ldr
$LN3@hdr_to_ldr:

; 679  :    free(data);

  00220	8b f4		 mov	 esi, esp
  00222	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00225	52		 push	 edx
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0022c	83 c4 04	 add	 esp, 4
  0022f	3b f4		 cmp	 esi, esp
  00231	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 680  :    return output;

  00236	8b 45 f0	 mov	 eax, DWORD PTR _output$[ebp]
$LN1@hdr_to_ldr:

; 681  : }

  00239	5e		 pop	 esi
  0023a	83 c4 24	 add	 esp, 36			; 00000024H
  0023d	3b ec		 cmp	 ebp, esp
  0023f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
?hdr_to_ldr@@YAPAEPAMHHH@Z ENDP				; hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_m$1 = -28						; size = 4
_c$2 = -24						; size = 4
_s$3 = -20						; size = 4
_code$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_h$ = 8							; size = 4
_count$ = 12						; size = 4
?build_huffman@@YAHPAUhuffman@@PAH@Z PROC		; build_huffman

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 766  :    int i,j,k=0,code;

  00021	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 767  :    // build size list for each symbol (from JPEG spec)
; 768  :    for (i=0; i < 16; ++i)

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@build_huff
$LN2@build_huff:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@build_huff:
  0003a	83 7d fc 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0003e	7d 3f		 jge	 SHORT $LN3@build_huff

; 769  :       for (j=0; j < count[i]; ++j)

  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN7@build_huff
$LN5@build_huff:
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  0004c	83 c1 01	 add	 ecx, 1
  0004f	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN7@build_huff:
  00052	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00055	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  0005b	3b 0c 90	 cmp	 ecx, DWORD PTR [eax+edx*4]
  0005e	7d 1d		 jge	 SHORT $LN6@build_huff

; 770  :          h->size[k++] = (uint8) (i+1);

  00060	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00063	83 c2 01	 add	 edx, 1
  00066	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  00069	03 45 f4	 add	 eax, DWORD PTR _k$[ebp]
  0006c	88 90 00 05 00
	00		 mov	 BYTE PTR [eax+1280], dl
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  00075	83 c1 01	 add	 ecx, 1
  00078	89 4d f4	 mov	 DWORD PTR _k$[ebp], ecx
  0007b	eb cc		 jmp	 SHORT $LN5@build_huff
$LN6@build_huff:
  0007d	eb b2		 jmp	 SHORT $LN2@build_huff
$LN3@build_huff:

; 771  :    h->size[k] = 0;

  0007f	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  00082	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  00085	c6 82 00 05 00
	00 00		 mov	 BYTE PTR [edx+1280], 0

; 772  : 
; 773  :    // compute actual symbols (from jpeg spec)
; 774  :    code = 0;

  0008c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _code$[ebp], 0

; 775  :    k = 0;

  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 776  :    for(j=1; j <= 16; ++j) {

  0009a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  000a1	eb 09		 jmp	 SHORT $LN10@build_huff
$LN8@build_huff:
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000a6	83 c0 01	 add	 eax, 1
  000a9	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN10@build_huff:
  000ac	83 7d f8 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  000b0	0f 8f aa 00 00
	00		 jg	 $LN9@build_huff

; 777  :       // compute delta to add to code to compute symbol id
; 778  :       h->delta[j] = k - code;

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  000b9	2b 4d f0	 sub	 ecx, DWORD PTR _code$[ebp]
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000bf	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  000c2	89 8c 90 4c 06
	00 00		 mov	 DWORD PTR [eax+edx*4+1612], ecx

; 779  :       if (h->size[k] == j) {

  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  000cc	03 4d f4	 add	 ecx, DWORD PTR _k$[ebp]
  000cf	0f b6 91 00 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1280]
  000d6	3b 55 f8	 cmp	 edx, DWORD PTR _j$[ebp]
  000d9	75 5e		 jne	 SHORT $LN19@build_huff
$LN11@build_huff:

; 780  :          while (h->size[k] == j)

  000db	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  000de	03 45 f4	 add	 eax, DWORD PTR _k$[ebp]
  000e1	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  000e8	3b 4d f8	 cmp	 ecx, DWORD PTR _j$[ebp]
  000eb	75 26		 jne	 SHORT $LN12@build_huff

; 781  :             h->code[k++] = (uint16) (code++);

  000ed	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  000f3	66 8b 4d f0	 mov	 cx, WORD PTR _code$[ebp]
  000f7	66 89 8c 50 00
	02 00 00	 mov	 WORD PTR [eax+edx*2+512], cx
  000ff	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  00102	83 c2 01	 add	 edx, 1
  00105	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx
  00108	8b 45 f0	 mov	 eax, DWORD PTR _code$[ebp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 45 f0	 mov	 DWORD PTR _code$[ebp], eax
  00111	eb c8		 jmp	 SHORT $LN11@build_huff
$LN12@build_huff:

; 782  :          if (code-1 >= (1 << j)) return e("bad code lengths","Corrupt JPEG");

  00113	8b 55 f0	 mov	 edx, DWORD PTR _code$[ebp]
  00116	83 ea 01	 sub	 edx, 1
  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00121	d3 e0		 shl	 eax, cl
  00123	3b d0		 cmp	 edx, eax
  00125	7c 12		 jl	 SHORT $LN19@build_huff
  00127	68 00 00 00 00	 push	 OFFSET $SG4294820264
  0012c	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00131	83 c4 04	 add	 esp, 4
  00134	e9 ea 00 00 00	 jmp	 $LN1@build_huff
$LN19@build_huff:

; 783  :       }
; 784  :       // compute largest code + 1 for this size, preshifted as needed later
; 785  :       h->maxcode[j] = code << (16-j);

  00139	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0013e	2b 4d f8	 sub	 ecx, DWORD PTR _j$[ebp]
  00141	8b 55 f0	 mov	 edx, DWORD PTR _code$[ebp]
  00144	d3 e2		 shl	 edx, cl
  00146	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00149	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  0014c	89 94 81 04 06
	00 00		 mov	 DWORD PTR [ecx+eax*4+1540], edx

; 786  :       code <<= 1;

  00153	8b 55 f0	 mov	 edx, DWORD PTR _code$[ebp]
  00156	d1 e2		 shl	 edx, 1
  00158	89 55 f0	 mov	 DWORD PTR _code$[ebp], edx

; 787  :    }

  0015b	e9 43 ff ff ff	 jmp	 $LN8@build_huff
$LN9@build_huff:

; 788  :    h->maxcode[j] = 0xffffffff;

  00160	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00163	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  00166	c7 84 81 04 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+1540], -1

; 789  : 
; 790  :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 791  :    memset(h->fast, 255, 1 << FAST_BITS);

  00171	8b f4		 mov	 esi, esp
  00173	68 00 02 00 00	 push	 512			; 00000200H
  00178	68 ff 00 00 00	 push	 255			; 000000ffH
  0017d	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  00180	52		 push	 edx
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018a	3b f4		 cmp	 esi, esp
  0018c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 792  :    for (i=0; i < k; ++i) {

  00191	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00198	eb 09		 jmp	 SHORT $LN15@build_huff
$LN13@build_huff:
  0019a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0019d	83 c0 01	 add	 eax, 1
  001a0	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN15@build_huff:
  001a3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001a6	3b 4d f4	 cmp	 ecx, DWORD PTR _k$[ebp]
  001a9	7d 73		 jge	 SHORT $LN14@build_huff

; 793  :       int s = h->size[i];

  001ab	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  001ae	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  001b1	0f b6 82 00 05
	00 00		 movzx	 eax, BYTE PTR [edx+1280]
  001b8	89 45 ec	 mov	 DWORD PTR _s$3[ebp], eax

; 794  :       if (s <= FAST_BITS) {

  001bb	83 7d ec 09	 cmp	 DWORD PTR _s$3[ebp], 9
  001bf	7f 58		 jg	 SHORT $LN21@build_huff

; 795  :          int c = h->code[i] << (FAST_BITS-s);

  001c1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001c4	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  001c7	0f b7 84 4a 00
	02 00 00	 movzx	 eax, WORD PTR [edx+ecx*2+512]
  001cf	b9 09 00 00 00	 mov	 ecx, 9
  001d4	2b 4d ec	 sub	 ecx, DWORD PTR _s$3[ebp]
  001d7	d3 e0		 shl	 eax, cl
  001d9	89 45 e8	 mov	 DWORD PTR _c$2[ebp], eax

; 796  :          int m = 1 << (FAST_BITS-s);

  001dc	b9 09 00 00 00	 mov	 ecx, 9
  001e1	2b 4d ec	 sub	 ecx, DWORD PTR _s$3[ebp]
  001e4	ba 01 00 00 00	 mov	 edx, 1
  001e9	d3 e2		 shl	 edx, cl
  001eb	89 55 e4	 mov	 DWORD PTR _m$1[ebp], edx

; 797  :          for (j=0; j < m; ++j) {

  001ee	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  001f5	eb 09		 jmp	 SHORT $LN18@build_huff
$LN16@build_huff:
  001f7	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  001fa	83 c0 01	 add	 eax, 1
  001fd	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN18@build_huff:
  00200	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00203	3b 4d e4	 cmp	 ecx, DWORD PTR _m$1[ebp]
  00206	7d 11		 jge	 SHORT $LN21@build_huff

; 798  :             h->fast[c+j] = (uint8) i;

  00208	8b 55 e8	 mov	 edx, DWORD PTR _c$2[ebp]
  0020b	03 55 f8	 add	 edx, DWORD PTR _j$[ebp]
  0020e	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  00211	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  00214	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 799  :          }

  00217	eb de		 jmp	 SHORT $LN16@build_huff
$LN21@build_huff:

; 800  :       }
; 801  :    }

  00219	e9 7c ff ff ff	 jmp	 $LN13@build_huff
$LN14@build_huff:

; 802  :    return 1;

  0021e	b8 01 00 00 00	 mov	 eax, 1
$LN1@build_huff:

; 803  : }

  00223	5e		 pop	 esi
  00224	83 c4 1c	 add	 esp, 28			; 0000001cH
  00227	3b ec		 cmp	 ebp, esp
  00229	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
?build_huffman@@YAHPAUhuffman@@PAH@Z ENDP		; build_huffman
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv69 = -12						; size = 4
_c$1 = -8						; size = 4
_b$2 = -4						; size = 4
_j$ = 8							; size = 4
?grow_buffer_unsafe@@YAXPAUjpeg@@@Z PROC		; grow_buffer_unsafe

; 806  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
$LN4@grow_buffe:

; 807  :    do {
; 808  :       int b = j->nomore ? 0 : get8(j->s);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0001e	83 b8 88 36 00
	00 00		 cmp	 DWORD PTR [eax+13960], 0
  00025	74 09		 je	 SHORT $LN8@grow_buffe
  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0002e	eb 11		 jmp	 SHORT $LN9@grow_buffe
$LN8@grow_buffe:
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
$LN9@grow_buffe:
  00041	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  00044	89 45 fc	 mov	 DWORD PTR _b$2[ebp], eax

; 809  :       if (b == 0xff) {

  00047	81 7d fc ff 00
	00 00		 cmp	 DWORD PTR _b$2[ebp], 255 ; 000000ffH
  0004e	75 32		 jne	 SHORT $LN5@grow_buffe

; 810  :          int c = get8(j->s);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 f8	 mov	 DWORD PTR _c$1[ebp], eax

; 811  :          if (c != 0) {

  00061	83 7d f8 00	 cmp	 DWORD PTR _c$1[ebp], 0
  00065	74 1b		 je	 SHORT $LN5@grow_buffe

; 812  :             j->marker = (unsigned char) c;

  00067	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0006a	8a 4d f8	 mov	 cl, BYTE PTR _c$1[ebp]
  0006d	88 88 84 36 00
	00		 mov	 BYTE PTR [eax+13956], cl

; 813  :             j->nomore = 1;

  00073	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00076	c7 82 88 36 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+13960], 1

; 814  :             return;

  00080	eb 4a		 jmp	 SHORT $LN1@grow_buffe
$LN5@grow_buffe:

; 815  :          }
; 816  :       }
; 817  :       j->code_buffer |= b << (24 - j->code_bits);

  00082	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00085	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0008a	2b 88 80 36 00
	00		 sub	 ecx, DWORD PTR [eax+13952]
  00090	8b 55 fc	 mov	 edx, DWORD PTR _b$2[ebp]
  00093	d3 e2		 shl	 edx, cl
  00095	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00098	0b 90 7c 36 00
	00		 or	 edx, DWORD PTR [eax+13948]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  000a1	89 91 7c 36 00
	00		 mov	 DWORD PTR [ecx+13948], edx

; 818  :       j->code_bits += 8;

  000a7	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000aa	8b 82 80 36 00
	00		 mov	 eax, DWORD PTR [edx+13952]
  000b0	83 c0 08	 add	 eax, 8
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  000b6	89 81 80 36 00
	00		 mov	 DWORD PTR [ecx+13952], eax

; 819  :    } while (j->code_bits <= 24);

  000bc	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000bf	83 ba 80 36 00
	00 18		 cmp	 DWORD PTR [edx+13952], 24 ; 00000018H
  000c6	0f 8e 4f ff ff
	ff		 jle	 $LN4@grow_buffe
$LN1@grow_buffe:

; 820  : }

  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	3b ec		 cmp	 ebp, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?grow_buffer_unsafe@@YAXPAUjpeg@@@Z ENDP		; grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$1 = -16						; size = 4
_k$ = -12						; size = 4
_c$ = -8						; size = 4
_temp$ = -4						; size = 4
_j$ = 8							; size = 4
_h$ = 12						; size = 4
?decode@@YAHPAUjpeg@@PAUhuffman@@@Z PROC		; decode

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 828  :    unsigned int temp;
; 829  :    int c,k;
; 830  : 
; 831  :    if (j->code_bits < 16) grow_buffer_unsafe(j);

  00018	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0001b	83 b8 80 36 00
	00 10		 cmp	 DWORD PTR [eax+13952], 16 ; 00000010H
  00022	7d 0c		 jge	 SHORT $LN5@decode
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?grow_buffer_unsafe@@YAXPAUjpeg@@@Z ; grow_buffer_unsafe
  0002d	83 c4 04	 add	 esp, 4
$LN5@decode:

; 832  : 
; 833  :    // look at the top FAST_BITS and determine what symbol ID it is,
; 834  :    // if the code is <= FAST_BITS
; 835  :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00030	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00033	8b 82 7c 36 00
	00		 mov	 eax, DWORD PTR [edx+13948]
  00039	c1 e8 17	 shr	 eax, 23			; 00000017H
  0003c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00041	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 836  :    k = h->fast[c];

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  00047	03 4d f8	 add	 ecx, DWORD PTR _c$[ebp]
  0004a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004d	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx

; 837  :    if (k < 255) {

  00050	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _k$[ebp], 255	; 000000ffH
  00057	7d 64		 jge	 SHORT $LN6@decode

; 838  :       int s = h->size[k];

  00059	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  0005c	03 45 f4	 add	 eax, DWORD PTR _k$[ebp]
  0005f	0f b6 88 00 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1280]
  00066	89 4d f0	 mov	 DWORD PTR _s$1[ebp], ecx

; 839  :       if (s > j->code_bits)

  00069	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  0006c	8b 45 f0	 mov	 eax, DWORD PTR _s$1[ebp]
  0006f	3b 82 80 36 00
	00		 cmp	 eax, DWORD PTR [edx+13952]
  00075	7e 08		 jle	 SHORT $LN7@decode

; 840  :          return -1;

  00077	83 c8 ff	 or	 eax, -1
  0007a	e9 7a 01 00 00	 jmp	 $LN1@decode
$LN7@decode:

; 841  :       j->code_buffer <<= s;

  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00082	8b 91 7c 36 00
	00		 mov	 edx, DWORD PTR [ecx+13948]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _s$1[ebp]
  0008b	d3 e2		 shl	 edx, cl
  0008d	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00090	89 90 7c 36 00
	00		 mov	 DWORD PTR [eax+13948], edx

; 842  :       j->code_bits -= s;

  00096	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00099	8b 91 80 36 00
	00		 mov	 edx, DWORD PTR [ecx+13952]
  0009f	2b 55 f0	 sub	 edx, DWORD PTR _s$1[ebp]
  000a2	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  000a5	89 90 80 36 00
	00		 mov	 DWORD PTR [eax+13952], edx

; 843  :       return h->values[k];

  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  000ae	03 4d f4	 add	 ecx, DWORD PTR _k$[ebp]
  000b1	0f b6 81 00 04
	00 00		 movzx	 eax, BYTE PTR [ecx+1024]
  000b8	e9 3c 01 00 00	 jmp	 $LN1@decode
$LN6@decode:

; 844  :    }
; 845  : 
; 846  :    // naive test is to shift the code_buffer down so k bits are
; 847  :    // valid, then test against maxcode. To speed this up, we've
; 848  :    // preshifted maxcode left so that it has (16-k) 0s at the
; 849  :    // end; in other words, regardless of the number of bits, it
; 850  :    // wants to be compared against something shifted to have 16;
; 851  :    // that way we don't need to shift inside the loop.
; 852  :    temp = j->code_buffer >> 16;

  000bd	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000c0	8b 82 7c 36 00
	00		 mov	 eax, DWORD PTR [edx+13948]
  000c6	c1 e8 10	 shr	 eax, 16			; 00000010H
  000c9	89 45 fc	 mov	 DWORD PTR _temp$[ebp], eax

; 853  :    for (k=FAST_BITS+1 ; ; ++k)

  000cc	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _k$[ebp], 10	; 0000000aH
  000d3	eb 09		 jmp	 SHORT $LN4@decode
$LN2@decode:
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  000d8	83 c1 01	 add	 ecx, 1
  000db	89 4d f4	 mov	 DWORD PTR _k$[ebp], ecx
$LN4@decode:

; 854  :       if (temp < h->maxcode[k])

  000de	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  000e1	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _temp$[ebp]
  000e7	3b 8c 90 04 06
	00 00		 cmp	 ecx, DWORD PTR [eax+edx*4+1540]
  000ee	73 02		 jae	 SHORT $LN8@decode

; 855  :          break;

  000f0	eb 02		 jmp	 SHORT $LN3@decode
$LN8@decode:

; 856  :    if (k == 17) {

  000f2	eb e1		 jmp	 SHORT $LN2@decode
$LN3@decode:
  000f4	83 7d f4 11	 cmp	 DWORD PTR _k$[ebp], 17	; 00000011H
  000f8	75 1d		 jne	 SHORT $LN9@decode

; 857  :       // error! code not found
; 858  :       j->code_bits -= 16;

  000fa	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000fd	8b 82 80 36 00
	00		 mov	 eax, DWORD PTR [edx+13952]
  00103	83 e8 10	 sub	 eax, 16			; 00000010H
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00109	89 81 80 36 00
	00		 mov	 DWORD PTR [ecx+13952], eax

; 859  :       return -1;

  0010f	83 c8 ff	 or	 eax, -1
  00112	e9 e2 00 00 00	 jmp	 $LN1@decode
$LN9@decode:

; 860  :    }
; 861  : 
; 862  :    if (k > j->code_bits)

  00117	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  0011a	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  0011d	3b 82 80 36 00
	00		 cmp	 eax, DWORD PTR [edx+13952]
  00123	7e 08		 jle	 SHORT $LN10@decode

; 863  :       return -1;

  00125	83 c8 ff	 or	 eax, -1
  00128	e9 cc 00 00 00	 jmp	 $LN1@decode
$LN10@decode:

; 864  : 
; 865  :    // convert the huffman code to the symbol id
; 866  :    c = ((j->code_buffer >> (32 - k)) & bmask[k]) + h->delta[k];

  0012d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00132	2b 4d f4	 sub	 ecx, DWORD PTR _k$[ebp]
  00135	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00138	8b 82 7c 36 00
	00		 mov	 eax, DWORD PTR [edx+13948]
  0013e	d3 e8		 shr	 eax, cl
  00140	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  00143	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR ?bmask@@3PAIA[ecx*4]
  0014a	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  00150	03 84 91 4c 06
	00 00		 add	 eax, DWORD PTR [ecx+edx*4+1612]
  00157	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 867  :    assert((((j->code_buffer) >> (32 - h->size[c])) & bmask[h->size[c]]) == h->code[c]);

  0015a	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  0015d	03 55 f8	 add	 edx, DWORD PTR _c$[ebp]
  00160	0f b6 82 00 05
	00 00		 movzx	 eax, BYTE PTR [edx+1280]
  00167	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0016c	2b c8		 sub	 ecx, eax
  0016e	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00171	8b 82 7c 36 00
	00		 mov	 eax, DWORD PTR [edx+13948]
  00177	d3 e8		 shr	 eax, cl
  00179	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  0017c	03 4d f8	 add	 ecx, DWORD PTR _c$[ebp]
  0017f	0f b6 91 00 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1280]
  00186	23 04 95 00 00
	00 00		 and	 eax, DWORD PTR ?bmask@@3PAIA[edx*4]
  0018d	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00190	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00193	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [edx+ecx*2+512]
  0019b	3b c1		 cmp	 eax, ecx
  0019d	74 21		 je	 SHORT $LN12@decode
  0019f	8b f4		 mov	 esi, esp
  001a1	68 63 03 00 00	 push	 867			; 00000363H
  001a6	68 00 00 00 00	 push	 OFFSET $SG4294820263
  001ab	68 00 00 00 00	 push	 OFFSET $SG4294820262
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	3b f4		 cmp	 esi, esp
  001bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@decode:

; 868  : 
; 869  :    // convert the id to a symbol
; 870  :    j->code_bits -= k;

  001c0	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  001c3	8b 88 80 36 00
	00		 mov	 ecx, DWORD PTR [eax+13952]
  001c9	2b 4d f4	 sub	 ecx, DWORD PTR _k$[ebp]
  001cc	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  001cf	89 8a 80 36 00
	00		 mov	 DWORD PTR [edx+13952], ecx

; 871  :    j->code_buffer <<= k;

  001d5	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  001d8	8b 90 7c 36 00
	00		 mov	 edx, DWORD PTR [eax+13948]
  001de	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  001e1	d3 e2		 shl	 edx, cl
  001e3	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  001e6	89 90 7c 36 00
	00		 mov	 DWORD PTR [eax+13948], edx

; 872  :    return h->values[c];

  001ec	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  001ef	03 4d f8	 add	 ecx, DWORD PTR _c$[ebp]
  001f2	0f b6 81 00 04
	00 00		 movzx	 eax, BYTE PTR [ecx+1024]
$LN1@decode:

; 873  : }

  001f9	5e		 pop	 esi
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
  001fd	3b ec		 cmp	 ebp, esp
  001ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c3		 ret	 0
?decode@@YAHPAUjpeg@@PAUhuffman@@@Z ENDP		; decode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_k$ = -8						; size = 4
_m$ = -4						; size = 4
_j$ = 8							; size = 4
_n$ = 12						; size = 4
?extend_receive@@YAHPAUjpeg@@H@Z PROC			; extend_receive

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 879  :    unsigned int m = 1 << (n-1);

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00018	83 e9 01	 sub	 ecx, 1
  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	d3 e0		 shl	 eax, cl
  00022	89 45 fc	 mov	 DWORD PTR _m$[ebp], eax

; 880  :    unsigned int k;
; 881  :    if (j->code_bits < n) grow_buffer_unsafe(j);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00028	8b 91 80 36 00
	00		 mov	 edx, DWORD PTR [ecx+13952]
  0002e	3b 55 0c	 cmp	 edx, DWORD PTR _n$[ebp]
  00031	7d 0c		 jge	 SHORT $LN2@extend_rec
  00033	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?grow_buffer_unsafe@@YAXPAUjpeg@@@Z ; grow_buffer_unsafe
  0003c	83 c4 04	 add	 esp, 4
$LN2@extend_rec:

; 882  : 
; 883  :    #if 1
; 884  :    k = stbi_lrot(j->code_buffer, n);

  0003f	8b f4		 mov	 esi, esp
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00048	8b 82 7c 36 00
	00		 mov	 eax, DWORD PTR [edx+13948]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___lrotl
  00055	83 c4 08	 add	 esp, 8
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax

; 885  :    j->code_buffer = k & ~bmask[n];

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00065	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?bmask@@3PAIA[ecx*4]
  0006c	f7 d2		 not	 edx
  0006e	23 55 f8	 and	 edx, DWORD PTR _k$[ebp]
  00071	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00074	89 90 7c 36 00
	00		 mov	 DWORD PTR [eax+13948], edx

; 886  :    k &= bmask[n];

  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  00080	23 14 8d 00 00
	00 00		 and	 edx, DWORD PTR ?bmask@@3PAIA[ecx*4]
  00087	89 55 f8	 mov	 DWORD PTR _k$[ebp], edx

; 887  :    j->code_bits -= n;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0008d	8b 88 80 36 00
	00		 mov	 ecx, DWORD PTR [eax+13952]
  00093	2b 4d 0c	 sub	 ecx, DWORD PTR _n$[ebp]
  00096	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00099	89 8a 80 36 00
	00		 mov	 DWORD PTR [edx+13952], ecx

; 888  :    #else
; 889  :    k = (j->code_buffer >> (32 - n)) & bmask[n];
; 890  :    j->code_bits -= n;
; 891  :    j->code_buffer <<= n;
; 892  :    #endif
; 893  :    // the following test is probably a random branch that won't
; 894  :    // predict well. I tried to table accelerate it but failed.
; 895  :    // maybe it's compiling as a conditional move?
; 896  :    if (k < m)

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  000a2	3b 45 fc	 cmp	 eax, DWORD PTR _m$[ebp]
  000a5	73 13		 jae	 SHORT $LN3@extend_rec

; 897  :       return (-1 << n) + k + 1;

  000a7	83 ca ff	 or	 edx, -1
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  000ad	d3 e2		 shl	 edx, cl
  000af	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  000b2	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
  000b6	eb 05		 jmp	 SHORT $LN1@extend_rec

; 898  :    else

  000b8	eb 03		 jmp	 SHORT $LN1@extend_rec
$LN3@extend_rec:

; 899  :       return k;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
$LN1@extend_rec:

; 900  : }

  000bd	5e		 pop	 esi
  000be	83 c4 08	 add	 esp, 8
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?extend_receive@@YAHPAUjpeg@@H@Z ENDP			; extend_receive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv77 = -32						; size = 4
_rs$1 = -28						; size = 4
_s$2 = -24						; size = 4
_r$3 = -20						; size = 4
_t$ = -16						; size = 4
_k$ = -12						; size = 4
_dc$ = -8						; size = 4
_diff$ = -4						; size = 4
_j$ = 8							; size = 4
_data$ = 12						; size = 4
_hdc$ = 16						; size = 4
_hac$ = 20						; size = 4
_b$ = 24						; size = 4
?decode_block@@YAHPAUjpeg@@QAFPAUhuffman@@2H@Z PROC	; decode_block

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 922  :    int diff,dc,k;
; 923  :    int t = decode(j, hdc);

  00024	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?decode@@YAHPAUjpeg@@PAUhuffman@@@Z ; decode
  00031	83 c4 08	 add	 esp, 8
  00034	89 45 f0	 mov	 DWORD PTR _t$[ebp], eax

; 924  :    if (t < 0) return e("bad huffman code","Corrupt JPEG");

  00037	83 7d f0 00	 cmp	 DWORD PTR _t$[ebp], 0
  0003b	7d 12		 jge	 SHORT $LN5@decode_blo
  0003d	68 00 00 00 00	 push	 OFFSET $SG4294820261
  00042	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00047	83 c4 04	 add	 esp, 4
  0004a	e9 1c 01 00 00	 jmp	 $LN1@decode_blo
$LN5@decode_blo:

; 925  : 
; 926  :    // 0 all the ac values now so we can do it 32-bits at a time
; 927  :    memset(data,0,64*sizeof(data[0]));

  0004f	8b f4		 mov	 esi, esp
  00051	68 80 00 00 00	 push	 128			; 00000080H
  00056	6a 00		 push	 0
  00058	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  0005b	52		 push	 edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 928  : 
; 929  :    diff = t ? extend_receive(j, t) : 0;

  0006c	83 7d f0 00	 cmp	 DWORD PTR _t$[ebp], 0
  00070	74 15		 je	 SHORT $LN11@decode_blo
  00072	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp]
  00075	50		 push	 eax
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?extend_receive@@YAHPAUjpeg@@H@Z ; extend_receive
  0007f	83 c4 08	 add	 esp, 8
  00082	89 45 e0	 mov	 DWORD PTR tv77[ebp], eax
  00085	eb 07		 jmp	 SHORT $LN12@decode_blo
$LN11@decode_blo:
  00087	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN12@decode_blo:
  0008e	8b 55 e0	 mov	 edx, DWORD PTR tv77[ebp]
  00091	89 55 fc	 mov	 DWORD PTR _diff$[ebp], edx

; 930  :    dc = j->img_comp[b].dc_pred + diff;

  00094	6b 45 18 38	 imul	 eax, DWORD PTR _b$[ebp], 56
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  0009b	8b 94 01 b4 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13748]
  000a2	03 55 fc	 add	 edx, DWORD PTR _diff$[ebp]
  000a5	89 55 f8	 mov	 DWORD PTR _dc$[ebp], edx

; 931  :    j->img_comp[b].dc_pred = dc;

  000a8	6b 45 18 38	 imul	 eax, DWORD PTR _b$[ebp], 56
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  000af	8b 55 f8	 mov	 edx, DWORD PTR _dc$[ebp]
  000b2	89 94 01 b4 35
	00 00		 mov	 DWORD PTR [ecx+eax+13748], edx

; 932  :    data[0] = (short) dc;

  000b9	b8 02 00 00 00	 mov	 eax, 2
  000be	6b c8 00	 imul	 ecx, eax, 0
  000c1	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  000c4	66 8b 45 f8	 mov	 ax, WORD PTR _dc$[ebp]
  000c8	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 933  : 
; 934  :    // decode AC components, see JPEG spec
; 935  :    k = 1;

  000cc	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
$LN4@decode_blo:

; 936  :    do {
; 937  :       int r,s;
; 938  :       int rs = decode(j, hac);

  000d3	8b 4d 14	 mov	 ecx, DWORD PTR _hac$[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 ?decode@@YAHPAUjpeg@@PAUhuffman@@@Z ; decode
  000e0	83 c4 08	 add	 esp, 8
  000e3	89 45 e4	 mov	 DWORD PTR _rs$1[ebp], eax

; 939  :       if (rs < 0) return e("bad huffman code","Corrupt JPEG");

  000e6	83 7d e4 00	 cmp	 DWORD PTR _rs$1[ebp], 0
  000ea	7d 0f		 jge	 SHORT $LN6@decode_blo
  000ec	68 00 00 00 00	 push	 OFFSET $SG4294820260
  000f1	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000f6	83 c4 04	 add	 esp, 4
  000f9	eb 70		 jmp	 SHORT $LN1@decode_blo
$LN6@decode_blo:

; 940  :       s = rs & 15;

  000fb	8b 45 e4	 mov	 eax, DWORD PTR _rs$1[ebp]
  000fe	83 e0 0f	 and	 eax, 15			; 0000000fH
  00101	89 45 e8	 mov	 DWORD PTR _s$2[ebp], eax

; 941  :       r = rs >> 4;

  00104	8b 4d e4	 mov	 ecx, DWORD PTR _rs$1[ebp]
  00107	c1 f9 04	 sar	 ecx, 4
  0010a	89 4d ec	 mov	 DWORD PTR _r$3[ebp], ecx

; 942  :       if (s == 0) {

  0010d	83 7d e8 00	 cmp	 DWORD PTR _s$2[ebp], 0
  00111	75 16		 jne	 SHORT $LN7@decode_blo

; 943  :          if (rs != 0xf0) break; // end block

  00113	81 7d e4 f0 00
	00 00		 cmp	 DWORD PTR _rs$1[ebp], 240 ; 000000f0H
  0011a	74 02		 je	 SHORT $LN9@decode_blo
  0011c	eb 48		 jmp	 SHORT $LN3@decode_blo
$LN9@decode_blo:

; 944  :          k += 16;

  0011e	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  00121	83 c2 10	 add	 edx, 16			; 00000010H
  00124	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx

; 945  :       } else {

  00127	eb 33		 jmp	 SHORT $LN2@decode_blo
$LN7@decode_blo:

; 946  :          k += r;

  00129	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  0012c	03 45 ec	 add	 eax, DWORD PTR _r$3[ebp]
  0012f	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax

; 947  :          // decode into unzigzag'd location
; 948  :          data[dezigzag[k++]] = (short) extend_receive(j,s);

  00132	8b 4d e8	 mov	 ecx, DWORD PTR _s$2[ebp]
  00135	51		 push	 ecx
  00136	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00139	52		 push	 edx
  0013a	e8 00 00 00 00	 call	 ?extend_receive@@YAHPAUjpeg@@H@Z ; extend_receive
  0013f	83 c4 08	 add	 esp, 8
  00142	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  00145	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?dezigzag@@3PAEA[ecx]
  0014c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0014f	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00153	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  00156	83 c2 01	 add	 edx, 1
  00159	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx
$LN2@decode_blo:

; 949  :       }
; 950  :    } while (k < 64);

  0015c	83 7d f4 40	 cmp	 DWORD PTR _k$[ebp], 64	; 00000040H
  00160	0f 8c 6d ff ff
	ff		 jl	 $LN4@decode_blo
$LN3@decode_blo:

; 951  :    return 1;

  00166	b8 01 00 00 00	 mov	 eax, 1
$LN1@decode_blo:

; 952  : }

  0016b	5e		 pop	 esi
  0016c	83 c4 20	 add	 esp, 32			; 00000020H
  0016f	3b ec		 cmp	 ebp, esp
  00171	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c3		 ret	 0
?decode_block@@YAHPAUjpeg@@QAFPAUhuffman@@2H@Z ENDP	; decode_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
?clamp@@YAEH@Z PROC					; clamp

; 956  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 957  :    // trick to use a single test to catch both cases
; 958  :    if ((unsigned int) x > 255) {

  00003	81 7d 08 ff 00
	00 00		 cmp	 DWORD PTR _x$[ebp], 255	; 000000ffH
  0000a	76 17		 jbe	 SHORT $LN2@clamp

; 959  :       if (x < 0) return 0;

  0000c	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00010	7d 04		 jge	 SHORT $LN3@clamp
  00012	32 c0		 xor	 al, al
  00014	eb 10		 jmp	 SHORT $LN1@clamp
$LN3@clamp:

; 960  :       if (x > 255) return 255;

  00016	81 7d 08 ff 00
	00 00		 cmp	 DWORD PTR _x$[ebp], 255	; 000000ffH
  0001d	7e 04		 jle	 SHORT $LN2@clamp
  0001f	0c ff		 or	 al, 255			; 000000ffH
  00021	eb 03		 jmp	 SHORT $LN1@clamp
$LN2@clamp:

; 961  :    }
; 962  :    return (uint8) x;

  00023	8a 45 08	 mov	 al, BYTE PTR _x$[ebp]
$LN1@clamp:

; 963  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?clamp@@YAEH@Z ENDP					; clamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_x3$1 = -396						; size = 4
_x2$2 = -392						; size = 4
_x1$3 = -388						; size = 4
_x0$4 = -384						; size = 4
_p5$5 = -380						; size = 4
_p4$6 = -376						; size = 4
_p3$7 = -372						; size = 4
_p2$8 = -368						; size = 4
_p1$9 = -364						; size = 4
_t3$10 = -360						; size = 4
_t2$11 = -356						; size = 4
_t1$12 = -352						; size = 4
_t0$13 = -348						; size = 4
_x3$14 = -344						; size = 4
_x2$15 = -340						; size = 4
_x1$16 = -336						; size = 4
_x0$17 = -332						; size = 4
_p5$18 = -328						; size = 4
_p4$19 = -324						; size = 4
_p3$20 = -320						; size = 4
_p2$21 = -316						; size = 4
_p1$22 = -312						; size = 4
_t3$23 = -308						; size = 4
_t2$24 = -304						; size = 4
_t1$25 = -300						; size = 4
_t0$26 = -296						; size = 4
_dcterm$27 = -292					; size = 4
_d$ = -288						; size = 4
_o$ = -284						; size = 4
_dq$ = -280						; size = 4
_v$ = -276						; size = 4
_val$ = -268						; size = 256
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_out_stride$ = 12					; size = 4
_data$ = 16						; size = 4
_dequantize$ = 20					; size = 4
?idct_block@@YAXPAEHQAF0@Z PROC				; idct_block

; 1014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	57		 push	 edi
  0000a	8d bd 74 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-396]
  00010	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1015 :    int i,val[64],*v=val;

  00026	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _val$[ebp]
  0002c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax

; 1016 :    stbi_dequantize_t *dq = dequantize;

  00032	8b 4d 14	 mov	 ecx, DWORD PTR _dequantize$[ebp]
  00035	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dq$[ebp], ecx

; 1017 :    uint8 *o;
; 1018 :    short *d = data;

  0003b	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  0003e	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _d$[ebp], edx

; 1019 : 
; 1020 :    // columns
; 1021 :    for (i=0; i < 8; ++i,++d,++dq, ++v) {

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 36		 jmp	 SHORT $LN4@idct_block
$LN2@idct_block:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00056	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _d$[ebp]
  0005c	83 c1 02	 add	 ecx, 2
  0005f	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _d$[ebp], ecx
  00065	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _dq$[ebp], edx
  00074	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0007a	83 c0 04	 add	 eax, 4
  0007d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
$LN4@idct_block:
  00083	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  00087	0f 8d 59 06 00
	00		 jge	 $LN3@idct_block

; 1022 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 1023 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 1024 :            && d[40]==0 && d[48]==0 && d[56]==0) {

  0008d	b9 02 00 00 00	 mov	 ecx, 2
  00092	c1 e1 03	 shl	 ecx, 3
  00095	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  0009b	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  0009f	85 c0		 test	 eax, eax
  000a1	0f 85 89 01 00
	00		 jne	 $LN8@idct_block
  000a7	b9 02 00 00 00	 mov	 ecx, 2
  000ac	c1 e1 04	 shl	 ecx, 4
  000af	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  000b5	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 6f 01 00
	00		 jne	 $LN8@idct_block
  000c1	b9 02 00 00 00	 mov	 ecx, 2
  000c6	6b d1 18	 imul	 edx, ecx, 24
  000c9	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  000cf	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  000d3	85 c9		 test	 ecx, ecx
  000d5	0f 85 55 01 00
	00		 jne	 $LN8@idct_block
  000db	ba 02 00 00 00	 mov	 edx, 2
  000e0	c1 e2 05	 shl	 edx, 5
  000e3	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  000e9	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  000ed	85 c9		 test	 ecx, ecx
  000ef	0f 85 3b 01 00
	00		 jne	 $LN8@idct_block
  000f5	ba 02 00 00 00	 mov	 edx, 2
  000fa	6b c2 28	 imul	 eax, edx, 40
  000fd	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _d$[ebp]
  00103	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00107	85 d2		 test	 edx, edx
  00109	0f 85 21 01 00
	00		 jne	 $LN8@idct_block
  0010f	b8 02 00 00 00	 mov	 eax, 2
  00114	6b c8 30	 imul	 ecx, eax, 48
  00117	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  0011d	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00121	85 c0		 test	 eax, eax
  00123	0f 85 07 01 00
	00		 jne	 $LN8@idct_block
  00129	b9 02 00 00 00	 mov	 ecx, 2
  0012e	6b d1 38	 imul	 edx, ecx, 56
  00131	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00137	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  0013b	85 c9		 test	 ecx, ecx
  0013d	0f 85 ed 00 00
	00		 jne	 $LN8@idct_block

; 1025 :          //    no shortcut                 0     seconds
; 1026 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 1027 :          //    all separate               -0.047 seconds
; 1028 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 1029 :          int dcterm = d[0] * dq[0] << 2;

  00143	ba 02 00 00 00	 mov	 edx, 2
  00148	6b c2 00	 imul	 eax, edx, 0
  0014b	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _d$[ebp]
  00151	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	6b c8 00	 imul	 ecx, eax, 0
  0015d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _dq$[ebp]
  00163	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00167	0f af d1	 imul	 edx, ecx
  0016a	c1 e2 02	 shl	 edx, 2
  0016d	89 95 dc fe ff
	ff		 mov	 DWORD PTR _dcterm$27[ebp], edx

; 1030 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

  00173	ba 04 00 00 00	 mov	 edx, 4
  00178	6b c2 38	 imul	 eax, edx, 56
  0017b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00181	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dcterm$27[ebp]
  00187	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	6b c8 30	 imul	 ecx, eax, 48
  00192	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  00198	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _dcterm$27[ebp]
  0019e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  001a1	b9 04 00 00 00	 mov	 ecx, 4
  001a6	6b d1 28	 imul	 edx, ecx, 40
  001a9	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  001af	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _dcterm$27[ebp]
  001b5	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
  001b8	ba 04 00 00 00	 mov	 edx, 4
  001bd	c1 e2 05	 shl	 edx, 5
  001c0	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  001c6	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _dcterm$27[ebp]
  001cc	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
  001cf	ba 04 00 00 00	 mov	 edx, 4
  001d4	6b c2 18	 imul	 eax, edx, 24
  001d7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  001dd	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dcterm$27[ebp]
  001e3	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  001e6	b8 04 00 00 00	 mov	 eax, 4
  001eb	c1 e0 04	 shl	 eax, 4
  001ee	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  001f4	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dcterm$27[ebp]
  001fa	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  001fd	b8 04 00 00 00	 mov	 eax, 4
  00202	c1 e0 03	 shl	 eax, 3
  00205	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0020b	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _dcterm$27[ebp]
  00211	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	6b c8 00	 imul	 ecx, eax, 0
  0021c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  00222	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _dcterm$27[ebp]
  00228	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 1031 :       } else {

  0022b	e9 b1 04 00 00	 jmp	 $LN9@idct_block
$LN8@idct_block:

; 1032 :          IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],

  00230	b9 02 00 00 00	 mov	 ecx, 2
  00235	c1 e1 04	 shl	 ecx, 4
  00238	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  0023e	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00242	b9 01 00 00 00	 mov	 ecx, 1
  00247	c1 e1 04	 shl	 ecx, 4
  0024a	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  00250	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00254	0f af c1	 imul	 eax, ecx
  00257	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _p2$21[ebp], eax
  0025d	ba 02 00 00 00	 mov	 edx, 2
  00262	6b c2 30	 imul	 eax, edx, 48
  00265	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _d$[ebp]
  0026b	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0026f	b8 01 00 00 00	 mov	 eax, 1
  00274	6b c8 30	 imul	 ecx, eax, 48
  00277	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _dq$[ebp]
  0027d	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00281	0f af d1	 imul	 edx, ecx
  00284	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _p3$20[ebp], edx
  0028a	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _p2$21[ebp]
  00290	03 95 c0 fe ff
	ff		 add	 edx, DWORD PTR _p3$20[ebp]
  00296	69 c2 a9 08 00
	00		 imul	 eax, edx, 2217
  0029c	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _p1$22[ebp], eax
  002a2	69 8d c0 fe ff
	ff 71 e2 ff ff	 imul	 ecx, DWORD PTR _p3$20[ebp], -7567
  002ac	03 8d c8 fe ff
	ff		 add	 ecx, DWORD PTR _p1$22[ebp]
  002b2	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _t2$24[ebp], ecx
  002b8	69 95 c4 fe ff
	ff 3f 0c 00 00	 imul	 edx, DWORD PTR _p2$21[ebp], 3135
  002c2	03 95 c8 fe ff
	ff		 add	 edx, DWORD PTR _p1$22[ebp]
  002c8	89 95 cc fe ff
	ff		 mov	 DWORD PTR _t3$23[ebp], edx
  002ce	b8 02 00 00 00	 mov	 eax, 2
  002d3	6b c8 00	 imul	 ecx, eax, 0
  002d6	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  002dc	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  002e0	b9 01 00 00 00	 mov	 ecx, 1
  002e5	6b d1 00	 imul	 edx, ecx, 0
  002e8	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _dq$[ebp]
  002ee	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  002f2	0f af c2	 imul	 eax, edx
  002f5	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _p2$21[ebp], eax
  002fb	b8 02 00 00 00	 mov	 eax, 2
  00300	c1 e0 05	 shl	 eax, 5
  00303	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _d$[ebp]
  00309	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0030d	b8 01 00 00 00	 mov	 eax, 1
  00312	c1 e0 05	 shl	 eax, 5
  00315	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _dq$[ebp]
  0031b	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  0031f	0f af d0	 imul	 edx, eax
  00322	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _p3$20[ebp], edx
  00328	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _p2$21[ebp]
  0032e	03 8d c0 fe ff
	ff		 add	 ecx, DWORD PTR _p3$20[ebp]
  00334	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00337	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _t0$26[ebp], ecx
  0033d	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _p2$21[ebp]
  00343	2b 95 c0 fe ff
	ff		 sub	 edx, DWORD PTR _p3$20[ebp]
  00349	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  0034c	89 95 d4 fe ff
	ff		 mov	 DWORD PTR _t1$25[ebp], edx
  00352	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _t0$26[ebp]
  00358	03 85 cc fe ff
	ff		 add	 eax, DWORD PTR _t3$23[ebp]
  0035e	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _x0$17[ebp], eax
  00364	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _t0$26[ebp]
  0036a	2b 8d cc fe ff
	ff		 sub	 ecx, DWORD PTR _t3$23[ebp]
  00370	89 8d a8 fe ff
	ff		 mov	 DWORD PTR _x3$14[ebp], ecx
  00376	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _t1$25[ebp]
  0037c	03 95 d0 fe ff
	ff		 add	 edx, DWORD PTR _t2$24[ebp]
  00382	89 95 b0 fe ff
	ff		 mov	 DWORD PTR _x1$16[ebp], edx
  00388	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _t1$25[ebp]
  0038e	2b 85 d0 fe ff
	ff		 sub	 eax, DWORD PTR _t2$24[ebp]
  00394	89 85 ac fe ff
	ff		 mov	 DWORD PTR _x2$15[ebp], eax
  0039a	b9 02 00 00 00	 mov	 ecx, 2
  0039f	6b d1 38	 imul	 edx, ecx, 56
  003a2	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  003a8	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  003ac	ba 01 00 00 00	 mov	 edx, 1
  003b1	6b c2 38	 imul	 eax, edx, 56
  003b4	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  003ba	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  003be	0f af c8	 imul	 ecx, eax
  003c1	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _t0$26[ebp], ecx
  003c7	b9 02 00 00 00	 mov	 ecx, 2
  003cc	6b d1 28	 imul	 edx, ecx, 40
  003cf	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  003d5	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  003d9	ba 01 00 00 00	 mov	 edx, 1
  003de	6b c2 28	 imul	 eax, edx, 40
  003e1	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  003e7	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  003eb	0f af c8	 imul	 ecx, eax
  003ee	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _t1$25[ebp], ecx
  003f4	b9 02 00 00 00	 mov	 ecx, 2
  003f9	6b d1 18	 imul	 edx, ecx, 24
  003fc	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00402	0f bf 0c 10	 movsx	 ecx, WORD PTR [eax+edx]
  00406	ba 01 00 00 00	 mov	 edx, 1
  0040b	6b c2 18	 imul	 eax, edx, 24
  0040e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  00414	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00418	0f af c8	 imul	 ecx, eax
  0041b	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _t2$24[ebp], ecx
  00421	b9 02 00 00 00	 mov	 ecx, 2
  00426	c1 e1 03	 shl	 ecx, 3
  00429	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _d$[ebp]
  0042f	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00433	b9 01 00 00 00	 mov	 ecx, 1
  00438	c1 e1 03	 shl	 ecx, 3
  0043b	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dq$[ebp]
  00441	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00445	0f af c1	 imul	 eax, ecx
  00448	89 85 cc fe ff
	ff		 mov	 DWORD PTR _t3$23[ebp], eax
  0044e	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _t0$26[ebp]
  00454	03 95 d0 fe ff
	ff		 add	 edx, DWORD PTR _t2$24[ebp]
  0045a	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _p3$20[ebp], edx
  00460	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _t1$25[ebp]
  00466	03 85 cc fe ff
	ff		 add	 eax, DWORD PTR _t3$23[ebp]
  0046c	89 85 bc fe ff
	ff		 mov	 DWORD PTR _p4$19[ebp], eax
  00472	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _t0$26[ebp]
  00478	03 8d cc fe ff
	ff		 add	 ecx, DWORD PTR _t3$23[ebp]
  0047e	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _p1$22[ebp], ecx
  00484	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _t1$25[ebp]
  0048a	03 95 d0 fe ff
	ff		 add	 edx, DWORD PTR _t2$24[ebp]
  00490	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _p2$21[ebp], edx
  00496	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _p3$20[ebp]
  0049c	03 85 bc fe ff
	ff		 add	 eax, DWORD PTR _p4$19[ebp]
  004a2	69 c8 d0 12 00
	00		 imul	 ecx, eax, 4816
  004a8	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _p5$18[ebp], ecx
  004ae	69 95 d8 fe ff
	ff c7 04 00 00	 imul	 edx, DWORD PTR _t0$26[ebp], 1223
  004b8	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _t0$26[ebp], edx
  004be	69 85 d4 fe ff
	ff da 20 00 00	 imul	 eax, DWORD PTR _t1$25[ebp], 8410
  004c8	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _t1$25[ebp], eax
  004ce	69 8d d0 fe ff
	ff 2a 31 00 00	 imul	 ecx, DWORD PTR _t2$24[ebp], 12586
  004d8	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _t2$24[ebp], ecx
  004de	69 95 cc fe ff
	ff 05 18 00 00	 imul	 edx, DWORD PTR _t3$23[ebp], 6149
  004e8	89 95 cc fe ff
	ff		 mov	 DWORD PTR _t3$23[ebp], edx
  004ee	69 85 c8 fe ff
	ff 9b f1 ff ff	 imul	 eax, DWORD PTR _p1$22[ebp], -3685
  004f8	03 85 b8 fe ff
	ff		 add	 eax, DWORD PTR _p5$18[ebp]
  004fe	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _p1$22[ebp], eax
  00504	69 8d c4 fe ff
	ff ff d6 ff ff	 imul	 ecx, DWORD PTR _p2$21[ebp], -10497
  0050e	03 8d b8 fe ff
	ff		 add	 ecx, DWORD PTR _p5$18[ebp]
  00514	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _p2$21[ebp], ecx
  0051a	69 95 c0 fe ff
	ff 9e e0 ff ff	 imul	 edx, DWORD PTR _p3$20[ebp], -8034
  00524	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _p3$20[ebp], edx
  0052a	69 85 bc fe ff
	ff c3 f9 ff ff	 imul	 eax, DWORD PTR _p4$19[ebp], -1597
  00534	89 85 bc fe ff
	ff		 mov	 DWORD PTR _p4$19[ebp], eax
  0053a	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _p1$22[ebp]
  00540	03 8d bc fe ff
	ff		 add	 ecx, DWORD PTR _p4$19[ebp]
  00546	03 8d cc fe ff
	ff		 add	 ecx, DWORD PTR _t3$23[ebp]
  0054c	89 8d cc fe ff
	ff		 mov	 DWORD PTR _t3$23[ebp], ecx
  00552	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _p2$21[ebp]
  00558	03 95 c0 fe ff
	ff		 add	 edx, DWORD PTR _p3$20[ebp]
  0055e	03 95 d0 fe ff
	ff		 add	 edx, DWORD PTR _t2$24[ebp]
  00564	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _t2$24[ebp], edx
  0056a	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _p2$21[ebp]
  00570	03 85 bc fe ff
	ff		 add	 eax, DWORD PTR _p4$19[ebp]
  00576	03 85 d4 fe ff
	ff		 add	 eax, DWORD PTR _t1$25[ebp]
  0057c	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _t1$25[ebp], eax
  00582	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _p1$22[ebp]
  00588	03 8d c0 fe ff
	ff		 add	 ecx, DWORD PTR _p3$20[ebp]
  0058e	03 8d d8 fe ff
	ff		 add	 ecx, DWORD PTR _t0$26[ebp]
  00594	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _t0$26[ebp], ecx

; 1033 :                  d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
; 1034 :          // constants scaled things up by 1<<12; let's bring them back
; 1035 :          // down, but keep 2 extra bits of precision
; 1036 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

  0059a	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _x0$17[ebp]
  005a0	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  005a6	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _x0$17[ebp], edx
  005ac	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _x1$16[ebp]
  005b2	05 00 02 00 00	 add	 eax, 512		; 00000200H
  005b7	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _x1$16[ebp], eax
  005bd	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _x2$15[ebp]
  005c3	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  005c9	89 8d ac fe ff
	ff		 mov	 DWORD PTR _x2$15[ebp], ecx
  005cf	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _x3$14[ebp]
  005d5	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  005db	89 95 a8 fe ff
	ff		 mov	 DWORD PTR _x3$14[ebp], edx

; 1037 :          v[ 0] = (x0+t3) >> 10;

  005e1	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _x0$17[ebp]
  005e7	03 85 cc fe ff
	ff		 add	 eax, DWORD PTR _t3$23[ebp]
  005ed	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  005f0	b9 04 00 00 00	 mov	 ecx, 4
  005f5	6b d1 00	 imul	 edx, ecx, 0
  005f8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  005fe	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 1038 :          v[56] = (x0-t3) >> 10;

  00601	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _x0$17[ebp]
  00607	2b 95 cc fe ff
	ff		 sub	 edx, DWORD PTR _t3$23[ebp]
  0060d	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  00610	b8 04 00 00 00	 mov	 eax, 4
  00615	6b c8 38	 imul	 ecx, eax, 56
  00618	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0061e	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 1039 :          v[ 8] = (x1+t2) >> 10;

  00621	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _x1$16[ebp]
  00627	03 8d d0 fe ff
	ff		 add	 ecx, DWORD PTR _t2$24[ebp]
  0062d	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  00630	ba 04 00 00 00	 mov	 edx, 4
  00635	c1 e2 03	 shl	 edx, 3
  00638	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0063e	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 1040 :          v[48] = (x1-t2) >> 10;

  00641	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _x1$16[ebp]
  00647	2b 8d d0 fe ff
	ff		 sub	 ecx, DWORD PTR _t2$24[ebp]
  0064d	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  00650	ba 04 00 00 00	 mov	 edx, 4
  00655	6b c2 30	 imul	 eax, edx, 48
  00658	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  0065e	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 1041 :          v[16] = (x2+t1) >> 10;

  00661	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _x2$15[ebp]
  00667	03 85 d4 fe ff
	ff		 add	 eax, DWORD PTR _t1$25[ebp]
  0066d	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00670	b9 04 00 00 00	 mov	 ecx, 4
  00675	c1 e1 04	 shl	 ecx, 4
  00678	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  0067e	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 1042 :          v[40] = (x2-t1) >> 10;

  00681	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _x2$15[ebp]
  00687	2b 85 d4 fe ff
	ff		 sub	 eax, DWORD PTR _t1$25[ebp]
  0068d	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00690	b9 04 00 00 00	 mov	 ecx, 4
  00695	6b d1 28	 imul	 edx, ecx, 40
  00698	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0069e	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 1043 :          v[24] = (x3+t0) >> 10;

  006a1	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _x3$14[ebp]
  006a7	03 95 d8 fe ff
	ff		 add	 edx, DWORD PTR _t0$26[ebp]
  006ad	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  006b0	b8 04 00 00 00	 mov	 eax, 4
  006b5	6b c8 18	 imul	 ecx, eax, 24
  006b8	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  006be	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 1044 :          v[32] = (x3-t0) >> 10;

  006c1	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _x3$14[ebp]
  006c7	2b 8d d8 fe ff
	ff		 sub	 ecx, DWORD PTR _t0$26[ebp]
  006cd	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  006d0	ba 04 00 00 00	 mov	 edx, 4
  006d5	c1 e2 05	 shl	 edx, 5
  006d8	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  006de	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
$LN9@idct_block:

; 1045 :       }
; 1046 :    }

  006e1	e9 67 f9 ff ff	 jmp	 $LN2@idct_block
$LN3@idct_block:

; 1047 : 
; 1048 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

  006e6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  006ed	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _val$[ebp]
  006f3	89 8d ec fe ff
	ff		 mov	 DWORD PTR _v$[ebp], ecx
  006f9	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  006fc	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _o$[ebp], edx
  00702	eb 27		 jmp	 SHORT $LN7@idct_block
$LN5@idct_block:
  00704	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00707	83 c0 01	 add	 eax, 1
  0070a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0070d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00713	83 c1 20	 add	 ecx, 32			; 00000020H
  00716	89 8d ec fe ff
	ff		 mov	 DWORD PTR _v$[ebp], ecx
  0071c	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _o$[ebp]
  00722	03 55 0c	 add	 edx, DWORD PTR _out_stride$[ebp]
  00725	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _o$[ebp], edx
$LN7@idct_block:
  0072b	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  0072f	0f 8d 4b 04 00
	00		 jge	 $LN1@idct_block

; 1049 :       // no fast case since the first 1D IDCT spread components out
; 1050 :       IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

  00735	b8 04 00 00 00	 mov	 eax, 4
  0073a	d1 e0		 shl	 eax, 1
  0073c	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00742	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00745	89 95 90 fe ff
	ff		 mov	 DWORD PTR _p2$8[ebp], edx
  0074b	b8 04 00 00 00	 mov	 eax, 4
  00750	6b c8 06	 imul	 ecx, eax, 6
  00753	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  00759	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0075c	89 85 8c fe ff
	ff		 mov	 DWORD PTR _p3$7[ebp], eax
  00762	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _p2$8[ebp]
  00768	03 8d 8c fe ff
	ff		 add	 ecx, DWORD PTR _p3$7[ebp]
  0076e	69 d1 a9 08 00
	00		 imul	 edx, ecx, 2217
  00774	89 95 94 fe ff
	ff		 mov	 DWORD PTR _p1$9[ebp], edx
  0077a	69 85 8c fe ff
	ff 71 e2 ff ff	 imul	 eax, DWORD PTR _p3$7[ebp], -7567
  00784	03 85 94 fe ff
	ff		 add	 eax, DWORD PTR _p1$9[ebp]
  0078a	89 85 9c fe ff
	ff		 mov	 DWORD PTR _t2$11[ebp], eax
  00790	69 8d 90 fe ff
	ff 3f 0c 00 00	 imul	 ecx, DWORD PTR _p2$8[ebp], 3135
  0079a	03 8d 94 fe ff
	ff		 add	 ecx, DWORD PTR _p1$9[ebp]
  007a0	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _t3$10[ebp], ecx
  007a6	ba 04 00 00 00	 mov	 edx, 4
  007ab	6b c2 00	 imul	 eax, edx, 0
  007ae	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  007b4	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  007b7	89 95 90 fe ff
	ff		 mov	 DWORD PTR _p2$8[ebp], edx
  007bd	b8 04 00 00 00	 mov	 eax, 4
  007c2	c1 e0 02	 shl	 eax, 2
  007c5	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  007cb	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  007ce	89 95 8c fe ff
	ff		 mov	 DWORD PTR _p3$7[ebp], edx
  007d4	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _p2$8[ebp]
  007da	03 85 8c fe ff
	ff		 add	 eax, DWORD PTR _p3$7[ebp]
  007e0	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  007e3	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _t0$13[ebp], eax
  007e9	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _p2$8[ebp]
  007ef	2b 8d 8c fe ff
	ff		 sub	 ecx, DWORD PTR _p3$7[ebp]
  007f5	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  007f8	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _t1$12[ebp], ecx
  007fe	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _t0$13[ebp]
  00804	03 95 98 fe ff
	ff		 add	 edx, DWORD PTR _t3$10[ebp]
  0080a	89 95 80 fe ff
	ff		 mov	 DWORD PTR _x0$4[ebp], edx
  00810	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _t0$13[ebp]
  00816	2b 85 98 fe ff
	ff		 sub	 eax, DWORD PTR _t3$10[ebp]
  0081c	89 85 74 fe ff
	ff		 mov	 DWORD PTR _x3$1[ebp], eax
  00822	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _t1$12[ebp]
  00828	03 8d 9c fe ff
	ff		 add	 ecx, DWORD PTR _t2$11[ebp]
  0082e	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x1$3[ebp], ecx
  00834	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _t1$12[ebp]
  0083a	2b 95 9c fe ff
	ff		 sub	 edx, DWORD PTR _t2$11[ebp]
  00840	89 95 78 fe ff
	ff		 mov	 DWORD PTR _x2$2[ebp], edx
  00846	b8 04 00 00 00	 mov	 eax, 4
  0084b	6b c8 07	 imul	 ecx, eax, 7
  0084e	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _v$[ebp]
  00854	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00857	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _t0$13[ebp], eax
  0085d	b9 04 00 00 00	 mov	 ecx, 4
  00862	6b d1 05	 imul	 edx, ecx, 5
  00865	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0086b	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0086e	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _t1$12[ebp], ecx
  00874	ba 04 00 00 00	 mov	 edx, 4
  00879	6b c2 03	 imul	 eax, edx, 3
  0087c	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00882	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00885	89 95 9c fe ff
	ff		 mov	 DWORD PTR _t2$11[ebp], edx
  0088b	b8 04 00 00 00	 mov	 eax, 4
  00890	c1 e0 00	 shl	 eax, 0
  00893	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00899	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0089c	89 95 98 fe ff
	ff		 mov	 DWORD PTR _t3$10[ebp], edx
  008a2	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _t0$13[ebp]
  008a8	03 85 9c fe ff
	ff		 add	 eax, DWORD PTR _t2$11[ebp]
  008ae	89 85 8c fe ff
	ff		 mov	 DWORD PTR _p3$7[ebp], eax
  008b4	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _t1$12[ebp]
  008ba	03 8d 98 fe ff
	ff		 add	 ecx, DWORD PTR _t3$10[ebp]
  008c0	89 8d 88 fe ff
	ff		 mov	 DWORD PTR _p4$6[ebp], ecx
  008c6	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _t0$13[ebp]
  008cc	03 95 98 fe ff
	ff		 add	 edx, DWORD PTR _t3$10[ebp]
  008d2	89 95 94 fe ff
	ff		 mov	 DWORD PTR _p1$9[ebp], edx
  008d8	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _t1$12[ebp]
  008de	03 85 9c fe ff
	ff		 add	 eax, DWORD PTR _t2$11[ebp]
  008e4	89 85 90 fe ff
	ff		 mov	 DWORD PTR _p2$8[ebp], eax
  008ea	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _p3$7[ebp]
  008f0	03 8d 88 fe ff
	ff		 add	 ecx, DWORD PTR _p4$6[ebp]
  008f6	69 d1 d0 12 00
	00		 imul	 edx, ecx, 4816
  008fc	89 95 84 fe ff
	ff		 mov	 DWORD PTR _p5$5[ebp], edx
  00902	69 85 a4 fe ff
	ff c7 04 00 00	 imul	 eax, DWORD PTR _t0$13[ebp], 1223
  0090c	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _t0$13[ebp], eax
  00912	69 8d a0 fe ff
	ff da 20 00 00	 imul	 ecx, DWORD PTR _t1$12[ebp], 8410
  0091c	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _t1$12[ebp], ecx
  00922	69 95 9c fe ff
	ff 2a 31 00 00	 imul	 edx, DWORD PTR _t2$11[ebp], 12586
  0092c	89 95 9c fe ff
	ff		 mov	 DWORD PTR _t2$11[ebp], edx
  00932	69 85 98 fe ff
	ff 05 18 00 00	 imul	 eax, DWORD PTR _t3$10[ebp], 6149
  0093c	89 85 98 fe ff
	ff		 mov	 DWORD PTR _t3$10[ebp], eax
  00942	69 8d 94 fe ff
	ff 9b f1 ff ff	 imul	 ecx, DWORD PTR _p1$9[ebp], -3685
  0094c	03 8d 84 fe ff
	ff		 add	 ecx, DWORD PTR _p5$5[ebp]
  00952	89 8d 94 fe ff
	ff		 mov	 DWORD PTR _p1$9[ebp], ecx
  00958	69 95 90 fe ff
	ff ff d6 ff ff	 imul	 edx, DWORD PTR _p2$8[ebp], -10497
  00962	03 95 84 fe ff
	ff		 add	 edx, DWORD PTR _p5$5[ebp]
  00968	89 95 90 fe ff
	ff		 mov	 DWORD PTR _p2$8[ebp], edx
  0096e	69 85 8c fe ff
	ff 9e e0 ff ff	 imul	 eax, DWORD PTR _p3$7[ebp], -8034
  00978	89 85 8c fe ff
	ff		 mov	 DWORD PTR _p3$7[ebp], eax
  0097e	69 8d 88 fe ff
	ff c3 f9 ff ff	 imul	 ecx, DWORD PTR _p4$6[ebp], -1597
  00988	89 8d 88 fe ff
	ff		 mov	 DWORD PTR _p4$6[ebp], ecx
  0098e	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _p1$9[ebp]
  00994	03 95 88 fe ff
	ff		 add	 edx, DWORD PTR _p4$6[ebp]
  0099a	03 95 98 fe ff
	ff		 add	 edx, DWORD PTR _t3$10[ebp]
  009a0	89 95 98 fe ff
	ff		 mov	 DWORD PTR _t3$10[ebp], edx
  009a6	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _p2$8[ebp]
  009ac	03 85 8c fe ff
	ff		 add	 eax, DWORD PTR _p3$7[ebp]
  009b2	03 85 9c fe ff
	ff		 add	 eax, DWORD PTR _t2$11[ebp]
  009b8	89 85 9c fe ff
	ff		 mov	 DWORD PTR _t2$11[ebp], eax
  009be	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _p2$8[ebp]
  009c4	03 8d 88 fe ff
	ff		 add	 ecx, DWORD PTR _p4$6[ebp]
  009ca	03 8d a0 fe ff
	ff		 add	 ecx, DWORD PTR _t1$12[ebp]
  009d0	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _t1$12[ebp], ecx
  009d6	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _p1$9[ebp]
  009dc	03 95 8c fe ff
	ff		 add	 edx, DWORD PTR _p3$7[ebp]
  009e2	03 95 a4 fe ff
	ff		 add	 edx, DWORD PTR _t0$13[ebp]
  009e8	89 95 a4 fe ff
	ff		 mov	 DWORD PTR _t0$13[ebp], edx

; 1051 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 1052 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 1053 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 1054 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 1055 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 1056 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 1057 :       x0 += 65536 + (128<<17);

  009ee	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _x0$4[ebp]
  009f4	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  009f9	89 85 80 fe ff
	ff		 mov	 DWORD PTR _x0$4[ebp], eax

; 1058 :       x1 += 65536 + (128<<17);

  009ff	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _x1$3[ebp]
  00a05	81 c1 00 00 01
	01		 add	 ecx, 16842752		; 01010000H
  00a0b	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _x1$3[ebp], ecx

; 1059 :       x2 += 65536 + (128<<17);

  00a11	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR _x2$2[ebp]
  00a17	81 c2 00 00 01
	01		 add	 edx, 16842752		; 01010000H
  00a1d	89 95 78 fe ff
	ff		 mov	 DWORD PTR _x2$2[ebp], edx

; 1060 :       x3 += 65536 + (128<<17);

  00a23	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _x3$1[ebp]
  00a29	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00a2e	89 85 74 fe ff
	ff		 mov	 DWORD PTR _x3$1[ebp], eax

; 1061 :       // tried computing the shifts into temps, or'ing the temps to see
; 1062 :       // if any were out of range, but that was slower
; 1063 :       o[0] = clamp((x0+t3) >> 17);

  00a34	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _x0$4[ebp]
  00a3a	03 8d 98 fe ff
	ff		 add	 ecx, DWORD PTR _t3$10[ebp]
  00a40	c1 f9 11	 sar	 ecx, 17			; 00000011H
  00a43	51		 push	 ecx
  00a44	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00a49	83 c4 04	 add	 esp, 4
  00a4c	ba 01 00 00 00	 mov	 edx, 1
  00a51	6b ca 00	 imul	 ecx, edx, 0
  00a54	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _o$[ebp]
  00a5a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1064 :       o[7] = clamp((x0-t3) >> 17);

  00a5d	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _x0$4[ebp]
  00a63	2b 85 98 fe ff
	ff		 sub	 eax, DWORD PTR _t3$10[ebp]
  00a69	c1 f8 11	 sar	 eax, 17			; 00000011H
  00a6c	50		 push	 eax
  00a6d	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00a72	83 c4 04	 add	 esp, 4
  00a75	b9 01 00 00 00	 mov	 ecx, 1
  00a7a	6b d1 07	 imul	 edx, ecx, 7
  00a7d	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _o$[ebp]
  00a83	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1065 :       o[1] = clamp((x1+t2) >> 17);

  00a86	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _x1$3[ebp]
  00a8c	03 95 9c fe ff
	ff		 add	 edx, DWORD PTR _t2$11[ebp]
  00a92	c1 fa 11	 sar	 edx, 17			; 00000011H
  00a95	52		 push	 edx
  00a96	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00a9b	83 c4 04	 add	 esp, 4
  00a9e	b9 01 00 00 00	 mov	 ecx, 1
  00aa3	c1 e1 00	 shl	 ecx, 0
  00aa6	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _o$[ebp]
  00aac	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1066 :       o[6] = clamp((x1-t2) >> 17);

  00aaf	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _x1$3[ebp]
  00ab5	2b 85 9c fe ff
	ff		 sub	 eax, DWORD PTR _t2$11[ebp]
  00abb	c1 f8 11	 sar	 eax, 17			; 00000011H
  00abe	50		 push	 eax
  00abf	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00ac4	83 c4 04	 add	 esp, 4
  00ac7	b9 01 00 00 00	 mov	 ecx, 1
  00acc	6b d1 06	 imul	 edx, ecx, 6
  00acf	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _o$[ebp]
  00ad5	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1067 :       o[2] = clamp((x2+t1) >> 17);

  00ad8	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR _x2$2[ebp]
  00ade	03 95 a0 fe ff
	ff		 add	 edx, DWORD PTR _t1$12[ebp]
  00ae4	c1 fa 11	 sar	 edx, 17			; 00000011H
  00ae7	52		 push	 edx
  00ae8	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00aed	83 c4 04	 add	 esp, 4
  00af0	b9 01 00 00 00	 mov	 ecx, 1
  00af5	d1 e1		 shl	 ecx, 1
  00af7	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _o$[ebp]
  00afd	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1068 :       o[5] = clamp((x2-t1) >> 17);

  00b00	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _x2$2[ebp]
  00b06	2b 85 a0 fe ff
	ff		 sub	 eax, DWORD PTR _t1$12[ebp]
  00b0c	c1 f8 11	 sar	 eax, 17			; 00000011H
  00b0f	50		 push	 eax
  00b10	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00b15	83 c4 04	 add	 esp, 4
  00b18	b9 01 00 00 00	 mov	 ecx, 1
  00b1d	6b d1 05	 imul	 edx, ecx, 5
  00b20	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _o$[ebp]
  00b26	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1069 :       o[3] = clamp((x3+t0) >> 17);

  00b29	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _x3$1[ebp]
  00b2f	03 95 a4 fe ff
	ff		 add	 edx, DWORD PTR _t0$13[ebp]
  00b35	c1 fa 11	 sar	 edx, 17			; 00000011H
  00b38	52		 push	 edx
  00b39	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00b3e	83 c4 04	 add	 esp, 4
  00b41	b9 01 00 00 00	 mov	 ecx, 1
  00b46	6b d1 03	 imul	 edx, ecx, 3
  00b49	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _o$[ebp]
  00b4f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1070 :       o[4] = clamp((x3-t0) >> 17);

  00b52	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _x3$1[ebp]
  00b58	2b 95 a4 fe ff
	ff		 sub	 edx, DWORD PTR _t0$13[ebp]
  00b5e	c1 fa 11	 sar	 edx, 17			; 00000011H
  00b61	52		 push	 edx
  00b62	e8 00 00 00 00	 call	 ?clamp@@YAEH@Z		; clamp
  00b67	83 c4 04	 add	 esp, 4
  00b6a	b9 01 00 00 00	 mov	 ecx, 1
  00b6f	c1 e1 02	 shl	 ecx, 2
  00b72	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _o$[ebp]
  00b78	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1071 :    }

  00b7b	e9 84 fb ff ff	 jmp	 $LN5@idct_block
$LN1@idct_block:

; 1072 : }

  00b80	52		 push	 edx
  00b81	8b cd		 mov	 ecx, ebp
  00b83	50		 push	 eax
  00b84	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@idct_block
  00b8a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b8f	58		 pop	 eax
  00b90	5a		 pop	 edx
  00b91	5f		 pop	 edi
  00b92	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b95	33 cd		 xor	 ecx, ebp
  00b97	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b9c	81 c4 8c 01 00
	00		 add	 esp, 396		; 0000018cH
  00ba2	3b ec		 cmp	 ebp, esp
  00ba4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ba9	8b e5		 mov	 esp, ebp
  00bab	5d		 pop	 ebp
  00bac	c3		 ret	 0
  00bad	0f 1f 00	 npad	 3
$LN13@idct_block:
  00bb0	01 00 00 00	 DD	 1
  00bb4	00 00 00 00	 DD	 $LN12@idct_block
$LN12@idct_block:
  00bb8	f4 fe ff ff	 DD	 -268			; fffffef4H
  00bbc	00 01 00 00	 DD	 256			; 00000100H
  00bc0	00 00 00 00	 DD	 $LN11@idct_block
$LN11@idct_block:
  00bc4	76		 DB	 118			; 00000076H
  00bc5	61		 DB	 97			; 00000061H
  00bc6	6c		 DB	 108			; 0000006cH
  00bc7	00		 DB	 0
?idct_block@@YAXPAEHQAF0@Z ENDP				; idct_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_x$ = -1						; size = 1
_j$ = 8							; size = 4
?get_marker@@YAEPAUjpeg@@@Z PROC			; get_marker

; 1088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1089 :    uint8 x;
; 1090 :    if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }

  0000b	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0000e	0f b6 88 84 36
	00 00		 movzx	 ecx, BYTE PTR [eax+13956]
  00015	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0001b	74 1b		 je	 SHORT $LN4@get_marker
  0001d	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00020	8a 82 84 36 00
	00		 mov	 al, BYTE PTR [edx+13956]
  00026	88 45 ff	 mov	 BYTE PTR _x$[ebp], al
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  0002c	c6 81 84 36 00
	00 ff		 mov	 BYTE PTR [ecx+13956], 255 ; 000000ffH
  00033	8a 45 ff	 mov	 al, BYTE PTR _x$[ebp]
  00036	eb 43		 jmp	 SHORT $LN1@get_marker
$LN4@get_marker:

; 1091 :    x = get8u(j->s);

  00038	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00043	83 c4 04	 add	 esp, 4
  00046	88 45 ff	 mov	 BYTE PTR _x$[ebp], al

; 1092 :    if (x != 0xff) return MARKER_none;

  00049	0f b6 4d ff	 movzx	 ecx, BYTE PTR _x$[ebp]
  0004d	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00053	74 04		 je	 SHORT $LN2@get_marker
  00055	0c ff		 or	 al, 255			; 000000ffH
  00057	eb 22		 jmp	 SHORT $LN1@get_marker
$LN2@get_marker:

; 1093 :    while (x == 0xff)

  00059	0f b6 55 ff	 movzx	 edx, BYTE PTR _x$[ebp]
  0005d	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00063	75 13		 jne	 SHORT $LN3@get_marker

; 1094 :       x = get8u(j->s);

  00065	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00070	83 c4 04	 add	 esp, 4
  00073	88 45 ff	 mov	 BYTE PTR _x$[ebp], al
  00076	eb e1		 jmp	 SHORT $LN2@get_marker
$LN3@get_marker:

; 1095 :    return x;

  00078	8a 45 ff	 mov	 al, BYTE PTR _x$[ebp]
$LN1@get_marker:

; 1096 : }

  0007b	83 c4 04	 add	 esp, 4
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?get_marker@@YAEPAUjpeg@@@Z ENDP			; get_marker
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv84 = -4						; size = 4
_j$ = 8							; size = 4
?reset@@YAXPAUjpeg@@@Z PROC				; reset

; 1105 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1106 :    j->code_bits = 0;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0000e	c7 80 80 36 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+13952], 0

; 1107 :    j->code_buffer = 0;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  0001b	c7 81 7c 36 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+13948], 0

; 1108 :    j->nomore = 0;

  00025	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00028	c7 82 88 36 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+13960], 0

; 1109 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;

  00032	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00037	d1 e0		 shl	 eax, 1
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  0003c	c7 84 01 b4 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+13748], 0
  00047	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  0004c	c1 e2 00	 shl	 edx, 0
  0004f	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00052	c7 84 10 b4 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+13748], 0
  0005d	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00062	6b d1 00	 imul	 edx, ecx, 0
  00065	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00068	c7 84 10 b4 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+13748], 0

; 1110 :    j->marker = MARKER_none;

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00076	c6 81 84 36 00
	00 ff		 mov	 BYTE PTR [ecx+13956], 255 ; 000000ffH

; 1111 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

  0007d	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00080	83 ba a0 36 00
	00 00		 cmp	 DWORD PTR [edx+13984], 0
  00087	74 0e		 je	 SHORT $LN3@reset
  00089	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0008c	8b 88 a0 36 00
	00		 mov	 ecx, DWORD PTR [eax+13984]
  00092	89 4d fc	 mov	 DWORD PTR tv84[ebp], ecx
  00095	eb 07		 jmp	 SHORT $LN4@reset
$LN3@reset:
  00097	c7 45 fc ff ff
	ff 7f		 mov	 DWORD PTR tv84[ebp], 2147483647 ; 7fffffffH
$LN4@reset:
  0009e	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000a1	8b 45 fc	 mov	 eax, DWORD PTR tv84[ebp]
  000a4	89 82 a4 36 00
	00		 mov	 DWORD PTR [edx+13988], eax

; 1112 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 1113 :    // since we don't even allow 1<<30 pixels
; 1114 : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?reset@@YAXPAUjpeg@@@Z ENDP				; reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv268 = -336						; size = 4
tv169 = -332						; size = 4
_y2$1 = -328						; size = 4
_x2$2 = -324						; size = 4
_n$3 = -320						; size = 4
_data$4 = -312						; size = 128
_y$5 = -180						; size = 4
_x$6 = -176						; size = 4
_k$7 = -172						; size = 4
_j$8 = -168						; size = 4
_i$9 = -164						; size = 4
_h$10 = -160						; size = 4
_w$11 = -156						; size = 4
_n$12 = -152						; size = 4
_data$13 = -144						; size = 128
_j$14 = -12						; size = 4
_i$15 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
?parse_entropy_coded_data@@YAHPAUjpeg@@@Z PROC		; parse_entropy_coded_data

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	57		 push	 edi
  0000a	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00010	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1118 :    reset(z);

  00026	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?reset@@YAXPAUjpeg@@@Z	; reset
  0002f	83 c4 04	 add	 esp, 4

; 1119 :    if (z->scan_n == 1) {

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00035	83 b9 8c 36 00
	00 01		 cmp	 DWORD PTR [ecx+13964], 1
  0003c	0f 85 f0 01 00
	00		 jne	 $LN23@parse_entr

; 1120 :       int i,j;
; 1121 :       #ifdef STBI_SIMD
; 1122 :       __declspec(align(16))
; 1123 :       #endif
; 1124 :       short data[64];
; 1125 :       int n = z->order[0];

  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	6b c2 00	 imul	 eax, edx, 0
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0004d	8b 94 01 90 36
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13968]
  00054	89 95 68 ff ff
	ff		 mov	 DWORD PTR _n$12[ebp], edx

; 1126 :       // non-interleaved data, we just need to process one block at a time,
; 1127 :       // in trivial scanline order
; 1128 :       // number of blocks to do just depends on how many actual "pixels" this
; 1129 :       // component has, independent of interleaved MCU blocking and such
; 1130 :       int w = (z->img_comp[n].x+7) >> 3;

  0005a	6b 85 68 ff ff
	ff 38		 imul	 eax, DWORD PTR _n$12[ebp], 56
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00064	8b 94 01 b8 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13752]
  0006b	83 c2 07	 add	 edx, 7
  0006e	c1 fa 03	 sar	 edx, 3
  00071	89 95 64 ff ff
	ff		 mov	 DWORD PTR _w$11[ebp], edx

; 1131 :       int h = (z->img_comp[n].y+7) >> 3;

  00077	6b 85 68 ff ff
	ff 38		 imul	 eax, DWORD PTR _n$12[ebp], 56
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00081	8b 94 01 bc 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13756]
  00088	83 c2 07	 add	 edx, 7
  0008b	c1 fa 03	 sar	 edx, 3
  0008e	89 95 60 ff ff
	ff		 mov	 DWORD PTR _h$10[ebp], edx

; 1132 :       for (j=0; j < h; ++j) {

  00094	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$14[ebp], 0
  0009b	eb 09		 jmp	 SHORT $LN4@parse_entr
$LN2@parse_entr:
  0009d	8b 45 f4	 mov	 eax, DWORD PTR _j$14[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f4	 mov	 DWORD PTR _j$14[ebp], eax
$LN4@parse_entr:
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _j$14[ebp]
  000a9	3b 8d 60 ff ff
	ff		 cmp	 ecx, DWORD PTR _h$10[ebp]
  000af	0f 8d 78 01 00
	00		 jge	 $LN3@parse_entr

; 1133 :          for (i=0; i < w; ++i) {

  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$15[ebp], 0
  000bc	eb 09		 jmp	 SHORT $LN7@parse_entr
$LN5@parse_entr:
  000be	8b 55 f8	 mov	 edx, DWORD PTR _i$15[ebp]
  000c1	83 c2 01	 add	 edx, 1
  000c4	89 55 f8	 mov	 DWORD PTR _i$15[ebp], edx
$LN7@parse_entr:
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _i$15[ebp]
  000ca	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _w$11[ebp]
  000d0	0f 8d 52 01 00
	00		 jge	 $LN6@parse_entr

; 1134 :             if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;

  000d6	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _n$12[ebp]
  000dc	51		 push	 ecx
  000dd	6b 95 68 ff ff
	ff 38		 imul	 edx, DWORD PTR _n$12[ebp], 56
  000e4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000e7	69 8c 10 b0 35
	00 00 90 06 00
	00		 imul	 ecx, DWORD PTR [eax+edx+13744], 1680
  000f2	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000f5	8d 84 0a 44 1a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+6724]
  000fc	50		 push	 eax
  000fd	6b 8d 68 ff ff
	ff 38		 imul	 ecx, DWORD PTR _n$12[ebp], 56
  00104	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00107	69 84 0a ac 35
	00 00 90 06 00
	00		 imul	 eax, DWORD PTR [edx+ecx+13740], 1680
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00115	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00119	52		 push	 edx
  0011a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _data$13[ebp]
  00120	50		 push	 eax
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?decode_block@@YAHPAUjpeg@@QAFPAUhuffman@@2H@Z ; decode_block
  0012a	83 c4 14	 add	 esp, 20			; 00000014H
  0012d	85 c0		 test	 eax, eax
  0012f	75 07		 jne	 SHORT $LN25@parse_entr
  00131	33 c0		 xor	 eax, eax
  00133	e9 c8 03 00 00	 jmp	 $LN1@parse_entr
$LN25@parse_entr:

; 1135 :             #ifdef STBI_SIMD
; 1136 :             stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
; 1137 :             #else
; 1138 :             idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);

  00138	6b 95 68 ff ff
	ff 38		 imul	 edx, DWORD PTR _n$12[ebp], 56
  0013f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00142	8b 8c 10 a8 35
	00 00		 mov	 ecx, DWORD PTR [eax+edx+13736]
  00149	c1 e1 06	 shl	 ecx, 6
  0014c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0014f	8d 84 0a 84 34
	00 00		 lea	 eax, DWORD PTR [edx+ecx+13444]
  00156	50		 push	 eax
  00157	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _data$13[ebp]
  0015d	51		 push	 ecx
  0015e	6b 95 68 ff ff
	ff 38		 imul	 edx, DWORD PTR _n$12[ebp], 56
  00165	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00168	8b 8c 10 c0 35
	00 00		 mov	 ecx, DWORD PTR [eax+edx+13760]
  0016f	51		 push	 ecx
  00170	6b 95 68 ff ff
	ff 38		 imul	 edx, DWORD PTR _n$12[ebp], 56
  00177	6b 85 68 ff ff
	ff 38		 imul	 eax, DWORD PTR _n$12[ebp], 56
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00181	8b 84 01 c0 35
	00 00		 mov	 eax, DWORD PTR [ecx+eax+13760]
  00188	0f af 45 f4	 imul	 eax, DWORD PTR _j$14[ebp]
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0018f	8b 94 11 c8 35
	00 00		 mov	 edx, DWORD PTR [ecx+edx+13768]
  00196	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  00199	8b 4d f8	 mov	 ecx, DWORD PTR _i$15[ebp]
  0019c	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  0019f	52		 push	 edx
  001a0	e8 00 00 00 00	 call	 ?idct_block@@YAXPAEHQAF0@Z ; idct_block
  001a5	83 c4 10	 add	 esp, 16			; 00000010H

; 1139 :             #endif
; 1140 :             // every data block is an MCU, so countdown the restart interval
; 1141 :             if (--z->todo <= 0) {

  001a8	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  001ab	8b 88 a4 36 00
	00		 mov	 ecx, DWORD PTR [eax+13988]
  001b1	83 e9 01	 sub	 ecx, 1
  001b4	89 8d b4 fe ff
	ff		 mov	 DWORD PTR tv169[ebp], ecx
  001ba	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001bd	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR tv169[ebp]
  001c3	89 82 a4 36 00
	00		 mov	 DWORD PTR [edx+13988], eax
  001c9	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR tv169[ebp], 0
  001d0	7f 51		 jg	 SHORT $LN26@parse_entr

; 1142 :                if (z->code_bits < 24) grow_buffer_unsafe(z);

  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  001d5	83 b9 80 36 00
	00 18		 cmp	 DWORD PTR [ecx+13952], 24 ; 00000018H
  001dc	7d 0c		 jge	 SHORT $LN27@parse_entr
  001de	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 ?grow_buffer_unsafe@@YAXPAUjpeg@@@Z ; grow_buffer_unsafe
  001e7	83 c4 04	 add	 esp, 4
$LN27@parse_entr:

; 1143 :                // if it's NOT a restart, then just bail, so we get corrupt data
; 1144 :                // rather than no data
; 1145 :                if (!RESTART(z->marker)) return 1;

  001ea	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  001ed	0f b6 88 84 36
	00 00		 movzx	 ecx, BYTE PTR [eax+13956]
  001f4	81 f9 d0 00 00
	00		 cmp	 ecx, 208		; 000000d0H
  001fa	7c 11		 jl	 SHORT $LN29@parse_entr
  001fc	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001ff	0f b6 82 84 36
	00 00		 movzx	 eax, BYTE PTR [edx+13956]
  00206	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  0020b	7e 0a		 jle	 SHORT $LN28@parse_entr
$LN29@parse_entr:
  0020d	b8 01 00 00 00	 mov	 eax, 1
  00212	e9 e9 02 00 00	 jmp	 $LN1@parse_entr
$LN28@parse_entr:

; 1146 :                reset(z);

  00217	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 ?reset@@YAXPAUjpeg@@@Z	; reset
  00220	83 c4 04	 add	 esp, 4
$LN26@parse_entr:

; 1147 :             }
; 1148 :          }

  00223	e9 96 fe ff ff	 jmp	 $LN5@parse_entr
$LN6@parse_entr:

; 1149 :       }

  00228	e9 70 fe ff ff	 jmp	 $LN2@parse_entr
$LN3@parse_entr:

; 1150 :    } else { // interleaved!

  0022d	e9 c9 02 00 00	 jmp	 $LN24@parse_entr
$LN23@parse_entr:

; 1151 :       int i,j,k,x,y;
; 1152 :       short data[64];
; 1153 :       for (j=0; j < z->img_mcu_y; ++j) {

  00232	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$8[ebp], 0
  0023c	eb 0f		 jmp	 SHORT $LN10@parse_entr
$LN8@parse_entr:
  0023e	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _j$8[ebp]
  00244	83 c2 01	 add	 edx, 1
  00247	89 95 58 ff ff
	ff		 mov	 DWORD PTR _j$8[ebp], edx
$LN10@parse_entr:
  0024d	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00250	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _j$8[ebp]
  00256	3b 88 90 35 00
	00		 cmp	 ecx, DWORD PTR [eax+13712]
  0025c	0f 8d 99 02 00
	00		 jge	 $LN24@parse_entr

; 1154 :          for (i=0; i < z->img_mcu_x; ++i) {

  00262	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$9[ebp], 0
  0026c	eb 0f		 jmp	 SHORT $LN13@parse_entr
$LN11@parse_entr:
  0026e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _i$9[ebp]
  00274	83 c2 01	 add	 edx, 1
  00277	89 95 5c ff ff
	ff		 mov	 DWORD PTR _i$9[ebp], edx
$LN13@parse_entr:
  0027d	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00280	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _i$9[ebp]
  00286	3b 88 8c 35 00
	00		 cmp	 ecx, DWORD PTR [eax+13708]
  0028c	0f 8d 64 02 00
	00		 jge	 $LN12@parse_entr

; 1155 :             // scan an interleaved mcu... process scan_n components in order
; 1156 :             for (k=0; k < z->scan_n; ++k) {

  00292	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$7[ebp], 0
  0029c	eb 0f		 jmp	 SHORT $LN16@parse_entr
$LN14@parse_entr:
  0029e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _k$7[ebp]
  002a4	83 c2 01	 add	 edx, 1
  002a7	89 95 54 ff ff
	ff		 mov	 DWORD PTR _k$7[ebp], edx
$LN16@parse_entr:
  002ad	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002b0	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _k$7[ebp]
  002b6	3b 88 8c 36 00
	00		 cmp	 ecx, DWORD PTR [eax+13964]
  002bc	0f 8d b7 01 00
	00		 jge	 $LN15@parse_entr

; 1157 :                int n = z->order[k];

  002c2	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _k$7[ebp]
  002c8	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002cb	8b 8c 90 90 36
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+13968]
  002d2	89 8d c0 fe ff
	ff		 mov	 DWORD PTR _n$3[ebp], ecx

; 1158 :                // scan out an mcu's worth of this component; that's just determined
; 1159 :                // by the basic H and V specified for the component
; 1160 :                for (y=0; y < z->img_comp[n].v; ++y) {

  002d8	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$5[ebp], 0
  002e2	eb 0f		 jmp	 SHORT $LN19@parse_entr
$LN17@parse_entr:
  002e4	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _y$5[ebp]
  002ea	83 c2 01	 add	 edx, 1
  002ed	89 95 4c ff ff
	ff		 mov	 DWORD PTR _y$5[ebp], edx
$LN19@parse_entr:
  002f3	6b 85 c0 fe ff
	ff 38		 imul	 eax, DWORD PTR _n$3[ebp], 56
  002fa	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  002fd	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _y$5[ebp]
  00303	3b 94 01 a4 35
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+13732]
  0030a	0f 8d 64 01 00
	00		 jge	 $LN18@parse_entr

; 1161 :                   for (x=0; x < z->img_comp[n].h; ++x) {

  00310	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$6[ebp], 0
  0031a	eb 0f		 jmp	 SHORT $LN22@parse_entr
$LN20@parse_entr:
  0031c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _x$6[ebp]
  00322	83 c0 01	 add	 eax, 1
  00325	89 85 50 ff ff
	ff		 mov	 DWORD PTR _x$6[ebp], eax
$LN22@parse_entr:
  0032b	6b 8d c0 fe ff
	ff 38		 imul	 ecx, DWORD PTR _n$3[ebp], 56
  00332	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00335	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _x$6[ebp]
  0033b	3b 84 0a a0 35
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+13728]
  00342	0f 8d 27 01 00
	00		 jge	 $LN21@parse_entr

; 1162 :                      int x2 = (i*z->img_comp[n].h + x)*8;

  00348	6b 8d c0 fe ff
	ff 38		 imul	 ecx, DWORD PTR _n$3[ebp], 56
  0034f	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00352	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _i$9[ebp]
  00358	0f af 84 0a a0
	35 00 00	 imul	 eax, DWORD PTR [edx+ecx+13728]
  00360	03 85 50 ff ff
	ff		 add	 eax, DWORD PTR _x$6[ebp]
  00366	c1 e0 03	 shl	 eax, 3
  00369	89 85 bc fe ff
	ff		 mov	 DWORD PTR _x2$2[ebp], eax

; 1163 :                      int y2 = (j*z->img_comp[n].v + y)*8;

  0036f	6b 8d c0 fe ff
	ff 38		 imul	 ecx, DWORD PTR _n$3[ebp], 56
  00376	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00379	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _j$8[ebp]
  0037f	0f af 84 0a a4
	35 00 00	 imul	 eax, DWORD PTR [edx+ecx+13732]
  00387	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _y$5[ebp]
  0038d	c1 e0 03	 shl	 eax, 3
  00390	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _y2$1[ebp], eax

; 1164 :                      if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;

  00396	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$3[ebp]
  0039c	51		 push	 ecx
  0039d	6b 95 c0 fe ff
	ff 38		 imul	 edx, DWORD PTR _n$3[ebp], 56
  003a4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  003a7	69 8c 10 b0 35
	00 00 90 06 00
	00		 imul	 ecx, DWORD PTR [eax+edx+13744], 1680
  003b2	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  003b5	8d 84 0a 44 1a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+6724]
  003bc	50		 push	 eax
  003bd	6b 8d c0 fe ff
	ff 38		 imul	 ecx, DWORD PTR _n$3[ebp], 56
  003c4	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  003c7	69 84 0a ac 35
	00 00 90 06 00
	00		 imul	 eax, DWORD PTR [edx+ecx+13740], 1680
  003d2	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003d5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003d9	52		 push	 edx
  003da	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _data$4[ebp]
  003e0	50		 push	 eax
  003e1	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003e4	51		 push	 ecx
  003e5	e8 00 00 00 00	 call	 ?decode_block@@YAHPAUjpeg@@QAFPAUhuffman@@2H@Z ; decode_block
  003ea	83 c4 14	 add	 esp, 20			; 00000014H
  003ed	85 c0		 test	 eax, eax
  003ef	75 07		 jne	 SHORT $LN30@parse_entr
  003f1	33 c0		 xor	 eax, eax
  003f3	e9 08 01 00 00	 jmp	 $LN1@parse_entr
$LN30@parse_entr:

; 1165 :                      #ifdef STBI_SIMD
; 1166 :                      stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
; 1167 :                      #else
; 1168 :                      idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);

  003f8	6b 95 c0 fe ff
	ff 38		 imul	 edx, DWORD PTR _n$3[ebp], 56
  003ff	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00402	8b 8c 10 a8 35
	00 00		 mov	 ecx, DWORD PTR [eax+edx+13736]
  00409	c1 e1 06	 shl	 ecx, 6
  0040c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0040f	8d 84 0a 84 34
	00 00		 lea	 eax, DWORD PTR [edx+ecx+13444]
  00416	50		 push	 eax
  00417	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _data$4[ebp]
  0041d	51		 push	 ecx
  0041e	6b 95 c0 fe ff
	ff 38		 imul	 edx, DWORD PTR _n$3[ebp], 56
  00425	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00428	8b 8c 10 c0 35
	00 00		 mov	 ecx, DWORD PTR [eax+edx+13760]
  0042f	51		 push	 ecx
  00430	6b 95 c0 fe ff
	ff 38		 imul	 edx, DWORD PTR _n$3[ebp], 56
  00437	6b 85 c0 fe ff
	ff 38		 imul	 eax, DWORD PTR _n$3[ebp], 56
  0043e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00441	8b 84 01 c0 35
	00 00		 mov	 eax, DWORD PTR [ecx+eax+13760]
  00448	0f af 85 b8 fe
	ff ff		 imul	 eax, DWORD PTR _y2$1[ebp]
  0044f	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00452	8b 94 11 c8 35
	00 00		 mov	 edx, DWORD PTR [ecx+edx+13768]
  00459	03 d0		 add	 edx, eax
  0045b	03 95 bc fe ff
	ff		 add	 edx, DWORD PTR _x2$2[ebp]
  00461	52		 push	 edx
  00462	e8 00 00 00 00	 call	 ?idct_block@@YAXPAEHQAF0@Z ; idct_block
  00467	83 c4 10	 add	 esp, 16			; 00000010H

; 1169 :                      #endif
; 1170 :                   }

  0046a	e9 ad fe ff ff	 jmp	 $LN20@parse_entr
$LN21@parse_entr:

; 1171 :                }

  0046f	e9 70 fe ff ff	 jmp	 $LN17@parse_entr
$LN18@parse_entr:

; 1172 :             }

  00474	e9 25 fe ff ff	 jmp	 $LN14@parse_entr
$LN15@parse_entr:

; 1173 :             // after all interleaved components, that's an interleaved MCU,
; 1174 :             // so now count down the restart interval
; 1175 :             if (--z->todo <= 0) {

  00479	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0047c	8b 88 a4 36 00
	00		 mov	 ecx, DWORD PTR [eax+13988]
  00482	83 e9 01	 sub	 ecx, 1
  00485	89 8d b0 fe ff
	ff		 mov	 DWORD PTR tv268[ebp], ecx
  0048b	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0048e	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv268[ebp]
  00494	89 82 a4 36 00
	00		 mov	 DWORD PTR [edx+13988], eax
  0049a	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR tv268[ebp], 0
  004a1	7f 4e		 jg	 SHORT $LN31@parse_entr

; 1176 :                if (z->code_bits < 24) grow_buffer_unsafe(z);

  004a3	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  004a6	83 b9 80 36 00
	00 18		 cmp	 DWORD PTR [ecx+13952], 24 ; 00000018H
  004ad	7d 0c		 jge	 SHORT $LN32@parse_entr
  004af	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  004b2	52		 push	 edx
  004b3	e8 00 00 00 00	 call	 ?grow_buffer_unsafe@@YAXPAUjpeg@@@Z ; grow_buffer_unsafe
  004b8	83 c4 04	 add	 esp, 4
$LN32@parse_entr:

; 1177 :                // if it's NOT a restart, then just bail, so we get corrupt data
; 1178 :                // rather than no data
; 1179 :                if (!RESTART(z->marker)) return 1;

  004bb	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  004be	0f b6 88 84 36
	00 00		 movzx	 ecx, BYTE PTR [eax+13956]
  004c5	81 f9 d0 00 00
	00		 cmp	 ecx, 208		; 000000d0H
  004cb	7c 11		 jl	 SHORT $LN34@parse_entr
  004cd	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  004d0	0f b6 82 84 36
	00 00		 movzx	 eax, BYTE PTR [edx+13956]
  004d7	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  004dc	7e 07		 jle	 SHORT $LN33@parse_entr
$LN34@parse_entr:
  004de	b8 01 00 00 00	 mov	 eax, 1
  004e3	eb 1b		 jmp	 SHORT $LN1@parse_entr
$LN33@parse_entr:

; 1180 :                reset(z);

  004e5	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  004e8	51		 push	 ecx
  004e9	e8 00 00 00 00	 call	 ?reset@@YAXPAUjpeg@@@Z	; reset
  004ee	83 c4 04	 add	 esp, 4
$LN31@parse_entr:

; 1181 :             }
; 1182 :          }

  004f1	e9 78 fd ff ff	 jmp	 $LN11@parse_entr
$LN12@parse_entr:

; 1183 :       }

  004f6	e9 43 fd ff ff	 jmp	 $LN8@parse_entr
$LN24@parse_entr:

; 1184 :    }
; 1185 :    return 1;

  004fb	b8 01 00 00 00	 mov	 eax, 1
$LN1@parse_entr:

; 1186 : }

  00500	52		 push	 edx
  00501	8b cd		 mov	 ecx, ebp
  00503	50		 push	 eax
  00504	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN39@parse_entr
  0050a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0050f	58		 pop	 eax
  00510	5a		 pop	 edx
  00511	5f		 pop	 edi
  00512	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00515	33 cd		 xor	 ecx, ebp
  00517	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051c	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  00522	3b ec		 cmp	 ebp, esp
  00524	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00529	8b e5		 mov	 esp, ebp
  0052b	5d		 pop	 ebp
  0052c	c3		 ret	 0
  0052d	0f 1f 00	 npad	 3
$LN39@parse_entr:
  00530	02 00 00 00	 DD	 2
  00534	00 00 00 00	 DD	 $LN38@parse_entr
$LN38@parse_entr:
  00538	70 ff ff ff	 DD	 -144			; ffffff70H
  0053c	80 00 00 00	 DD	 128			; 00000080H
  00540	00 00 00 00	 DD	 $LN36@parse_entr
  00544	c8 fe ff ff	 DD	 -312			; fffffec8H
  00548	80 00 00 00	 DD	 128			; 00000080H
  0054c	00 00 00 00	 DD	 $LN37@parse_entr
$LN37@parse_entr:
  00550	64		 DB	 100			; 00000064H
  00551	61		 DB	 97			; 00000061H
  00552	74		 DB	 116			; 00000074H
  00553	61		 DB	 97			; 00000061H
  00554	00		 DB	 0
$LN36@parse_entr:
  00555	64		 DB	 100			; 00000064H
  00556	61		 DB	 97			; 00000061H
  00557	74		 DB	 116			; 00000074H
  00558	61		 DB	 97			; 00000061H
  00559	00		 DB	 0
?parse_entropy_coded_data@@YAHPAUjpeg@@@Z ENDP		; parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv200 = -132						; size = 4
tv142 = -128						; size = 4
tv64 = -124						; size = 4
_th$1 = -120						; size = 4
_tc$2 = -116						; size = 4
_q$3 = -112						; size = 4
_m$4 = -108						; size = 4
_i$5 = -104						; size = 4
_sizes$6 = -96						; size = 64
_v$7 = -28						; size = 4
_i$8 = -24						; size = 4
_t$9 = -20						; size = 4
_p$10 = -16						; size = 4
_q$11 = -12						; size = 4
_L$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_m$ = 12						; size = 4
?process_marker@@YAHPAUjpeg@@H@Z PROC			; process_marker

; 1189 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	57		 push	 edi
  0000a	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-132]
  00010	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1190 :    int L;
; 1191 :    switch (m) {

  00026	8b 45 0c	 mov	 eax, DWORD PTR _m$[ebp]
  00029	89 45 84	 mov	 DWORD PTR tv64[ebp], eax
  0002c	8b 4d 84	 mov	 ecx, DWORD PTR tv64[ebp]
  0002f	81 e9 c2 00 00
	00		 sub	 ecx, 194		; 000000c2H
  00035	89 4d 84	 mov	 DWORD PTR tv64[ebp], ecx
  00038	83 7d 84 3d	 cmp	 DWORD PTR tv64[ebp], 61	; 0000003dH
  0003c	0f 87 eb 02 00
	00		 ja	 $LN2@process_ma
  00042	8b 55 84	 mov	 edx, DWORD PTR tv64[ebp]
  00045	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN39@process_ma[edx]
  0004c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN43@process_ma[eax*4]
$LN17@process_ma:

; 1192 :       case MARKER_none: // no marker found
; 1193 :          return e("expected marker","Corrupt JPEG");

  00053	68 00 00 00 00	 push	 OFFSET $SG4294820259
  00058	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0005d	83 c4 04	 add	 esp, 4
  00060	e9 0c 03 00 00	 jmp	 $LN1@process_ma
$LN18@process_ma:

; 1194 : 
; 1195 :       case 0xC2: // SOF - progressive
; 1196 :          return e("progressive jpeg","JPEG format not supported (progressive)");

  00065	68 00 00 00 00	 push	 OFFSET $SG4294820258
  0006a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006f	83 c4 04	 add	 esp, 4
  00072	e9 fa 02 00 00	 jmp	 $LN1@process_ma
$LN19@process_ma:

; 1197 : 
; 1198 :       case 0xDD: // DRI - specify restart interval
; 1199 :          if (get16(z->s) != 4) return e("bad DRI len","Corrupt JPEG");

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0007a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00082	83 c4 04	 add	 esp, 4
  00085	83 f8 04	 cmp	 eax, 4
  00088	74 12		 je	 SHORT $LN20@process_ma
  0008a	68 00 00 00 00	 push	 OFFSET $SG4294820257
  0008f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00094	83 c4 04	 add	 esp, 4
  00097	e9 d5 02 00 00	 jmp	 $LN1@process_ma
$LN20@process_ma:

; 1200 :          z->restart_interval = get16(z->s);

  0009c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000a7	83 c4 04	 add	 esp, 4
  000aa	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000ad	89 82 a0 36 00
	00		 mov	 DWORD PTR [edx+13984], eax

; 1201 :          return 1;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	e9 b4 02 00 00	 jmp	 $LN1@process_ma
$LN21@process_ma:

; 1202 : 
; 1203 :       case 0xDB: // DQT - define quantization table
; 1204 :          L = get16(z->s)-2;

  000bd	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000c8	83 c4 04	 add	 esp, 4
  000cb	83 e8 02	 sub	 eax, 2
  000ce	89 45 f8	 mov	 DWORD PTR _L$[ebp], eax
$LN4@process_ma:

; 1205 :          while (L > 0) {

  000d1	83 7d f8 00	 cmp	 DWORD PTR _L$[ebp], 0
  000d5	0f 8e a6 00 00
	00		 jle	 $LN5@process_ma

; 1206 :             int q = get8(z->s);

  000db	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000de	8b 02		 mov	 eax, DWORD PTR [edx]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000e6	83 c4 04	 add	 esp, 4
  000e9	89 45 f4	 mov	 DWORD PTR _q$11[ebp], eax

; 1207 :             int p = q >> 4;

  000ec	8b 4d f4	 mov	 ecx, DWORD PTR _q$11[ebp]
  000ef	c1 f9 04	 sar	 ecx, 4
  000f2	89 4d f0	 mov	 DWORD PTR _p$10[ebp], ecx

; 1208 :             int t = q & 15,i;

  000f5	8b 55 f4	 mov	 edx, DWORD PTR _q$11[ebp]
  000f8	83 e2 0f	 and	 edx, 15			; 0000000fH
  000fb	89 55 ec	 mov	 DWORD PTR _t$9[ebp], edx

; 1209 :             if (p != 0) return e("bad DQT type","Corrupt JPEG");

  000fe	83 7d f0 00	 cmp	 DWORD PTR _p$10[ebp], 0
  00102	74 12		 je	 SHORT $LN22@process_ma
  00104	68 00 00 00 00	 push	 OFFSET $SG4294820256
  00109	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0010e	83 c4 04	 add	 esp, 4
  00111	e9 5b 02 00 00	 jmp	 $LN1@process_ma
$LN22@process_ma:

; 1210 :             if (t > 3) return e("bad DQT table","Corrupt JPEG");

  00116	83 7d ec 03	 cmp	 DWORD PTR _t$9[ebp], 3
  0011a	7e 12		 jle	 SHORT $LN23@process_ma
  0011c	68 00 00 00 00	 push	 OFFSET $SG4294820255
  00121	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00126	83 c4 04	 add	 esp, 4
  00129	e9 43 02 00 00	 jmp	 $LN1@process_ma
$LN23@process_ma:

; 1211 :             for (i=0; i < 64; ++i)

  0012e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN8@process_ma
$LN6@process_ma:
  00137	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 e8	 mov	 DWORD PTR _i$8[ebp], eax
$LN8@process_ma:
  00140	83 7d e8 40	 cmp	 DWORD PTR _i$8[ebp], 64	; 00000040H
  00144	7d 2d		 jge	 SHORT $LN7@process_ma

; 1212 :                z->dequant[t][dezigzag[i]] = get8u(z->s);

  00146	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00149	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014b	52		 push	 edx
  0014c	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00151	83 c4 04	 add	 esp, 4
  00154	8b 4d ec	 mov	 ecx, DWORD PTR _t$9[ebp]
  00157	c1 e1 06	 shl	 ecx, 6
  0015a	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0015d	8d 8c 0a 84 34
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+13444]
  00164	8b 55 e8	 mov	 edx, DWORD PTR _i$8[ebp]
  00167	0f b6 92 00 00
	00 00		 movzx	 edx, BYTE PTR ?dezigzag@@3PAEA[edx]
  0016e	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00171	eb c4		 jmp	 SHORT $LN6@process_ma
$LN7@process_ma:

; 1213 :             #ifdef STBI_SIMD
; 1214 :             for (i=0; i < 64; ++i)
; 1215 :                z->dequant2[t][i] = z->dequant[t][i];
; 1216 :             #endif
; 1217 :             L -= 65;

  00173	8b 45 f8	 mov	 eax, DWORD PTR _L$[ebp]
  00176	83 e8 41	 sub	 eax, 65			; 00000041H
  00179	89 45 f8	 mov	 DWORD PTR _L$[ebp], eax

; 1218 :          }

  0017c	e9 50 ff ff ff	 jmp	 $LN4@process_ma
$LN5@process_ma:

; 1219 :          return L==0;

  00181	83 7d f8 00	 cmp	 DWORD PTR _L$[ebp], 0
  00185	75 09		 jne	 SHORT $LN35@process_ma
  00187	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  0018e	eb 07		 jmp	 SHORT $LN36@process_ma
$LN35@process_ma:
  00190	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$LN36@process_ma:
  00197	8b 45 80	 mov	 eax, DWORD PTR tv142[ebp]
  0019a	e9 d2 01 00 00	 jmp	 $LN1@process_ma
$LN24@process_ma:

; 1220 : 
; 1221 :       case 0xC4: // DHT - define huffman table
; 1222 :          L = get16(z->s)-2;

  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  001a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  001aa	83 c4 04	 add	 esp, 4
  001ad	83 e8 02	 sub	 eax, 2
  001b0	89 45 f8	 mov	 DWORD PTR _L$[ebp], eax
$LN9@process_ma:

; 1223 :          while (L > 0) {

  001b3	83 7d f8 00	 cmp	 DWORD PTR _L$[ebp], 0
  001b7	0f 8e 4c 01 00
	00		 jle	 $LN10@process_ma

; 1224 :             uint8 *v;
; 1225 :             int sizes[16],i,m=0;

  001bd	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _m$4[ebp], 0

; 1226 :             int q = get8(z->s);

  001c4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  001c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c9	51		 push	 ecx
  001ca	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001cf	83 c4 04	 add	 esp, 4
  001d2	89 45 90	 mov	 DWORD PTR _q$3[ebp], eax

; 1227 :             int tc = q >> 4;

  001d5	8b 55 90	 mov	 edx, DWORD PTR _q$3[ebp]
  001d8	c1 fa 04	 sar	 edx, 4
  001db	89 55 8c	 mov	 DWORD PTR _tc$2[ebp], edx

; 1228 :             int th = q & 15;

  001de	8b 45 90	 mov	 eax, DWORD PTR _q$3[ebp]
  001e1	83 e0 0f	 and	 eax, 15			; 0000000fH
  001e4	89 45 88	 mov	 DWORD PTR _th$1[ebp], eax

; 1229 :             if (tc > 1 || th > 3) return e("bad DHT header","Corrupt JPEG");

  001e7	83 7d 8c 01	 cmp	 DWORD PTR _tc$2[ebp], 1
  001eb	7f 06		 jg	 SHORT $LN26@process_ma
  001ed	83 7d 88 03	 cmp	 DWORD PTR _th$1[ebp], 3
  001f1	7e 12		 jle	 SHORT $LN25@process_ma
$LN26@process_ma:
  001f3	68 00 00 00 00	 push	 OFFSET $SG4294820254
  001f8	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001fd	83 c4 04	 add	 esp, 4
  00200	e9 6c 01 00 00	 jmp	 $LN1@process_ma
$LN25@process_ma:

; 1230 :             for (i=0; i < 16; ++i) {

  00205	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN13@process_ma
$LN11@process_ma:
  0020e	8b 4d 98	 mov	 ecx, DWORD PTR _i$5[ebp]
  00211	83 c1 01	 add	 ecx, 1
  00214	89 4d 98	 mov	 DWORD PTR _i$5[ebp], ecx
$LN13@process_ma:
  00217	83 7d 98 10	 cmp	 DWORD PTR _i$5[ebp], 16	; 00000010H
  0021b	7d 24		 jge	 SHORT $LN12@process_ma

; 1231 :                sizes[i] = get8(z->s);

  0021d	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00220	8b 02		 mov	 eax, DWORD PTR [edx]
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00228	83 c4 04	 add	 esp, 4
  0022b	8b 4d 98	 mov	 ecx, DWORD PTR _i$5[ebp]
  0022e	89 44 8d a0	 mov	 DWORD PTR _sizes$6[ebp+ecx*4], eax

; 1232 :                m += sizes[i];

  00232	8b 55 98	 mov	 edx, DWORD PTR _i$5[ebp]
  00235	8b 45 94	 mov	 eax, DWORD PTR _m$4[ebp]
  00238	03 44 95 a0	 add	 eax, DWORD PTR _sizes$6[ebp+edx*4]
  0023c	89 45 94	 mov	 DWORD PTR _m$4[ebp], eax

; 1233 :             }

  0023f	eb cd		 jmp	 SHORT $LN11@process_ma
$LN12@process_ma:

; 1234 :             L -= 17;

  00241	8b 4d f8	 mov	 ecx, DWORD PTR _L$[ebp]
  00244	83 e9 11	 sub	 ecx, 17			; 00000011H
  00247	89 4d f8	 mov	 DWORD PTR _L$[ebp], ecx

; 1235 :             if (tc == 0) {

  0024a	83 7d 8c 00	 cmp	 DWORD PTR _tc$2[ebp], 0
  0024e	75 3c		 jne	 SHORT $LN27@process_ma

; 1236 :                if (!build_huffman(z->huff_dc+th, sizes)) return 0;

  00250	8d 55 a0	 lea	 edx, DWORD PTR _sizes$6[ebp]
  00253	52		 push	 edx
  00254	69 45 88 90 06
	00 00		 imul	 eax, DWORD PTR _th$1[ebp], 1680
  0025b	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0025e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 ?build_huffman@@YAHPAUhuffman@@PAH@Z ; build_huffman
  00268	83 c4 08	 add	 esp, 8
  0026b	85 c0		 test	 eax, eax
  0026d	75 07		 jne	 SHORT $LN29@process_ma
  0026f	33 c0		 xor	 eax, eax
  00271	e9 fb 00 00 00	 jmp	 $LN1@process_ma
$LN29@process_ma:

; 1237 :                v = z->huff_dc[th].values;

  00276	69 45 88 90 06
	00 00		 imul	 eax, DWORD PTR _th$1[ebp], 1680
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00280	8d 94 01 04 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1028]
  00287	89 55 e4	 mov	 DWORD PTR _v$7[ebp], edx

; 1238 :             } else {

  0028a	eb 3d		 jmp	 SHORT $LN28@process_ma
$LN27@process_ma:

; 1239 :                if (!build_huffman(z->huff_ac+th, sizes)) return 0;

  0028c	8d 45 a0	 lea	 eax, DWORD PTR _sizes$6[ebp]
  0028f	50		 push	 eax
  00290	69 4d 88 90 06
	00 00		 imul	 ecx, DWORD PTR _th$1[ebp], 1680
  00297	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0029a	8d 84 0a 44 1a
	00 00		 lea	 eax, DWORD PTR [edx+ecx+6724]
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 ?build_huffman@@YAHPAUhuffman@@PAH@Z ; build_huffman
  002a7	83 c4 08	 add	 esp, 8
  002aa	85 c0		 test	 eax, eax
  002ac	75 07		 jne	 SHORT $LN30@process_ma
  002ae	33 c0		 xor	 eax, eax
  002b0	e9 bc 00 00 00	 jmp	 $LN1@process_ma
$LN30@process_ma:

; 1240 :                v = z->huff_ac[th].values;

  002b5	69 4d 88 90 06
	00 00		 imul	 ecx, DWORD PTR _th$1[ebp], 1680
  002bc	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  002bf	8d 84 0a 44 1e
	00 00		 lea	 eax, DWORD PTR [edx+ecx+7748]
  002c6	89 45 e4	 mov	 DWORD PTR _v$7[ebp], eax
$LN28@process_ma:

; 1241 :             }
; 1242 :             for (i=0; i < m; ++i)

  002c9	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  002d0	eb 09		 jmp	 SHORT $LN16@process_ma
$LN14@process_ma:
  002d2	8b 4d 98	 mov	 ecx, DWORD PTR _i$5[ebp]
  002d5	83 c1 01	 add	 ecx, 1
  002d8	89 4d 98	 mov	 DWORD PTR _i$5[ebp], ecx
$LN16@process_ma:
  002db	8b 55 98	 mov	 edx, DWORD PTR _i$5[ebp]
  002de	3b 55 94	 cmp	 edx, DWORD PTR _m$4[ebp]
  002e1	7d 18		 jge	 SHORT $LN15@process_ma

; 1243 :                v[i] = get8u(z->s);

  002e3	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e8	51		 push	 ecx
  002e9	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  002ee	83 c4 04	 add	 esp, 4
  002f1	8b 55 e4	 mov	 edx, DWORD PTR _v$7[ebp]
  002f4	03 55 98	 add	 edx, DWORD PTR _i$5[ebp]
  002f7	88 02		 mov	 BYTE PTR [edx], al
  002f9	eb d7		 jmp	 SHORT $LN14@process_ma
$LN15@process_ma:

; 1244 :             L -= m;

  002fb	8b 45 f8	 mov	 eax, DWORD PTR _L$[ebp]
  002fe	2b 45 94	 sub	 eax, DWORD PTR _m$4[ebp]
  00301	89 45 f8	 mov	 DWORD PTR _L$[ebp], eax

; 1245 :          }

  00304	e9 aa fe ff ff	 jmp	 $LN9@process_ma
$LN10@process_ma:

; 1246 :          return L==0;

  00309	83 7d f8 00	 cmp	 DWORD PTR _L$[ebp], 0
  0030d	75 0c		 jne	 SHORT $LN37@process_ma
  0030f	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv200[ebp], 1
  00319	eb 0a		 jmp	 SHORT $LN38@process_ma
$LN37@process_ma:
  0031b	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv200[ebp], 0
$LN38@process_ma:
  00325	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  0032b	eb 44		 jmp	 SHORT $LN1@process_ma
$LN2@process_ma:

; 1247 :    }
; 1248 :    // check for comment block or APP blocks
; 1249 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

  0032d	81 7d 0c e0 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 224	; 000000e0H
  00334	7c 09		 jl	 SHORT $LN33@process_ma
  00336	81 7d 0c ef 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 239	; 000000efH
  0033d	7e 09		 jle	 SHORT $LN32@process_ma
$LN33@process_ma:
  0033f	81 7d 0c fe 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 254	; 000000feH
  00346	75 27		 jne	 SHORT $LN31@process_ma
$LN32@process_ma:

; 1250 :       skip(z->s, get16(z->s)-2);

  00348	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0034b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0034d	52		 push	 edx
  0034e	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00353	83 c4 04	 add	 esp, 4
  00356	83 e8 02	 sub	 eax, 2
  00359	50		 push	 eax
  0035a	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0035d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035f	51		 push	 ecx
  00360	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00365	83 c4 08	 add	 esp, 8

; 1251 :       return 1;

  00368	b8 01 00 00 00	 mov	 eax, 1
  0036d	eb 02		 jmp	 SHORT $LN1@process_ma
$LN31@process_ma:

; 1252 :    }
; 1253 :    return 0;

  0036f	33 c0		 xor	 eax, eax
$LN1@process_ma:

; 1254 : }

  00371	52		 push	 edx
  00372	8b cd		 mov	 ecx, ebp
  00374	50		 push	 eax
  00375	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN42@process_ma
  0037b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00380	58		 pop	 eax
  00381	5a		 pop	 edx
  00382	5f		 pop	 edi
  00383	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00386	33 cd		 xor	 ecx, ebp
  00388	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038d	81 c4 84 00 00
	00		 add	 esp, 132		; 00000084H
  00393	3b ec		 cmp	 ebp, esp
  00395	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039a	8b e5		 mov	 esp, ebp
  0039c	5d		 pop	 ebp
  0039d	c3		 ret	 0
  0039e	66 90		 npad	 2
$LN42@process_ma:
  003a0	01 00 00 00	 DD	 1
  003a4	00 00 00 00	 DD	 $LN41@process_ma
$LN41@process_ma:
  003a8	a0 ff ff ff	 DD	 -96			; ffffffa0H
  003ac	40 00 00 00	 DD	 64			; 00000040H
  003b0	00 00 00 00	 DD	 $LN40@process_ma
$LN40@process_ma:
  003b4	73		 DB	 115			; 00000073H
  003b5	69		 DB	 105			; 00000069H
  003b6	7a		 DB	 122			; 0000007aH
  003b7	65		 DB	 101			; 00000065H
  003b8	73		 DB	 115			; 00000073H
  003b9	00		 DB	 0
  003ba	66 90		 npad	 2
$LN43@process_ma:
  003bc	00 00 00 00	 DD	 $LN18@process_ma
  003c0	00 00 00 00	 DD	 $LN24@process_ma
  003c4	00 00 00 00	 DD	 $LN21@process_ma
  003c8	00 00 00 00	 DD	 $LN19@process_ma
  003cc	00 00 00 00	 DD	 $LN17@process_ma
  003d0	00 00 00 00	 DD	 $LN2@process_ma
$LN39@process_ma:
  003d4	00		 DB	 0
  003d5	05		 DB	 5
  003d6	01		 DB	 1
  003d7	05		 DB	 5
  003d8	05		 DB	 5
  003d9	05		 DB	 5
  003da	05		 DB	 5
  003db	05		 DB	 5
  003dc	05		 DB	 5
  003dd	05		 DB	 5
  003de	05		 DB	 5
  003df	05		 DB	 5
  003e0	05		 DB	 5
  003e1	05		 DB	 5
  003e2	05		 DB	 5
  003e3	05		 DB	 5
  003e4	05		 DB	 5
  003e5	05		 DB	 5
  003e6	05		 DB	 5
  003e7	05		 DB	 5
  003e8	05		 DB	 5
  003e9	05		 DB	 5
  003ea	05		 DB	 5
  003eb	05		 DB	 5
  003ec	05		 DB	 5
  003ed	02		 DB	 2
  003ee	05		 DB	 5
  003ef	03		 DB	 3
  003f0	05		 DB	 5
  003f1	05		 DB	 5
  003f2	05		 DB	 5
  003f3	05		 DB	 5
  003f4	05		 DB	 5
  003f5	05		 DB	 5
  003f6	05		 DB	 5
  003f7	05		 DB	 5
  003f8	05		 DB	 5
  003f9	05		 DB	 5
  003fa	05		 DB	 5
  003fb	05		 DB	 5
  003fc	05		 DB	 5
  003fd	05		 DB	 5
  003fe	05		 DB	 5
  003ff	05		 DB	 5
  00400	05		 DB	 5
  00401	05		 DB	 5
  00402	05		 DB	 5
  00403	05		 DB	 5
  00404	05		 DB	 5
  00405	05		 DB	 5
  00406	05		 DB	 5
  00407	05		 DB	 5
  00408	05		 DB	 5
  00409	05		 DB	 5
  0040a	05		 DB	 5
  0040b	05		 DB	 5
  0040c	05		 DB	 5
  0040d	05		 DB	 5
  0040e	05		 DB	 5
  0040f	05		 DB	 5
  00410	05		 DB	 5
  00411	04		 DB	 4
?process_marker@@YAHPAUjpeg@@H@Z ENDP			; process_marker
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_q$1 = -20						; size = 4
_which$2 = -16						; size = 4
_id$3 = -12						; size = 4
_Ls$ = -8						; size = 4
_i$ = -4						; size = 4
_z$ = 8							; size = 4
?process_scan_header@@YAHPAUjpeg@@@Z PROC		; process_scan_header

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1259 :    int i;
; 1260 :    int Ls = get16(z->s);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f8	 mov	 DWORD PTR _Ls$[ebp], eax

; 1261 :    z->scan_n = get8(z->s);

  0002b	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0003c	89 81 8c 36 00
	00		 mov	 DWORD PTR [ecx+13964], eax

; 1262 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return e("bad SOS component count","Corrupt JPEG");

  00042	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00045	83 ba 8c 36 00
	00 01		 cmp	 DWORD PTR [edx+13964], 1
  0004c	7c 1f		 jl	 SHORT $LN9@process_sc
  0004e	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00051	83 b8 8c 36 00
	00 04		 cmp	 DWORD PTR [eax+13964], 4
  00058	7f 13		 jg	 SHORT $LN9@process_sc
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00062	8b 88 8c 36 00
	00		 mov	 ecx, DWORD PTR [eax+13964]
  00068	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0006b	7e 12		 jle	 SHORT $LN8@process_sc
$LN9@process_sc:
  0006d	68 00 00 00 00	 push	 OFFSET $SG4294820253
  00072	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00077	83 c4 04	 add	 esp, 4
  0007a	e9 89 01 00 00	 jmp	 $LN1@process_sc
$LN8@process_sc:

; 1263 :    if (Ls != 6+2*z->scan_n) return e("bad SOS len","Corrupt JPEG");

  0007f	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00082	8b 82 8c 36 00
	00		 mov	 eax, DWORD PTR [edx+13964]
  00088	8d 4c 00 06	 lea	 ecx, DWORD PTR [eax+eax+6]
  0008c	39 4d f8	 cmp	 DWORD PTR _Ls$[ebp], ecx
  0008f	74 12		 je	 SHORT $LN10@process_sc
  00091	68 00 00 00 00	 push	 OFFSET $SG4294820252
  00096	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0009b	83 c4 04	 add	 esp, 4
  0009e	e9 65 01 00 00	 jmp	 $LN1@process_sc
$LN10@process_sc:

; 1264 :    for (i=0; i < z->scan_n; ++i) {

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN4@process_sc
$LN2@process_sc:
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000af	83 c2 01	 add	 edx, 1
  000b2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN4@process_sc:
  000b5	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000bb	3b 88 8c 36 00
	00		 cmp	 ecx, DWORD PTR [eax+13964]
  000c1	0f 8d ec 00 00
	00		 jge	 $LN3@process_sc

; 1265 :       int id = get8(z->s), which;

  000c7	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000ca	8b 02		 mov	 eax, DWORD PTR [edx]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000d2	83 c4 04	 add	 esp, 4
  000d5	89 45 f4	 mov	 DWORD PTR _id$3[ebp], eax

; 1266 :       int q = get8(z->s);

  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  000db	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dd	52		 push	 edx
  000de	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000e3	83 c4 04	 add	 esp, 4
  000e6	89 45 ec	 mov	 DWORD PTR _q$1[ebp], eax

; 1267 :       for (which = 0; which < z->s->img_n; ++which)

  000e9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _which$2[ebp], 0
  000f0	eb 09		 jmp	 SHORT $LN7@process_sc
$LN5@process_sc:
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _which$2[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 f0	 mov	 DWORD PTR _which$2[ebp], eax
$LN7@process_sc:
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  000fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00100	8b 45 f0	 mov	 eax, DWORD PTR _which$2[ebp]
  00103	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00106	7d 17		 jge	 SHORT $LN6@process_sc

; 1268 :          if (z->img_comp[which].id == id)

  00108	6b 4d f0 38	 imul	 ecx, DWORD PTR _which$2[ebp], 56
  0010c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0010f	8b 84 0a 9c 35
	00 00		 mov	 eax, DWORD PTR [edx+ecx+13724]
  00116	3b 45 f4	 cmp	 eax, DWORD PTR _id$3[ebp]
  00119	75 02		 jne	 SHORT $LN11@process_sc

; 1269 :             break;

  0011b	eb 02		 jmp	 SHORT $LN6@process_sc
$LN11@process_sc:

; 1270 :       if (which == z->s->img_n) return 0;

  0011d	eb d3		 jmp	 SHORT $LN5@process_sc
$LN6@process_sc:
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00122	8b 11		 mov	 edx, DWORD PTR [ecx]
  00124	8b 45 f0	 mov	 eax, DWORD PTR _which$2[ebp]
  00127	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0012a	75 07		 jne	 SHORT $LN12@process_sc
  0012c	33 c0		 xor	 eax, eax
  0012e	e9 d5 00 00 00	 jmp	 $LN1@process_sc
$LN12@process_sc:

; 1271 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e("bad DC huff","Corrupt JPEG");

  00133	8b 4d ec	 mov	 ecx, DWORD PTR _q$1[ebp]
  00136	c1 f9 04	 sar	 ecx, 4
  00139	6b 55 f0 38	 imul	 edx, DWORD PTR _which$2[ebp], 56
  0013d	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00140	89 8c 10 ac 35
	00 00		 mov	 DWORD PTR [eax+edx+13740], ecx
  00147	6b 4d f0 38	 imul	 ecx, DWORD PTR _which$2[ebp], 56
  0014b	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0014e	83 bc 0a ac 35
	00 00 03	 cmp	 DWORD PTR [edx+ecx+13740], 3
  00156	7e 12		 jle	 SHORT $LN13@process_sc
  00158	68 00 00 00 00	 push	 OFFSET $SG4294820251
  0015d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00162	83 c4 04	 add	 esp, 4
  00165	e9 9e 00 00 00	 jmp	 $LN1@process_sc
$LN13@process_sc:

; 1272 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e("bad AC huff","Corrupt JPEG");

  0016a	8b 45 ec	 mov	 eax, DWORD PTR _q$1[ebp]
  0016d	83 e0 0f	 and	 eax, 15			; 0000000fH
  00170	6b 4d f0 38	 imul	 ecx, DWORD PTR _which$2[ebp], 56
  00174	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00177	89 84 0a b0 35
	00 00		 mov	 DWORD PTR [edx+ecx+13744], eax
  0017e	6b 45 f0 38	 imul	 eax, DWORD PTR _which$2[ebp], 56
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00185	83 bc 01 b0 35
	00 00 03	 cmp	 DWORD PTR [ecx+eax+13744], 3
  0018d	7e 0f		 jle	 SHORT $LN14@process_sc
  0018f	68 00 00 00 00	 push	 OFFSET $SG4294820250
  00194	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00199	83 c4 04	 add	 esp, 4
  0019c	eb 6a		 jmp	 SHORT $LN1@process_sc
$LN14@process_sc:

; 1273 :       z->order[i] = which;

  0019e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001a1	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  001a4	8b 4d f0	 mov	 ecx, DWORD PTR _which$2[ebp]
  001a7	89 8c 90 90 36
	00 00		 mov	 DWORD PTR [eax+edx*4+13968], ecx

; 1274 :    }

  001ae	e9 f9 fe ff ff	 jmp	 $LN2@process_sc
$LN3@process_sc:

; 1275 :    if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");

  001b3	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001b6	8b 02		 mov	 eax, DWORD PTR [edx]
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001be	83 c4 04	 add	 esp, 4
  001c1	85 c0		 test	 eax, eax
  001c3	74 0f		 je	 SHORT $LN15@process_sc
  001c5	68 00 00 00 00	 push	 OFFSET $SG4294820249
  001ca	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001cf	83 c4 04	 add	 esp, 4
  001d2	eb 34		 jmp	 SHORT $LN1@process_sc
$LN15@process_sc:

; 1276 :    get8(z->s); // should be 63, but might be 0

  001d4	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  001d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d9	52		 push	 edx
  001da	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001df	83 c4 04	 add	 esp, 4

; 1277 :    if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");

  001e2	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  001e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e7	51		 push	 ecx
  001e8	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001ed	83 c4 04	 add	 esp, 4
  001f0	85 c0		 test	 eax, eax
  001f2	74 0f		 je	 SHORT $LN16@process_sc
  001f4	68 00 00 00 00	 push	 OFFSET $SG4294820248
  001f9	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001fe	83 c4 04	 add	 esp, 4
  00201	eb 05		 jmp	 SHORT $LN1@process_sc
$LN16@process_sc:

; 1278 : 
; 1279 :    return 1;

  00203	b8 01 00 00 00	 mov	 eax, 1
$LN1@process_sc:

; 1280 : }

  00208	83 c4 14	 add	 esp, 20			; 00000014H
  0020b	3b ec		 cmp	 ebp, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
?process_scan_header@@YAHPAUjpeg@@@Z ENDP		; process_scan_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_c$ = -32						; size = 4
_v_max$ = -28						; size = 4
_h_max$ = -24						; size = 4
_q$ = -20						; size = 4
_i$ = -16						; size = 4
_p$ = -12						; size = 4
_Lf$ = -8						; size = 4
_s$ = -4						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
?process_frame_header@@YAHPAUjpeg@@H@Z PROC		; process_frame_header

; 1283 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1284 :    stbi *s = z->s;

  00024	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 1285 :    int Lf,p,i,q, h_max=1,v_max=1,c;

  0002c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _h_max$[ebp], 1
  00033	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _v_max$[ebp], 1

; 1286 :    Lf = get16(s);         if (Lf < 11) return e("bad SOF len","Corrupt JPEG"); // JPEG

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 f8	 mov	 DWORD PTR _Lf$[ebp], eax
  00049	83 7d f8 0b	 cmp	 DWORD PTR _Lf$[ebp], 11	; 0000000bH
  0004d	7d 12		 jge	 SHORT $LN17@process_fr
  0004f	68 00 00 00 00	 push	 OFFSET $SG4294820247
  00054	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00059	83 c4 04	 add	 esp, 4
  0005c	e9 53 05 00 00	 jmp	 $LN1@process_fr
$LN17@process_fr:

; 1287 :    p  = get8(s);          if (p != 8) return e("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

  00061	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00070	83 7d f4 08	 cmp	 DWORD PTR _p$[ebp], 8
  00074	74 12		 je	 SHORT $LN18@process_fr
  00076	68 00 00 00 00	 push	 OFFSET $SG4294820246
  0007b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00080	83 c4 04	 add	 esp, 4
  00083	e9 2c 05 00 00	 jmp	 $LN1@process_fr
$LN18@process_fr:

; 1288 :    s->img_y = get16(s);   if (s->img_y == 0) return e("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00091	83 c4 04	 add	 esp, 4
  00094	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00097	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0009d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a1	75 12		 jne	 SHORT $LN19@process_fr
  000a3	68 00 00 00 00	 push	 OFFSET $SG4294820245
  000a8	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000ad	83 c4 04	 add	 esp, 4
  000b0	e9 ff 04 00 00	 jmp	 $LN1@process_fr
$LN19@process_fr:

; 1289 :    s->img_x = get16(s);   if (s->img_x == 0) return e("0 width","Corrupt JPEG"); // JPEG requires

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000be	83 c4 04	 add	 esp, 4
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000c4	89 02		 mov	 DWORD PTR [edx], eax
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000c9	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cc	75 12		 jne	 SHORT $LN20@process_fr
  000ce	68 00 00 00 00	 push	 OFFSET $SG4294820244
  000d3	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000d8	83 c4 04	 add	 esp, 4
  000db	e9 d4 04 00 00	 jmp	 $LN1@process_fr
$LN20@process_fr:

; 1290 :    c = get8(s);

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000e9	83 c4 04	 add	 esp, 4
  000ec	89 45 e0	 mov	 DWORD PTR _c$[ebp], eax

; 1291 :    if (c != 3 && c != 1) return e("bad component count","Corrupt JPEG");    // JFIF requires

  000ef	83 7d e0 03	 cmp	 DWORD PTR _c$[ebp], 3
  000f3	74 18		 je	 SHORT $LN21@process_fr
  000f5	83 7d e0 01	 cmp	 DWORD PTR _c$[ebp], 1
  000f9	74 12		 je	 SHORT $LN21@process_fr
  000fb	68 00 00 00 00	 push	 OFFSET $SG4294820243
  00100	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00105	83 c4 04	 add	 esp, 4
  00108	e9 a7 04 00 00	 jmp	 $LN1@process_fr
$LN21@process_fr:

; 1292 :    s->img_n = c;

  0010d	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00110	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00113	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1293 :    for (i=0; i < c; ++i) {

  00116	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN4@process_fr
$LN2@process_fr:
  0011f	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00122	83 c1 01	 add	 ecx, 1
  00125	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@process_fr:
  00128	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0012b	3b 55 e0	 cmp	 edx, DWORD PTR _c$[ebp]
  0012e	7d 26		 jge	 SHORT $LN3@process_fr

; 1294 :       z->img_comp[i].data = NULL;

  00130	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00137	c7 84 01 c8 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+13768], 0

; 1295 :       z->img_comp[i].linebuf = NULL;

  00142	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00146	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00149	c7 84 10 d0 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+13776], 0

; 1296 :    }

  00154	eb c9		 jmp	 SHORT $LN2@process_fr
$LN3@process_fr:

; 1297 : 
; 1298 :    if (Lf != 8+3*s->img_n) return e("bad SOF len","Corrupt JPEG");

  00156	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00159	6b 51 08 03	 imul	 edx, DWORD PTR [ecx+8], 3
  0015d	83 c2 08	 add	 edx, 8
  00160	39 55 f8	 cmp	 DWORD PTR _Lf$[ebp], edx
  00163	74 12		 je	 SHORT $LN22@process_fr
  00165	68 00 00 00 00	 push	 OFFSET $SG4294820242
  0016a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0016f	83 c4 04	 add	 esp, 4
  00172	e9 3d 04 00 00	 jmp	 $LN1@process_fr
$LN22@process_fr:

; 1299 : 
; 1300 :    for (i=0; i < s->img_n; ++i) {

  00177	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0017e	eb 09		 jmp	 SHORT $LN7@process_fr
$LN5@process_fr:
  00180	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00183	83 c0 01	 add	 eax, 1
  00186	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@process_fr:
  00189	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0018c	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0018f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00192	0f 8d 36 01 00
	00		 jge	 $LN6@process_fr

; 1301 :       z->img_comp[i].id = get8(s);

  00198	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001a1	83 c4 04	 add	 esp, 4
  001a4	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  001a8	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001ab	89 84 0a 9c 35
	00 00		 mov	 DWORD PTR [edx+ecx+13724], eax

; 1302 :       if (z->img_comp[i].id != i+1)   // JFIF requires

  001b2	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  001b9	83 c1 01	 add	 ecx, 1
  001bc	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001bf	39 8c 02 9c 35
	00 00		 cmp	 DWORD PTR [edx+eax+13724], ecx
  001c6	74 25		 je	 SHORT $LN23@process_fr

; 1303 :          if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!

  001c8	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  001cf	8b 94 01 9c 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13724]
  001d6	3b 55 f0	 cmp	 edx, DWORD PTR _i$[ebp]
  001d9	74 12		 je	 SHORT $LN23@process_fr

; 1304 :             return e("bad component ID","Corrupt JPEG");

  001db	68 00 00 00 00	 push	 OFFSET $SG4294820241
  001e0	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001e5	83 c4 04	 add	 esp, 4
  001e8	e9 c7 03 00 00	 jmp	 $LN1@process_fr
$LN23@process_fr:

; 1305 :       q = get8(s);

  001ed	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001f6	83 c4 04	 add	 esp, 4
  001f9	89 45 ec	 mov	 DWORD PTR _q$[ebp], eax

; 1306 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return e("bad H","Corrupt JPEG");

  001fc	8b 4d ec	 mov	 ecx, DWORD PTR _q$[ebp]
  001ff	c1 f9 04	 sar	 ecx, 4
  00202	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00206	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00209	89 8c 10 a0 35
	00 00		 mov	 DWORD PTR [eax+edx+13728], ecx
  00210	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00214	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00217	83 bc 0a a0 35
	00 00 00	 cmp	 DWORD PTR [edx+ecx+13728], 0
  0021f	74 11		 je	 SHORT $LN26@process_fr
  00221	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00225	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00228	83 bc 01 a0 35
	00 00 04	 cmp	 DWORD PTR [ecx+eax+13728], 4
  00230	7e 12		 jle	 SHORT $LN25@process_fr
$LN26@process_fr:
  00232	68 00 00 00 00	 push	 OFFSET $SG4294820240
  00237	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0023c	83 c4 04	 add	 esp, 4
  0023f	e9 70 03 00 00	 jmp	 $LN1@process_fr
$LN25@process_fr:

; 1307 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return e("bad V","Corrupt JPEG");

  00244	8b 55 ec	 mov	 edx, DWORD PTR _q$[ebp]
  00247	83 e2 0f	 and	 edx, 15			; 0000000fH
  0024a	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0024e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00251	89 94 01 a4 35
	00 00		 mov	 DWORD PTR [ecx+eax+13732], edx
  00258	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  0025c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0025f	83 bc 10 a4 35
	00 00 00	 cmp	 DWORD PTR [eax+edx+13732], 0
  00267	74 11		 je	 SHORT $LN28@process_fr
  00269	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  0026d	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00270	83 bc 0a a4 35
	00 00 04	 cmp	 DWORD PTR [edx+ecx+13732], 4
  00278	7e 12		 jle	 SHORT $LN27@process_fr
$LN28@process_fr:
  0027a	68 00 00 00 00	 push	 OFFSET $SG4294820239
  0027f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00284	83 c4 04	 add	 esp, 4
  00287	e9 28 03 00 00	 jmp	 $LN1@process_fr
$LN27@process_fr:

; 1308 :       z->img_comp[i].tq = get8(s);  if (z->img_comp[i].tq > 3) return e("bad TQ","Corrupt JPEG");

  0028c	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00295	83 c4 04	 add	 esp, 4
  00298	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  0029c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0029f	89 84 0a a8 35
	00 00		 mov	 DWORD PTR [edx+ecx+13736], eax
  002a6	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  002ad	83 bc 01 a8 35
	00 00 03	 cmp	 DWORD PTR [ecx+eax+13736], 3
  002b5	7e 12		 jle	 SHORT $LN29@process_fr
  002b7	68 00 00 00 00	 push	 OFFSET $SG4294820238
  002bc	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002c1	83 c4 04	 add	 esp, 4
  002c4	e9 eb 02 00 00	 jmp	 $LN1@process_fr
$LN29@process_fr:

; 1309 :    }

  002c9	e9 b2 fe ff ff	 jmp	 $LN5@process_fr
$LN6@process_fr:

; 1310 : 
; 1311 :    if (scan != SCAN_load) return 1;

  002ce	83 7d 0c 00	 cmp	 DWORD PTR _scan$[ebp], 0
  002d2	74 0a		 je	 SHORT $LN30@process_fr
  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	e9 d6 02 00 00	 jmp	 $LN1@process_fr
$LN30@process_fr:

; 1312 : 
; 1313 :    if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");

  002de	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  002e1	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  002e6	33 d2		 xor	 edx, edx
  002e8	f7 31		 div	 DWORD PTR [ecx]
  002ea	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  002ed	33 d2		 xor	 edx, edx
  002ef	f7 71 08	 div	 DWORD PTR [ecx+8]
  002f2	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  002f5	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  002f8	73 12		 jae	 SHORT $LN31@process_fr
  002fa	68 00 00 00 00	 push	 OFFSET $SG4294820237
  002ff	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00304	83 c4 04	 add	 esp, 4
  00307	e9 a8 02 00 00	 jmp	 $LN1@process_fr
$LN31@process_fr:

; 1314 : 
; 1315 :    for (i=0; i < s->img_n; ++i) {

  0030c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00313	eb 09		 jmp	 SHORT $LN10@process_fr
$LN8@process_fr:
  00315	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00318	83 c0 01	 add	 eax, 1
  0031b	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN10@process_fr:
  0031e	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00321	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00324	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00327	7d 4a		 jge	 SHORT $LN9@process_fr

; 1316 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

  00329	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0032d	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00330	8b 94 01 a0 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13728]
  00337	3b 55 e8	 cmp	 edx, DWORD PTR _h_max$[ebp]
  0033a	7e 11		 jle	 SHORT $LN32@process_fr
  0033c	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00340	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00343	8b 94 01 a0 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13728]
  0034a	89 55 e8	 mov	 DWORD PTR _h_max$[ebp], edx
$LN32@process_fr:

; 1317 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

  0034d	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00351	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00354	8b 94 01 a4 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13732]
  0035b	3b 55 e4	 cmp	 edx, DWORD PTR _v_max$[ebp]
  0035e	7e 11		 jle	 SHORT $LN33@process_fr
  00360	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00364	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00367	8b 94 01 a4 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13732]
  0036e	89 55 e4	 mov	 DWORD PTR _v_max$[ebp], edx
$LN33@process_fr:

; 1318 :    }

  00371	eb a2		 jmp	 SHORT $LN8@process_fr
$LN9@process_fr:

; 1319 : 
; 1320 :    // compute interleaved mcu info
; 1321 :    z->img_h_max = h_max;

  00373	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00376	8b 4d e8	 mov	 ecx, DWORD PTR _h_max$[ebp]
  00379	89 88 84 35 00
	00		 mov	 DWORD PTR [eax+13700], ecx

; 1322 :    z->img_v_max = v_max;

  0037f	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00382	8b 45 e4	 mov	 eax, DWORD PTR _v_max$[ebp]
  00385	89 82 88 35 00
	00		 mov	 DWORD PTR [edx+13704], eax

; 1323 :    z->img_mcu_w = h_max * 8;

  0038b	8b 4d e8	 mov	 ecx, DWORD PTR _h_max$[ebp]
  0038e	c1 e1 03	 shl	 ecx, 3
  00391	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00394	89 8a 94 35 00
	00		 mov	 DWORD PTR [edx+13716], ecx

; 1324 :    z->img_mcu_h = v_max * 8;

  0039a	8b 45 e4	 mov	 eax, DWORD PTR _v_max$[ebp]
  0039d	c1 e0 03	 shl	 eax, 3
  003a0	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003a3	89 81 98 35 00
	00		 mov	 DWORD PTR [ecx+13720], eax

; 1325 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

  003a9	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  003ac	8b 02		 mov	 eax, DWORD PTR [edx]
  003ae	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003b1	8b 91 94 35 00
	00		 mov	 edx, DWORD PTR [ecx+13716]
  003b7	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  003bb	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003be	33 d2		 xor	 edx, edx
  003c0	f7 b1 94 35 00
	00		 div	 DWORD PTR [ecx+13716]
  003c6	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  003c9	89 82 8c 35 00
	00		 mov	 DWORD PTR [edx+13708], eax

; 1326 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

  003cf	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  003d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003d5	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  003d8	8b 82 98 35 00
	00		 mov	 eax, DWORD PTR [edx+13720]
  003de	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  003e2	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  003e5	33 d2		 xor	 edx, edx
  003e7	f7 b1 98 35 00
	00		 div	 DWORD PTR [ecx+13720]
  003ed	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  003f0	89 82 90 35 00
	00		 mov	 DWORD PTR [edx+13712], eax

; 1327 : 
; 1328 :    for (i=0; i < s->img_n; ++i) {

  003f6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003fd	eb 09		 jmp	 SHORT $LN13@process_fr
$LN11@process_fr:
  003ff	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00402	83 c0 01	 add	 eax, 1
  00405	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN13@process_fr:
  00408	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0040b	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0040e	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00411	0f 8d 98 01 00
	00		 jge	 $LN12@process_fr

; 1329 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 1330 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

  00417	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0041b	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0041e	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00421	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00423	0f af 8c 02 a0
	35 00 00	 imul	 ecx, DWORD PTR [edx+eax+13728]
  0042b	8b 55 e8	 mov	 edx, DWORD PTR _h_max$[ebp]
  0042e	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00432	33 d2		 xor	 edx, edx
  00434	f7 75 e8	 div	 DWORD PTR _h_max$[ebp]
  00437	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  0043b	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0043e	89 84 0a b8 35
	00 00		 mov	 DWORD PTR [edx+ecx+13752], eax

; 1331 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

  00445	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00449	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0044c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0044f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00452	0f af 8c 02 a4
	35 00 00	 imul	 ecx, DWORD PTR [edx+eax+13732]
  0045a	8b 55 e4	 mov	 edx, DWORD PTR _v_max$[ebp]
  0045d	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00461	33 d2		 xor	 edx, edx
  00463	f7 75 e4	 div	 DWORD PTR _v_max$[ebp]
  00466	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  0046a	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0046d	89 84 0a bc 35
	00 00		 mov	 DWORD PTR [edx+ecx+13756], eax

; 1332 :       // to simplify generation, we'll allocate enough memory to decode
; 1333 :       // the bogus oversized data from using interleaved MCUs and their
; 1334 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 1335 :       // discard the extra data until colorspace conversion
; 1336 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

  00474	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00478	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0047b	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0047e	8b 89 8c 35 00
	00		 mov	 ecx, DWORD PTR [ecx+13708]
  00484	0f af 8c 02 a0
	35 00 00	 imul	 ecx, DWORD PTR [edx+eax+13728]
  0048c	c1 e1 03	 shl	 ecx, 3
  0048f	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00493	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00496	89 8c 10 c0 35
	00 00		 mov	 DWORD PTR [eax+edx+13760], ecx

; 1337 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

  0049d	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  004a1	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  004a4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  004a7	8b 92 90 35 00
	00		 mov	 edx, DWORD PTR [edx+13712]
  004ad	0f af 94 08 a4
	35 00 00	 imul	 edx, DWORD PTR [eax+ecx+13732]
  004b5	c1 e2 03	 shl	 edx, 3
  004b8	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  004bc	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  004bf	89 94 01 c4 35
	00 00		 mov	 DWORD PTR [ecx+eax+13764], edx

; 1338 :       z->img_comp[i].raw_data = malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);

  004c6	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  004ca	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  004ce	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  004d1	8b 75 08	 mov	 esi, DWORD PTR _z$[ebp]
  004d4	8b 94 11 c0 35
	00 00		 mov	 edx, DWORD PTR [ecx+edx+13760]
  004db	0f af 94 06 c4
	35 00 00	 imul	 edx, DWORD PTR [esi+eax+13764]
  004e3	83 c2 0f	 add	 edx, 15			; 0000000fH
  004e6	8b f4		 mov	 esi, esp
  004e8	52		 push	 edx
  004e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  004ef	83 c4 04	 add	 esp, 4
  004f2	3b f4		 cmp	 esi, esp
  004f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004f9	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  004fd	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00500	89 84 0a cc 35
	00 00		 mov	 DWORD PTR [edx+ecx+13772], eax

; 1339 :       if (z->img_comp[i].raw_data == NULL) {

  00507	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0050b	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0050e	83 bc 01 cc 35
	00 00 00	 cmp	 DWORD PTR [ecx+eax+13772], 0
  00516	75 5e		 jne	 SHORT $LN34@process_fr

; 1340 :          for(--i; i >= 0; --i) {

  00518	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0051b	83 ea 01	 sub	 edx, 1
  0051e	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
  00521	eb 09		 jmp	 SHORT $LN16@process_fr
$LN14@process_fr:
  00523	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00526	83 e8 01	 sub	 eax, 1
  00529	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN16@process_fr:
  0052c	83 7d f0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00530	7c 35		 jl	 SHORT $LN15@process_fr

; 1341 :             free(z->img_comp[i].raw_data);

  00532	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00536	8b f4		 mov	 esi, esp
  00538	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0053b	8b 84 0a cc 35
	00 00		 mov	 eax, DWORD PTR [edx+ecx+13772]
  00542	50		 push	 eax
  00543	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00549	83 c4 04	 add	 esp, 4
  0054c	3b f4		 cmp	 esi, esp
  0054e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1342 :             z->img_comp[i].data = NULL;

  00553	6b 4d f0 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00557	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0055a	c7 84 0a c8 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+13768], 0

; 1343 :          }

  00565	eb bc		 jmp	 SHORT $LN14@process_fr
$LN15@process_fr:

; 1344 :          return e("outofmem", "Out of memory");

  00567	68 00 00 00 00	 push	 OFFSET $SG4294820236
  0056c	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00571	83 c4 04	 add	 esp, 4
  00574	eb 3e		 jmp	 SHORT $LN1@process_fr
$LN34@process_fr:

; 1345 :       }
; 1346 :       // align blocks for installable-idct using mmx/sse
; 1347 :       z->img_comp[i].data = (uint8*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

  00576	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0057a	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0057d	8b 94 01 cc 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13772]
  00584	83 c2 0f	 add	 edx, 15			; 0000000fH
  00587	83 e2 f0	 and	 edx, -16		; fffffff0H
  0058a	6b 45 f0 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0058e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00591	89 94 01 c8 35
	00 00		 mov	 DWORD PTR [ecx+eax+13768], edx

; 1348 :       z->img_comp[i].linebuf = NULL;

  00598	6b 55 f0 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  0059c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0059f	c7 84 10 d0 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+13776], 0

; 1349 :    }

  005aa	e9 50 fe ff ff	 jmp	 $LN11@process_fr
$LN12@process_fr:

; 1350 : 
; 1351 :    return 1;

  005af	b8 01 00 00 00	 mov	 eax, 1
$LN1@process_fr:

; 1352 : }

  005b4	5e		 pop	 esi
  005b5	83 c4 20	 add	 esp, 32			; 00000020H
  005b8	3b ec		 cmp	 ebp, esp
  005ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c3		 ret	 0
?process_frame_header@@YAHPAUjpeg@@H@Z ENDP		; process_frame_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_m$ = -4						; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
?decode_jpeg_header@@YAHPAUjpeg@@H@Z PROC		; decode_jpeg_header

; 1362 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1363 :    int m;
; 1364 :    z->marker = MARKER_none; // initialize cached marker to empty

  0000b	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0000e	c6 80 84 36 00
	00 ff		 mov	 BYTE PTR [eax+13956], 255 ; 000000ffH

; 1365 :    m = get_marker(z);

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  0001e	83 c4 04	 add	 esp, 4
  00021	0f b6 d0	 movzx	 edx, al
  00024	89 55 fc	 mov	 DWORD PTR _m$[ebp], edx

; 1366 :    if (!SOI(m)) return e("no SOI","Corrupt JPEG");

  00027	81 7d fc d8 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 216	; 000000d8H
  0002e	74 12		 je	 SHORT $LN6@decode_jpe
  00030	68 00 00 00 00	 push	 OFFSET $SG4294820235
  00035	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0003a	83 c4 04	 add	 esp, 4
  0003d	e9 bb 00 00 00	 jmp	 $LN1@decode_jpe
$LN6@decode_jpe:

; 1367 :    if (scan == SCAN_type) return 1;

  00042	83 7d 0c 01	 cmp	 DWORD PTR _scan$[ebp], 1
  00046	75 0a		 jne	 SHORT $LN7@decode_jpe
  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	e9 ab 00 00 00	 jmp	 $LN1@decode_jpe
$LN7@decode_jpe:

; 1368 :    m = get_marker(z);

  00052	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f b6 c8	 movzx	 ecx, al
  00061	89 4d fc	 mov	 DWORD PTR _m$[ebp], ecx
$LN2@decode_jpe:

; 1369 :    while (!SOF(m)) {

  00064	81 7d fc c0 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 192	; 000000c0H
  0006b	74 73		 je	 SHORT $LN3@decode_jpe
  0006d	81 7d fc c1 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 193	; 000000c1H
  00074	74 6a		 je	 SHORT $LN3@decode_jpe

; 1370 :       if (!process_marker(z,m)) return 0;

  00076	8b 55 fc	 mov	 edx, DWORD PTR _m$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?process_marker@@YAHPAUjpeg@@H@Z ; process_marker
  00083	83 c4 08	 add	 esp, 8
  00086	85 c0		 test	 eax, eax
  00088	75 04		 jne	 SHORT $LN8@decode_jpe
  0008a	33 c0		 xor	 eax, eax
  0008c	eb 6f		 jmp	 SHORT $LN1@decode_jpe
$LN8@decode_jpe:

; 1371 :       m = get_marker(z);

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  00097	83 c4 04	 add	 esp, 4
  0009a	0f b6 d0	 movzx	 edx, al
  0009d	89 55 fc	 mov	 DWORD PTR _m$[ebp], edx
$LN4@decode_jpe:

; 1372 :       while (m == MARKER_none) {

  000a0	81 7d fc ff 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 255	; 000000ffH
  000a7	75 35		 jne	 SHORT $LN5@decode_jpe

; 1373 :          // some files have extra padding after their blocks, so ok, we'll scan
; 1374 :          if (at_eof(z->s)) return e("no SOF", "Corrupt JPEG");

  000a9	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	74 0f		 je	 SHORT $LN9@decode_jpe
  000bb	68 00 00 00 00	 push	 OFFSET $SG4294820234
  000c0	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000c5	83 c4 04	 add	 esp, 4
  000c8	eb 33		 jmp	 SHORT $LN1@decode_jpe
$LN9@decode_jpe:

; 1375 :          m = get_marker(z);

  000ca	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  000d3	83 c4 04	 add	 esp, 4
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	89 45 fc	 mov	 DWORD PTR _m$[ebp], eax

; 1376 :       }

  000dc	eb c2		 jmp	 SHORT $LN4@decode_jpe
$LN5@decode_jpe:

; 1377 :    }

  000de	eb 84		 jmp	 SHORT $LN2@decode_jpe
$LN3@decode_jpe:

; 1378 :    if (!process_frame_header(z, scan)) return 0;

  000e0	8b 4d 0c	 mov	 ecx, DWORD PTR _scan$[ebp]
  000e3	51		 push	 ecx
  000e4	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?process_frame_header@@YAHPAUjpeg@@H@Z ; process_frame_header
  000ed	83 c4 08	 add	 esp, 8
  000f0	85 c0		 test	 eax, eax
  000f2	75 04		 jne	 SHORT $LN10@decode_jpe
  000f4	33 c0		 xor	 eax, eax
  000f6	eb 05		 jmp	 SHORT $LN1@decode_jpe
$LN10@decode_jpe:

; 1379 :    return 1;

  000f8	b8 01 00 00 00	 mov	 eax, 1
$LN1@decode_jpe:

; 1380 : }

  000fd	83 c4 04	 add	 esp, 4
  00100	3b ec		 cmp	 ebp, esp
  00102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?decode_jpeg_header@@YAHPAUjpeg@@H@Z ENDP		; decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_x$1 = -8						; size = 4
_m$ = -4						; size = 4
_j$ = 8							; size = 4
?decode_jpeg_image@@YAHPAUjpeg@@@Z PROC			; decode_jpeg_image

; 1383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1384 :    int m;
; 1385 :    j->restart_interval = 0;

  00014	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00017	c7 80 a0 36 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+13984], 0

; 1386 :    if (!decode_jpeg_header(j, SCAN_load)) return 0;

  00021	6a 00		 push	 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?decode_jpeg_header@@YAHPAUjpeg@@H@Z ; decode_jpeg_header
  0002c	83 c4 08	 add	 esp, 8
  0002f	85 c0		 test	 eax, eax
  00031	75 07		 jne	 SHORT $LN6@decode_jpe
  00033	33 c0		 xor	 eax, eax
  00035	e9 f5 00 00 00	 jmp	 $LN1@decode_jpe
$LN6@decode_jpe:

; 1387 :    m = get_marker(j);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  00043	83 c4 04	 add	 esp, 4
  00046	0f b6 c0	 movzx	 eax, al
  00049	89 45 fc	 mov	 DWORD PTR _m$[ebp], eax
$LN2@decode_jpe:

; 1388 :    while (!EOI(m)) {

  0004c	81 7d fc d9 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 217	; 000000d9H
  00053	0f 84 d1 00 00
	00		 je	 $LN3@decode_jpe

; 1389 :       if (SOS(m)) {

  00059	81 7d fc da 00
	00 00		 cmp	 DWORD PTR _m$[ebp], 218	; 000000daH
  00060	0f 85 95 00 00
	00		 jne	 $LN7@decode_jpe

; 1390 :          if (!process_scan_header(j)) return 0;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?process_scan_header@@YAHPAUjpeg@@@Z ; process_scan_header
  0006f	83 c4 04	 add	 esp, 4
  00072	85 c0		 test	 eax, eax
  00074	75 07		 jne	 SHORT $LN9@decode_jpe
  00076	33 c0		 xor	 eax, eax
  00078	e9 b2 00 00 00	 jmp	 $LN1@decode_jpe
$LN9@decode_jpe:

; 1391 :          if (!parse_entropy_coded_data(j)) return 0;

  0007d	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ?parse_entropy_coded_data@@YAHPAUjpeg@@@Z ; parse_entropy_coded_data
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	75 07		 jne	 SHORT $LN10@decode_jpe
  0008d	33 c0		 xor	 eax, eax
  0008f	e9 9b 00 00 00	 jmp	 $LN1@decode_jpe
$LN10@decode_jpe:

; 1392 :          if (j->marker == MARKER_none ) {

  00094	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00097	0f b6 88 84 36
	00 00		 movzx	 ecx, BYTE PTR [eax+13956]
  0009e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000a4	75 53		 jne	 SHORT $LN11@decode_jpe
$LN4@decode_jpe:

; 1393 :             // handle 0s at the end of image data from IP Kamera 9060
; 1394 :             while (!at_eof(j->s)) {

  000a6	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  000b1	83 c4 04	 add	 esp, 4
  000b4	85 c0		 test	 eax, eax
  000b6	75 41		 jne	 SHORT $LN11@decode_jpe

; 1395 :                int x = get8(j->s);

  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000c3	83 c4 04	 add	 esp, 4
  000c6	89 45 f8	 mov	 DWORD PTR _x$1[ebp], eax

; 1396 :                if (x == 255) {

  000c9	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _x$1[ebp], 255 ; 000000ffH
  000d0	75 1b		 jne	 SHORT $LN12@decode_jpe

; 1397 :                   j->marker = get8u(j->s);

  000d2	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000dd	83 c4 04	 add	 esp, 4
  000e0	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000e3	88 82 84 36 00
	00		 mov	 BYTE PTR [edx+13956], al

; 1398 :                   break;

  000e9	eb 0e		 jmp	 SHORT $LN11@decode_jpe
  000eb	eb 0a		 jmp	 SHORT $LN13@decode_jpe
$LN12@decode_jpe:

; 1399 :                } else if (x != 0) {

  000ed	83 7d f8 00	 cmp	 DWORD PTR _x$1[ebp], 0
  000f1	74 04		 je	 SHORT $LN13@decode_jpe

; 1400 :                   return 0;

  000f3	33 c0		 xor	 eax, eax
  000f5	eb 38		 jmp	 SHORT $LN1@decode_jpe
$LN13@decode_jpe:

; 1401 :                }
; 1402 :             }

  000f7	eb ad		 jmp	 SHORT $LN4@decode_jpe
$LN11@decode_jpe:

; 1403 :             // if we reach eof without hitting a marker, get_marker() below will fail and we'll eventually return 0
; 1404 :          }
; 1405 :       } else {

  000f9	eb 18		 jmp	 SHORT $LN8@decode_jpe
$LN7@decode_jpe:

; 1406 :          if (!process_marker(j, m)) return 0;

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _m$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 ?process_marker@@YAHPAUjpeg@@H@Z ; process_marker
  00108	83 c4 08	 add	 esp, 8
  0010b	85 c0		 test	 eax, eax
  0010d	75 04		 jne	 SHORT $LN8@decode_jpe
  0010f	33 c0		 xor	 eax, eax
  00111	eb 1c		 jmp	 SHORT $LN1@decode_jpe
$LN8@decode_jpe:

; 1407 :       }
; 1408 :       m = get_marker(j);

  00113	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 ?get_marker@@YAEPAUjpeg@@@Z ; get_marker
  0011c	83 c4 04	 add	 esp, 4
  0011f	0f b6 c0	 movzx	 eax, al
  00122	89 45 fc	 mov	 DWORD PTR _m$[ebp], eax

; 1409 :    }

  00125	e9 22 ff ff ff	 jmp	 $LN2@decode_jpe
$LN3@decode_jpe:

; 1410 :    return 1;

  0012a	b8 01 00 00 00	 mov	 eax, 1
$LN1@decode_jpe:

; 1411 : }

  0012f	83 c4 08	 add	 esp, 8
  00132	3b ec		 cmp	 ebp, esp
  00134	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?decode_jpeg_image@@YAHPAUjpeg@@@Z ENDP			; decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_1@@YAPAEPAE00HH@Z PROC			; resample_row_1

; 1421 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1422 :    STBI_NOTUSED(out);
; 1423 :    STBI_NOTUSED(in_far);
; 1424 :    STBI_NOTUSED(w);
; 1425 :    STBI_NOTUSED(hs);
; 1426 :    return in_near;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in_near$[ebp]

; 1427 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?resample_row_1@@YAPAEPAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_v_2@@YAPAEPAE00HH@Z PROC			; resample_row_v_2

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1431 :    // need to generate two samples vertically for every one in input
; 1432 :    int i;
; 1433 :    STBI_NOTUSED(hs);
; 1434 :    for (i=0; i < w; ++i)

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00012	eb 09		 jmp	 SHORT $LN4@resample_r
$LN2@resample_r:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@resample_r:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00020	3b 4d 14	 cmp	 ecx, DWORD PTR _w$[ebp]
  00023	7d 26		 jge	 SHORT $LN3@resample_r

; 1435 :       out[i] = div4(3*in_near[i] + in_far[i] + 2);

  00025	8b 55 0c	 mov	 edx, DWORD PTR _in_near$[ebp]
  00028	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002e	6b c8 03	 imul	 ecx, eax, 3
  00031	8b 55 10	 mov	 edx, DWORD PTR _in_far$[ebp]
  00034	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00037	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0003a	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  0003e	c1 f9 02	 sar	 ecx, 2
  00041	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00044	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00047	88 0a		 mov	 BYTE PTR [edx], cl
  00049	eb c9		 jmp	 SHORT $LN2@resample_r
$LN3@resample_r:

; 1436 :    return out;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]

; 1437 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?resample_row_v_2@@YAPAEPAE00HH@Z ENDP			; resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_input$ = -8						; size = 4
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_h_2@@YAPAEPAE00HH@Z PROC			; resample_row_h_2

; 1440 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1441 :    // need to generate two samples horizontally for every one in input
; 1442 :    int i;
; 1443 :    uint8 *input = in_near;

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _in_near$[ebp]
  0001f	89 45 f8	 mov	 DWORD PTR _input$[ebp], eax

; 1444 : 
; 1445 :    if (w == 1) {

  00022	83 7d 14 01	 cmp	 DWORD PTR _w$[ebp], 1
  00026	75 40		 jne	 SHORT $LN5@resample_r

; 1446 :       // if only one sample, can't do any interpolation
; 1447 :       out[0] = out[1] = input[0];

  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	6b d1 00	 imul	 edx, ecx, 0
  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	c1 e0 00	 shl	 eax, 0
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  0003b	8b 75 f8	 mov	 esi, DWORD PTR _input$[ebp]
  0003e	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00041	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 01 00 00 00	 mov	 ecx, 1
  00051	6b d1 00	 imul	 edx, ecx, 0
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _out$[ebp]
  0005a	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0005d	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1448 :       return out;

  00060	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  00063	e9 f3 00 00 00	 jmp	 $LN1@resample_r
$LN5@resample_r:

; 1449 :    }
; 1450 : 
; 1451 :    out[0] = input[0];

  00068	b9 01 00 00 00	 mov	 ecx, 1
  0006d	6b d1 00	 imul	 edx, ecx, 0
  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	6b c8 00	 imul	 ecx, eax, 0
  00078	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0007b	8b 75 f8	 mov	 esi, DWORD PTR _input$[ebp]
  0007e	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00081	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1452 :    out[1] = div4(input[0]*3 + input[1] + 2);

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	6b c8 00	 imul	 ecx, eax, 0
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  0008f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00093	6b c8 03	 imul	 ecx, eax, 3
  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	c1 e2 00	 shl	 edx, 0
  0009e	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000a1	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  000a5	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  000a9	c1 f8 02	 sar	 eax, 2
  000ac	b9 01 00 00 00	 mov	 ecx, 1
  000b1	c1 e1 00	 shl	 ecx, 0
  000b4	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  000b7	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1453 :    for (i=1; i < w-1; ++i) {

  000ba	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000c1	eb 09		 jmp	 SHORT $LN4@resample_r
$LN2@resample_r:
  000c3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c6	83 c0 01	 add	 eax, 1
  000c9	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@resample_r:
  000cc	8b 4d 14	 mov	 ecx, DWORD PTR _w$[ebp]
  000cf	83 e9 01	 sub	 ecx, 1
  000d2	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  000d5	7d 47		 jge	 SHORT $LN3@resample_r

; 1454 :       int n = 3*input[i]+2;

  000d7	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  000da	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000dd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e0	6b c8 03	 imul	 ecx, eax, 3
  000e3	83 c1 02	 add	 ecx, 2
  000e6	89 4d f4	 mov	 DWORD PTR _n$1[ebp], ecx

; 1455 :       out[i*2+0] = div4(n+input[i-1]);

  000e9	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  000ec	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000ef	0f b6 42 ff	 movzx	 eax, BYTE PTR [edx-1]
  000f3	03 45 f4	 add	 eax, DWORD PTR _n$1[ebp]
  000f6	c1 f8 02	 sar	 eax, 2
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000fc	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  000ff	88 04 4a	 mov	 BYTE PTR [edx+ecx*2], al

; 1456 :       out[i*2+1] = div4(n+input[i+1]);

  00102	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  00105	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00108	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0010c	03 4d f4	 add	 ecx, DWORD PTR _n$1[ebp]
  0010f	c1 f9 02	 sar	 ecx, 2
  00112	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00115	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  00118	88 4c 50 01	 mov	 BYTE PTR [eax+edx*2+1], cl

; 1457 :    }

  0011c	eb a5		 jmp	 SHORT $LN2@resample_r
$LN3@resample_r:

; 1458 :    out[i*2+0] = div4(input[w-2]*3 + input[w-1] + 2);

  0011e	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  00121	03 4d 14	 add	 ecx, DWORD PTR _w$[ebp]
  00124	0f b6 51 fe	 movzx	 edx, BYTE PTR [ecx-2]
  00128	6b c2 03	 imul	 eax, edx, 3
  0012b	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  0012e	03 4d 14	 add	 ecx, DWORD PTR _w$[ebp]
  00131	0f b6 51 ff	 movzx	 edx, BYTE PTR [ecx-1]
  00135	8d 44 10 02	 lea	 eax, DWORD PTR [eax+edx+2]
  00139	c1 f8 02	 sar	 eax, 2
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0013f	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00142	88 04 4a	 mov	 BYTE PTR [edx+ecx*2], al

; 1459 :    out[i*2+1] = input[w-1];

  00145	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  00148	03 45 14	 add	 eax, DWORD PTR _w$[ebp]
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014e	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00151	8a 40 ff	 mov	 al, BYTE PTR [eax-1]
  00154	88 44 4a 01	 mov	 BYTE PTR [edx+ecx*2+1], al

; 1460 : 
; 1461 :    STBI_NOTUSED(in_far);
; 1462 :    STBI_NOTUSED(hs);
; 1463 : 
; 1464 :    return out;

  00158	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@resample_r:

; 1465 : }

  0015b	5e		 pop	 esi
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
?resample_row_h_2@@YAPAEPAE00HH@Z ENDP			; resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv78 = -16						; size = 4
_t1$ = -12						; size = 4
_t0$ = -8						; size = 4
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_hv_2@@YAPAEPAE00HH@Z PROC			; resample_row_hv_2

; 1470 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1471 :    // need to generate 2x2 samples for every one in input
; 1472 :    int i,t0,t1;
; 1473 :    if (w == 1) {

  00017	83 7d 14 01	 cmp	 DWORD PTR _w$[ebp], 1
  0001b	75 55		 jne	 SHORT $LN5@resample_r

; 1474 :       out[0] = out[1] = div4(3*in_near[0] + in_far[0] + 2);

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	8b 55 0c	 mov	 edx, DWORD PTR _in_near$[ebp]
  00028	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0002c	6b c8 03	 imul	 ecx, eax, 3
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	6b c2 00	 imul	 eax, edx, 0
  00037	8b 55 10	 mov	 edx, DWORD PTR _in_far$[ebp]
  0003a	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  0003e	8d 4c 01 02	 lea	 ecx, DWORD PTR [ecx+eax+2]
  00042	c1 f9 02	 sar	 ecx, 2
  00045	89 4d f0	 mov	 DWORD PTR tv78[ebp], ecx
  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	c1 e2 00	 shl	 edx, 0
  00050	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  00053	8a 4d f0	 mov	 cl, BYTE PTR tv78[ebp]
  00056	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00059	ba 01 00 00 00	 mov	 edx, 1
  0005e	6b c2 00	 imul	 eax, edx, 0
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00064	8a 55 f0	 mov	 dl, BYTE PTR tv78[ebp]
  00067	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1475 :       return out;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0006d	e9 be 00 00 00	 jmp	 $LN1@resample_r
$LN5@resample_r:

; 1476 :    }
; 1477 : 
; 1478 :    t1 = 3*in_near[0] + in_far[0];

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	6b c8 00	 imul	 ecx, eax, 0
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _in_near$[ebp]
  0007d	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00081	6b c8 03	 imul	 ecx, eax, 3
  00084	ba 01 00 00 00	 mov	 edx, 1
  00089	6b c2 00	 imul	 eax, edx, 0
  0008c	8b 55 10	 mov	 edx, DWORD PTR _in_far$[ebp]
  0008f	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00093	03 c8		 add	 ecx, eax
  00095	89 4d f4	 mov	 DWORD PTR _t1$[ebp], ecx

; 1479 :    out[0] = div4(t1+2);

  00098	8b 4d f4	 mov	 ecx, DWORD PTR _t1$[ebp]
  0009b	83 c1 02	 add	 ecx, 2
  0009e	c1 f9 02	 sar	 ecx, 2
  000a1	ba 01 00 00 00	 mov	 edx, 1
  000a6	6b c2 00	 imul	 eax, edx, 0
  000a9	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  000ac	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 1480 :    for (i=1; i < w; ++i) {

  000af	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000b6	eb 09		 jmp	 SHORT $LN4@resample_r
$LN2@resample_r:
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@resample_r:
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c4	3b 4d 14	 cmp	 ecx, DWORD PTR _w$[ebp]
  000c7	7d 51		 jge	 SHORT $LN3@resample_r

; 1481 :       t0 = t1;

  000c9	8b 55 f4	 mov	 edx, DWORD PTR _t1$[ebp]
  000cc	89 55 f8	 mov	 DWORD PTR _t0$[ebp], edx

; 1482 :       t1 = 3*in_near[i]+in_far[i];

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _in_near$[ebp]
  000d2	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000d5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d8	6b d1 03	 imul	 edx, ecx, 3
  000db	8b 45 10	 mov	 eax, DWORD PTR _in_far$[ebp]
  000de	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000e1	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e4	03 d1		 add	 edx, ecx
  000e6	89 55 f4	 mov	 DWORD PTR _t1$[ebp], edx

; 1483 :       out[i*2-1] = div16(3*t0 + t1 + 8);

  000e9	6b 55 f8 03	 imul	 edx, DWORD PTR _t0$[ebp], 3
  000ed	8b 45 f4	 mov	 eax, DWORD PTR _t1$[ebp]
  000f0	8d 4c 02 08	 lea	 ecx, DWORD PTR [edx+eax+8]
  000f4	c1 f9 04	 sar	 ecx, 4
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fa	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  000fd	88 4c 50 ff	 mov	 BYTE PTR [eax+edx*2-1], cl

; 1484 :       out[i*2  ] = div16(3*t1 + t0 + 8);

  00101	6b 4d f4 03	 imul	 ecx, DWORD PTR _t1$[ebp], 3
  00105	8b 55 f8	 mov	 edx, DWORD PTR _t0$[ebp]
  00108	8d 44 11 08	 lea	 eax, DWORD PTR [ecx+edx+8]
  0010c	c1 f8 04	 sar	 eax, 4
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00112	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00115	88 04 4a	 mov	 BYTE PTR [edx+ecx*2], al

; 1485 :    }

  00118	eb 9e		 jmp	 SHORT $LN2@resample_r
$LN3@resample_r:

; 1486 :    out[w*2-1] = div4(t1+2);

  0011a	8b 45 f4	 mov	 eax, DWORD PTR _t1$[ebp]
  0011d	83 c0 02	 add	 eax, 2
  00120	c1 f8 02	 sar	 eax, 2
  00123	8b 4d 14	 mov	 ecx, DWORD PTR _w$[ebp]
  00126	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00129	88 44 4a ff	 mov	 BYTE PTR [edx+ecx*2-1], al

; 1487 : 
; 1488 :    STBI_NOTUSED(hs);
; 1489 : 
; 1490 :    return out;

  0012d	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@resample_r:

; 1491 : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
?resample_row_hv_2@@YAPAEPAE00HH@Z ENDP			; resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_in_near$ = 12						; size = 4
_in_far$ = 16						; size = 4
_w$ = 20						; size = 4
_hs$ = 24						; size = 4
?resample_row_generic@@YAPAEPAE00HH@Z PROC		; resample_row_generic

; 1494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1495 :    // resample with nearest-neighbor
; 1496 :    int i,j;
; 1497 :    in_far = in_far;

  00014	8b 45 10	 mov	 eax, DWORD PTR _in_far$[ebp]
  00017	89 45 10	 mov	 DWORD PTR _in_far$[ebp], eax

; 1498 :    for (i=0; i < w; ++i)

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@resample_r
$LN2@resample_r:
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	83 c1 01	 add	 ecx, 1
  00029	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@resample_r:
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	3b 55 14	 cmp	 edx, DWORD PTR _w$[ebp]
  00032	7d 36		 jge	 SHORT $LN3@resample_r

; 1499 :       for (j=0; j < hs; ++j)

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN7@resample_r
$LN5@resample_r:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@resample_r:
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00049	3b 4d 18	 cmp	 ecx, DWORD PTR _hs$[ebp]
  0004c	7d 1a		 jge	 SHORT $LN6@resample_r

; 1500 :          out[i*hs+j] = in_near[i];

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00051	0f af 55 18	 imul	 edx, DWORD PTR _hs$[ebp]
  00055	03 55 f8	 add	 edx, DWORD PTR _j$[ebp]
  00058	8b 45 0c	 mov	 eax, DWORD PTR _in_near$[ebp]
  0005b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00061	8a 00		 mov	 al, BYTE PTR [eax]
  00063	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00066	eb d5		 jmp	 SHORT $LN5@resample_r
$LN6@resample_r:
  00068	eb b9		 jmp	 SHORT $LN2@resample_r
$LN3@resample_r:

; 1501 :    return out;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]

; 1502 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?resample_row_generic@@YAPAEPAE00HH@Z ENDP		; resample_row_generic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_cb$1 = -28						; size = 4
_cr$2 = -24						; size = 4
_b$3 = -20						; size = 4
_g$4 = -16						; size = 4
_r$5 = -12						; size = 4
_y_fixed$6 = -8						; size = 4
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_y$ = 12						; size = 4
_pcb$ = 16						; size = 4
_pcr$ = 20						; size = 4
_count$ = 24						; size = 4
_step$ = 28						; size = 4
?YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z PROC			; YCbCr_to_RGB_row

; 1509 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1510 :    int i;
; 1511 :    for (i=0; i < count; ++i) {

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@YCbCr_to_R
$LN2@YCbCr_to_R:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@YCbCr_to_R:
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00035	3b 4d 18	 cmp	 ecx, DWORD PTR _count$[ebp]
  00038	0f 8d 31 01 00
	00		 jge	 $LN1@YCbCr_to_R

; 1512 :       int y_fixed = (y[i] << 16) + 32768; // rounding

  0003e	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00041	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00044	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00047	c1 e0 10	 shl	 eax, 16			; 00000010H
  0004a	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  0004f	89 45 f8	 mov	 DWORD PTR _y_fixed$6[ebp], eax

; 1513 :       int r,g,b;
; 1514 :       int cr = pcr[i] - 128;

  00052	8b 4d 14	 mov	 ecx, DWORD PTR _pcr$[ebp]
  00055	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00058	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0005b	81 ea 80 00 00
	00		 sub	 edx, 128		; 00000080H
  00061	89 55 e8	 mov	 DWORD PTR _cr$2[ebp], edx

; 1515 :       int cb = pcb[i] - 128;

  00064	8b 45 10	 mov	 eax, DWORD PTR _pcb$[ebp]
  00067	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0006a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0006d	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
  00073	89 4d e4	 mov	 DWORD PTR _cb$1[ebp], ecx

; 1516 :       r = y_fixed + cr*float2fixed(1.40200f);

  00076	69 55 e8 e9 66
	01 00		 imul	 edx, DWORD PTR _cr$2[ebp], 91881
  0007d	03 55 f8	 add	 edx, DWORD PTR _y_fixed$6[ebp]
  00080	89 55 f4	 mov	 DWORD PTR _r$5[ebp], edx

; 1517 :       g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);

  00083	69 45 e8 d2 b6
	00 00		 imul	 eax, DWORD PTR _cr$2[ebp], 46802
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _y_fixed$6[ebp]
  0008d	2b c8		 sub	 ecx, eax
  0008f	69 55 e4 1a 58
	00 00		 imul	 edx, DWORD PTR _cb$1[ebp], 22554
  00096	2b ca		 sub	 ecx, edx
  00098	89 4d f0	 mov	 DWORD PTR _g$4[ebp], ecx

; 1518 :       b = y_fixed                            + cb*float2fixed(1.77200f);

  0009b	69 45 e4 a2 c5
	01 00		 imul	 eax, DWORD PTR _cb$1[ebp], 116130
  000a2	03 45 f8	 add	 eax, DWORD PTR _y_fixed$6[ebp]
  000a5	89 45 ec	 mov	 DWORD PTR _b$3[ebp], eax

; 1519 :       r >>= 16;

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _r$5[ebp]
  000ab	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000ae	89 4d f4	 mov	 DWORD PTR _r$5[ebp], ecx

; 1520 :       g >>= 16;

  000b1	8b 55 f0	 mov	 edx, DWORD PTR _g$4[ebp]
  000b4	c1 fa 10	 sar	 edx, 16			; 00000010H
  000b7	89 55 f0	 mov	 DWORD PTR _g$4[ebp], edx

; 1521 :       b >>= 16;

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _b$3[ebp]
  000bd	c1 f8 10	 sar	 eax, 16			; 00000010H
  000c0	89 45 ec	 mov	 DWORD PTR _b$3[ebp], eax

; 1522 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  000c3	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _r$5[ebp], 255 ; 000000ffH
  000ca	76 16		 jbe	 SHORT $LN5@YCbCr_to_R
  000cc	83 7d f4 00	 cmp	 DWORD PTR _r$5[ebp], 0
  000d0	7d 09		 jge	 SHORT $LN6@YCbCr_to_R
  000d2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _r$5[ebp], 0
  000d9	eb 07		 jmp	 SHORT $LN5@YCbCr_to_R
$LN6@YCbCr_to_R:
  000db	c7 45 f4 ff 00
	00 00		 mov	 DWORD PTR _r$5[ebp], 255 ; 000000ffH
$LN5@YCbCr_to_R:

; 1523 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  000e2	81 7d f0 ff 00
	00 00		 cmp	 DWORD PTR _g$4[ebp], 255 ; 000000ffH
  000e9	76 16		 jbe	 SHORT $LN8@YCbCr_to_R
  000eb	83 7d f0 00	 cmp	 DWORD PTR _g$4[ebp], 0
  000ef	7d 09		 jge	 SHORT $LN9@YCbCr_to_R
  000f1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _g$4[ebp], 0
  000f8	eb 07		 jmp	 SHORT $LN8@YCbCr_to_R
$LN9@YCbCr_to_R:
  000fa	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR _g$4[ebp], 255 ; 000000ffH
$LN8@YCbCr_to_R:

; 1524 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  00101	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _b$3[ebp], 255 ; 000000ffH
  00108	76 16		 jbe	 SHORT $LN11@YCbCr_to_R
  0010a	83 7d ec 00	 cmp	 DWORD PTR _b$3[ebp], 0
  0010e	7d 09		 jge	 SHORT $LN12@YCbCr_to_R
  00110	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _b$3[ebp], 0
  00117	eb 07		 jmp	 SHORT $LN11@YCbCr_to_R
$LN12@YCbCr_to_R:
  00119	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR _b$3[ebp], 255 ; 000000ffH
$LN11@YCbCr_to_R:

; 1525 :       out[0] = (uint8)r;

  00120	b9 01 00 00 00	 mov	 ecx, 1
  00125	6b d1 00	 imul	 edx, ecx, 0
  00128	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0012b	8a 4d f4	 mov	 cl, BYTE PTR _r$5[ebp]
  0012e	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1526 :       out[1] = (uint8)g;

  00131	ba 01 00 00 00	 mov	 edx, 1
  00136	c1 e2 00	 shl	 edx, 0
  00139	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0013c	8a 4d f0	 mov	 cl, BYTE PTR _g$4[ebp]
  0013f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1527 :       out[2] = (uint8)b;

  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	d1 e2		 shl	 edx, 1
  00149	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  0014c	8a 4d ec	 mov	 cl, BYTE PTR _b$3[ebp]
  0014f	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1528 :       out[3] = 255;

  00152	ba 01 00 00 00	 mov	 edx, 1
  00157	6b c2 03	 imul	 eax, edx, 3
  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  0015d	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH

; 1529 :       out += step;

  00161	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  00164	03 55 1c	 add	 edx, DWORD PTR _step$[ebp]
  00167	89 55 08	 mov	 DWORD PTR _out$[ebp], edx

; 1530 :    }

  0016a	e9 ba fe ff ff	 jmp	 $LN2@YCbCr_to_R
$LN1@YCbCr_to_R:

; 1531 : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
?YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z ENDP			; YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_j$ = 8							; size = 4
?cleanup_jpeg@@YAXPAUjpeg@@@Z PROC			; cleanup_jpeg

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1546 :    int i;
; 1547 :    for (i=0; i < j->s->img_n; ++i) {

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@cleanup_jp
$LN2@cleanup_jp:
  00015	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cleanup_jp:
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00026	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00029	0f 8d 8d 00 00
	00		 jge	 $LN1@cleanup_jp

; 1548 :       if (j->img_comp[i].data) {

  0002f	6b 4d fc 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00033	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00036	83 bc 0a c8 35
	00 00 00	 cmp	 DWORD PTR [edx+ecx+13768], 0
  0003e	74 33		 je	 SHORT $LN5@cleanup_jp

; 1549 :          free(j->img_comp[i].raw_data);

  00040	6b 45 fc 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00044	8b f4		 mov	 esi, esp
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00049	8b 94 01 cc 35
	00 00		 mov	 edx, DWORD PTR [ecx+eax+13772]
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00057	83 c4 04	 add	 esp, 4
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1550 :          j->img_comp[i].data = NULL;

  00061	6b 45 fc 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00068	c7 84 01 c8 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+13768], 0
$LN5@cleanup_jp:

; 1551 :       }
; 1552 :       if (j->img_comp[i].linebuf) {

  00073	6b 55 fc 38	 imul	 edx, DWORD PTR _i$[ebp], 56
  00077	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  0007a	83 bc 10 d0 35
	00 00 00	 cmp	 DWORD PTR [eax+edx+13776], 0
  00082	74 33		 je	 SHORT $LN6@cleanup_jp

; 1553 :          free(j->img_comp[i].linebuf);

  00084	6b 4d fc 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  00088	8b f4		 mov	 esi, esp
  0008a	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  0008d	8b 84 0a d0 35
	00 00		 mov	 eax, DWORD PTR [edx+ecx+13776]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1554 :          j->img_comp[i].linebuf = NULL;

  000a5	6b 4d fc 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  000a9	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  000ac	c7 84 0a d0 35
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+13776], 0
$LN6@cleanup_jp:

; 1555 :       }
; 1556 :    }

  000b7	e9 59 ff ff ff	 jmp	 $LN2@cleanup_jp
$LN1@cleanup_jp:

; 1557 : }

  000bc	5e		 pop	 esi
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?cleanup_jpeg@@YAXPAUjpeg@@@Z ENDP			; cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv267 = -248						; size = 4
tv259 = -244						; size = 4
tv250 = -240						; size = 4
tv245 = -236						; size = 4
tv233 = -232						; size = 4
tv215 = -228						; size = 4
tv143 = -224						; size = 4
tv79 = -220						; size = 4
tv69 = -216						; size = 4
_y$1 = -212						; size = 4
_y$2 = -208						; size = 4
_y_bot$3 = -204						; size = 4
_r$4 = -200						; size = 4
_out$5 = -196						; size = 4
_r$6 = -192						; size = 4
_res_comp$7 = -184					; size = 128
_coutput$8 = -48					; size = 16
_output$9 = -28						; size = 4
_j$10 = -24						; size = 4
_i$11 = -20						; size = 4
_k$12 = -16						; size = 4
_decode_n$ = -12					; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_out_x$ = 12						; size = 4
_out_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?load_jpeg_image@@YAPAEPAUjpeg@@PAH11H@Z PROC		; load_jpeg_image

; 1570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00011	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1571 :    int n, decode_n;
; 1572 :    // validate req_comp
; 1573 :    if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");

  00027	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  0002b	7c 06		 jl	 SHORT $LN21@load_jpeg_
  0002d	83 7d 18 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  00031	7e 32		 jle	 SHORT $LN20@load_jpeg_
$LN21@load_jpeg_:
  00033	68 00 00 00 00	 push	 OFFSET $SG4294820233
  00038	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 0c		 je	 SHORT $LN45@load_jpeg_
  00044	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  0004e	eb 0a		 jmp	 SHORT $LN46@load_jpeg_
$LN45@load_jpeg_:
  00050	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN46@load_jpeg_:
  0005a	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00060	e9 e2 06 00 00	 jmp	 $LN1@load_jpeg_
$LN20@load_jpeg_:

; 1574 :    z->s->img_n = 0;

  00065	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 1575 : 
; 1576 :    // load a jpeg image from whichever source
; 1577 :    if (!decode_jpeg_image(z)) { cleanup_jpeg(z); return NULL; }

  00071	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?decode_jpeg_image@@YAHPAUjpeg@@@Z ; decode_jpeg_image
  0007a	83 c4 04	 add	 esp, 4
  0007d	85 c0		 test	 eax, eax
  0007f	75 13		 jne	 SHORT $LN22@load_jpeg_
  00081	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?cleanup_jpeg@@YAXPAUjpeg@@@Z ; cleanup_jpeg
  0008a	83 c4 04	 add	 esp, 4
  0008d	33 c0		 xor	 eax, eax
  0008f	e9 b3 06 00 00	 jmp	 $LN1@load_jpeg_
$LN22@load_jpeg_:

; 1578 : 
; 1579 :    // determine actual number of components to generate
; 1580 :    n = req_comp ? req_comp : z->s->img_n;

  00094	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00098	74 0b		 je	 SHORT $LN47@load_jpeg_
  0009a	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  0009d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
  000a3	eb 0e		 jmp	 SHORT $LN48@load_jpeg_
$LN47@load_jpeg_:
  000a5	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ad	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
$LN48@load_jpeg_:
  000b3	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  000b9	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx

; 1581 : 
; 1582 :    if (z->s->img_n == 3 && n < 3)

  000bc	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c1	83 79 08 03	 cmp	 DWORD PTR [ecx+8], 3
  000c5	75 0f		 jne	 SHORT $LN23@load_jpeg_
  000c7	83 7d f8 03	 cmp	 DWORD PTR _n$[ebp], 3
  000cb	7d 09		 jge	 SHORT $LN23@load_jpeg_

; 1583 :       decode_n = 1;

  000cd	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _decode_n$[ebp], 1

; 1584 :    else

  000d4	eb 0b		 jmp	 SHORT $LN24@load_jpeg_
$LN23@load_jpeg_:

; 1585 :       decode_n = z->s->img_n;

  000d6	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000de	89 4d f4	 mov	 DWORD PTR _decode_n$[ebp], ecx
$LN24@load_jpeg_:

; 1586 : 
; 1587 :    // resample and color-convert
; 1588 :    {
; 1589 :       int k;
; 1590 :       uint i,j;
; 1591 :       uint8 *output;
; 1592 :       uint8 *coutput[4];
; 1593 : 
; 1594 :       stbi_resample res_comp[4];
; 1595 : 
; 1596 :       for (k=0; k < decode_n; ++k) {

  000e1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$12[ebp], 0
  000e8	eb 09		 jmp	 SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
  000ea	8b 55 f0	 mov	 edx, DWORD PTR _k$12[ebp]
  000ed	83 c2 01	 add	 edx, 1
  000f0	89 55 f0	 mov	 DWORD PTR _k$12[ebp], edx
$LN4@load_jpeg_:
  000f3	8b 45 f0	 mov	 eax, DWORD PTR _k$12[ebp]
  000f6	3b 45 f4	 cmp	 eax, DWORD PTR _decode_n$[ebp]
  000f9	0f 8d ea 01 00
	00		 jge	 $LN3@load_jpeg_

; 1597 :          stbi_resample *r = &res_comp[k];

  000ff	8b 4d f0	 mov	 ecx, DWORD PTR _k$12[ebp]
  00102	c1 e1 05	 shl	 ecx, 5
  00105	8d 94 0d 48 ff
	ff ff		 lea	 edx, DWORD PTR _res_comp$7[ebp+ecx]
  0010c	89 95 40 ff ff
	ff		 mov	 DWORD PTR _r$6[ebp], edx

; 1598 : 
; 1599 :          // allocate line buffer big enough for upsampling off the edges
; 1600 :          // with upsample factor of 4
; 1601 :          z->img_comp[k].linebuf = (uint8 *) malloc(z->s->img_x + 3);

  00112	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00115	8b 08		 mov	 ecx, DWORD PTR [eax]
  00117	8b 11		 mov	 edx, DWORD PTR [ecx]
  00119	83 c2 03	 add	 edx, 3
  0011c	8b f4		 mov	 esi, esp
  0011e	52		 push	 edx
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00125	83 c4 04	 add	 esp, 4
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  00133	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00136	89 84 0a d0 35
	00 00		 mov	 DWORD PTR [edx+ecx+13776], eax

; 1602 :          if (!z->img_comp[k].linebuf) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

  0013d	6b 45 f0 38	 imul	 eax, DWORD PTR _k$12[ebp], 56
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00144	83 bc 01 d0 35
	00 00 00	 cmp	 DWORD PTR [ecx+eax+13776], 0
  0014c	75 3e		 jne	 SHORT $LN25@load_jpeg_
  0014e	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 ?cleanup_jpeg@@YAXPAUjpeg@@@Z ; cleanup_jpeg
  00157	83 c4 04	 add	 esp, 4
  0015a	68 00 00 00 00	 push	 OFFSET $SG4294820232
  0015f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00164	83 c4 04	 add	 esp, 4
  00167	85 c0		 test	 eax, eax
  00169	74 0c		 je	 SHORT $LN49@load_jpeg_
  0016b	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv143[ebp], 0
  00175	eb 0a		 jmp	 SHORT $LN50@load_jpeg_
$LN49@load_jpeg_:
  00177	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv143[ebp], 0
$LN50@load_jpeg_:
  00181	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  00187	e9 bb 05 00 00	 jmp	 $LN1@load_jpeg_
$LN25@load_jpeg_:

; 1603 : 
; 1604 :          r->hs      = z->img_h_max / z->img_comp[k].h;

  0018c	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  00190	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00193	8b 75 08	 mov	 esi, DWORD PTR _z$[ebp]
  00196	8b 82 84 35 00
	00		 mov	 eax, DWORD PTR [edx+13700]
  0019c	99		 cdq
  0019d	f7 bc 0e a0 35
	00 00		 idiv	 DWORD PTR [esi+ecx+13728]
  001a4	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  001aa	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1605 :          r->vs      = z->img_v_max / z->img_comp[k].v;

  001ad	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  001b1	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001b4	8b 75 08	 mov	 esi, DWORD PTR _z$[ebp]
  001b7	8b 82 88 35 00
	00		 mov	 eax, DWORD PTR [edx+13704]
  001bd	99		 cdq
  001be	f7 bc 0e a4 35
	00 00		 idiv	 DWORD PTR [esi+ecx+13732]
  001c5	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  001cb	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1606 :          r->ystep   = r->vs >> 1;

  001ce	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  001d4	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001d7	d1 f8		 sar	 eax, 1
  001d9	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  001df	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1607 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;

  001e2	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001e5	8b 02		 mov	 eax, DWORD PTR [edx]
  001e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e9	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  001ef	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001f2	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  001f6	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  001fc	33 d2		 xor	 edx, edx
  001fe	f7 71 0c	 div	 DWORD PTR [ecx+12]
  00201	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  00207	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1608 :          r->ypos    = 0;

  0020a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  00210	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1609 :          r->line0   = r->line1 = z->img_comp[k].data;

  00217	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  0021b	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  00221	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00224	8b 8c 08 c8 35
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+13768]
  0022b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0022e	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  00234	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  0023a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0023d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1610 : 
; 1611 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

  00240	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  00246	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  0024a	75 1a		 jne	 SHORT $LN26@load_jpeg_
  0024c	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  00252	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00256	75 0e		 jne	 SHORT $LN26@load_jpeg_
  00258	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  0025e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ?resample_row_1@@YAPAEPAE00HH@Z ; resample_row_1
  00264	eb 7e		 jmp	 SHORT $LN27@load_jpeg_
$LN26@load_jpeg_:

; 1612 :          else if (r->hs == 1 && r->vs == 2) r->resample = resample_row_v_2;

  00266	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  0026c	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  00270	75 1a		 jne	 SHORT $LN28@load_jpeg_
  00272	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  00278	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  0027c	75 0e		 jne	 SHORT $LN28@load_jpeg_
  0027e	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  00284	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ?resample_row_v_2@@YAPAEPAE00HH@Z ; resample_row_v_2
  0028a	eb 58		 jmp	 SHORT $LN27@load_jpeg_
$LN28@load_jpeg_:

; 1613 :          else if (r->hs == 2 && r->vs == 1) r->resample = resample_row_h_2;

  0028c	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  00292	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00296	75 1a		 jne	 SHORT $LN30@load_jpeg_
  00298	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  0029e	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  002a2	75 0e		 jne	 SHORT $LN30@load_jpeg_
  002a4	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  002aa	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ?resample_row_h_2@@YAPAEPAE00HH@Z ; resample_row_h_2
  002b0	eb 32		 jmp	 SHORT $LN27@load_jpeg_
$LN30@load_jpeg_:

; 1614 :          else if (r->hs == 2 && r->vs == 2) r->resample = resample_row_hv_2;

  002b2	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  002b8	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  002bc	75 1a		 jne	 SHORT $LN32@load_jpeg_
  002be	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _r$6[ebp]
  002c4	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  002c8	75 0e		 jne	 SHORT $LN32@load_jpeg_
  002ca	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  002d0	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ?resample_row_hv_2@@YAPAEPAE00HH@Z ; resample_row_hv_2
  002d6	eb 0c		 jmp	 SHORT $LN27@load_jpeg_
$LN32@load_jpeg_:

; 1615 :          else                               r->resample = resample_row_generic;

  002d8	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _r$6[ebp]
  002de	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ?resample_row_generic@@YAPAEPAE00HH@Z ; resample_row_generic
$LN27@load_jpeg_:

; 1616 :       }

  002e4	e9 01 fe ff ff	 jmp	 $LN2@load_jpeg_
$LN3@load_jpeg_:

; 1617 : 
; 1618 :       // can't error after this so, this is safe
; 1619 :       output = (uint8 *) malloc(n * z->s->img_x * z->s->img_y + 1);

  002e9	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ee	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  002f1	0f af 11	 imul	 edx, DWORD PTR [ecx]
  002f4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f9	0f af 51 04	 imul	 edx, DWORD PTR [ecx+4]
  002fd	83 c2 01	 add	 edx, 1
  00300	8b f4		 mov	 esi, esp
  00302	52		 push	 edx
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00309	83 c4 04	 add	 esp, 4
  0030c	3b f4		 cmp	 esi, esp
  0030e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00313	89 45 e4	 mov	 DWORD PTR _output$9[ebp], eax

; 1620 :       if (!output) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

  00316	83 7d e4 00	 cmp	 DWORD PTR _output$9[ebp], 0
  0031a	75 3e		 jne	 SHORT $LN34@load_jpeg_
  0031c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0031f	52		 push	 edx
  00320	e8 00 00 00 00	 call	 ?cleanup_jpeg@@YAXPAUjpeg@@@Z ; cleanup_jpeg
  00325	83 c4 04	 add	 esp, 4
  00328	68 00 00 00 00	 push	 OFFSET $SG4294820231
  0032d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00332	83 c4 04	 add	 esp, 4
  00335	85 c0		 test	 eax, eax
  00337	74 0c		 je	 SHORT $LN51@load_jpeg_
  00339	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv215[ebp], 0
  00343	eb 0a		 jmp	 SHORT $LN52@load_jpeg_
$LN51@load_jpeg_:
  00345	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv215[ebp], 0
$LN52@load_jpeg_:
  0034f	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv215[ebp]
  00355	e9 ed 03 00 00	 jmp	 $LN1@load_jpeg_
$LN34@load_jpeg_:

; 1621 : 
; 1622 :       // now go ahead and resample
; 1623 :       for (j=0; j < z->s->img_y; ++j) {

  0035a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$10[ebp], 0
  00361	eb 09		 jmp	 SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
  00363	8b 45 e8	 mov	 eax, DWORD PTR _j$10[ebp]
  00366	83 c0 01	 add	 eax, 1
  00369	89 45 e8	 mov	 DWORD PTR _j$10[ebp], eax
$LN7@load_jpeg_:
  0036c	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0036f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00371	8b 45 e8	 mov	 eax, DWORD PTR _j$10[ebp]
  00374	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00377	0f 83 8f 03 00
	00		 jae	 $LN6@load_jpeg_

; 1624 :          uint8 *out = output + n * z->s->img_x * j;

  0037d	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00380	8b 11		 mov	 edx, DWORD PTR [ecx]
  00382	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00385	0f af 02	 imul	 eax, DWORD PTR [edx]
  00388	0f af 45 e8	 imul	 eax, DWORD PTR _j$10[ebp]
  0038c	03 45 e4	 add	 eax, DWORD PTR _output$9[ebp]
  0038f	89 85 3c ff ff
	ff		 mov	 DWORD PTR _out$5[ebp], eax

; 1625 :          for (k=0; k < decode_n; ++k) {

  00395	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$12[ebp], 0
  0039c	eb 09		 jmp	 SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
  0039e	8b 4d f0	 mov	 ecx, DWORD PTR _k$12[ebp]
  003a1	83 c1 01	 add	 ecx, 1
  003a4	89 4d f0	 mov	 DWORD PTR _k$12[ebp], ecx
$LN10@load_jpeg_:
  003a7	8b 55 f0	 mov	 edx, DWORD PTR _k$12[ebp]
  003aa	3b 55 f4	 cmp	 edx, DWORD PTR _decode_n$[ebp]
  003ad	0f 8d 98 01 00
	00		 jge	 $LN9@load_jpeg_

; 1626 :             stbi_resample *r = &res_comp[k];

  003b3	8b 45 f0	 mov	 eax, DWORD PTR _k$12[ebp]
  003b6	c1 e0 05	 shl	 eax, 5
  003b9	8d 8c 05 48 ff
	ff ff		 lea	 ecx, DWORD PTR _res_comp$7[ebp+eax]
  003c0	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _r$4[ebp], ecx

; 1627 :             int y_bot = r->ystep >= (r->vs >> 1);

  003c6	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  003cc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  003cf	d1 f8		 sar	 eax, 1
  003d1	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  003d7	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  003da	7c 0c		 jl	 SHORT $LN53@load_jpeg_
  003dc	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv233[ebp], 1
  003e6	eb 0a		 jmp	 SHORT $LN54@load_jpeg_
$LN53@load_jpeg_:
  003e8	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv233[ebp], 0
$LN54@load_jpeg_:
  003f2	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv233[ebp]
  003f8	89 95 34 ff ff
	ff		 mov	 DWORD PTR _y_bot$3[ebp], edx

; 1628 :             coutput[k] = r->resample(z->img_comp[k].linebuf,

  003fe	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _y_bot$3[ebp], 0
  00405	74 11		 je	 SHORT $LN55@load_jpeg_
  00407	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _r$4[ebp]
  0040d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00410	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], ecx
  00416	eb 0f		 jmp	 SHORT $LN56@load_jpeg_
$LN55@load_jpeg_:
  00418	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  0041e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00421	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
$LN56@load_jpeg_:
  00427	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _y_bot$3[ebp], 0
  0042e	74 11		 je	 SHORT $LN57@load_jpeg_
  00430	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  00436	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00439	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv250[ebp], edx
  0043f	eb 0f		 jmp	 SHORT $LN58@load_jpeg_
$LN57@load_jpeg_:
  00441	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _r$4[ebp]
  00447	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0044a	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv250[ebp], ecx
$LN58@load_jpeg_:
  00450	8b f4		 mov	 esi, esp
  00452	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  00458	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0045b	50		 push	 eax
  0045c	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  00462	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00465	52		 push	 edx
  00466	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv245[ebp]
  0046c	50		 push	 eax
  0046d	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv250[ebp]
  00473	51		 push	 ecx
  00474	6b 55 f0 38	 imul	 edx, DWORD PTR _k$12[ebp], 56
  00478	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0047b	8b 8c 10 d0 35
	00 00		 mov	 ecx, DWORD PTR [eax+edx+13776]
  00482	51		 push	 ecx
  00483	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  00489	8b 02		 mov	 eax, DWORD PTR [edx]
  0048b	ff d0		 call	 eax
  0048d	83 c4 14	 add	 esp, 20			; 00000014H
  00490	3b f4		 cmp	 esi, esp
  00492	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00497	8b 4d f0	 mov	 ecx, DWORD PTR _k$12[ebp]
  0049a	89 44 8d d0	 mov	 DWORD PTR _coutput$8[ebp+ecx*4], eax

; 1629 :                                      y_bot ? r->line1 : r->line0,
; 1630 :                                      y_bot ? r->line0 : r->line1,
; 1631 :                                      r->w_lores, r->hs);
; 1632 :             if (++r->ystep >= r->vs) {

  0049e	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  004a4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  004a7	83 c0 01	 add	 eax, 1
  004aa	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv259[ebp], eax
  004b0	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  004b6	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv259[ebp]
  004bc	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  004bf	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _r$4[ebp]
  004c5	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv259[ebp]
  004cb	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  004ce	7c 76		 jl	 SHORT $LN35@load_jpeg_

; 1633 :                r->ystep = 0;

  004d0	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  004d6	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1634 :                r->line0 = r->line1;

  004dd	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _r$4[ebp]
  004e3	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  004e9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  004ec	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1635 :                if (++r->ypos < z->img_comp[k].y)

  004ef	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _r$4[ebp]
  004f5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  004f8	83 c1 01	 add	 ecx, 1
  004fb	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv267[ebp], ecx
  00501	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  00507	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv267[ebp]
  0050d	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00510	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  00514	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00517	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv267[ebp]
  0051d	3b 84 0a bc 35
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+13756]
  00524	7d 20		 jge	 SHORT $LN35@load_jpeg_

; 1636 :                   r->line1 += z->img_comp[k].w2;

  00526	6b 4d f0 38	 imul	 ecx, DWORD PTR _k$12[ebp], 56
  0052a	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _r$4[ebp]
  00530	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00533	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00536	03 84 0a c0 35
	00 00		 add	 eax, DWORD PTR [edx+ecx+13760]
  0053d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _r$4[ebp]
  00543	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN35@load_jpeg_:

; 1637 :             }
; 1638 :          }

  00546	e9 53 fe ff ff	 jmp	 $LN8@load_jpeg_
$LN9@load_jpeg_:

; 1639 :          if (n >= 3) {

  0054b	83 7d f8 03	 cmp	 DWORD PTR _n$[ebp], 3
  0054f	0f 8c 08 01 00
	00		 jl	 $LN37@load_jpeg_

; 1640 :             uint8 *y = coutput[0];

  00555	ba 04 00 00 00	 mov	 edx, 4
  0055a	6b c2 00	 imul	 eax, edx, 0
  0055d	8b 4c 05 d0	 mov	 ecx, DWORD PTR _coutput$8[ebp+eax]
  00561	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _y$2[ebp], ecx

; 1641 :             if (z->s->img_n == 3) {

  00567	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0056a	8b 02		 mov	 eax, DWORD PTR [edx]
  0056c	83 78 08 03	 cmp	 DWORD PTR [eax+8], 3
  00570	75 40		 jne	 SHORT $LN39@load_jpeg_

; 1642 :                #ifdef STBI_SIMD
; 1643 :                stbi_YCbCr_installed(out, y, coutput[1], coutput[2], z->s.img_x, n);
; 1644 :                #else
; 1645 :                YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00572	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00575	51		 push	 ecx
  00576	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00579	8b 02		 mov	 eax, DWORD PTR [edx]
  0057b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0057d	51		 push	 ecx
  0057e	ba 04 00 00 00	 mov	 edx, 4
  00583	d1 e2		 shl	 edx, 1
  00585	8b 44 15 d0	 mov	 eax, DWORD PTR _coutput$8[ebp+edx]
  00589	50		 push	 eax
  0058a	b9 04 00 00 00	 mov	 ecx, 4
  0058f	c1 e1 00	 shl	 ecx, 0
  00592	8b 54 0d d0	 mov	 edx, DWORD PTR _coutput$8[ebp+ecx]
  00596	52		 push	 edx
  00597	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  0059d	50		 push	 eax
  0059e	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _out$5[ebp]
  005a4	51		 push	 ecx
  005a5	e8 00 00 00 00	 call	 ?YCbCr_to_RGB_row@@YAXPAEPBE11HH@Z ; YCbCr_to_RGB_row
  005aa	83 c4 18	 add	 esp, 24			; 00000018H

; 1646 :                #endif
; 1647 :             } else

  005ad	e9 a6 00 00 00	 jmp	 $LN40@load_jpeg_
$LN39@load_jpeg_:

; 1648 :                for (i=0; i < z->s->img_x; ++i) {

  005b2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$11[ebp], 0
  005b9	eb 09		 jmp	 SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
  005bb	8b 55 ec	 mov	 edx, DWORD PTR _i$11[ebp]
  005be	83 c2 01	 add	 edx, 1
  005c1	89 55 ec	 mov	 DWORD PTR _i$11[ebp], edx
$LN13@load_jpeg_:
  005c4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  005c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c9	8b 55 ec	 mov	 edx, DWORD PTR _i$11[ebp]
  005cc	3b 11		 cmp	 edx, DWORD PTR [ecx]
  005ce	0f 83 84 00 00
	00		 jae	 $LN40@load_jpeg_

; 1649 :                   out[0] = out[1] = out[2] = y[i];

  005d4	b8 01 00 00 00	 mov	 eax, 1
  005d9	d1 e0		 shl	 eax, 1
  005db	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _y$2[ebp]
  005e1	03 4d ec	 add	 ecx, DWORD PTR _i$11[ebp]
  005e4	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _out$5[ebp]
  005ea	8a 09		 mov	 cl, BYTE PTR [ecx]
  005ec	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  005ef	ba 01 00 00 00	 mov	 edx, 1
  005f4	d1 e2		 shl	 edx, 1
  005f6	b8 01 00 00 00	 mov	 eax, 1
  005fb	c1 e0 00	 shl	 eax, 0
  005fe	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _out$5[ebp]
  00604	8b b5 3c ff ff
	ff		 mov	 esi, DWORD PTR _out$5[ebp]
  0060a	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0060d	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00610	b8 01 00 00 00	 mov	 eax, 1
  00615	c1 e0 00	 shl	 eax, 0
  00618	b9 01 00 00 00	 mov	 ecx, 1
  0061d	6b d1 00	 imul	 edx, ecx, 0
  00620	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _out$5[ebp]
  00626	8b b5 3c ff ff
	ff		 mov	 esi, DWORD PTR _out$5[ebp]
  0062c	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0062f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1650 :                   out[3] = 255; // not used if n==3

  00632	b9 01 00 00 00	 mov	 ecx, 1
  00637	6b d1 03	 imul	 edx, ecx, 3
  0063a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _out$5[ebp]
  00640	c6 04 10 ff	 mov	 BYTE PTR [eax+edx], 255	; 000000ffH

; 1651 :                   out += n;

  00644	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _out$5[ebp]
  0064a	03 4d f8	 add	 ecx, DWORD PTR _n$[ebp]
  0064d	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _out$5[ebp], ecx

; 1652 :                }

  00653	e9 63 ff ff ff	 jmp	 $LN11@load_jpeg_
$LN40@load_jpeg_:

; 1653 :          } else {

  00658	e9 aa 00 00 00	 jmp	 $LN38@load_jpeg_
$LN37@load_jpeg_:

; 1654 :             uint8 *y = coutput[0];

  0065d	ba 04 00 00 00	 mov	 edx, 4
  00662	6b c2 00	 imul	 eax, edx, 0
  00665	8b 4c 05 d0	 mov	 ecx, DWORD PTR _coutput$8[ebp+eax]
  00669	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _y$1[ebp], ecx

; 1655 :             if (n == 1)

  0066f	83 7d f8 01	 cmp	 DWORD PTR _n$[ebp], 1
  00673	75 38		 jne	 SHORT $LN41@load_jpeg_

; 1656 :                for (i=0; i < z->s->img_x; ++i) out[i] = y[i];

  00675	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$11[ebp], 0
  0067c	eb 09		 jmp	 SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
  0067e	8b 55 ec	 mov	 edx, DWORD PTR _i$11[ebp]
  00681	83 c2 01	 add	 edx, 1
  00684	89 55 ec	 mov	 DWORD PTR _i$11[ebp], edx
$LN16@load_jpeg_:
  00687	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0068a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068c	8b 55 ec	 mov	 edx, DWORD PTR _i$11[ebp]
  0068f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00691	73 18		 jae	 SHORT $LN15@load_jpeg_
  00693	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _out$5[ebp]
  00699	03 45 ec	 add	 eax, DWORD PTR _i$11[ebp]
  0069c	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _y$1[ebp]
  006a2	03 4d ec	 add	 ecx, DWORD PTR _i$11[ebp]
  006a5	8a 11		 mov	 dl, BYTE PTR [ecx]
  006a7	88 10		 mov	 BYTE PTR [eax], dl
  006a9	eb d3		 jmp	 SHORT $LN14@load_jpeg_
$LN15@load_jpeg_:

; 1657 :             else

  006ab	eb 5a		 jmp	 SHORT $LN38@load_jpeg_
$LN41@load_jpeg_:

; 1658 :                for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;

  006ad	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$11[ebp], 0
  006b4	eb 09		 jmp	 SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
  006b6	8b 45 ec	 mov	 eax, DWORD PTR _i$11[ebp]
  006b9	83 c0 01	 add	 eax, 1
  006bc	89 45 ec	 mov	 DWORD PTR _i$11[ebp], eax
$LN19@load_jpeg_:
  006bf	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  006c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  006c4	8b 45 ec	 mov	 eax, DWORD PTR _i$11[ebp]
  006c7	3b 02		 cmp	 eax, DWORD PTR [edx]
  006c9	73 3c		 jae	 SHORT $LN38@load_jpeg_
  006cb	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _y$1[ebp]
  006d1	03 4d ec	 add	 ecx, DWORD PTR _i$11[ebp]
  006d4	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _out$5[ebp]
  006da	8a 01		 mov	 al, BYTE PTR [ecx]
  006dc	88 02		 mov	 BYTE PTR [edx], al
  006de	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _out$5[ebp]
  006e4	83 c1 01	 add	 ecx, 1
  006e7	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _out$5[ebp], ecx
  006ed	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _out$5[ebp]
  006f3	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
  006f6	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _out$5[ebp]
  006fc	83 c0 01	 add	 eax, 1
  006ff	89 85 3c ff ff
	ff		 mov	 DWORD PTR _out$5[ebp], eax
  00705	eb af		 jmp	 SHORT $LN17@load_jpeg_
$LN38@load_jpeg_:

; 1659 :          }
; 1660 :       }

  00707	e9 57 fc ff ff	 jmp	 $LN5@load_jpeg_
$LN6@load_jpeg_:

; 1661 :       cleanup_jpeg(z);

  0070c	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0070f	51		 push	 ecx
  00710	e8 00 00 00 00	 call	 ?cleanup_jpeg@@YAXPAUjpeg@@@Z ; cleanup_jpeg
  00715	83 c4 04	 add	 esp, 4

; 1662 :       *out_x = z->s->img_x;

  00718	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0071b	8b 02		 mov	 eax, DWORD PTR [edx]
  0071d	8b 4d 0c	 mov	 ecx, DWORD PTR _out_x$[ebp]
  00720	8b 10		 mov	 edx, DWORD PTR [eax]
  00722	89 11		 mov	 DWORD PTR [ecx], edx

; 1663 :       *out_y = z->s->img_y;

  00724	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00727	8b 08		 mov	 ecx, DWORD PTR [eax]
  00729	8b 55 10	 mov	 edx, DWORD PTR _out_y$[ebp]
  0072c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0072f	89 02		 mov	 DWORD PTR [edx], eax

; 1664 :       if (comp) *comp  = z->s->img_n; // report original components, not output

  00731	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  00735	74 0d		 je	 SHORT $LN43@load_jpeg_
  00737	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0073a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0073c	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  0073f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00742	89 08		 mov	 DWORD PTR [eax], ecx
$LN43@load_jpeg_:

; 1665 :       return output;

  00744	8b 45 e4	 mov	 eax, DWORD PTR _output$9[ebp]
$LN1@load_jpeg_:

; 1666 :    }
; 1667 : }

  00747	52		 push	 edx
  00748	8b cd		 mov	 ecx, ebp
  0074a	50		 push	 eax
  0074b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN62@load_jpeg_
  00751	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00756	58		 pop	 eax
  00757	5a		 pop	 edx
  00758	5f		 pop	 edi
  00759	5e		 pop	 esi
  0075a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0075d	33 cd		 xor	 ecx, ebp
  0075f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00764	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0076a	3b ec		 cmp	 ebp, esp
  0076c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00771	8b e5		 mov	 esp, ebp
  00773	5d		 pop	 ebp
  00774	c3		 ret	 0
  00775	0f 1f 00	 npad	 3
$LN62@load_jpeg_:
  00778	02 00 00 00	 DD	 2
  0077c	00 00 00 00	 DD	 $LN61@load_jpeg_
$LN61@load_jpeg_:
  00780	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00784	10 00 00 00	 DD	 16			; 00000010H
  00788	00 00 00 00	 DD	 $LN59@load_jpeg_
  0078c	48 ff ff ff	 DD	 -184			; ffffff48H
  00790	80 00 00 00	 DD	 128			; 00000080H
  00794	00 00 00 00	 DD	 $LN60@load_jpeg_
$LN60@load_jpeg_:
  00798	72		 DB	 114			; 00000072H
  00799	65		 DB	 101			; 00000065H
  0079a	73		 DB	 115			; 00000073H
  0079b	5f		 DB	 95			; 0000005fH
  0079c	63		 DB	 99			; 00000063H
  0079d	6f		 DB	 111			; 0000006fH
  0079e	6d		 DB	 109			; 0000006dH
  0079f	70		 DB	 112			; 00000070H
  007a0	00		 DB	 0
$LN59@load_jpeg_:
  007a1	63		 DB	 99			; 00000063H
  007a2	6f		 DB	 111			; 0000006fH
  007a3	75		 DB	 117			; 00000075H
  007a4	74		 DB	 116			; 00000074H
  007a5	70		 DB	 112			; 00000070H
  007a6	75		 DB	 117			; 00000075H
  007a7	74		 DB	 116			; 00000074H
  007a8	00		 DB	 0
?load_jpeg_image@@YAPAEPAUjpeg@@PAH11H@Z ENDP		; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_j$ = -14000						; size = 13992
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_jpeg_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_jpeg_load

; 1670 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 b4 36 00 00	 mov	 eax, 14004		; 000036b4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd 4c c9 ff
	ff		 lea	 edi, DWORD PTR [ebp-14004]
  00014	b9 ad 0d 00 00	 mov	 ecx, 3501		; 00000dadH
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1671 :    jpeg j;
; 1672 :    j.s = s;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	89 85 50 c9 ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 1673 :    return load_jpeg_image(&j, x,y,comp,req_comp);

  00033	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00042	51		 push	 ecx
  00043	8d 95 50 c9 ff
	ff		 lea	 edx, DWORD PTR _j$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?load_jpeg_image@@YAPAEPAUjpeg@@PAH11H@Z ; load_jpeg_image
  0004f	83 c4 14	 add	 esp, 20			; 00000014H

; 1674 : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_jpeg_
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	5f		 pop	 edi
  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	81 c4 b4 36 00
	00		 add	 esp, 14004		; 000036b4H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
  0007f	90		 npad	 1
$LN5@stbi_jpeg_:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@stbi_jpeg_
$LN4@stbi_jpeg_:
  00088	50 c9 ff ff	 DD	 -14000			; ffffc950H
  0008c	a8 36 00 00	 DD	 13992			; 000036a8H
  00090	00 00 00 00	 DD	 $LN3@stbi_jpeg_
$LN3@stbi_jpeg_:
  00094	6a		 DB	 106			; 0000006aH
  00095	00		 DB	 0
?stbi_jpeg_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_jpeg_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_j$ = -14004						; size = 13992
_r$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?stbi_jpeg_test@@YAHPAUstbi@@@Z PROC			; stbi_jpeg_test

; 1677 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 b8 36 00 00	 mov	 eax, 14008		; 000036b8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd 48 c9 ff
	ff		 lea	 edi, DWORD PTR [ebp-14008]
  00014	b9 ae 0d 00 00	 mov	 ecx, 3502		; 00000daeH
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1678 :    int r;
; 1679 :    jpeg j;
; 1680 :    j.s = s;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	89 85 4c c9 ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 1681 :    r = decode_jpeg_header(&j, SCAN_type);

  00033	6a 01		 push	 1
  00035	8d 8d 4c c9 ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?decode_jpeg_header@@YAHPAUjpeg@@H@Z ; decode_jpeg_header
  00041	83 c4 08	 add	 esp, 8
  00044	89 45 f8	 mov	 DWORD PTR _r$[ebp], eax

; 1682 :    stbi_rewind(s);

  00047	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00050	83 c4 04	 add	 esp, 4

; 1683 :    return r;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]

; 1684 : }

  00056	52		 push	 edx
  00057	8b cd		 mov	 ecx, ebp
  00059	50		 push	 eax
  0005a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_jpeg_
  00060	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00065	58		 pop	 eax
  00066	5a		 pop	 edx
  00067	5f		 pop	 edi
  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	81 c4 b8 36 00
	00		 add	 esp, 14008		; 000036b8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	90		 npad	 1
$LN5@stbi_jpeg_:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@stbi_jpeg_
$LN4@stbi_jpeg_:
  0008c	4c c9 ff ff	 DD	 -14004			; ffffc94cH
  00090	a8 36 00 00	 DD	 13992			; 000036a8H
  00094	00 00 00 00	 DD	 $LN3@stbi_jpeg_
$LN3@stbi_jpeg_:
  00098	6a		 DB	 106			; 0000006aH
  00099	00		 DB	 0
?stbi_jpeg_test@@YAHPAUstbi@@@Z ENDP			; stbi_jpeg_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_j$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_jpeg_info_raw@@YAHPAUjpeg@@PAH11@Z PROC		; stbi_jpeg_info_raw

; 1687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1688 :    if (!decode_jpeg_header(j, SCAN_header)) {

  00003	6a 02		 push	 2
  00005	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?decode_jpeg_header@@YAHPAUjpeg@@H@Z ; decode_jpeg_header
  0000e	83 c4 08	 add	 esp, 8
  00011	85 c0		 test	 eax, eax
  00013	75 12		 jne	 SHORT $LN2@stbi_jpeg_

; 1689 :       stbi_rewind( j->s );

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00020	83 c4 04	 add	 esp, 4

; 1690 :       return 0;

  00023	33 c0		 xor	 eax, eax
  00025	eb 3d		 jmp	 SHORT $LN1@stbi_jpeg_
$LN2@stbi_jpeg_:

; 1691 :    }
; 1692 :    if (x) *x = j->s->img_x;

  00027	83 7d 0c 00	 cmp	 DWORD PTR _x$[ebp], 0
  0002b	74 0c		 je	 SHORT $LN3@stbi_jpeg_
  0002d	8b 45 08	 mov	 eax, DWORD PTR _j$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	89 02		 mov	 DWORD PTR [edx], eax
$LN3@stbi_jpeg_:

; 1693 :    if (y) *y = j->s->img_y;

  00039	83 7d 10 00	 cmp	 DWORD PTR _y$[ebp], 0
  0003d	74 0d		 je	 SHORT $LN4@stbi_jpeg_
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _j$[ebp]
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00047	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@stbi_jpeg_:

; 1694 :    if (comp) *comp = j->s->img_n;

  0004c	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  00050	74 0d		 je	 SHORT $LN5@stbi_jpeg_
  00052	8b 55 08	 mov	 edx, DWORD PTR _j$[ebp]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0005a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@stbi_jpeg_:

; 1695 :    return 1;

  0005f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_jpeg_:

; 1696 : }

  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?stbi_jpeg_info_raw@@YAHPAUjpeg@@PAH11@Z ENDP		; stbi_jpeg_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_j$ = -14000						; size = 13992
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_jpeg_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_jpeg_info

; 1699 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 b4 36 00 00	 mov	 eax, 14004		; 000036b4H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd 4c c9 ff
	ff		 lea	 edi, DWORD PTR [ebp-14004]
  00014	b9 ad 0d 00 00	 mov	 ecx, 3501		; 00000dadH
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1700 :    jpeg j;
; 1701 :    j.s = s;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	89 85 50 c9 ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 1702 :    return stbi_jpeg_info_raw(&j, x, y, comp);

  00033	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0003e	50		 push	 eax
  0003f	8d 8d 50 c9 ff
	ff		 lea	 ecx, DWORD PTR _j$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?stbi_jpeg_info_raw@@YAHPAUjpeg@@PAH11@Z ; stbi_jpeg_info_raw
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 1703 : }

  0004e	52		 push	 edx
  0004f	8b cd		 mov	 ecx, ebp
  00051	50		 push	 eax
  00052	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_jpeg_
  00058	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005d	58		 pop	 eax
  0005e	5a		 pop	 edx
  0005f	5f		 pop	 edi
  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	81 c4 b4 36 00
	00		 add	 esp, 14004		; 000036b4H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
  0007b	90		 npad	 1
$LN5@stbi_jpeg_:
  0007c	01 00 00 00	 DD	 1
  00080	00 00 00 00	 DD	 $LN4@stbi_jpeg_
$LN4@stbi_jpeg_:
  00084	50 c9 ff ff	 DD	 -14000			; ffffc950H
  00088	a8 36 00 00	 DD	 13992			; 000036a8H
  0008c	00 00 00 00	 DD	 $LN3@stbi_jpeg_
$LN3@stbi_jpeg_:
  00090	6a		 DB	 106			; 0000006aH
  00091	00		 DB	 0
?stbi_jpeg_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_jpeg_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_n$ = 8							; size = 4
?bitreverse16@@YAHH@Z PROC				; bitreverse16

; 1729 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1730 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0000b	d1 f8		 sar	 eax, 1
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00010	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  00016	d1 e1		 shl	 ecx, 1
  00018	0b c1		 or	 eax, ecx
  0001a	89 45 08	 mov	 DWORD PTR _n$[ebp], eax

; 1731 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  0001d	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00020	81 e2 cc cc 00
	00		 and	 edx, 52428		; 0000ccccH
  00026	c1 fa 02	 sar	 edx, 2
  00029	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0002c	25 33 33 00 00	 and	 eax, 13107		; 00003333H
  00031	c1 e0 02	 shl	 eax, 2
  00034	0b d0		 or	 edx, eax
  00036	89 55 08	 mov	 DWORD PTR _n$[ebp], edx

; 1732 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  0003c	81 e1 f0 f0 00
	00		 and	 ecx, 61680		; 0000f0f0H
  00042	c1 f9 04	 sar	 ecx, 4
  00045	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  00048	81 e2 0f 0f 00
	00		 and	 edx, 3855		; 00000f0fH
  0004e	c1 e2 04	 shl	 edx, 4
  00051	0b ca		 or	 ecx, edx
  00053	89 4d 08	 mov	 DWORD PTR _n$[ebp], ecx

; 1733 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  00056	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00059	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0005e	c1 f8 08	 sar	 eax, 8
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00064	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0006a	c1 e1 08	 shl	 ecx, 8
  0006d	0b c1		 or	 eax, ecx
  0006f	89 45 08	 mov	 DWORD PTR _n$[ebp], eax

; 1734 :   return n;

  00072	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 1735 : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?bitreverse16@@YAHH@Z ENDP				; bitreverse16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_v$ = 8							; size = 4
_bits$ = 12						; size = 4
?bit_reverse@@YAHHH@Z PROC				; bit_reverse

; 1738 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1739 :    assert(bits <= 16);

  00004	83 7d 0c 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00008	7e 21		 jle	 SHORT $LN3@bit_revers
  0000a	8b f4		 mov	 esi, esp
  0000c	68 cb 06 00 00	 push	 1739			; 000006cbH
  00011	68 00 00 00 00	 push	 OFFSET $SG4294820230
  00016	68 00 00 00 00	 push	 OFFSET $SG4294820229
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@bit_revers:

; 1740 :    // to bit reverse n bits, reverse 16 and shift
; 1741 :    // e.g. 11 bits, bit reverse and shift away 5
; 1742 :    return bitreverse16(v) >> (16-bits);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?bitreverse16@@YAHH@Z	; bitreverse16
  00034	83 c4 04	 add	 esp, 4
  00037	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0003c	2b 4d 0c	 sub	 ecx, DWORD PTR _bits$[ebp]
  0003f	d3 f8		 sar	 eax, cl

; 1743 : }

  00041	5e		 pop	 esi
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?bit_reverse@@YAHHH@Z ENDP				; bit_reverse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_k$1 = -176						; size = 4
_c$2 = -172						; size = 4
_s$3 = -168						; size = 4
_sizes$ = -160						; size = 68
_next_code$ = -84					; size = 64
_code$ = -16						; size = 4
_k$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_sizelist$ = 12						; size = 4
_num$ = 16						; size = 4
?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z PROC		; zbuild_huffman

; 1746 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00011	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1747 :    int i,k=0;

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 1748 :    int code, next_code[16], sizes[17];
; 1749 : 
; 1750 :    // DEFLATE spec for generating codes
; 1751 :    memset(sizes, 0, sizeof(sizes));

  0002e	8b f4		 mov	 esi, esp
  00030	6a 44		 push	 68			; 00000044H
  00032	6a 00		 push	 0
  00034	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _sizes$[ebp]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1752 :    memset(z->fast, 255, sizeof(z->fast));

  0004b	8b f4		 mov	 esi, esp
  0004d	68 00 04 00 00	 push	 1024			; 00000400H
  00052	68 ff 00 00 00	 push	 255			; 000000ffH
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0005a	51		 push	 ecx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1753 :    for (i=0; i < num; ++i) 

  0006b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00072	eb 09		 jmp	 SHORT $LN4@zbuild_huf
$LN2@zbuild_huf:
  00074	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00077	83 c2 01	 add	 edx, 1
  0007a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@zbuild_huf:
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00080	3b 45 10	 cmp	 eax, DWORD PTR _num$[ebp]
  00083	7d 25		 jge	 SHORT $LN3@zbuild_huf

; 1754 :       ++sizes[sizelist[i]];

  00085	8b 4d 0c	 mov	 ecx, DWORD PTR _sizelist$[ebp]
  00088	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  0008b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0008e	8b 84 95 60 ff
	ff ff		 mov	 eax, DWORD PTR _sizes$[ebp+edx*4]
  00095	83 c0 01	 add	 eax, 1
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _sizelist$[ebp]
  0009b	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  0009e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000a1	89 84 95 60 ff
	ff ff		 mov	 DWORD PTR _sizes$[ebp+edx*4], eax
  000a8	eb ca		 jmp	 SHORT $LN2@zbuild_huf
$LN3@zbuild_huf:

; 1755 :    sizes[0] = 0;

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	6b c8 00	 imul	 ecx, eax, 0
  000b2	c7 84 0d 60 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _sizes$[ebp+ecx], 0

; 1756 :    for (i=1; i < 16; ++i)

  000bd	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000c4	eb 09		 jmp	 SHORT $LN7@zbuild_huf
$LN5@zbuild_huf:
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000c9	83 c2 01	 add	 edx, 1
  000cc	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN7@zbuild_huf:
  000cf	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  000d3	7d 39		 jge	 SHORT $LN6@zbuild_huf

; 1757 :       assert(sizes[i] <= (1 << i));

  000d5	b8 01 00 00 00	 mov	 eax, 1
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000dd	d3 e0		 shl	 eax, cl
  000df	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000e2	39 84 8d 60 ff
	ff ff		 cmp	 DWORD PTR _sizes$[ebp+ecx*4], eax
  000e9	7e 21		 jle	 SHORT $LN21@zbuild_huf
  000eb	8b f4		 mov	 esi, esp
  000ed	68 dd 06 00 00	 push	 1757			; 000006ddH
  000f2	68 00 00 00 00	 push	 OFFSET $SG4294820228
  000f7	68 00 00 00 00	 push	 OFFSET $SG4294820227
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@zbuild_huf:
  0010c	eb b8		 jmp	 SHORT $LN5@zbuild_huf
$LN6@zbuild_huf:

; 1758 :    code = 0;

  0010e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _code$[ebp], 0

; 1759 :    for (i=1; i < 16; ++i) {

  00115	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0011c	eb 09		 jmp	 SHORT $LN10@zbuild_huf
$LN8@zbuild_huf:
  0011e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@zbuild_huf:
  00127	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0012b	0f 8d a8 00 00
	00		 jge	 $LN9@zbuild_huf

; 1760 :       next_code[i] = code;

  00131	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00134	8b 55 f0	 mov	 edx, DWORD PTR _code$[ebp]
  00137	89 54 8d ac	 mov	 DWORD PTR _next_code$[ebp+ecx*4], edx

; 1761 :       z->firstcode[i] = (uint16) code;

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00141	66 8b 55 f0	 mov	 dx, WORD PTR _code$[ebp]
  00145	66 89 94 41 00
	04 00 00	 mov	 WORD PTR [ecx+eax*2+1024], dx

; 1762 :       z->firstsymbol[i] = (uint16) k;

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00150	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00153	66 8b 55 f4	 mov	 dx, WORD PTR _k$[ebp]
  00157	66 89 94 41 64
	04 00 00	 mov	 WORD PTR [ecx+eax*2+1124], dx

; 1763 :       code = (code + sizes[i]);

  0015f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00162	8b 4d f0	 mov	 ecx, DWORD PTR _code$[ebp]
  00165	03 8c 85 60 ff
	ff ff		 add	 ecx, DWORD PTR _sizes$[ebp+eax*4]
  0016c	89 4d f0	 mov	 DWORD PTR _code$[ebp], ecx

; 1764 :       if (sizes[i])

  0016f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00172	83 bc 95 60 ff
	ff ff 00	 cmp	 DWORD PTR _sizes$[ebp+edx*4], 0
  0017a	74 26		 je	 SHORT $LN16@zbuild_huf

; 1765 :          if (code-1 >= (1 << i)) return e("bad codelengths","Corrupt JPEG");

  0017c	8b 45 f0	 mov	 eax, DWORD PTR _code$[ebp]
  0017f	83 e8 01	 sub	 eax, 1
  00182	ba 01 00 00 00	 mov	 edx, 1
  00187	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0018a	d3 e2		 shl	 edx, cl
  0018c	3b c2		 cmp	 eax, edx
  0018e	7c 12		 jl	 SHORT $LN16@zbuild_huf
  00190	68 00 00 00 00	 push	 OFFSET $SG4294820226
  00195	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0019a	83 c4 04	 add	 esp, 4
  0019d	e9 6c 01 00 00	 jmp	 $LN1@zbuild_huf
$LN16@zbuild_huf:

; 1766 :       z->maxcode[i] = code << (16-i); // preshift for inner loop

  001a2	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001a7	2b 4d f8	 sub	 ecx, DWORD PTR _i$[ebp]
  001aa	8b 45 f0	 mov	 eax, DWORD PTR _code$[ebp]
  001ad	d3 e0		 shl	 eax, cl
  001af	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001b2	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  001b5	89 84 8a 20 04
	00 00		 mov	 DWORD PTR [edx+ecx*4+1056], eax

; 1767 :       code <<= 1;

  001bc	8b 45 f0	 mov	 eax, DWORD PTR _code$[ebp]
  001bf	d1 e0		 shl	 eax, 1
  001c1	89 45 f0	 mov	 DWORD PTR _code$[ebp], eax

; 1768 :       k += sizes[i];

  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001c7	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  001ca	03 94 8d 60 ff
	ff ff		 add	 edx, DWORD PTR _sizes$[ebp+ecx*4]
  001d1	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx

; 1769 :    }

  001d4	e9 45 ff ff ff	 jmp	 $LN8@zbuild_huf
$LN9@zbuild_huf:

; 1770 :    z->maxcode[16] = 0x10000; // sentinel

  001d9	b8 04 00 00 00	 mov	 eax, 4
  001de	c1 e0 04	 shl	 eax, 4
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  001e4	c7 84 01 20 04
	00 00 00 00 01
	00		 mov	 DWORD PTR [ecx+eax+1056], 65536 ; 00010000H

; 1771 :    for (i=0; i < num; ++i) {

  001ef	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001f6	eb 09		 jmp	 SHORT $LN13@zbuild_huf
$LN11@zbuild_huf:
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  001fb	83 c2 01	 add	 edx, 1
  001fe	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN13@zbuild_huf:
  00201	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00204	3b 45 10	 cmp	 eax, DWORD PTR _num$[ebp]
  00207	0f 8d fc 00 00
	00		 jge	 $LN12@zbuild_huf

; 1772 :       int s = sizelist[i];

  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR _sizelist$[ebp]
  00210	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00213	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00216	89 95 58 ff ff
	ff		 mov	 DWORD PTR _s$3[ebp], edx

; 1773 :       if (s) {

  0021c	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _s$3[ebp], 0
  00223	0f 84 db 00 00
	00		 je	 $LN18@zbuild_huf

; 1774 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

  00229	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  0022f	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00232	0f b7 94 41 00
	04 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+1024]
  0023a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  00240	8b 4c 85 ac	 mov	 ecx, DWORD PTR _next_code$[ebp+eax*4]
  00244	2b ca		 sub	 ecx, edx
  00246	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _s$3[ebp]
  0024c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0024f	0f b7 94 50 64
	04 00 00	 movzx	 edx, WORD PTR [eax+edx*2+1124]
  00257	03 ca		 add	 ecx, edx
  00259	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _c$2[ebp], ecx

; 1775 :          z->size[c] = (uint8)s;

  0025f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00262	03 85 54 ff ff
	ff		 add	 eax, DWORD PTR _c$2[ebp]
  00268	8a 8d 58 ff ff
	ff		 mov	 cl, BYTE PTR _s$3[ebp]
  0026e	88 88 84 04 00
	00		 mov	 BYTE PTR [eax+1156], cl

; 1776 :          z->value[c] = (uint16)i;

  00274	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _c$2[ebp]
  0027a	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0027d	66 8b 4d f8	 mov	 cx, WORD PTR _i$[ebp]
  00281	66 89 8c 50 a4
	05 00 00	 mov	 WORD PTR [eax+edx*2+1444], cx

; 1777 :          if (s <= ZFAST_BITS) {

  00289	83 bd 58 ff ff
	ff 09		 cmp	 DWORD PTR _s$3[ebp], 9
  00290	7f 5b		 jg	 SHORT $LN19@zbuild_huf

; 1778 :             int k = bit_reverse(next_code[s],s);

  00292	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _s$3[ebp]
  00298	52		 push	 edx
  00299	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  0029f	8b 4c 85 ac	 mov	 ecx, DWORD PTR _next_code$[ebp+eax*4]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 ?bit_reverse@@YAHHH@Z	; bit_reverse
  002a9	83 c4 08	 add	 esp, 8
  002ac	89 85 50 ff ff
	ff		 mov	 DWORD PTR _k$1[ebp], eax
$LN14@zbuild_huf:

; 1779 :             while (k < (1 << ZFAST_BITS)) {

  002b2	81 bd 50 ff ff
	ff 00 02 00 00	 cmp	 DWORD PTR _k$1[ebp], 512 ; 00000200H
  002bc	7d 2f		 jge	 SHORT $LN19@zbuild_huf

; 1780 :                z->fast[k] = (uint16) c;

  002be	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _k$1[ebp]
  002c4	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  002c7	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _c$2[ebp]
  002ce	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 1781 :                k += (1 << s);

  002d2	ba 01 00 00 00	 mov	 edx, 1
  002d7	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _s$3[ebp]
  002dd	d3 e2		 shl	 edx, cl
  002df	03 95 50 ff ff
	ff		 add	 edx, DWORD PTR _k$1[ebp]
  002e5	89 95 50 ff ff
	ff		 mov	 DWORD PTR _k$1[ebp], edx

; 1782 :             }

  002eb	eb c5		 jmp	 SHORT $LN14@zbuild_huf
$LN19@zbuild_huf:

; 1783 :          }
; 1784 :          ++next_code[s];

  002ed	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  002f3	8b 4c 85 ac	 mov	 ecx, DWORD PTR _next_code$[ebp+eax*4]
  002f7	83 c1 01	 add	 ecx, 1
  002fa	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _s$3[ebp]
  00300	89 4c 95 ac	 mov	 DWORD PTR _next_code$[ebp+edx*4], ecx
$LN18@zbuild_huf:

; 1785 :       }
; 1786 :    }

  00304	e9 ef fe ff ff	 jmp	 $LN11@zbuild_huf
$LN12@zbuild_huf:

; 1787 :    return 1;

  00309	b8 01 00 00 00	 mov	 eax, 1
$LN1@zbuild_huf:

; 1788 : }

  0030e	52		 push	 edx
  0030f	8b cd		 mov	 ecx, ebp
  00311	50		 push	 eax
  00312	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@zbuild_huf
  00318	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0031d	58		 pop	 eax
  0031e	5a		 pop	 edx
  0031f	5f		 pop	 edi
  00320	5e		 pop	 esi
  00321	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00324	33 cd		 xor	 ecx, ebp
  00326	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032b	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  00331	3b ec		 cmp	 ebp, esp
  00333	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00338	8b e5		 mov	 esp, ebp
  0033a	5d		 pop	 ebp
  0033b	c3		 ret	 0
$LN25@zbuild_huf:
  0033c	02 00 00 00	 DD	 2
  00340	00 00 00 00	 DD	 $LN24@zbuild_huf
$LN24@zbuild_huf:
  00344	ac ff ff ff	 DD	 -84			; ffffffacH
  00348	40 00 00 00	 DD	 64			; 00000040H
  0034c	00 00 00 00	 DD	 $LN22@zbuild_huf
  00350	60 ff ff ff	 DD	 -160			; ffffff60H
  00354	44 00 00 00	 DD	 68			; 00000044H
  00358	00 00 00 00	 DD	 $LN23@zbuild_huf
$LN23@zbuild_huf:
  0035c	73		 DB	 115			; 00000073H
  0035d	69		 DB	 105			; 00000069H
  0035e	7a		 DB	 122			; 0000007aH
  0035f	65		 DB	 101			; 00000065H
  00360	73		 DB	 115			; 00000073H
  00361	00		 DB	 0
$LN22@zbuild_huf:
  00362	6e		 DB	 110			; 0000006eH
  00363	65		 DB	 101			; 00000065H
  00364	78		 DB	 120			; 00000078H
  00365	74		 DB	 116			; 00000074H
  00366	5f		 DB	 95			; 0000005fH
  00367	63		 DB	 99			; 00000063H
  00368	6f		 DB	 111			; 0000006fH
  00369	64		 DB	 100			; 00000064H
  0036a	65		 DB	 101			; 00000065H
  0036b	00		 DB	 0
?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ENDP		; zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv73 = -4						; size = 4
_z$ = 8							; size = 4
?zget8@@YAHPAUzbuf@@@Z PROC				; zget8

; 1811 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1812 :    if (z->zbuffer >= z->zbuffer_end) return 0;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00016	72 04		 jb	 SHORT $LN2@zget8
  00018	33 c0		 xor	 eax, eax
  0001a	eb 1b		 jmp	 SHORT $LN1@zget8
$LN2@zget8:

; 1813 :    return *z->zbuffer++;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00024	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx
  00034	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
$LN1@zget8:

; 1814 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?zget8@@YAHPAUzbuf@@@Z ENDP				; zget8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = 8							; size = 4
?fill_bits@@YAXPAUzbuf@@@Z PROC				; fill_bits

; 1817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
$LN4@fill_bits:

; 1818 :    do {
; 1819 :       assert(z->code_buffer < (1U << z->num_bits));

  00004	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00007	ba 01 00 00 00	 mov	 edx, 1
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	d3 e2		 shl	 edx, cl
  00011	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	72 21		 jb	 SHORT $LN6@fill_bits
  00019	8b f4		 mov	 esi, esp
  0001b	68 1b 07 00 00	 push	 1819			; 0000071bH
  00020	68 00 00 00 00	 push	 OFFSET $SG4294820225
  00025	68 00 00 00 00	 push	 OFFSET $SG4294820224
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@fill_bits:

; 1820 :       z->code_buffer |= zget8(z) << z->num_bits;

  0003a	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?zget8@@YAHPAUzbuf@@@Z	; zget8
  00043	83 c4 04	 add	 esp, 4
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00049	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0004c	d3 e0		 shl	 eax, cl
  0004e	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00051	0b 42 0c	 or	 eax, DWORD PTR [edx+12]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00057	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1821 :       z->num_bits += 8;

  0005a	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	83 c0 08	 add	 eax, 8
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00066	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1822 :    } while (z->num_bits <= 24);

  00069	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0006c	83 7a 08 18	 cmp	 DWORD PTR [edx+8], 24	; 00000018H
  00070	7e 92		 jle	 SHORT $LN4@fill_bits

; 1823 : }

  00072	5e		 pop	 esi
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?fill_bits@@YAXPAUzbuf@@@Z ENDP				; fill_bits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_k$ = -4						; size = 4
_z$ = 8							; size = 4
_n$ = 12						; size = 4
?zreceive@@YAIPAUzbuf@@H@Z PROC				; zreceive

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1827 :    unsigned int k;
; 1828 :    if (z->num_bits < n) fill_bits(z);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0000e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR _n$[ebp]
  00014	7d 0c		 jge	 SHORT $LN2@zreceive
  00016	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ?fill_bits@@YAXPAUzbuf@@@Z ; fill_bits
  0001f	83 c4 04	 add	 esp, 4
$LN2@zreceive:

; 1829 :    k = z->code_buffer & ((1 << n) - 1);

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0002a	d3 e0		 shl	 eax, cl
  0002c	83 e8 01	 sub	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00032	23 41 0c	 and	 eax, DWORD PTR [ecx+12]
  00035	89 45 fc	 mov	 DWORD PTR _k$[ebp], eax

; 1830 :    z->code_buffer >>= n;

  00038	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0003b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00041	d3 e8		 shr	 eax, cl
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00046	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1831 :    z->num_bits -= n;

  00049	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0004c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004f	2b 45 0c	 sub	 eax, DWORD PTR _n$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00055	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1832 :    return k;   

  00058	8b 45 fc	 mov	 eax, DWORD PTR _k$[ebp]

; 1833 : }

  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?zreceive@@YAIPAUzbuf@@H@Z ENDP				; zreceive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_k$ = -12						; size = 4
_s$ = -8						; size = 4
_b$ = -4						; size = 4
_a$ = 8							; size = 4
_z$ = 12						; size = 4
?zhuffman_decode@@YAHPAUzbuf@@PAUzhuffman@@@Z PROC	; zhuffman_decode

; 1836 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1837 :    int b,s,k;
; 1838 :    if (a->num_bits < 16) fill_bits(a);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001f	83 78 08 10	 cmp	 DWORD PTR [eax+8], 16	; 00000010H
  00023	7d 0c		 jge	 SHORT $LN5@zhuffman_d
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?fill_bits@@YAXPAUzbuf@@@Z ; fill_bits
  0002e	83 c4 04	 add	 esp, 4
$LN5@zhuffman_d:

; 1839 :    b = z->fast[a->code_buffer & ZFAST_MASK];

  00031	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00034	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00037	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _z$[ebp]
  0003f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00043	89 55 fc	 mov	 DWORD PTR _b$[ebp], edx

; 1840 :    if (b < 0xffff) {

  00046	81 7d fc ff ff
	00 00		 cmp	 DWORD PTR _b$[ebp], 65535 ; 0000ffffH
  0004d	7d 43		 jge	 SHORT $LN6@zhuffman_d

; 1841 :       s = z->size[b];

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _z$[ebp]
  00052	03 45 fc	 add	 eax, DWORD PTR _b$[ebp]
  00055	0f b6 88 84 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1156]
  0005c	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx

; 1842 :       a->code_buffer >>= s;

  0005f	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00062	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00068	d3 e8		 shr	 eax, cl
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0006d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1843 :       a->num_bits -= s;

  00070	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00073	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00076	2b 45 f8	 sub	 eax, DWORD PTR _s$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0007c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1844 :       return z->value[b];

  0007f	8b 55 fc	 mov	 edx, DWORD PTR _b$[ebp]
  00082	8b 45 0c	 mov	 eax, DWORD PTR _z$[ebp]
  00085	0f b7 84 50 a4
	05 00 00	 movzx	 eax, WORD PTR [eax+edx*2+1444]
  0008d	e9 db 00 00 00	 jmp	 $LN1@zhuffman_d
$LN6@zhuffman_d:

; 1845 :    }
; 1846 : 
; 1847 :    // not resolved by fast table, so compute it the slow way
; 1848 :    // use jpeg approach, which requires MSbits at top
; 1849 :    k = bit_reverse(a->code_buffer, 16);

  00092	6a 10		 push	 16			; 00000010H
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00097	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?bit_reverse@@YAHHH@Z	; bit_reverse
  000a0	83 c4 08	 add	 esp, 8
  000a3	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax

; 1850 :    for (s=ZFAST_BITS+1; ; ++s)

  000a6	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _s$[ebp], 10	; 0000000aH
  000ad	eb 09		 jmp	 SHORT $LN4@zhuffman_d
$LN2@zhuffman_d:
  000af	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
$LN4@zhuffman_d:

; 1851 :       if (k < z->maxcode[s])

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000bb	8b 55 0c	 mov	 edx, DWORD PTR _z$[ebp]
  000be	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  000c1	3b 84 8a 20 04
	00 00		 cmp	 eax, DWORD PTR [edx+ecx*4+1056]
  000c8	7d 02		 jge	 SHORT $LN7@zhuffman_d

; 1852 :          break;

  000ca	eb 02		 jmp	 SHORT $LN3@zhuffman_d
$LN7@zhuffman_d:

; 1853 :    if (s == 16) return -1; // invalid code!

  000cc	eb e1		 jmp	 SHORT $LN2@zhuffman_d
$LN3@zhuffman_d:
  000ce	83 7d f8 10	 cmp	 DWORD PTR _s$[ebp], 16	; 00000010H
  000d2	75 08		 jne	 SHORT $LN8@zhuffman_d
  000d4	83 c8 ff	 or	 eax, -1
  000d7	e9 91 00 00 00	 jmp	 $LN1@zhuffman_d
$LN8@zhuffman_d:

; 1854 :    // code size is s, so:
; 1855 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

  000dc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000e1	2b 4d f8	 sub	 ecx, DWORD PTR _s$[ebp]
  000e4	8b 55 f4	 mov	 edx, DWORD PTR _k$[ebp]
  000e7	d3 fa		 sar	 edx, cl
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR _z$[ebp]
  000ef	0f b7 84 41 00
	04 00 00	 movzx	 eax, WORD PTR [ecx+eax*2+1024]
  000f7	2b d0		 sub	 edx, eax
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000fc	8b 45 0c	 mov	 eax, DWORD PTR _z$[ebp]
  000ff	0f b7 8c 48 64
	04 00 00	 movzx	 ecx, WORD PTR [eax+ecx*2+1124]
  00107	03 d1		 add	 edx, ecx
  00109	89 55 fc	 mov	 DWORD PTR _b$[ebp], edx

; 1856 :    assert(z->size[b] == s);

  0010c	8b 55 0c	 mov	 edx, DWORD PTR _z$[ebp]
  0010f	03 55 fc	 add	 edx, DWORD PTR _b$[ebp]
  00112	0f b6 82 84 04
	00 00		 movzx	 eax, BYTE PTR [edx+1156]
  00119	3b 45 f8	 cmp	 eax, DWORD PTR _s$[ebp]
  0011c	74 21		 je	 SHORT $LN10@zhuffman_d
  0011e	8b f4		 mov	 esi, esp
  00120	68 40 07 00 00	 push	 1856			; 00000740H
  00125	68 00 00 00 00	 push	 OFFSET $SG4294820223
  0012a	68 00 00 00 00	 push	 OFFSET $SG4294820222
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	3b f4		 cmp	 esi, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@zhuffman_d:

; 1857 :    a->code_buffer >>= s;

  0013f	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00142	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00145	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00148	d3 e8		 shr	 eax, cl
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0014d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1858 :    a->num_bits -= s;

  00150	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00153	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00156	2b 45 f8	 sub	 eax, DWORD PTR _s$[ebp]
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0015c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1859 :    return z->value[b];

  0015f	8b 55 fc	 mov	 edx, DWORD PTR _b$[ebp]
  00162	8b 45 0c	 mov	 eax, DWORD PTR _z$[ebp]
  00165	0f b7 84 50 a4
	05 00 00	 movzx	 eax, WORD PTR [eax+edx*2+1444]
$LN1@zhuffman_d:

; 1860 : }

  0016d	5e		 pop	 esi
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
?zhuffman_decode@@YAHPAUzbuf@@PAUzhuffman@@@Z ENDP	; zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_limit$ = -12						; size = 4
_cur$ = -8						; size = 4
_q$ = -4						; size = 4
_z$ = 8							; size = 4
_n$ = 12						; size = 4
?expand@@YAHPAUzbuf@@H@Z PROC				; expand

; 1863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1864 :    char *q;
; 1865 :    int cur, limit;
; 1866 :    if (!z->z_expandable) return e("output buffer limit","Corrupt PNG");

  0001c	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0001f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00023	75 12		 jne	 SHORT $LN4@expand
  00025	68 00 00 00 00	 push	 OFFSET $SG4294820221
  0002a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0002f	83 c4 04	 add	 esp, 4
  00032	e9 8e 00 00 00	 jmp	 $LN1@expand
$LN4@expand:

; 1867 :    cur   = (int) (z->zout     - z->zout_start);

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0003d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00040	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00043	89 45 f8	 mov	 DWORD PTR _cur$[ebp], eax

; 1868 :    limit = (int) (z->zout_end - z->zout_start);

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00049	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0004c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0004f	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00052	89 45 f4	 mov	 DWORD PTR _limit$[ebp], eax
$LN2@expand:

; 1869 :    while (cur + n > limit)

  00055	8b 4d f8	 mov	 ecx, DWORD PTR _cur$[ebp]
  00058	03 4d 0c	 add	 ecx, DWORD PTR _n$[ebp]
  0005b	3b 4d f4	 cmp	 ecx, DWORD PTR _limit$[ebp]
  0005e	7e 0a		 jle	 SHORT $LN3@expand

; 1870 :       limit *= 2;

  00060	8b 55 f4	 mov	 edx, DWORD PTR _limit$[ebp]
  00063	d1 e2		 shl	 edx, 1
  00065	89 55 f4	 mov	 DWORD PTR _limit$[ebp], edx
  00068	eb eb		 jmp	 SHORT $LN2@expand
$LN3@expand:

; 1871 :    q = (char *) realloc(z->zout_start, limit);

  0006a	8b f4		 mov	 esi, esp
  0006c	8b 45 f4	 mov	 eax, DWORD PTR _limit$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00073	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00076	52		 push	 edx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0007d	83 c4 08	 add	 esp, 8
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	89 45 fc	 mov	 DWORD PTR _q$[ebp], eax

; 1872 :    if (q == NULL) return e("outofmem", "Out of memory");

  0008a	83 7d fc 00	 cmp	 DWORD PTR _q$[ebp], 0
  0008e	75 0f		 jne	 SHORT $LN5@expand
  00090	68 00 00 00 00	 push	 OFFSET $SG4294820220
  00095	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0009a	83 c4 04	 add	 esp, 4
  0009d	eb 26		 jmp	 SHORT $LN1@expand
$LN5@expand:

; 1873 :    z->zout_start = q;

  0009f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  000a5	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1874 :    z->zout       = q + cur;

  000a8	8b 55 fc	 mov	 edx, DWORD PTR _q$[ebp]
  000ab	03 55 f8	 add	 edx, DWORD PTR _cur$[ebp]
  000ae	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  000b1	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1875 :    z->zout_end   = q + limit;

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  000b7	03 4d f4	 add	 ecx, DWORD PTR _limit$[ebp]
  000ba	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  000bd	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1876 :    return 1;

  000c0	b8 01 00 00 00	 mov	 eax, 1
$LN1@expand:

; 1877 : }

  000c5	5e		 pop	 esi
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?expand@@YAHPAUzbuf@@H@Z ENDP				; expand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv164 = -20						; size = 4
_dist$1 = -16						; size = 4
_len$2 = -12						; size = 4
_p$3 = -8						; size = 4
_z$4 = -4						; size = 4
_a$ = 8							; size = 4
?parse_huffman_block@@YAHPAUzbuf@@@Z PROC		; parse_huffman_block

; 1894 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
$LN4@parse_huff:

; 1895 :    for(;;) {
; 1896 :       int z = zhuffman_decode(a, &a->z_length);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001d	83 c0 20	 add	 eax, 32			; 00000020H
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?zhuffman_decode@@YAHPAUzbuf@@PAUzhuffman@@@Z ; zhuffman_decode
  0002a	83 c4 08	 add	 esp, 8
  0002d	89 45 fc	 mov	 DWORD PTR _z$4[ebp], eax

; 1897 :       if (z < 256) {

  00030	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _z$4[ebp], 256 ; 00000100H
  00037	7d 5e		 jge	 SHORT $LN7@parse_huff

; 1898 :          if (z < 0) return e("bad huffman code","Corrupt PNG"); // error in huffman codes

  00039	83 7d fc 00	 cmp	 DWORD PTR _z$4[ebp], 0
  0003d	7d 12		 jge	 SHORT $LN9@parse_huff
  0003f	68 00 00 00 00	 push	 OFFSET $SG4294820219
  00044	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00049	83 c4 04	 add	 esp, 4
  0004c	e9 99 01 00 00	 jmp	 $LN1@parse_huff
$LN9@parse_huff:

; 1899 :          if (a->zout >= a->zout_end) if (!expand(a, 1)) return 0;

  00051	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0005a	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0005d	72 19		 jb	 SHORT $LN10@parse_huff
  0005f	6a 01		 push	 1
  00061	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ?expand@@YAHPAUzbuf@@H@Z ; expand
  0006a	83 c4 08	 add	 esp, 8
  0006d	85 c0		 test	 eax, eax
  0006f	75 07		 jne	 SHORT $LN10@parse_huff
  00071	33 c0		 xor	 eax, eax
  00073	e9 72 01 00 00	 jmp	 $LN1@parse_huff
$LN10@parse_huff:

; 1900 :          *a->zout++ = (char) z;

  00078	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0007b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0007e	8a 55 fc	 mov	 dl, BYTE PTR _z$4[ebp]
  00081	88 11		 mov	 BYTE PTR [ecx], dl
  00083	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00086	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00089	83 c1 01	 add	 ecx, 1
  0008c	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0008f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1901 :       } else {

  00092	e9 4e 01 00 00	 jmp	 $LN8@parse_huff
$LN7@parse_huff:

; 1902 :          uint8 *p;
; 1903 :          int len,dist;
; 1904 :          if (z == 256) return 1;

  00097	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _z$4[ebp], 256 ; 00000100H
  0009e	75 0a		 jne	 SHORT $LN12@parse_huff
  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	e9 40 01 00 00	 jmp	 $LN1@parse_huff
$LN12@parse_huff:

; 1905 :          z -= 257;

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _z$4[ebp]
  000ad	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  000b2	89 45 fc	 mov	 DWORD PTR _z$4[ebp], eax

; 1906 :          len = length_base[z];

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _z$4[ebp]
  000b8	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?length_base@@3PAHA[ecx*4]
  000bf	89 55 f4	 mov	 DWORD PTR _len$2[ebp], edx

; 1907 :          if (length_extra[z]) len += zreceive(a, length_extra[z]);

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _z$4[ebp]
  000c5	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?length_extra@@3PAHA[eax*4], 0
  000cd	74 1d		 je	 SHORT $LN13@parse_huff
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _z$4[ebp]
  000d2	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?length_extra@@3PAHA[ecx*4]
  000d9	52		 push	 edx
  000da	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  000e3	83 c4 08	 add	 esp, 8
  000e6	03 45 f4	 add	 eax, DWORD PTR _len$2[ebp]
  000e9	89 45 f4	 mov	 DWORD PTR _len$2[ebp], eax
$LN13@parse_huff:

; 1908 :          z = zhuffman_decode(a, &a->z_distance);

  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000ef	81 c1 04 08 00
	00		 add	 ecx, 2052		; 00000804H
  000f5	51		 push	 ecx
  000f6	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ?zhuffman_decode@@YAHPAUzbuf@@PAUzhuffman@@@Z ; zhuffman_decode
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 fc	 mov	 DWORD PTR _z$4[ebp], eax

; 1909 :          if (z < 0) return e("bad huffman code","Corrupt PNG");

  00105	83 7d fc 00	 cmp	 DWORD PTR _z$4[ebp], 0
  00109	7d 12		 jge	 SHORT $LN14@parse_huff
  0010b	68 00 00 00 00	 push	 OFFSET $SG4294820218
  00110	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00115	83 c4 04	 add	 esp, 4
  00118	e9 cd 00 00 00	 jmp	 $LN1@parse_huff
$LN14@parse_huff:

; 1910 :          dist = dist_base[z];

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _z$4[ebp]
  00120	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?dist_base@@3PAHA[eax*4]
  00127	89 4d f0	 mov	 DWORD PTR _dist$1[ebp], ecx

; 1911 :          if (dist_extra[z]) dist += zreceive(a, dist_extra[z]);

  0012a	8b 55 fc	 mov	 edx, DWORD PTR _z$4[ebp]
  0012d	83 3c 95 00 00
	00 00 00	 cmp	 DWORD PTR ?dist_extra@@3PAHA[edx*4], 0
  00135	74 1d		 je	 SHORT $LN15@parse_huff
  00137	8b 45 fc	 mov	 eax, DWORD PTR _z$4[ebp]
  0013a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?dist_extra@@3PAHA[eax*4]
  00141	51		 push	 ecx
  00142	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00145	52		 push	 edx
  00146	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  0014b	83 c4 08	 add	 esp, 8
  0014e	03 45 f0	 add	 eax, DWORD PTR _dist$1[ebp]
  00151	89 45 f0	 mov	 DWORD PTR _dist$1[ebp], eax
$LN15@parse_huff:

; 1912 :          if (a->zout - a->zout_start < dist) return e("bad dist","Corrupt PNG");

  00154	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0015a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0015d	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00160	3b 55 f0	 cmp	 edx, DWORD PTR _dist$1[ebp]
  00163	7d 0f		 jge	 SHORT $LN16@parse_huff
  00165	68 00 00 00 00	 push	 OFFSET $SG4294820217
  0016a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0016f	83 c4 04	 add	 esp, 4
  00172	eb 76		 jmp	 SHORT $LN1@parse_huff
$LN16@parse_huff:

; 1913 :          if (a->zout + len > a->zout_end) if (!expand(a, len)) return 0;

  00174	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00177	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0017a	03 4d f4	 add	 ecx, DWORD PTR _len$2[ebp]
  0017d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00180	3b 4a 18	 cmp	 ecx, DWORD PTR [edx+24]
  00183	76 18		 jbe	 SHORT $LN17@parse_huff
  00185	8b 45 f4	 mov	 eax, DWORD PTR _len$2[ebp]
  00188	50		 push	 eax
  00189	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ?expand@@YAHPAUzbuf@@H@Z ; expand
  00192	83 c4 08	 add	 esp, 8
  00195	85 c0		 test	 eax, eax
  00197	75 04		 jne	 SHORT $LN17@parse_huff
  00199	33 c0		 xor	 eax, eax
  0019b	eb 4d		 jmp	 SHORT $LN1@parse_huff
$LN17@parse_huff:

; 1914 :          p = (uint8 *) (a->zout - dist);

  0019d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001a0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001a3	2b 45 f0	 sub	 eax, DWORD PTR _dist$1[ebp]
  001a6	89 45 f8	 mov	 DWORD PTR _p$3[ebp], eax
$LN5@parse_huff:

; 1915 :          while (len--)

  001a9	8b 4d f4	 mov	 ecx, DWORD PTR _len$2[ebp]
  001ac	89 4d ec	 mov	 DWORD PTR tv164[ebp], ecx
  001af	8b 55 f4	 mov	 edx, DWORD PTR _len$2[ebp]
  001b2	83 ea 01	 sub	 edx, 1
  001b5	89 55 f4	 mov	 DWORD PTR _len$2[ebp], edx
  001b8	83 7d ec 00	 cmp	 DWORD PTR tv164[ebp], 0
  001bc	74 27		 je	 SHORT $LN8@parse_huff

; 1916 :             *a->zout++ = *p++;

  001be	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001c1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001c4	8b 55 f8	 mov	 edx, DWORD PTR _p$3[ebp]
  001c7	8a 02		 mov	 al, BYTE PTR [edx]
  001c9	88 01		 mov	 BYTE PTR [ecx], al
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001ce	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001d1	83 c2 01	 add	 edx, 1
  001d4	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001d7	89 50 10	 mov	 DWORD PTR [eax+16], edx
  001da	8b 4d f8	 mov	 ecx, DWORD PTR _p$3[ebp]
  001dd	83 c1 01	 add	 ecx, 1
  001e0	89 4d f8	 mov	 DWORD PTR _p$3[ebp], ecx
  001e3	eb c4		 jmp	 SHORT $LN5@parse_huff
$LN8@parse_huff:

; 1917 :       }
; 1918 :    }

  001e5	e9 30 fe ff ff	 jmp	 $LN4@parse_huff
$LN1@parse_huff:

; 1919 : }

  001ea	83 c4 14	 add	 esp, 20			; 00000014H
  001ed	3b ec		 cmp	 ebp, esp
  001ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
?parse_huffman_block@@YAHPAUzbuf@@@Z ENDP		; parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_c$1 = -2552						; size = 4
_s$2 = -2548						; size = 4
_hclen$ = -2544						; size = 4
_hdist$ = -2540						; size = 4
_hlit$ = -2536						; size = 4
_n$ = -2532						; size = 4
_i$ = -2528						; size = 4
_codelength_sizes$ = -2520				; size = 19
_lencodes$ = -2492					; size = 455
_z_codelength$ = -2028					; size = 2020
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
?compute_huffman_codes@@YAHPAUzbuf@@@Z PROC		; compute_huffman_codes

; 1922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 09 00
	00		 sub	 esp, 2552		; 000009f8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 08 f6 ff
	ff		 lea	 edi, DWORD PTR [ebp-2552]
  00011	b9 7e 02 00 00	 mov	 ecx, 638		; 0000027eH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1923 :    static uint8 length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 1924 :    zhuffman z_codelength;
; 1925 :    uint8 lencodes[286+32+137];//padding for maximum single op
; 1926 :    uint8 codelength_sizes[19];
; 1927 :    int i,n;
; 1928 : 
; 1929 :    int hlit  = zreceive(a,5) + 257;

  00027	6a 05		 push	 5
  00029	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  00032	83 c4 08	 add	 esp, 8
  00035	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0003a	89 85 18 f6 ff
	ff		 mov	 DWORD PTR _hlit$[ebp], eax

; 1930 :    int hdist = zreceive(a,5) + 1;

  00040	6a 05		 push	 5
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  0004b	83 c4 08	 add	 esp, 8
  0004e	83 c0 01	 add	 eax, 1
  00051	89 85 14 f6 ff
	ff		 mov	 DWORD PTR _hdist$[ebp], eax

; 1931 :    int hclen = zreceive(a,4) + 4;

  00057	6a 04		 push	 4
  00059	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  00062	83 c4 08	 add	 esp, 8
  00065	83 c0 04	 add	 eax, 4
  00068	89 85 10 f6 ff
	ff		 mov	 DWORD PTR _hclen$[ebp], eax

; 1932 : 
; 1933 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));

  0006e	8b f4		 mov	 esi, esp
  00070	6a 13		 push	 19			; 00000013H
  00072	6a 00		 push	 0
  00074	8d 85 28 f6 ff
	ff		 lea	 eax, DWORD PTR _codelength_sizes$[ebp]
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1934 :    for (i=0; i < hclen; ++i) {

  0008b	c7 85 20 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00095	eb 0f		 jmp	 SHORT $LN4@compute_hu
$LN2@compute_hu:
  00097	8b 8d 20 f6 ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0009d	83 c1 01	 add	 ecx, 1
  000a0	89 8d 20 f6 ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN4@compute_hu:
  000a6	8b 95 20 f6 ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  000ac	3b 95 10 f6 ff
	ff		 cmp	 edx, DWORD PTR _hclen$[ebp]
  000b2	7d 30		 jge	 SHORT $LN3@compute_hu

; 1935 :       int s = zreceive(a,3);

  000b4	6a 03		 push	 3
  000b6	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 85 0c f6 ff
	ff		 mov	 DWORD PTR _s$2[ebp], eax

; 1936 :       codelength_sizes[length_dezigzag[i]] = (uint8) s;

  000c8	8b 8d 20 f6 ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000ce	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?length_dezigzag@?1??compute_huffman_codes@@YAHPAUzbuf@@@Z@4PAEA[ecx]
  000d5	8a 85 0c f6 ff
	ff		 mov	 al, BYTE PTR _s$2[ebp]
  000db	88 84 15 28 f6
	ff ff		 mov	 BYTE PTR _codelength_sizes$[ebp+edx], al

; 1937 :    }

  000e2	eb b3		 jmp	 SHORT $LN2@compute_hu
$LN3@compute_hu:

; 1938 :    if (!zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

  000e4	6a 13		 push	 19			; 00000013H
  000e6	8d 8d 28 f6 ff
	ff		 lea	 ecx, DWORD PTR _codelength_sizes$[ebp]
  000ec	51		 push	 ecx
  000ed	8d 95 14 f8 ff
	ff		 lea	 edx, DWORD PTR _z_codelength$[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ; zbuild_huffman
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	85 c0		 test	 eax, eax
  000fe	75 07		 jne	 SHORT $LN7@compute_hu
  00100	33 c0		 xor	 eax, eax
  00102	e9 65 02 00 00	 jmp	 $LN1@compute_hu
$LN7@compute_hu:

; 1939 : 
; 1940 :    n = 0;

  00107	c7 85 1c f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
$LN5@compute_hu:

; 1941 :    while (n < hlit + hdist) {

  00111	8b 85 18 f6 ff
	ff		 mov	 eax, DWORD PTR _hlit$[ebp]
  00117	03 85 14 f6 ff
	ff		 add	 eax, DWORD PTR _hdist$[ebp]
  0011d	39 85 1c f6 ff
	ff		 cmp	 DWORD PTR _n$[ebp], eax
  00123	0f 8d c7 01 00
	00		 jge	 $LN6@compute_hu

; 1942 :       int c = zhuffman_decode(a, &z_codelength);

  00129	8d 8d 14 f8 ff
	ff		 lea	 ecx, DWORD PTR _z_codelength$[ebp]
  0012f	51		 push	 ecx
  00130	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 ?zhuffman_decode@@YAHPAUzbuf@@PAUzhuffman@@@Z ; zhuffman_decode
  00139	83 c4 08	 add	 esp, 8
  0013c	89 85 08 f6 ff
	ff		 mov	 DWORD PTR _c$1[ebp], eax

; 1943 :       assert(c >= 0 && c < 19);

  00142	83 bd 08 f6 ff
	ff 00		 cmp	 DWORD PTR _c$1[ebp], 0
  00149	7c 09		 jl	 SHORT $LN18@compute_hu
  0014b	83 bd 08 f6 ff
	ff 13		 cmp	 DWORD PTR _c$1[ebp], 19	; 00000013H
  00152	7c 21		 jl	 SHORT $LN19@compute_hu
$LN18@compute_hu:
  00154	8b f4		 mov	 esi, esp
  00156	68 97 07 00 00	 push	 1943			; 00000797H
  0015b	68 00 00 00 00	 push	 OFFSET $SG4294820216
  00160	68 00 00 00 00	 push	 OFFSET $SG4294820215
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	3b f4		 cmp	 esi, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@compute_hu:

; 1944 :       if (c < 16)

  00175	83 bd 08 f6 ff
	ff 10		 cmp	 DWORD PTR _c$1[ebp], 16	; 00000010H
  0017c	7d 27		 jge	 SHORT $LN8@compute_hu

; 1945 :          lencodes[n++] = (uint8) c;

  0017e	8b 8d 1c f6 ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00184	8a 95 08 f6 ff
	ff		 mov	 dl, BYTE PTR _c$1[ebp]
  0018a	88 94 0d 44 f6
	ff ff		 mov	 BYTE PTR _lencodes$[ebp+ecx], dl
  00191	8b 85 1c f6 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00197	83 c0 01	 add	 eax, 1
  0019a	89 85 1c f6 ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  001a0	e9 46 01 00 00	 jmp	 $LN9@compute_hu
$LN8@compute_hu:

; 1946 :       else if (c == 16) {

  001a5	83 bd 08 f6 ff
	ff 10		 cmp	 DWORD PTR _c$1[ebp], 16	; 00000010H
  001ac	75 64		 jne	 SHORT $LN10@compute_hu

; 1947 :          c = zreceive(a,2)+3;

  001ae	6a 02		 push	 2
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  001b9	83 c4 08	 add	 esp, 8
  001bc	83 c0 03	 add	 eax, 3
  001bf	89 85 08 f6 ff
	ff		 mov	 DWORD PTR _c$1[ebp], eax

; 1948 :          memset(lencodes+n, lencodes[n-1], c);

  001c5	8b f4		 mov	 esi, esp
  001c7	8b 95 08 f6 ff
	ff		 mov	 edx, DWORD PTR _c$1[ebp]
  001cd	52		 push	 edx
  001ce	8b 85 1c f6 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  001d4	0f b6 8c 05 43
	f6 ff ff	 movzx	 ecx, BYTE PTR _lencodes$[ebp+eax-1]
  001dc	51		 push	 ecx
  001dd	8b 95 1c f6 ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  001e3	8d 84 15 44 f6
	ff ff		 lea	 eax, DWORD PTR _lencodes$[ebp+edx]
  001ea	50		 push	 eax
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f4	3b f4		 cmp	 esi, esp
  001f6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1949 :          n += c;

  001fb	8b 8d 1c f6 ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00201	03 8d 08 f6 ff
	ff		 add	 ecx, DWORD PTR _c$1[ebp]
  00207	89 8d 1c f6 ff
	ff		 mov	 DWORD PTR _n$[ebp], ecx
  0020d	e9 d9 00 00 00	 jmp	 $LN9@compute_hu
$LN10@compute_hu:

; 1950 :       } else if (c == 17) {

  00212	83 bd 08 f6 ff
	ff 11		 cmp	 DWORD PTR _c$1[ebp], 17	; 00000011H
  00219	75 54		 jne	 SHORT $LN12@compute_hu

; 1951 :          c = zreceive(a,3)+3;

  0021b	6a 03		 push	 3
  0021d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00220	52		 push	 edx
  00221	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  00226	83 c4 08	 add	 esp, 8
  00229	83 c0 03	 add	 eax, 3
  0022c	89 85 08 f6 ff
	ff		 mov	 DWORD PTR _c$1[ebp], eax

; 1952 :          memset(lencodes+n, 0, c);

  00232	8b f4		 mov	 esi, esp
  00234	8b 85 08 f6 ff
	ff		 mov	 eax, DWORD PTR _c$1[ebp]
  0023a	50		 push	 eax
  0023b	6a 00		 push	 0
  0023d	8b 8d 1c f6 ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00243	8d 94 0d 44 f6
	ff ff		 lea	 edx, DWORD PTR _lencodes$[ebp+ecx]
  0024a	52		 push	 edx
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH
  00254	3b f4		 cmp	 esi, esp
  00256	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1953 :          n += c;

  0025b	8b 85 1c f6 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00261	03 85 08 f6 ff
	ff		 add	 eax, DWORD PTR _c$1[ebp]
  00267	89 85 1c f6 ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1954 :       } else {

  0026d	eb 7c		 jmp	 SHORT $LN9@compute_hu
$LN12@compute_hu:

; 1955 :          assert(c == 18);

  0026f	83 bd 08 f6 ff
	ff 12		 cmp	 DWORD PTR _c$1[ebp], 18	; 00000012H
  00276	74 21		 je	 SHORT $LN20@compute_hu
  00278	8b f4		 mov	 esi, esp
  0027a	68 a3 07 00 00	 push	 1955			; 000007a3H
  0027f	68 00 00 00 00	 push	 OFFSET $SG4294820214
  00284	68 00 00 00 00	 push	 OFFSET $SG4294820213
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	3b f4		 cmp	 esi, esp
  00294	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@compute_hu:

; 1956 :          c = zreceive(a,7)+11;

  00299	6a 07		 push	 7
  0029b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0029e	52		 push	 edx
  0029f	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  002a4	83 c4 08	 add	 esp, 8
  002a7	83 c0 0b	 add	 eax, 11			; 0000000bH
  002aa	89 85 08 f6 ff
	ff		 mov	 DWORD PTR _c$1[ebp], eax

; 1957 :          memset(lencodes+n, 0, c);

  002b0	8b f4		 mov	 esi, esp
  002b2	8b 85 08 f6 ff
	ff		 mov	 eax, DWORD PTR _c$1[ebp]
  002b8	50		 push	 eax
  002b9	6a 00		 push	 0
  002bb	8b 8d 1c f6 ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  002c1	8d 94 0d 44 f6
	ff ff		 lea	 edx, DWORD PTR _lencodes$[ebp+ecx]
  002c8	52		 push	 edx
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d2	3b f4		 cmp	 esi, esp
  002d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1958 :          n += c;

  002d9	8b 85 1c f6 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  002df	03 85 08 f6 ff
	ff		 add	 eax, DWORD PTR _c$1[ebp]
  002e5	89 85 1c f6 ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN9@compute_hu:

; 1959 :       }
; 1960 :    }

  002eb	e9 21 fe ff ff	 jmp	 $LN5@compute_hu
$LN6@compute_hu:

; 1961 :    if (n != hlit+hdist) return e("bad codelengths","Corrupt PNG");

  002f0	8b 8d 18 f6 ff
	ff		 mov	 ecx, DWORD PTR _hlit$[ebp]
  002f6	03 8d 14 f6 ff
	ff		 add	 ecx, DWORD PTR _hdist$[ebp]
  002fc	39 8d 1c f6 ff
	ff		 cmp	 DWORD PTR _n$[ebp], ecx
  00302	74 0f		 je	 SHORT $LN14@compute_hu
  00304	68 00 00 00 00	 push	 OFFSET $SG4294820212
  00309	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0030e	83 c4 04	 add	 esp, 4
  00311	eb 59		 jmp	 SHORT $LN1@compute_hu
$LN14@compute_hu:

; 1962 :    if (!zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

  00313	8b 95 18 f6 ff
	ff		 mov	 edx, DWORD PTR _hlit$[ebp]
  00319	52		 push	 edx
  0031a	8d 85 44 f6 ff
	ff		 lea	 eax, DWORD PTR _lencodes$[ebp]
  00320	50		 push	 eax
  00321	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00324	83 c1 20	 add	 ecx, 32			; 00000020H
  00327	51		 push	 ecx
  00328	e8 00 00 00 00	 call	 ?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ; zbuild_huffman
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	85 c0		 test	 eax, eax
  00332	75 04		 jne	 SHORT $LN15@compute_hu
  00334	33 c0		 xor	 eax, eax
  00336	eb 34		 jmp	 SHORT $LN1@compute_hu
$LN15@compute_hu:

; 1963 :    if (!zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

  00338	8b 95 14 f6 ff
	ff		 mov	 edx, DWORD PTR _hdist$[ebp]
  0033e	52		 push	 edx
  0033f	8b 85 18 f6 ff
	ff		 mov	 eax, DWORD PTR _hlit$[ebp]
  00345	8d 8c 05 44 f6
	ff ff		 lea	 ecx, DWORD PTR _lencodes$[ebp+eax]
  0034c	51		 push	 ecx
  0034d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00350	81 c2 04 08 00
	00		 add	 edx, 2052		; 00000804H
  00356	52		 push	 edx
  00357	e8 00 00 00 00	 call	 ?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ; zbuild_huffman
  0035c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035f	85 c0		 test	 eax, eax
  00361	75 04		 jne	 SHORT $LN16@compute_hu
  00363	33 c0		 xor	 eax, eax
  00365	eb 05		 jmp	 SHORT $LN1@compute_hu
$LN16@compute_hu:

; 1964 :    return 1;

  00367	b8 01 00 00 00	 mov	 eax, 1
$LN1@compute_hu:

; 1965 : }

  0036c	52		 push	 edx
  0036d	8b cd		 mov	 ecx, ebp
  0036f	50		 push	 eax
  00370	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@compute_hu
  00376	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0037b	58		 pop	 eax
  0037c	5a		 pop	 edx
  0037d	5f		 pop	 edi
  0037e	5e		 pop	 esi
  0037f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00382	33 cd		 xor	 ecx, ebp
  00384	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00389	81 c4 f8 09 00
	00		 add	 esp, 2552		; 000009f8H
  0038f	3b ec		 cmp	 ebp, esp
  00391	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00396	8b e5		 mov	 esp, ebp
  00398	5d		 pop	 ebp
  00399	c3		 ret	 0
  0039a	66 90		 npad	 2
$LN25@compute_hu:
  0039c	03 00 00 00	 DD	 3
  003a0	00 00 00 00	 DD	 $LN24@compute_hu
$LN24@compute_hu:
  003a4	14 f8 ff ff	 DD	 -2028			; fffff814H
  003a8	e4 07 00 00	 DD	 2020			; 000007e4H
  003ac	00 00 00 00	 DD	 $LN21@compute_hu
  003b0	44 f6 ff ff	 DD	 -2492			; fffff644H
  003b4	c7 01 00 00	 DD	 455			; 000001c7H
  003b8	00 00 00 00	 DD	 $LN22@compute_hu
  003bc	28 f6 ff ff	 DD	 -2520			; fffff628H
  003c0	13 00 00 00	 DD	 19			; 00000013H
  003c4	00 00 00 00	 DD	 $LN23@compute_hu
$LN23@compute_hu:
  003c8	63		 DB	 99			; 00000063H
  003c9	6f		 DB	 111			; 0000006fH
  003ca	64		 DB	 100			; 00000064H
  003cb	65		 DB	 101			; 00000065H
  003cc	6c		 DB	 108			; 0000006cH
  003cd	65		 DB	 101			; 00000065H
  003ce	6e		 DB	 110			; 0000006eH
  003cf	67		 DB	 103			; 00000067H
  003d0	74		 DB	 116			; 00000074H
  003d1	68		 DB	 104			; 00000068H
  003d2	5f		 DB	 95			; 0000005fH
  003d3	73		 DB	 115			; 00000073H
  003d4	69		 DB	 105			; 00000069H
  003d5	7a		 DB	 122			; 0000007aH
  003d6	65		 DB	 101			; 00000065H
  003d7	73		 DB	 115			; 00000073H
  003d8	00		 DB	 0
$LN22@compute_hu:
  003d9	6c		 DB	 108			; 0000006cH
  003da	65		 DB	 101			; 00000065H
  003db	6e		 DB	 110			; 0000006eH
  003dc	63		 DB	 99			; 00000063H
  003dd	6f		 DB	 111			; 0000006fH
  003de	64		 DB	 100			; 00000064H
  003df	65		 DB	 101			; 00000065H
  003e0	73		 DB	 115			; 00000073H
  003e1	00		 DB	 0
$LN21@compute_hu:
  003e2	7a		 DB	 122			; 0000007aH
  003e3	5f		 DB	 95			; 0000005fH
  003e4	63		 DB	 99			; 00000063H
  003e5	6f		 DB	 111			; 0000006fH
  003e6	64		 DB	 100			; 00000064H
  003e7	65		 DB	 101			; 00000065H
  003e8	6c		 DB	 108			; 0000006cH
  003e9	65		 DB	 101			; 00000065H
  003ea	6e		 DB	 110			; 0000006eH
  003eb	67		 DB	 103			; 00000067H
  003ec	74		 DB	 116			; 00000074H
  003ed	68		 DB	 104			; 00000068H
  003ee	00		 DB	 0
?compute_huffman_codes@@YAHPAUzbuf@@@Z ENDP		; compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_k$ = -24						; size = 4
_nlen$ = -20						; size = 4
_len$ = -16						; size = 4
_header$ = -8						; size = 4
_a$ = 8							; size = 4
?parse_uncompressed_block@@YAHPAUzbuf@@@Z PROC		; parse_uncompressed_block

; 1968 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1969 :    uint8 header[4];
; 1970 :    int len,nlen,k;
; 1971 :    if (a->num_bits & 7)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00024	83 e1 07	 and	 ecx, 7
  00027	74 16		 je	 SHORT $LN6@parse_unco

; 1972 :       zreceive(a, a->num_bits & 7); // discard

  00029	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0002c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002f	83 e0 07	 and	 eax, 7
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  0003c	83 c4 08	 add	 esp, 8
$LN6@parse_unco:

; 1973 :    // drain the bit-packed data into header
; 1974 :    k = 0;

  0003f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
$LN2@parse_unco:

; 1975 :    while (a->num_bits > 0) {

  00046	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00049	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0004d	7e 3c		 jle	 SHORT $LN3@parse_unco

; 1976 :       header[k++] = (uint8) (a->code_buffer & 255); // wtf this warns?

  0004f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00052	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00055	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0005b	8b 55 e8	 mov	 edx, DWORD PTR _k$[ebp]
  0005e	88 4c 15 f8	 mov	 BYTE PTR _header$[ebp+edx], cl
  00062	8b 45 e8	 mov	 eax, DWORD PTR _k$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 e8	 mov	 DWORD PTR _k$[ebp], eax

; 1977 :       a->code_buffer >>= 8;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0006e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00071	c1 ea 08	 shr	 edx, 8
  00074	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00077	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1978 :       a->num_bits -= 8;

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0007d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00080	83 ea 08	 sub	 edx, 8
  00083	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00086	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1979 :    }

  00089	eb bb		 jmp	 SHORT $LN2@parse_unco
$LN3@parse_unco:

; 1980 :    assert(a->num_bits == 0);

  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0008e	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00092	74 21		 je	 SHORT $LN4@parse_unco
  00094	8b f4		 mov	 esi, esp
  00096	68 bc 07 00 00	 push	 1980			; 000007bcH
  0009b	68 00 00 00 00	 push	 OFFSET $SG4294820211
  000a0	68 00 00 00 00	 push	 OFFSET $SG4294820210
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@parse_unco:

; 1981 :    // now fill header the normal way
; 1982 :    while (k < 4)

  000b5	83 7d e8 04	 cmp	 DWORD PTR _k$[ebp], 4
  000b9	7d 1e		 jge	 SHORT $LN5@parse_unco

; 1983 :       header[k++] = (uint8) zget8(a);

  000bb	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?zget8@@YAHPAUzbuf@@@Z	; zget8
  000c4	83 c4 04	 add	 esp, 4
  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _k$[ebp]
  000ca	88 44 0d f8	 mov	 BYTE PTR _header$[ebp+ecx], al
  000ce	8b 55 e8	 mov	 edx, DWORD PTR _k$[ebp]
  000d1	83 c2 01	 add	 edx, 1
  000d4	89 55 e8	 mov	 DWORD PTR _k$[ebp], edx
  000d7	eb dc		 jmp	 SHORT $LN4@parse_unco
$LN5@parse_unco:

; 1984 :    len  = header[1] * 256 + header[0];

  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	c1 e0 00	 shl	 eax, 0
  000e1	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _header$[ebp+eax]
  000e6	c1 e1 08	 shl	 ecx, 8
  000e9	ba 01 00 00 00	 mov	 edx, 1
  000ee	6b c2 00	 imul	 eax, edx, 0
  000f1	0f b6 54 05 f8	 movzx	 edx, BYTE PTR _header$[ebp+eax]
  000f6	03 ca		 add	 ecx, edx
  000f8	89 4d f0	 mov	 DWORD PTR _len$[ebp], ecx

; 1985 :    nlen = header[3] * 256 + header[2];

  000fb	b8 01 00 00 00	 mov	 eax, 1
  00100	6b c8 03	 imul	 ecx, eax, 3
  00103	0f b6 54 0d f8	 movzx	 edx, BYTE PTR _header$[ebp+ecx]
  00108	c1 e2 08	 shl	 edx, 8
  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	d1 e0		 shl	 eax, 1
  00112	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _header$[ebp+eax]
  00117	03 d1		 add	 edx, ecx
  00119	89 55 ec	 mov	 DWORD PTR _nlen$[ebp], edx

; 1986 :    if (nlen != (len ^ 0xffff)) return e("zlib corrupt","Corrupt PNG");

  0011c	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  0011f	81 f2 ff ff 00
	00		 xor	 edx, 65535		; 0000ffffH
  00125	39 55 ec	 cmp	 DWORD PTR _nlen$[ebp], edx
  00128	74 12		 je	 SHORT $LN7@parse_unco
  0012a	68 00 00 00 00	 push	 OFFSET $SG4294820209
  0012f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00134	83 c4 04	 add	 esp, 4
  00137	e9 8c 00 00 00	 jmp	 $LN1@parse_unco
$LN7@parse_unco:

; 1987 :    if (a->zbuffer + len > a->zbuffer_end) return e("read past buffer","Corrupt PNG");

  0013c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0013f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00141	03 4d f0	 add	 ecx, DWORD PTR _len$[ebp]
  00144	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00147	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  0014a	76 0f		 jbe	 SHORT $LN8@parse_unco
  0014c	68 00 00 00 00	 push	 OFFSET $SG4294820208
  00151	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00156	83 c4 04	 add	 esp, 4
  00159	eb 6d		 jmp	 SHORT $LN1@parse_unco
$LN8@parse_unco:

; 1988 :    if (a->zout + len > a->zout_end)

  0015b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0015e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00161	03 4d f0	 add	 ecx, DWORD PTR _len$[ebp]
  00164	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00167	3b 4a 18	 cmp	 ecx, DWORD PTR [edx+24]
  0016a	76 18		 jbe	 SHORT $LN9@parse_unco

; 1989 :       if (!expand(a, len)) return 0;

  0016c	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  0016f	50		 push	 eax
  00170	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00173	51		 push	 ecx
  00174	e8 00 00 00 00	 call	 ?expand@@YAHPAUzbuf@@H@Z ; expand
  00179	83 c4 08	 add	 esp, 8
  0017c	85 c0		 test	 eax, eax
  0017e	75 04		 jne	 SHORT $LN9@parse_unco
  00180	33 c0		 xor	 eax, eax
  00182	eb 44		 jmp	 SHORT $LN1@parse_unco
$LN9@parse_unco:

; 1990 :    memcpy(a->zout, a->zbuffer, len);

  00184	8b f4		 mov	 esi, esp
  00186	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  00189	52		 push	 edx
  0018a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0018d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018f	51		 push	 ecx
  00190	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00193	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1991 :    a->zbuffer += len;

  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ac	03 55 f0	 add	 edx, DWORD PTR _len$[ebp]
  001af	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001b2	89 10		 mov	 DWORD PTR [eax], edx

; 1992 :    a->zout += len;

  001b4	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001b7	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001ba	03 55 f0	 add	 edx, DWORD PTR _len$[ebp]
  001bd	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001c0	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1993 :    return 1;

  001c3	b8 01 00 00 00	 mov	 eax, 1
$LN1@parse_unco:

; 1994 : }

  001c8	52		 push	 edx
  001c9	8b cd		 mov	 ecx, ebp
  001cb	50		 push	 eax
  001cc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@parse_unco
  001d2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d7	58		 pop	 eax
  001d8	5a		 pop	 edx
  001d9	5e		 pop	 esi
  001da	83 c4 18	 add	 esp, 24			; 00000018H
  001dd	3b ec		 cmp	 ebp, esp
  001df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
$LN15@parse_unco:
  001e8	01 00 00 00	 DD	 1
  001ec	00 00 00 00	 DD	 $LN14@parse_unco
$LN14@parse_unco:
  001f0	f8 ff ff ff	 DD	 -8			; fffffff8H
  001f4	04 00 00 00	 DD	 4
  001f8	00 00 00 00	 DD	 $LN13@parse_unco
$LN13@parse_unco:
  001fc	68		 DB	 104			; 00000068H
  001fd	65		 DB	 101			; 00000065H
  001fe	61		 DB	 97			; 00000061H
  001ff	64		 DB	 100			; 00000064H
  00200	65		 DB	 101			; 00000065H
  00201	72		 DB	 114			; 00000072H
  00202	00		 DB	 0
?parse_uncompressed_block@@YAHPAUzbuf@@@Z ENDP		; parse_uncompressed_block
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_flg$ = -12						; size = 4
_cm$ = -8						; size = 4
_cmf$ = -4						; size = 4
_a$ = 8							; size = 4
?parse_zlib_header@@YAHPAUzbuf@@@Z PROC			; parse_zlib_header

; 1997 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1998 :    int cmf   = zget8(a);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?zget8@@YAHPAUzbuf@@@Z	; zget8
  00024	83 c4 04	 add	 esp, 4
  00027	89 45 fc	 mov	 DWORD PTR _cmf$[ebp], eax

; 1999 :    int cm    = cmf & 15;

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _cmf$[ebp]
  0002d	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00030	89 4d f8	 mov	 DWORD PTR _cm$[ebp], ecx

; 2000 :    /* int cinfo = cmf >> 4; */
; 2001 :    int flg   = zget8(a);

  00033	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?zget8@@YAHPAUzbuf@@@Z	; zget8
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f4	 mov	 DWORD PTR _flg$[ebp], eax

; 2002 :    if ((cmf*256+flg) % 31 != 0) return e("bad zlib header","Corrupt PNG"); // zlib spec

  00042	8b 45 fc	 mov	 eax, DWORD PTR _cmf$[ebp]
  00045	c1 e0 08	 shl	 eax, 8
  00048	03 45 f4	 add	 eax, DWORD PTR _flg$[ebp]
  0004b	99		 cdq
  0004c	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00051	f7 f9		 idiv	 ecx
  00053	85 d2		 test	 edx, edx
  00055	74 0f		 je	 SHORT $LN2@parse_zlib
  00057	68 00 00 00 00	 push	 OFFSET $SG4294820207
  0005c	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00061	83 c4 04	 add	 esp, 4
  00064	eb 31		 jmp	 SHORT $LN1@parse_zlib
$LN2@parse_zlib:

; 2003 :    if (flg & 32) return e("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

  00066	8b 55 f4	 mov	 edx, DWORD PTR _flg$[ebp]
  00069	83 e2 20	 and	 edx, 32			; 00000020H
  0006c	74 0f		 je	 SHORT $LN3@parse_zlib
  0006e	68 00 00 00 00	 push	 OFFSET $SG4294820206
  00073	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00078	83 c4 04	 add	 esp, 4
  0007b	eb 1a		 jmp	 SHORT $LN1@parse_zlib
$LN3@parse_zlib:

; 2004 :    if (cm != 8) return e("bad compression","Corrupt PNG"); // DEFLATE required for png

  0007d	83 7d f8 08	 cmp	 DWORD PTR _cm$[ebp], 8
  00081	74 0f		 je	 SHORT $LN4@parse_zlib
  00083	68 00 00 00 00	 push	 OFFSET $SG4294820205
  00088	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0008d	83 c4 04	 add	 esp, 4
  00090	eb 05		 jmp	 SHORT $LN1@parse_zlib
$LN4@parse_zlib:

; 2005 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 2006 :    return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
$LN1@parse_zlib:

; 2007 : }

  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?parse_zlib_header@@YAHPAUzbuf@@@Z ENDP			; parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
?init_defaults@@YAXXZ PROC				; init_defaults

; 2012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2013 :    int i;   // use <= to match clearly with spec
; 2014 :    for (i=0; i <= 143; ++i)     default_length[i]   = 8;

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00012	eb 09		 jmp	 SHORT $LN4@init_defau
$LN2@init_defau:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@init_defau:
  0001d	81 7d fc 8f 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 143	; 0000008fH
  00024	7f 0c		 jg	 SHORT $LN3@init_defau
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00029	c6 81 00 00 00
	00 08		 mov	 BYTE PTR ?default_length@@3PAEA[ecx], 8
  00030	eb e2		 jmp	 SHORT $LN2@init_defau
$LN3@init_defau:

; 2015 :    for (   ; i <= 255; ++i)     default_length[i]   = 9;

  00032	eb 09		 jmp	 SHORT $LN7@init_defau
$LN5@init_defau:
  00034	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00037	83 c2 01	 add	 edx, 1
  0003a	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@init_defau:
  0003d	81 7d fc ff 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 255	; 000000ffH
  00044	7f 0c		 jg	 SHORT $LN6@init_defau
  00046	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00049	c6 80 00 00 00
	00 09		 mov	 BYTE PTR ?default_length@@3PAEA[eax], 9
  00050	eb e2		 jmp	 SHORT $LN5@init_defau
$LN6@init_defau:

; 2016 :    for (   ; i <= 279; ++i)     default_length[i]   = 7;

  00052	eb 09		 jmp	 SHORT $LN10@init_defau
$LN8@init_defau:
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00057	83 c1 01	 add	 ecx, 1
  0005a	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN10@init_defau:
  0005d	81 7d fc 17 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 279	; 00000117H
  00064	7f 0c		 jg	 SHORT $LN9@init_defau
  00066	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00069	c6 82 00 00 00
	00 07		 mov	 BYTE PTR ?default_length@@3PAEA[edx], 7
  00070	eb e2		 jmp	 SHORT $LN8@init_defau
$LN9@init_defau:

; 2017 :    for (   ; i <= 287; ++i)     default_length[i]   = 8;

  00072	eb 09		 jmp	 SHORT $LN13@init_defau
$LN11@init_defau:
  00074	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00077	83 c0 01	 add	 eax, 1
  0007a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@init_defau:
  0007d	81 7d fc 1f 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 287	; 0000011fH
  00084	7f 0c		 jg	 SHORT $LN12@init_defau
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00089	c6 81 00 00 00
	00 08		 mov	 BYTE PTR ?default_length@@3PAEA[ecx], 8
  00090	eb e2		 jmp	 SHORT $LN11@init_defau
$LN12@init_defau:

; 2018 : 
; 2019 :    for (i=0; i <=  31; ++i)     default_distance[i] = 5;

  00092	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00099	eb 09		 jmp	 SHORT $LN16@init_defau
$LN14@init_defau:
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0009e	83 c2 01	 add	 edx, 1
  000a1	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN16@init_defau:
  000a4	83 7d fc 1f	 cmp	 DWORD PTR _i$[ebp], 31	; 0000001fH
  000a8	7f 0c		 jg	 SHORT $LN1@init_defau
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	c6 80 00 00 00
	00 05		 mov	 BYTE PTR ?default_distance@@3PAEA[eax], 5
  000b4	eb e5		 jmp	 SHORT $LN14@init_defau
$LN1@init_defau:

; 2020 : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?init_defaults@@YAXXZ ENDP				; init_defaults
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_type$ = -8						; size = 4
_final$ = -4						; size = 4
_a$ = 8							; size = 4
_parse_header$ = 12					; size = 4
?parse_zlib@@YAHPAUzbuf@@H@Z PROC			; parse_zlib

; 2024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2025 :    int final, type;
; 2026 :    if (parse_header)

  00014	83 7d 0c 00	 cmp	 DWORD PTR _parse_header$[ebp], 0
  00018	74 17		 je	 SHORT $LN5@parse_zlib

; 2027 :       if (!parse_zlib_header(a)) return 0;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?parse_zlib_header@@YAHPAUzbuf@@@Z ; parse_zlib_header
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 07		 jne	 SHORT $LN5@parse_zlib
  0002a	33 c0		 xor	 eax, eax
  0002c	e9 21 01 00 00	 jmp	 $LN1@parse_zlib
$LN5@parse_zlib:

; 2028 :    a->num_bits = 0;

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00034	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 2029 :    a->code_buffer = 0;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$LN4@parse_zlib:

; 2030 :    do {
; 2031 :       final = zreceive(a,1);

  00045	6a 01		 push	 1
  00047	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 fc	 mov	 DWORD PTR _final$[ebp], eax

; 2032 :       type = zreceive(a,2);

  00056	6a 02		 push	 2
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?zreceive@@YAIPAUzbuf@@H@Z ; zreceive
  00061	83 c4 08	 add	 esp, 8
  00064	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 2033 :       if (type == 0) {

  00067	83 7d f8 00	 cmp	 DWORD PTR _type$[ebp], 0
  0006b	75 1c		 jne	 SHORT $LN7@parse_zlib

; 2034 :          if (!parse_uncompressed_block(a)) return 0;

  0006d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ?parse_uncompressed_block@@YAHPAUzbuf@@@Z ; parse_uncompressed_block
  00076	83 c4 04	 add	 esp, 4
  00079	85 c0		 test	 eax, eax
  0007b	75 07		 jne	 SHORT $LN9@parse_zlib
  0007d	33 c0		 xor	 eax, eax
  0007f	e9 ce 00 00 00	 jmp	 $LN1@parse_zlib
$LN9@parse_zlib:

; 2035 :       } else if (type == 3) {

  00084	e9 9c 00 00 00	 jmp	 $LN8@parse_zlib
$LN7@parse_zlib:
  00089	83 7d f8 03	 cmp	 DWORD PTR _type$[ebp], 3
  0008d	75 0c		 jne	 SHORT $LN10@parse_zlib

; 2036 :          return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 bc 00 00 00	 jmp	 $LN1@parse_zlib

; 2037 :       } else {

  00096	e9 8a 00 00 00	 jmp	 $LN8@parse_zlib
$LN10@parse_zlib:

; 2038 :          if (type == 1) {

  0009b	83 7d f8 01	 cmp	 DWORD PTR _type$[ebp], 1
  0009f	75 5c		 jne	 SHORT $LN12@parse_zlib

; 2039 :             // use fixed code lengths
; 2040 :             if (!default_distance[31]) init_defaults();

  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	6b c8 1f	 imul	 ecx, eax, 31
  000a9	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?default_distance@@3PAEA[ecx]
  000b0	85 d2		 test	 edx, edx
  000b2	75 05		 jne	 SHORT $LN14@parse_zlib
  000b4	e8 00 00 00 00	 call	 ?init_defaults@@YAXXZ	; init_defaults
$LN14@parse_zlib:

; 2041 :             if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;

  000b9	68 20 01 00 00	 push	 288			; 00000120H
  000be	68 00 00 00 00	 push	 OFFSET ?default_length@@3PAEA
  000c3	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000c6	83 c0 20	 add	 eax, 32			; 00000020H
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ; zbuild_huffman
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d2	85 c0		 test	 eax, eax
  000d4	75 04		 jne	 SHORT $LN15@parse_zlib
  000d6	33 c0		 xor	 eax, eax
  000d8	eb 78		 jmp	 SHORT $LN1@parse_zlib
$LN15@parse_zlib:

; 2042 :             if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;

  000da	6a 20		 push	 32			; 00000020H
  000dc	68 00 00 00 00	 push	 OFFSET ?default_distance@@3PAEA
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000e4	81 c1 04 08 00
	00		 add	 ecx, 2052		; 00000804H
  000ea	51		 push	 ecx
  000eb	e8 00 00 00 00	 call	 ?zbuild_huffman@@YAHPAUzhuffman@@PAEH@Z ; zbuild_huffman
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f3	85 c0		 test	 eax, eax
  000f5	75 04		 jne	 SHORT $LN16@parse_zlib
  000f7	33 c0		 xor	 eax, eax
  000f9	eb 57		 jmp	 SHORT $LN1@parse_zlib
$LN16@parse_zlib:

; 2043 :          } else {

  000fb	eb 14		 jmp	 SHORT $LN13@parse_zlib
$LN12@parse_zlib:

; 2044 :             if (!compute_huffman_codes(a)) return 0;

  000fd	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 ?compute_huffman_codes@@YAHPAUzbuf@@@Z ; compute_huffman_codes
  00106	83 c4 04	 add	 esp, 4
  00109	85 c0		 test	 eax, eax
  0010b	75 04		 jne	 SHORT $LN13@parse_zlib
  0010d	33 c0		 xor	 eax, eax
  0010f	eb 41		 jmp	 SHORT $LN1@parse_zlib
$LN13@parse_zlib:

; 2045 :          }
; 2046 :          if (!parse_huffman_block(a)) return 0;

  00111	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?parse_huffman_block@@YAHPAUzbuf@@@Z ; parse_huffman_block
  0011a	83 c4 04	 add	 esp, 4
  0011d	85 c0		 test	 eax, eax
  0011f	75 04		 jne	 SHORT $LN8@parse_zlib
  00121	33 c0		 xor	 eax, eax
  00123	eb 2d		 jmp	 SHORT $LN1@parse_zlib
$LN8@parse_zlib:

; 2047 :       }
; 2048 :       if (stbi_png_partial && a->zout - a->zout_start > 65536)

  00125	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stbi_png_partial@@3HA, 0 ; stbi_png_partial
  0012c	74 15		 je	 SHORT $LN2@parse_zlib
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00131	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00134	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00137	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  0013a	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  0013f	7e 02		 jle	 SHORT $LN2@parse_zlib

; 2049 :          break;

  00141	eb 0a		 jmp	 SHORT $LN3@parse_zlib
$LN2@parse_zlib:

; 2050 :    } while (!final);

  00143	83 7d fc 00	 cmp	 DWORD PTR _final$[ebp], 0
  00147	0f 84 f8 fe ff
	ff		 je	 $LN4@parse_zlib
$LN3@parse_zlib:

; 2051 :    return 1;

  0014d	b8 01 00 00 00	 mov	 eax, 1
$LN1@parse_zlib:

; 2052 : }

  00152	83 c4 08	 add	 esp, 8
  00155	3b ec		 cmp	 ebp, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
?parse_zlib@@YAHPAUzbuf@@H@Z ENDP			; parse_zlib
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_obuf$ = 12						; size = 4
_olen$ = 16						; size = 4
_exp$ = 20						; size = 4
_parse_header$ = 24					; size = 4
?do_zlib@@YAHPAUzbuf@@PADHHH@Z PROC			; do_zlib

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2056 :    a->zout_start = obuf;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _obuf$[ebp]
  00009	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2057 :    a->zout       = obuf;

  0000c	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _obuf$[ebp]
  00012	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2058 :    a->zout_end   = obuf + olen;

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _obuf$[ebp]
  00018	03 4d 10	 add	 ecx, DWORD PTR _olen$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0001e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 2059 :    a->z_expandable = exp;

  00021	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _exp$[ebp]
  00027	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 2060 : 
; 2061 :    return parse_zlib(a, parse_header);

  0002a	8b 55 18	 mov	 edx, DWORD PTR _parse_header$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?parse_zlib@@YAHPAUzbuf@@H@Z ; parse_zlib
  00037	83 c4 08	 add	 esp, 8

; 2062 : }

  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?do_zlib@@YAHPAUzbuf@@PADHHH@Z ENDP			; do_zlib
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = -4088						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_stbi_zlib_decode_malloc_guesssize PROC

; 2065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 0f 00
	00		 sub	 esp, 4088		; 00000ff8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 08 f0 ff
	ff		 lea	 edi, DWORD PTR [ebp-4088]
  00011	b9 fe 03 00 00	 mov	 ecx, 1022		; 000003feH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2066 :    zbuf a;
; 2067 :    char *p = (char *) malloc(initial_size);

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 10	 mov	 eax, DWORD PTR _initial_size$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 85 08 f0 ff
	ff		 mov	 DWORD PTR _p$[ebp], eax

; 2068 :    if (p == NULL) return NULL;

  00043	83 bd 08 f0 ff
	ff 00		 cmp	 DWORD PTR _p$[ebp], 0
  0004a	75 04		 jne	 SHORT $LN2@stbi_zlib_
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 73		 jmp	 SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 2069 :    a.zbuffer = (uint8 *) buffer;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00053	89 8d 10 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp], ecx

; 2070 :    a.zbuffer_end = (uint8 *) buffer + len;

  00059	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0005c	03 55 0c	 add	 edx, DWORD PTR _len$[ebp]
  0005f	89 95 14 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp+4], edx

; 2071 :    if (do_zlib(&a, p, initial_size, 1, 1)) {

  00065	6a 01		 push	 1
  00067	6a 01		 push	 1
  00069	8b 45 10	 mov	 eax, DWORD PTR _initial_size$[ebp]
  0006c	50		 push	 eax
  0006d	8b 8d 08 f0 ff
	ff		 mov	 ecx, DWORD PTR _p$[ebp]
  00073	51		 push	 ecx
  00074	8d 95 10 f0 ff
	ff		 lea	 edx, DWORD PTR _a$[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 ?do_zlib@@YAHPAUzbuf@@PADHHH@Z ; do_zlib
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	85 c0		 test	 eax, eax
  00085	74 21		 je	 SHORT $LN3@stbi_zlib_

; 2072 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  00087	83 7d 14 00	 cmp	 DWORD PTR _outlen$[ebp], 0
  0008b	74 11		 je	 SHORT $LN5@stbi_zlib_
  0008d	8b 85 20 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+16]
  00093	2b 85 24 f0 ff
	ff		 sub	 eax, DWORD PTR _a$[ebp+20]
  00099	8b 4d 14	 mov	 ecx, DWORD PTR _outlen$[ebp]
  0009c	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@stbi_zlib_:

; 2073 :       return a.zout_start;

  0009e	8b 85 24 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+20]
  000a4	eb 1d		 jmp	 SHORT $LN1@stbi_zlib_

; 2074 :    } else {

  000a6	eb 1b		 jmp	 SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 2075 :       free(a.zout_start);

  000a8	8b f4		 mov	 esi, esp
  000aa	8b 95 24 f0 ff
	ff		 mov	 edx, DWORD PTR _a$[ebp+20]
  000b0	52		 push	 edx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2076 :       return NULL;

  000c1	33 c0		 xor	 eax, eax
$LN1@stbi_zlib_:

; 2077 :    }
; 2078 : }

  000c3	52		 push	 edx
  000c4	8b cd		 mov	 ecx, ebp
  000c6	50		 push	 eax
  000c7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbi_zlib_
  000cd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d2	58		 pop	 eax
  000d3	5a		 pop	 edx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	81 c4 f8 0f 00
	00		 add	 esp, 4088		; 00000ff8H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
  000f1	0f 1f 00	 npad	 3
$LN9@stbi_zlib_:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $LN8@stbi_zlib_
$LN8@stbi_zlib_:
  000fc	10 f0 ff ff	 DD	 -4080			; fffff010H
  00100	e8 0f 00 00	 DD	 4072			; 00000fe8H
  00104	00 00 00 00	 DD	 $LN7@stbi_zlib_
$LN7@stbi_zlib_:
  00108	61		 DB	 97			; 00000061H
  00109	00		 DB	 0
_stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_malloc PROC

; 2081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2082 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

  00003	8b 45 10	 mov	 eax, DWORD PTR _outlen$[ebp]
  00006	50		 push	 eax
  00007	68 00 40 00 00	 push	 16384			; 00004000H
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _stbi_zlib_decode_malloc_guesssize
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 2083 : }

  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = -4088						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_initial_size$ = 16					; size = 4
_outlen$ = 20						; size = 4
_parse_header$ = 24					; size = 4
?stbi_zlib_decode_malloc_guesssize_headerflag@@YAPADPBDHHPAHH@Z PROC ; stbi_zlib_decode_malloc_guesssize_headerflag

; 2086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 0f 00
	00		 sub	 esp, 4088		; 00000ff8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 08 f0 ff
	ff		 lea	 edi, DWORD PTR [ebp-4088]
  00011	b9 fe 03 00 00	 mov	 ecx, 1022		; 000003feH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2087 :    zbuf a;
; 2088 :    char *p = (char *) malloc(initial_size);

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 10	 mov	 eax, DWORD PTR _initial_size$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 85 08 f0 ff
	ff		 mov	 DWORD PTR _p$[ebp], eax

; 2089 :    if (p == NULL) return NULL;

  00043	83 bd 08 f0 ff
	ff 00		 cmp	 DWORD PTR _p$[ebp], 0
  0004a	75 04		 jne	 SHORT $LN2@stbi_zlib_
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 75		 jmp	 SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 2090 :    a.zbuffer = (uint8 *) buffer;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00053	89 8d 10 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp], ecx

; 2091 :    a.zbuffer_end = (uint8 *) buffer + len;

  00059	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0005c	03 55 0c	 add	 edx, DWORD PTR _len$[ebp]
  0005f	89 95 14 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp+4], edx

; 2092 :    if (do_zlib(&a, p, initial_size, 1, parse_header)) {

  00065	8b 45 18	 mov	 eax, DWORD PTR _parse_header$[ebp]
  00068	50		 push	 eax
  00069	6a 01		 push	 1
  0006b	8b 4d 10	 mov	 ecx, DWORD PTR _initial_size$[ebp]
  0006e	51		 push	 ecx
  0006f	8b 95 08 f0 ff
	ff		 mov	 edx, DWORD PTR _p$[ebp]
  00075	52		 push	 edx
  00076	8d 85 10 f0 ff
	ff		 lea	 eax, DWORD PTR _a$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?do_zlib@@YAHPAUzbuf@@PADHHH@Z ; do_zlib
  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	85 c0		 test	 eax, eax
  00087	74 21		 je	 SHORT $LN3@stbi_zlib_

; 2093 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  00089	83 7d 14 00	 cmp	 DWORD PTR _outlen$[ebp], 0
  0008d	74 11		 je	 SHORT $LN5@stbi_zlib_
  0008f	8b 8d 20 f0 ff
	ff		 mov	 ecx, DWORD PTR _a$[ebp+16]
  00095	2b 8d 24 f0 ff
	ff		 sub	 ecx, DWORD PTR _a$[ebp+20]
  0009b	8b 55 14	 mov	 edx, DWORD PTR _outlen$[ebp]
  0009e	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@stbi_zlib_:

; 2094 :       return a.zout_start;

  000a0	8b 85 24 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+20]
  000a6	eb 1d		 jmp	 SHORT $LN1@stbi_zlib_

; 2095 :    } else {

  000a8	eb 1b		 jmp	 SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 2096 :       free(a.zout_start);

  000aa	8b f4		 mov	 esi, esp
  000ac	8b 85 24 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+20]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b9	83 c4 04	 add	 esp, 4
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2097 :       return NULL;

  000c3	33 c0		 xor	 eax, eax
$LN1@stbi_zlib_:

; 2098 :    }
; 2099 : }

  000c5	52		 push	 edx
  000c6	8b cd		 mov	 ecx, ebp
  000c8	50		 push	 eax
  000c9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbi_zlib_
  000cf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d4	58		 pop	 eax
  000d5	5a		 pop	 edx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	81 c4 f8 0f 00
	00		 add	 esp, 4088		; 00000ff8H
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
  000f3	90		 npad	 1
$LN9@stbi_zlib_:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $LN8@stbi_zlib_
$LN8@stbi_zlib_:
  000fc	10 f0 ff ff	 DD	 -4080			; fffff010H
  00100	e8 0f 00 00	 DD	 4072			; 00000fe8H
  00104	00 00 00 00	 DD	 $LN7@stbi_zlib_
$LN7@stbi_zlib_:
  00108	61		 DB	 97			; 00000061H
  00109	00		 DB	 0
?stbi_zlib_decode_malloc_guesssize_headerflag@@YAPADPBDHHPAHH@Z ENDP ; stbi_zlib_decode_malloc_guesssize_headerflag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_buffer PROC

; 2102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 0f 00
	00		 sub	 esp, 4084		; 00000ff4H
  00009	57		 push	 edi
  0000a	8d bd 0c f0 ff
	ff		 lea	 edi, DWORD PTR [ebp-4084]
  00010	b9 fd 03 00 00	 mov	 ecx, 1021		; 000003fdH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2103 :    zbuf a;
; 2104 :    a.zbuffer = (uint8 *) ibuffer;

  00026	8b 45 10	 mov	 eax, DWORD PTR _ibuffer$[ebp]
  00029	89 85 10 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp], eax

; 2105 :    a.zbuffer_end = (uint8 *) ibuffer + ilen;

  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _ibuffer$[ebp]
  00032	03 4d 14	 add	 ecx, DWORD PTR _ilen$[ebp]
  00035	89 8d 14 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp+4], ecx

; 2106 :    if (do_zlib(&a, obuffer, olen, 0, 1))

  0003b	6a 01		 push	 1
  0003d	6a 00		 push	 0
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _olen$[ebp]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _obuffer$[ebp]
  00046	50		 push	 eax
  00047	8d 8d 10 f0 ff
	ff		 lea	 ecx, DWORD PTR _a$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?do_zlib@@YAHPAUzbuf@@PADHHH@Z ; do_zlib
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	85 c0		 test	 eax, eax
  00058	74 10		 je	 SHORT $LN2@stbi_zlib_

; 2107 :       return (int) (a.zout - a.zout_start);

  0005a	8b 85 20 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+16]
  00060	2b 85 24 f0 ff
	ff		 sub	 eax, DWORD PTR _a$[ebp+20]
  00066	eb 05		 jmp	 SHORT $LN1@stbi_zlib_

; 2108 :    else

  00068	eb 03		 jmp	 SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 2109 :       return -1;

  0006a	83 c8 ff	 or	 eax, -1
$LN1@stbi_zlib_:

; 2110 : }

  0006d	52		 push	 edx
  0006e	8b cd		 mov	 ecx, ebp
  00070	50		 push	 eax
  00071	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@stbi_zlib_
  00077	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007c	58		 pop	 eax
  0007d	5a		 pop	 edx
  0007e	5f		 pop	 edi
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	81 c4 f4 0f 00
	00		 add	 esp, 4084		; 00000ff4H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN7@stbi_zlib_:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN6@stbi_zlib_
$LN6@stbi_zlib_:
  000a4	10 f0 ff ff	 DD	 -4080			; fffff010H
  000a8	e8 0f 00 00	 DD	 4072			; 00000fe8H
  000ac	00 00 00 00	 DD	 $LN5@stbi_zlib_
$LN5@stbi_zlib_:
  000b0	61		 DB	 97			; 00000061H
  000b1	00		 DB	 0
_stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = -4088						; size = 4
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_outlen$ = 16						; size = 4
_stbi_zlib_decode_noheader_malloc PROC

; 2113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 0f 00
	00		 sub	 esp, 4088		; 00000ff8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 08 f0 ff
	ff		 lea	 edi, DWORD PTR [ebp-4088]
  00011	b9 fe 03 00 00	 mov	 ecx, 1022		; 000003feH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2114 :    zbuf a;
; 2115 :    char *p = (char *) malloc(16384);

  00027	8b f4		 mov	 esi, esp
  00029	68 00 40 00 00	 push	 16384			; 00004000H
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 85 08 f0 ff
	ff		 mov	 DWORD PTR _p$[ebp], eax

; 2116 :    if (p == NULL) return NULL;

  00044	83 bd 08 f0 ff
	ff 00		 cmp	 DWORD PTR _p$[ebp], 0
  0004b	75 04		 jne	 SHORT $LN2@stbi_zlib_
  0004d	33 c0		 xor	 eax, eax
  0004f	eb 74		 jmp	 SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 2117 :    a.zbuffer = (uint8 *) buffer;

  00051	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00054	89 85 10 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp], eax

; 2118 :    a.zbuffer_end = (uint8 *) buffer+len;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0005d	03 4d 0c	 add	 ecx, DWORD PTR _len$[ebp]
  00060	89 8d 14 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp+4], ecx

; 2119 :    if (do_zlib(&a, p, 16384, 1, 0)) {

  00066	6a 00		 push	 0
  00068	6a 01		 push	 1
  0006a	68 00 40 00 00	 push	 16384			; 00004000H
  0006f	8b 95 08 f0 ff
	ff		 mov	 edx, DWORD PTR _p$[ebp]
  00075	52		 push	 edx
  00076	8d 85 10 f0 ff
	ff		 lea	 eax, DWORD PTR _a$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?do_zlib@@YAHPAUzbuf@@PADHHH@Z ; do_zlib
  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	85 c0		 test	 eax, eax
  00087	74 21		 je	 SHORT $LN3@stbi_zlib_

; 2120 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  00089	83 7d 10 00	 cmp	 DWORD PTR _outlen$[ebp], 0
  0008d	74 11		 je	 SHORT $LN5@stbi_zlib_
  0008f	8b 8d 20 f0 ff
	ff		 mov	 ecx, DWORD PTR _a$[ebp+16]
  00095	2b 8d 24 f0 ff
	ff		 sub	 ecx, DWORD PTR _a$[ebp+20]
  0009b	8b 55 10	 mov	 edx, DWORD PTR _outlen$[ebp]
  0009e	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@stbi_zlib_:

; 2121 :       return a.zout_start;

  000a0	8b 85 24 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+20]
  000a6	eb 1d		 jmp	 SHORT $LN1@stbi_zlib_

; 2122 :    } else {

  000a8	eb 1b		 jmp	 SHORT $LN1@stbi_zlib_
$LN3@stbi_zlib_:

; 2123 :       free(a.zout_start);

  000aa	8b f4		 mov	 esi, esp
  000ac	8b 85 24 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+20]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b9	83 c4 04	 add	 esp, 4
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2124 :       return NULL;

  000c3	33 c0		 xor	 eax, eax
$LN1@stbi_zlib_:

; 2125 :    }
; 2126 : }

  000c5	52		 push	 edx
  000c6	8b cd		 mov	 ecx, ebp
  000c8	50		 push	 eax
  000c9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbi_zlib_
  000cf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d4	58		 pop	 eax
  000d5	5a		 pop	 edx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	81 c4 f8 0f 00
	00		 add	 esp, 4088		; 00000ff8H
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
  000f3	90		 npad	 1
$LN9@stbi_zlib_:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $LN8@stbi_zlib_
$LN8@stbi_zlib_:
  000fc	10 f0 ff ff	 DD	 -4080			; fffff010H
  00100	e8 0f 00 00	 DD	 4072			; 00000fe8H
  00104	00 00 00 00	 DD	 $LN7@stbi_zlib_
$LN7@stbi_zlib_:
  00108	61		 DB	 97			; 00000061H
  00109	00		 DB	 0
_stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_a$ = -4080						; size = 4072
__$ArrayPad$ = -4					; size = 4
_obuffer$ = 8						; size = 4
_olen$ = 12						; size = 4
_ibuffer$ = 16						; size = 4
_ilen$ = 20						; size = 4
_stbi_zlib_decode_noheader_buffer PROC

; 2129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 0f 00
	00		 sub	 esp, 4084		; 00000ff4H
  00009	57		 push	 edi
  0000a	8d bd 0c f0 ff
	ff		 lea	 edi, DWORD PTR [ebp-4084]
  00010	b9 fd 03 00 00	 mov	 ecx, 1021		; 000003fdH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2130 :    zbuf a;
; 2131 :    a.zbuffer = (uint8 *) ibuffer;

  00026	8b 45 10	 mov	 eax, DWORD PTR _ibuffer$[ebp]
  00029	89 85 10 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp], eax

; 2132 :    a.zbuffer_end = (uint8 *) ibuffer + ilen;

  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _ibuffer$[ebp]
  00032	03 4d 14	 add	 ecx, DWORD PTR _ilen$[ebp]
  00035	89 8d 14 f0 ff
	ff		 mov	 DWORD PTR _a$[ebp+4], ecx

; 2133 :    if (do_zlib(&a, obuffer, olen, 0, 0))

  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _olen$[ebp]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _obuffer$[ebp]
  00046	50		 push	 eax
  00047	8d 8d 10 f0 ff
	ff		 lea	 ecx, DWORD PTR _a$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?do_zlib@@YAHPAUzbuf@@PADHHH@Z ; do_zlib
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	85 c0		 test	 eax, eax
  00058	74 10		 je	 SHORT $LN2@stbi_zlib_

; 2134 :       return (int) (a.zout - a.zout_start);

  0005a	8b 85 20 f0 ff
	ff		 mov	 eax, DWORD PTR _a$[ebp+16]
  00060	2b 85 24 f0 ff
	ff		 sub	 eax, DWORD PTR _a$[ebp+20]
  00066	eb 05		 jmp	 SHORT $LN1@stbi_zlib_

; 2135 :    else

  00068	eb 03		 jmp	 SHORT $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 2136 :       return -1;

  0006a	83 c8 ff	 or	 eax, -1
$LN1@stbi_zlib_:

; 2137 : }

  0006d	52		 push	 edx
  0006e	8b cd		 mov	 ecx, ebp
  00070	50		 push	 eax
  00071	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@stbi_zlib_
  00077	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007c	58		 pop	 eax
  0007d	5a		 pop	 edx
  0007e	5f		 pop	 edi
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	81 c4 f4 0f 00
	00		 add	 esp, 4084		; 00000ff4H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN7@stbi_zlib_:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN6@stbi_zlib_
$LN6@stbi_zlib_:
  000a4	10 f0 ff ff	 DD	 -4080			; fffff010H
  000a8	e8 0f 00 00	 DD	 4072			; 00000fe8H
  000ac	00 00 00 00	 DD	 $LN5@stbi_zlib_
$LN5@stbi_zlib_:
  000b0	61		 DB	 97			; 00000061H
  000b1	00		 DB	 0
_stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_c$ = -12						; size = 8
_s$ = 8							; size = 4
?get_chunk_header@@YA?AUchunk@@PAUstbi@@@Z PROC		; get_chunk_header

; 2159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2160 :    chunk c;
; 2161 :    c.length = get32(s);

  00017	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f4	 mov	 DWORD PTR _c$[ebp], eax

; 2162 :    c.type   = get32(s);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f8	 mov	 DWORD PTR _c$[ebp+4], eax

; 2163 :    return c;

  00035	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  00038	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp+4]

; 2164 : }

  0003b	52		 push	 edx
  0003c	8b cd		 mov	 ecx, ebp
  0003e	50		 push	 eax
  0003f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@get_chunk_
  00045	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004a	58		 pop	 eax
  0004b	5a		 pop	 edx
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
  0005a	66 90		 npad	 2
$LN5@get_chunk_:
  0005c	01 00 00 00	 DD	 1
  00060	00 00 00 00	 DD	 $LN4@get_chunk_
$LN4@get_chunk_:
  00064	f4 ff ff ff	 DD	 -12			; fffffff4H
  00068	08 00 00 00	 DD	 8
  0006c	00 00 00 00	 DD	 $LN3@get_chunk_
$LN3@get_chunk_:
  00070	63		 DB	 99			; 00000063H
  00071	00		 DB	 0
?get_chunk_header@@YA?AUchunk@@PAUstbi@@@Z ENDP		; get_chunk_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_s$ = 8							; size = 4
?check_png_header@@YAHPAUstbi@@@Z PROC			; check_png_header

; 2167 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2168 :    static uint8 png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 2169 :    int i;
; 2170 :    for (i=0; i < 8; ++i)

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00012	eb 09		 jmp	 SHORT $LN4@check_png_
$LN2@check_png_:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@check_png_:
  0001d	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00021	7d 2e		 jge	 SHORT $LN3@check_png_

; 2171 :       if (get8u(s) != png_sig[i]) return e("bad png sig","Not a PNG");

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0002c	83 c4 04	 add	 esp, 4
  0002f	0f b6 d0	 movzx	 edx, al
  00032	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00035	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?png_sig@?1??check_png_header@@YAHPAUstbi@@@Z@4PAEA[eax]
  0003c	3b d1		 cmp	 edx, ecx
  0003e	74 0f		 je	 SHORT $LN5@check_png_
  00040	68 00 00 00 00	 push	 OFFSET $SG4294820204
  00045	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0004a	83 c4 04	 add	 esp, 4
  0004d	eb 07		 jmp	 SHORT $LN1@check_png_
$LN5@check_png_:

; 2172 :    return 1;

  0004f	eb c3		 jmp	 SHORT $LN2@check_png_
$LN3@check_png_:
  00051	b8 01 00 00 00	 mov	 eax, 1
$LN1@check_png_:

; 2173 : }

  00056	83 c4 04	 add	 esp, 4
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?check_png_header@@YAHPAUstbi@@@Z ENDP			; check_png_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_pc$ = -16						; size = 4
_pb$ = -12						; size = 4
_pa$ = -8						; size = 4
_p$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?paeth@@YAHHHH@Z PROC					; paeth

; 2193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2194 :    int p = a + b - c;

  00018	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001b	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
  0001e	2b 45 10	 sub	 eax, DWORD PTR _c$[ebp]
  00021	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 2195 :    int pa = abs(p-a);

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00027	2b 4d 08	 sub	 ecx, DWORD PTR _a$[ebp]
  0002a	8b f4		 mov	 esi, esp
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abs
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 45 f8	 mov	 DWORD PTR _pa$[ebp], eax

; 2196 :    int pb = abs(p-b);

  00040	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00043	2b 55 0c	 sub	 edx, DWORD PTR _b$[ebp]
  00046	8b f4		 mov	 esi, esp
  00048	52		 push	 edx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abs
  0004f	83 c4 04	 add	 esp, 4
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	89 45 f4	 mov	 DWORD PTR _pb$[ebp], eax

; 2197 :    int pc = abs(p-c);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0005f	2b 45 10	 sub	 eax, DWORD PTR _c$[ebp]
  00062	8b f4		 mov	 esi, esp
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abs
  0006b	83 c4 04	 add	 esp, 4
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	89 45 f0	 mov	 DWORD PTR _pc$[ebp], eax

; 2198 :    if (pa <= pb && pa <= pc) return a;

  00078	8b 4d f8	 mov	 ecx, DWORD PTR _pa$[ebp]
  0007b	3b 4d f4	 cmp	 ecx, DWORD PTR _pb$[ebp]
  0007e	7f 0d		 jg	 SHORT $LN2@paeth
  00080	8b 55 f8	 mov	 edx, DWORD PTR _pa$[ebp]
  00083	3b 55 f0	 cmp	 edx, DWORD PTR _pc$[ebp]
  00086	7f 05		 jg	 SHORT $LN2@paeth
  00088	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0008b	eb 10		 jmp	 SHORT $LN1@paeth
$LN2@paeth:

; 2199 :    if (pb <= pc) return b;

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _pb$[ebp]
  00090	3b 45 f0	 cmp	 eax, DWORD PTR _pc$[ebp]
  00093	7f 05		 jg	 SHORT $LN3@paeth
  00095	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00098	eb 03		 jmp	 SHORT $LN1@paeth
$LN3@paeth:

; 2200 :    return c;

  0009a	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@paeth:

; 2201 : }

  0009d	5e		 pop	 esi
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?paeth@@YAHHHH@Z ENDP					; paeth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv369 = -48						; size = 4
tv215 = -44						; size = 4
tv155 = -40						; size = 4
_filter$1 = -36						; size = 4
_prior$2 = -32						; size = 4
_cur$3 = -28						; size = 4
_img_n$ = -24						; size = 4
_k$ = -20						; size = 4
_stride$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_s$ = -4						; size = 4
_a$ = 8							; size = 4
_raw$ = 12						; size = 4
_raw_len$ = 16						; size = 4
_out_n$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
?create_png_image_raw@@YAHPAUpng@@PAEIHII@Z PROC	; create_png_image_raw

; 2205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd

; 2206 :    stbi *s = a->s;

  00018	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 2207 :    uint32 i,j,stride = x*out_n;

  00020	8b 55 18	 mov	 edx, DWORD PTR _x$[ebp]
  00023	0f af 55 14	 imul	 edx, DWORD PTR _out_n$[ebp]
  00027	89 55 f0	 mov	 DWORD PTR _stride$[ebp], edx

; 2208 :    int k;
; 2209 :    int img_n = s->img_n; // copy it into a local for later

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	89 4d e8	 mov	 DWORD PTR _img_n$[ebp], ecx

; 2210 :    assert(out_n == s->img_n || out_n == s->img_n+1);

  00033	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00036	8b 45 14	 mov	 eax, DWORD PTR _out_n$[ebp]
  00039	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0003c	74 2f		 je	 SHORT $LN132@create_png
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00041	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00044	83 c2 01	 add	 edx, 1
  00047	39 55 14	 cmp	 DWORD PTR _out_n$[ebp], edx
  0004a	74 21		 je	 SHORT $LN132@create_png
  0004c	8b f4		 mov	 esi, esp
  0004e	68 a2 08 00 00	 push	 2210			; 000008a2H
  00053	68 00 00 00 00	 push	 OFFSET $SG4294820203
  00058	68 00 00 00 00	 push	 OFFSET $SG4294820202
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN132@create_png:

; 2211 :    if (stbi_png_partial) y = 1;

  0006d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stbi_png_partial@@3HA, 0 ; stbi_png_partial
  00074	74 07		 je	 SHORT $LN98@create_png
  00076	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _y$[ebp], 1
$LN98@create_png:

; 2212 :    a->out = (uint8 *) malloc(x * y * out_n);

  0007d	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  00080	0f af 4d 1c	 imul	 ecx, DWORD PTR _y$[ebp]
  00084	0f af 4d 14	 imul	 ecx, DWORD PTR _out_n$[ebp]
  00088	8b f4		 mov	 esi, esp
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0009e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2213 :    if (!a->out) return e("outofmem", "Out of memory");

  000a1	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a4	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a8	75 12		 jne	 SHORT $LN99@create_png
  000aa	68 00 00 00 00	 push	 OFFSET $SG4294820201
  000af	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000b4	83 c4 04	 add	 esp, 4
  000b7	e9 94 09 00 00	 jmp	 $LN1@create_png
$LN99@create_png:

; 2214 :    if (!stbi_png_partial) {

  000bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stbi_png_partial@@3HA, 0 ; stbi_png_partial
  000c3	75 61		 jne	 SHORT $LN100@create_png

; 2215 :       if (s->img_x == x && s->img_y == y) {

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ca	3b 55 18	 cmp	 edx, DWORD PTR _x$[ebp]
  000cd	75 32		 jne	 SHORT $LN101@create_png
  000cf	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d5	3b 4d 1c	 cmp	 ecx, DWORD PTR _y$[ebp]
  000d8	75 27		 jne	 SHORT $LN101@create_png

; 2216 :          if (raw_len != (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");

  000da	8b 55 e8	 mov	 edx, DWORD PTR _img_n$[ebp]
  000dd	0f af 55 18	 imul	 edx, DWORD PTR _x$[ebp]
  000e1	83 c2 01	 add	 edx, 1
  000e4	0f af 55 1c	 imul	 edx, DWORD PTR _y$[ebp]
  000e8	39 55 10	 cmp	 DWORD PTR _raw_len$[ebp], edx
  000eb	74 12		 je	 SHORT $LN103@create_png
  000ed	68 00 00 00 00	 push	 OFFSET $SG4294820200
  000f2	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000f7	83 c4 04	 add	 esp, 4
  000fa	e9 51 09 00 00	 jmp	 $LN1@create_png
$LN103@create_png:

; 2217 :       } else { // interlaced:

  000ff	eb 25		 jmp	 SHORT $LN100@create_png
$LN101@create_png:

; 2218 :          if (raw_len < (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");

  00101	8b 45 e8	 mov	 eax, DWORD PTR _img_n$[ebp]
  00104	0f af 45 18	 imul	 eax, DWORD PTR _x$[ebp]
  00108	83 c0 01	 add	 eax, 1
  0010b	0f af 45 1c	 imul	 eax, DWORD PTR _y$[ebp]
  0010f	39 45 10	 cmp	 DWORD PTR _raw_len$[ebp], eax
  00112	73 12		 jae	 SHORT $LN100@create_png
  00114	68 00 00 00 00	 push	 OFFSET $SG4294820199
  00119	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0011e	83 c4 04	 add	 esp, 4
  00121	e9 2a 09 00 00	 jmp	 $LN1@create_png
$LN100@create_png:

; 2219 :       }
; 2220 :    }
; 2221 :    for (j=0; j < y; ++j) {

  00126	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0012d	eb 09		 jmp	 SHORT $LN4@create_png
$LN2@create_png:
  0012f	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00132	83 c1 01	 add	 ecx, 1
  00135	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN4@create_png:
  00138	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  0013b	3b 55 1c	 cmp	 edx, DWORD PTR _y$[ebp]
  0013e	0f 83 07 09 00
	00		 jae	 $LN3@create_png

; 2222 :       uint8 *cur = a->out + stride*j;

  00144	8b 45 f0	 mov	 eax, DWORD PTR _stride$[ebp]
  00147	0f af 45 f4	 imul	 eax, DWORD PTR _j$[ebp]
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0014e	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00151	89 45 e4	 mov	 DWORD PTR _cur$3[ebp], eax

; 2223 :       uint8 *prior = cur - stride;

  00154	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00157	2b 55 f0	 sub	 edx, DWORD PTR _stride$[ebp]
  0015a	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx

; 2224 :       int filter = *raw++;

  0015d	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  00160	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00163	89 4d dc	 mov	 DWORD PTR _filter$1[ebp], ecx
  00166	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00169	83 c2 01	 add	 edx, 1
  0016c	89 55 0c	 mov	 DWORD PTR _raw$[ebp], edx

; 2225 :       if (filter > 4) return e("invalid filter","Corrupt PNG");

  0016f	83 7d dc 04	 cmp	 DWORD PTR _filter$1[ebp], 4
  00173	7e 12		 jle	 SHORT $LN105@create_png
  00175	68 00 00 00 00	 push	 OFFSET $SG4294820198
  0017a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0017f	83 c4 04	 add	 esp, 4
  00182	e9 c9 08 00 00	 jmp	 $LN1@create_png
$LN105@create_png:

; 2226 :       // if first row, use special filter that doesn't sample previous row
; 2227 :       if (j == 0) filter = first_row_filter[filter];

  00187	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  0018b	75 0d		 jne	 SHORT $LN106@create_png
  0018d	8b 45 dc	 mov	 eax, DWORD PTR _filter$1[ebp]
  00190	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?first_row_filter@@3PAEA[eax]
  00197	89 4d dc	 mov	 DWORD PTR _filter$1[ebp], ecx
$LN106@create_png:

; 2228 :       // handle first pixel explicitly
; 2229 :       for (k=0; k < img_n; ++k) {

  0019a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  001a1	eb 09		 jmp	 SHORT $LN7@create_png
$LN5@create_png:
  001a3	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  001a6	83 c2 01	 add	 edx, 1
  001a9	89 55 ec	 mov	 DWORD PTR _k$[ebp], edx
$LN7@create_png:
  001ac	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  001af	3b 45 e8	 cmp	 eax, DWORD PTR _img_n$[ebp]
  001b2	0f 8d d4 00 00
	00		 jge	 $LN6@create_png

; 2230 :          switch (filter) {

  001b8	8b 4d dc	 mov	 ecx, DWORD PTR _filter$1[ebp]
  001bb	89 4d d8	 mov	 DWORD PTR tv155[ebp], ecx
  001be	83 7d d8 06	 cmp	 DWORD PTR tv155[ebp], 6
  001c2	0f 87 bf 00 00
	00		 ja	 $LN8@create_png
  001c8	8b 55 d8	 mov	 edx, DWORD PTR tv155[ebp]
  001cb	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN134@create_png[edx*4]
$LN107@create_png:

; 2231 :             case F_none       : cur[k] = raw[k]; break;

  001d2	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  001d5	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  001d8	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  001db	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  001de	8a 11		 mov	 dl, BYTE PTR [ecx]
  001e0	88 10		 mov	 BYTE PTR [eax], dl
  001e2	e9 a0 00 00 00	 jmp	 $LN8@create_png
$LN108@create_png:

; 2232 :             case F_sub        : cur[k] = raw[k]; break;

  001e7	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  001ea	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  001ed	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  001f0	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  001f3	8a 11		 mov	 dl, BYTE PTR [ecx]
  001f5	88 10		 mov	 BYTE PTR [eax], dl
  001f7	e9 8b 00 00 00	 jmp	 $LN8@create_png
$LN109@create_png:

; 2233 :             case F_up         : cur[k] = raw[k] + prior[k]; break;

  001fc	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  001ff	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00202	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00205	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  00208	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  0020b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0020e	03 c8		 add	 ecx, eax
  00210	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00213	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00216	88 0a		 mov	 BYTE PTR [edx], cl
  00218	eb 6d		 jmp	 SHORT $LN8@create_png
$LN110@create_png:

; 2234 :             case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;

  0021a	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  0021d	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00220	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00223	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  00226	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00229	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0022c	d1 f8		 sar	 eax, 1
  0022e	03 c8		 add	 ecx, eax
  00230	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00233	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00236	88 0a		 mov	 BYTE PTR [edx], cl
  00238	eb 4d		 jmp	 SHORT $LN8@create_png
$LN111@create_png:

; 2235 :             case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;

  0023a	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  0023d	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00240	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  00243	6a 00		 push	 0
  00245	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  00248	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  0024b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0024e	52		 push	 edx
  0024f	6a 00		 push	 0
  00251	e8 00 00 00 00	 call	 ?paeth@@YAHHHH@Z	; paeth
  00256	83 c4 0c	 add	 esp, 12			; 0000000cH
  00259	03 d8		 add	 ebx, eax
  0025b	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  0025e	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00261	88 18		 mov	 BYTE PTR [eax], bl
  00263	eb 22		 jmp	 SHORT $LN8@create_png
$LN112@create_png:

; 2236 :             case F_avg_first  : cur[k] = raw[k]; break;

  00265	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00268	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  0026b	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  0026e	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00271	8a 02		 mov	 al, BYTE PTR [edx]
  00273	88 01		 mov	 BYTE PTR [ecx], al
  00275	eb 10		 jmp	 SHORT $LN8@create_png
$LN113@create_png:

; 2237 :             case F_paeth_first: cur[k] = raw[k]; break;

  00277	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  0027a	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  0027d	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00280	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00283	8a 02		 mov	 al, BYTE PTR [edx]
  00285	88 01		 mov	 BYTE PTR [ecx], al
$LN8@create_png:

; 2238 :          }
; 2239 :       }

  00287	e9 17 ff ff ff	 jmp	 $LN5@create_png
$LN6@create_png:

; 2240 :       if (img_n != out_n) cur[img_n] = 255;

  0028c	8b 4d e8	 mov	 ecx, DWORD PTR _img_n$[ebp]
  0028f	3b 4d 14	 cmp	 ecx, DWORD PTR _out_n$[ebp]
  00292	74 09		 je	 SHORT $LN114@create_png
  00294	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00297	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  0029a	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
$LN114@create_png:

; 2241 :       raw += img_n;

  0029d	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  002a0	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  002a3	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax

; 2242 :       cur += out_n;

  002a6	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  002a9	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  002ac	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx

; 2243 :       prior += out_n;

  002af	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  002b2	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  002b5	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx

; 2244 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 2245 :       if (img_n == out_n) {

  002b8	8b 45 e8	 mov	 eax, DWORD PTR _img_n$[ebp]
  002bb	3b 45 14	 cmp	 eax, DWORD PTR _out_n$[ebp]
  002be	0f 85 8e 03 00
	00		 jne	 $LN115@create_png

; 2246 :          #define CASE(f) \
; 2247 :              case f:     \
; 2248 :                 for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \
; 2249 :                    for (k=0; k < img_n; ++k)
; 2250 :          switch (filter) {

  002c4	8b 4d dc	 mov	 ecx, DWORD PTR _filter$1[ebp]
  002c7	89 4d d4	 mov	 DWORD PTR tv215[ebp], ecx
  002ca	83 7d d4 06	 cmp	 DWORD PTR tv215[ebp], 6
  002ce	0f 87 79 03 00
	00		 ja	 $LN10@create_png
  002d4	8b 55 d4	 mov	 edx, DWORD PTR tv215[ebp]
  002d7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN135@create_png[edx*4]
$LN117@create_png:

; 2251 :             CASE(F_none)  cur[k] = raw[k]; break;

  002de	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  002e1	83 e8 01	 sub	 eax, 1
  002e4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  002e7	eb 24		 jmp	 SHORT $LN14@create_png
$LN12@create_png:
  002e9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  002ec	83 e9 01	 sub	 ecx, 1
  002ef	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  002f2	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  002f5	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  002f8	89 55 0c	 mov	 DWORD PTR _raw$[ebp], edx
  002fb	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  002fe	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  00301	89 45 e4	 mov	 DWORD PTR _cur$3[ebp], eax
  00304	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  00307	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  0030a	89 4d e0	 mov	 DWORD PTR _prior$2[ebp], ecx
$LN14@create_png:
  0030d	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00311	72 2e		 jb	 SHORT $LN13@create_png
  00313	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0031a	eb 09		 jmp	 SHORT $LN17@create_png
$LN15@create_png:
  0031c	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  0031f	83 c2 01	 add	 edx, 1
  00322	89 55 ec	 mov	 DWORD PTR _k$[ebp], edx
$LN17@create_png:
  00325	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00328	3b 45 e8	 cmp	 eax, DWORD PTR _img_n$[ebp]
  0032b	7d 12		 jge	 SHORT $LN16@create_png
  0032d	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00330	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  00333	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00336	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00339	8a 02		 mov	 al, BYTE PTR [edx]
  0033b	88 01		 mov	 BYTE PTR [ecx], al
  0033d	eb dd		 jmp	 SHORT $LN15@create_png
$LN16@create_png:
  0033f	eb a8		 jmp	 SHORT $LN12@create_png
$LN13@create_png:
  00341	e9 07 03 00 00	 jmp	 $LN10@create_png
$LN118@create_png:

; 2252 :             CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;

  00346	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  00349	83 e9 01	 sub	 ecx, 1
  0034c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0034f	eb 24		 jmp	 SHORT $LN20@create_png
$LN18@create_png:
  00351	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00354	83 ea 01	 sub	 edx, 1
  00357	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0035a	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  0035d	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  00360	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  00363	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00366	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  00369	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  0036c	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  0036f	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  00372	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN20@create_png:
  00375	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00379	72 3e		 jb	 SHORT $LN19@create_png
  0037b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00382	eb 09		 jmp	 SHORT $LN23@create_png
$LN21@create_png:
  00384	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00387	83 c0 01	 add	 eax, 1
  0038a	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN23@create_png:
  0038d	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00390	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  00393	7d 22		 jge	 SHORT $LN22@create_png
  00395	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00398	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  0039b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0039e	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  003a1	2b 4d e8	 sub	 ecx, DWORD PTR _img_n$[ebp]
  003a4	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  003a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  003ab	03 c1		 add	 eax, ecx
  003ad	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  003b0	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  003b3	88 02		 mov	 BYTE PTR [edx], al
  003b5	eb cd		 jmp	 SHORT $LN21@create_png
$LN22@create_png:
  003b7	eb 98		 jmp	 SHORT $LN18@create_png
$LN19@create_png:
  003b9	e9 8f 02 00 00	 jmp	 $LN10@create_png
$LN119@create_png:

; 2253 :             CASE(F_up)    cur[k] = raw[k] + prior[k]; break;

  003be	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  003c1	83 e8 01	 sub	 eax, 1
  003c4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  003c7	eb 24		 jmp	 SHORT $LN26@create_png
$LN24@create_png:
  003c9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  003cc	83 e9 01	 sub	 ecx, 1
  003cf	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  003d2	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  003d5	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  003d8	89 55 0c	 mov	 DWORD PTR _raw$[ebp], edx
  003db	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  003de	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  003e1	89 45 e4	 mov	 DWORD PTR _cur$3[ebp], eax
  003e4	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  003e7	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  003ea	89 4d e0	 mov	 DWORD PTR _prior$2[ebp], ecx
$LN26@create_png:
  003ed	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  003f1	72 3a		 jb	 SHORT $LN25@create_png
  003f3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  003fa	eb 09		 jmp	 SHORT $LN29@create_png
$LN27@create_png:
  003fc	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  003ff	83 c2 01	 add	 edx, 1
  00402	89 55 ec	 mov	 DWORD PTR _k$[ebp], edx
$LN29@create_png:
  00405	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00408	3b 45 e8	 cmp	 eax, DWORD PTR _img_n$[ebp]
  0040b	7d 1e		 jge	 SHORT $LN28@create_png
  0040d	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  00410	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  00413	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00416	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  00419	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  0041c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0041f	03 d1		 add	 edx, ecx
  00421	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00424	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00427	88 10		 mov	 BYTE PTR [eax], dl
  00429	eb d1		 jmp	 SHORT $LN27@create_png
$LN28@create_png:
  0042b	eb 9c		 jmp	 SHORT $LN24@create_png
$LN25@create_png:
  0042d	e9 1b 02 00 00	 jmp	 $LN10@create_png
$LN120@create_png:

; 2254 :             CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;

  00432	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  00435	83 e9 01	 sub	 ecx, 1
  00438	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0043b	eb 24		 jmp	 SHORT $LN32@create_png
$LN30@create_png:
  0043d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00440	83 ea 01	 sub	 edx, 1
  00443	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00446	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  00449	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  0044c	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  0044f	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00452	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  00455	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  00458	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  0045b	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  0045e	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN32@create_png:
  00461	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00465	72 4b		 jb	 SHORT $LN31@create_png
  00467	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0046e	eb 09		 jmp	 SHORT $LN35@create_png
$LN33@create_png:
  00470	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00473	83 c0 01	 add	 eax, 1
  00476	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN35@create_png:
  00479	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  0047c	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  0047f	7d 2f		 jge	 SHORT $LN34@create_png
  00481	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00484	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00487	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0048a	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  0048d	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  00490	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00493	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00496	2b 4d e8	 sub	 ecx, DWORD PTR _img_n$[ebp]
  00499	8b 75 e4	 mov	 esi, DWORD PTR _cur$3[ebp]
  0049c	0f b6 0c 0e	 movzx	 ecx, BYTE PTR [esi+ecx]
  004a0	03 d1		 add	 edx, ecx
  004a2	d1 fa		 sar	 edx, 1
  004a4	03 c2		 add	 eax, edx
  004a6	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  004a9	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  004ac	88 02		 mov	 BYTE PTR [edx], al
  004ae	eb c0		 jmp	 SHORT $LN33@create_png
$LN34@create_png:
  004b0	eb 8b		 jmp	 SHORT $LN30@create_png
$LN31@create_png:
  004b2	e9 96 01 00 00	 jmp	 $LN10@create_png
$LN121@create_png:

; 2255 :             CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;

  004b7	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  004ba	83 e8 01	 sub	 eax, 1
  004bd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  004c0	eb 24		 jmp	 SHORT $LN38@create_png
$LN36@create_png:
  004c2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  004c5	83 e9 01	 sub	 ecx, 1
  004c8	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  004cb	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  004ce	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  004d1	89 55 0c	 mov	 DWORD PTR _raw$[ebp], edx
  004d4	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  004d7	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  004da	89 45 e4	 mov	 DWORD PTR _cur$3[ebp], eax
  004dd	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  004e0	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  004e3	89 4d e0	 mov	 DWORD PTR _prior$2[ebp], ecx
$LN38@create_png:
  004e6	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  004ea	72 62		 jb	 SHORT $LN37@create_png
  004ec	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  004f3	eb 09		 jmp	 SHORT $LN41@create_png
$LN39@create_png:
  004f5	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  004f8	83 c2 01	 add	 edx, 1
  004fb	89 55 ec	 mov	 DWORD PTR _k$[ebp], edx
$LN41@create_png:
  004fe	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00501	3b 45 e8	 cmp	 eax, DWORD PTR _img_n$[ebp]
  00504	7d 43		 jge	 SHORT $LN40@create_png
  00506	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  00509	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  0050c	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  0050f	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  00512	2b 55 e8	 sub	 edx, DWORD PTR _img_n$[ebp]
  00515	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  00518	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0051c	51		 push	 ecx
  0051d	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  00520	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00523	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00526	50		 push	 eax
  00527	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  0052a	2b 4d e8	 sub	 ecx, DWORD PTR _img_n$[ebp]
  0052d	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00530	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00534	50		 push	 eax
  00535	e8 00 00 00 00	 call	 ?paeth@@YAHHHH@Z	; paeth
  0053a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0053d	03 d8		 add	 ebx, eax
  0053f	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00542	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  00545	88 19		 mov	 BYTE PTR [ecx], bl
  00547	eb ac		 jmp	 SHORT $LN39@create_png
$LN40@create_png:
  00549	e9 74 ff ff ff	 jmp	 $LN36@create_png
$LN37@create_png:
  0054e	e9 fa 00 00 00	 jmp	 $LN10@create_png
$LN122@create_png:

; 2256 :             CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;

  00553	8b 55 18	 mov	 edx, DWORD PTR _x$[ebp]
  00556	83 ea 01	 sub	 edx, 1
  00559	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0055c	eb 24		 jmp	 SHORT $LN44@create_png
$LN42@create_png:
  0055e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00561	83 e8 01	 sub	 eax, 1
  00564	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00567	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  0056a	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  0056d	89 4d 0c	 mov	 DWORD PTR _raw$[ebp], ecx
  00570	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00573	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  00576	89 55 e4	 mov	 DWORD PTR _cur$3[ebp], edx
  00579	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  0057c	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  0057f	89 45 e0	 mov	 DWORD PTR _prior$2[ebp], eax
$LN44@create_png:
  00582	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00586	72 40		 jb	 SHORT $LN43@create_png
  00588	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0058f	eb 09		 jmp	 SHORT $LN47@create_png
$LN45@create_png:
  00591	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00594	83 c1 01	 add	 ecx, 1
  00597	89 4d ec	 mov	 DWORD PTR _k$[ebp], ecx
$LN47@create_png:
  0059a	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  0059d	3b 55 e8	 cmp	 edx, DWORD PTR _img_n$[ebp]
  005a0	7d 24		 jge	 SHORT $LN46@create_png
  005a2	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  005a5	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  005a8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  005ab	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  005ae	2b 55 e8	 sub	 edx, DWORD PTR _img_n$[ebp]
  005b1	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  005b4	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  005b8	d1 fa		 sar	 edx, 1
  005ba	03 ca		 add	 ecx, edx
  005bc	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  005bf	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  005c2	88 08		 mov	 BYTE PTR [eax], cl
  005c4	eb cb		 jmp	 SHORT $LN45@create_png
$LN46@create_png:
  005c6	eb 96		 jmp	 SHORT $LN42@create_png
$LN43@create_png:
  005c8	e9 80 00 00 00	 jmp	 $LN10@create_png
$LN123@create_png:

; 2257 :             CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;

  005cd	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  005d0	83 e9 01	 sub	 ecx, 1
  005d3	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  005d6	eb 24		 jmp	 SHORT $LN50@create_png
$LN48@create_png:
  005d8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  005db	83 ea 01	 sub	 edx, 1
  005de	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  005e1	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  005e4	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  005e7	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  005ea	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  005ed	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  005f0	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  005f3	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  005f6	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  005f9	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN50@create_png:
  005fc	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00600	72 4b		 jb	 SHORT $LN10@create_png
  00602	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00609	eb 09		 jmp	 SHORT $LN53@create_png
$LN51@create_png:
  0060b	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  0060e	83 c0 01	 add	 eax, 1
  00611	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN53@create_png:
  00614	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00617	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  0061a	7d 2f		 jge	 SHORT $LN52@create_png
  0061c	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  0061f	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00622	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  00625	6a 00		 push	 0
  00627	6a 00		 push	 0
  00629	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  0062c	2b 45 e8	 sub	 eax, DWORD PTR _img_n$[ebp]
  0062f	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00632	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00636	52		 push	 edx
  00637	e8 00 00 00 00	 call	 ?paeth@@YAHHHH@Z	; paeth
  0063c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0063f	03 d8		 add	 ebx, eax
  00641	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00644	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00647	88 18		 mov	 BYTE PTR [eax], bl
  00649	eb c0		 jmp	 SHORT $LN51@create_png
$LN52@create_png:
  0064b	eb 8b		 jmp	 SHORT $LN48@create_png
$LN10@create_png:

; 2258 :          }
; 2259 :          #undef CASE
; 2260 :       } else {

  0064d	e9 f4 03 00 00	 jmp	 $LN116@create_png
$LN115@create_png:

; 2261 :          assert(img_n+1 == out_n);

  00652	8b 4d e8	 mov	 ecx, DWORD PTR _img_n$[ebp]
  00655	83 c1 01	 add	 ecx, 1
  00658	3b 4d 14	 cmp	 ecx, DWORD PTR _out_n$[ebp]
  0065b	74 21		 je	 SHORT $LN133@create_png
  0065d	8b f4		 mov	 esi, esp
  0065f	68 d5 08 00 00	 push	 2261			; 000008d5H
  00664	68 00 00 00 00	 push	 OFFSET $SG4294820197
  00669	68 00 00 00 00	 push	 OFFSET $SG4294820196
  0066e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00674	83 c4 0c	 add	 esp, 12			; 0000000cH
  00677	3b f4		 cmp	 esi, esp
  00679	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN133@create_png:

; 2262 :          #define CASE(f) \
; 2263 :              case f:     \
; 2264 :                 for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
; 2265 :                    for (k=0; k < img_n; ++k)
; 2266 :          switch (filter) {

  0067e	8b 45 dc	 mov	 eax, DWORD PTR _filter$1[ebp]
  00681	89 45 d0	 mov	 DWORD PTR tv369[ebp], eax
  00684	83 7d d0 06	 cmp	 DWORD PTR tv369[ebp], 6
  00688	0f 87 b8 03 00
	00		 ja	 $LN116@create_png
  0068e	8b 4d d0	 mov	 ecx, DWORD PTR tv369[ebp]
  00691	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN136@create_png[ecx*4]
$LN124@create_png:

; 2267 :             CASE(F_none)  cur[k] = raw[k]; break;

  00698	8b 55 18	 mov	 edx, DWORD PTR _x$[ebp]
  0069b	83 ea 01	 sub	 edx, 1
  0069e	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  006a1	eb 2d		 jmp	 SHORT $LN58@create_png
$LN56@create_png:
  006a3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  006a6	83 e8 01	 sub	 eax, 1
  006a9	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  006ac	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  006af	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  006b2	c6 01 ff	 mov	 BYTE PTR [ecx], 255	; 000000ffH
  006b5	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  006b8	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  006bb	89 55 0c	 mov	 DWORD PTR _raw$[ebp], edx
  006be	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  006c1	03 45 14	 add	 eax, DWORD PTR _out_n$[ebp]
  006c4	89 45 e4	 mov	 DWORD PTR _cur$3[ebp], eax
  006c7	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  006ca	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  006cd	89 4d e0	 mov	 DWORD PTR _prior$2[ebp], ecx
$LN58@create_png:
  006d0	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  006d4	72 2e		 jb	 SHORT $LN57@create_png
  006d6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  006dd	eb 09		 jmp	 SHORT $LN61@create_png
$LN59@create_png:
  006df	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  006e2	83 c2 01	 add	 edx, 1
  006e5	89 55 ec	 mov	 DWORD PTR _k$[ebp], edx
$LN61@create_png:
  006e8	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  006eb	3b 45 e8	 cmp	 eax, DWORD PTR _img_n$[ebp]
  006ee	7d 12		 jge	 SHORT $LN60@create_png
  006f0	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  006f3	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  006f6	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  006f9	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  006fc	8a 02		 mov	 al, BYTE PTR [edx]
  006fe	88 01		 mov	 BYTE PTR [ecx], al
  00700	eb dd		 jmp	 SHORT $LN59@create_png
$LN60@create_png:
  00702	eb 9f		 jmp	 SHORT $LN56@create_png
$LN57@create_png:
  00704	e9 3d 03 00 00	 jmp	 $LN116@create_png
$LN125@create_png:

; 2268 :             CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;

  00709	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  0070c	83 e9 01	 sub	 ecx, 1
  0070f	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00712	eb 2d		 jmp	 SHORT $LN64@create_png
$LN62@create_png:
  00714	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00717	83 ea 01	 sub	 edx, 1
  0071a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0071d	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00720	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  00723	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  00726	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  00729	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  0072c	89 4d 0c	 mov	 DWORD PTR _raw$[ebp], ecx
  0072f	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00732	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  00735	89 55 e4	 mov	 DWORD PTR _cur$3[ebp], edx
  00738	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  0073b	03 45 14	 add	 eax, DWORD PTR _out_n$[ebp]
  0073e	89 45 e0	 mov	 DWORD PTR _prior$2[ebp], eax
$LN64@create_png:
  00741	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00745	72 3e		 jb	 SHORT $LN63@create_png
  00747	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0074e	eb 09		 jmp	 SHORT $LN67@create_png
$LN65@create_png:
  00750	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00753	83 c1 01	 add	 ecx, 1
  00756	89 4d ec	 mov	 DWORD PTR _k$[ebp], ecx
$LN67@create_png:
  00759	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  0075c	3b 55 e8	 cmp	 edx, DWORD PTR _img_n$[ebp]
  0075f	7d 22		 jge	 SHORT $LN66@create_png
  00761	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  00764	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00767	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0076a	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  0076d	2b 55 14	 sub	 edx, DWORD PTR _out_n$[ebp]
  00770	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00773	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00777	03 ca		 add	 ecx, edx
  00779	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  0077c	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  0077f	88 08		 mov	 BYTE PTR [eax], cl
  00781	eb cd		 jmp	 SHORT $LN65@create_png
$LN66@create_png:
  00783	eb 8f		 jmp	 SHORT $LN62@create_png
$LN63@create_png:
  00785	e9 bc 02 00 00	 jmp	 $LN116@create_png
$LN126@create_png:

; 2269 :             CASE(F_up)    cur[k] = raw[k] + prior[k]; break;

  0078a	8b 4d 18	 mov	 ecx, DWORD PTR _x$[ebp]
  0078d	83 e9 01	 sub	 ecx, 1
  00790	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00793	eb 2d		 jmp	 SHORT $LN70@create_png
$LN68@create_png:
  00795	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00798	83 ea 01	 sub	 edx, 1
  0079b	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0079e	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  007a1	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  007a4	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  007a7	8b 4d 0c	 mov	 ecx, DWORD PTR _raw$[ebp]
  007aa	03 4d e8	 add	 ecx, DWORD PTR _img_n$[ebp]
  007ad	89 4d 0c	 mov	 DWORD PTR _raw$[ebp], ecx
  007b0	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  007b3	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  007b6	89 55 e4	 mov	 DWORD PTR _cur$3[ebp], edx
  007b9	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  007bc	03 45 14	 add	 eax, DWORD PTR _out_n$[ebp]
  007bf	89 45 e0	 mov	 DWORD PTR _prior$2[ebp], eax
$LN70@create_png:
  007c2	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  007c6	72 3a		 jb	 SHORT $LN69@create_png
  007c8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  007cf	eb 09		 jmp	 SHORT $LN73@create_png
$LN71@create_png:
  007d1	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  007d4	83 c1 01	 add	 ecx, 1
  007d7	89 4d ec	 mov	 DWORD PTR _k$[ebp], ecx
$LN73@create_png:
  007da	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  007dd	3b 55 e8	 cmp	 edx, DWORD PTR _img_n$[ebp]
  007e0	7d 1e		 jge	 SHORT $LN72@create_png
  007e2	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  007e5	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  007e8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  007eb	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  007ee	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  007f1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  007f4	03 c8		 add	 ecx, eax
  007f6	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  007f9	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  007fc	88 0a		 mov	 BYTE PTR [edx], cl
  007fe	eb d1		 jmp	 SHORT $LN71@create_png
$LN72@create_png:
  00800	eb 93		 jmp	 SHORT $LN68@create_png
$LN69@create_png:
  00802	e9 3f 02 00 00	 jmp	 $LN116@create_png
$LN127@create_png:

; 2270 :             CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;

  00807	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  0080a	83 e8 01	 sub	 eax, 1
  0080d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00810	eb 2d		 jmp	 SHORT $LN76@create_png
$LN74@create_png:
  00812	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00815	83 e9 01	 sub	 ecx, 1
  00818	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0081b	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  0081e	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  00821	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
  00824	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  00827	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  0082a	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  0082d	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00830	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  00833	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  00836	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  00839	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  0083c	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN76@create_png:
  0083f	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00843	72 4b		 jb	 SHORT $LN75@create_png
  00845	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0084c	eb 09		 jmp	 SHORT $LN79@create_png
$LN77@create_png:
  0084e	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00851	83 c0 01	 add	 eax, 1
  00854	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN79@create_png:
  00857	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  0085a	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  0085d	7d 2f		 jge	 SHORT $LN78@create_png
  0085f	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00862	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00865	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00868	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  0086b	03 4d ec	 add	 ecx, DWORD PTR _k$[ebp]
  0086e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00871	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00874	2b 4d 14	 sub	 ecx, DWORD PTR _out_n$[ebp]
  00877	8b 75 e4	 mov	 esi, DWORD PTR _cur$3[ebp]
  0087a	0f b6 0c 0e	 movzx	 ecx, BYTE PTR [esi+ecx]
  0087e	03 d1		 add	 edx, ecx
  00880	d1 fa		 sar	 edx, 1
  00882	03 c2		 add	 eax, edx
  00884	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00887	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  0088a	88 02		 mov	 BYTE PTR [edx], al
  0088c	eb c0		 jmp	 SHORT $LN77@create_png
$LN78@create_png:
  0088e	eb 82		 jmp	 SHORT $LN74@create_png
$LN75@create_png:
  00890	e9 b1 01 00 00	 jmp	 $LN116@create_png
$LN128@create_png:

; 2271 :             CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;

  00895	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  00898	83 e8 01	 sub	 eax, 1
  0089b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0089e	eb 2d		 jmp	 SHORT $LN82@create_png
$LN80@create_png:
  008a0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  008a3	83 e9 01	 sub	 ecx, 1
  008a6	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  008a9	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  008ac	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  008af	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
  008b2	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  008b5	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  008b8	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  008bb	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  008be	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  008c1	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  008c4	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  008c7	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  008ca	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN82@create_png:
  008cd	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  008d1	72 62		 jb	 SHORT $LN81@create_png
  008d3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  008da	eb 09		 jmp	 SHORT $LN85@create_png
$LN83@create_png:
  008dc	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  008df	83 c0 01	 add	 eax, 1
  008e2	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN85@create_png:
  008e5	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  008e8	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  008eb	7d 43		 jge	 SHORT $LN84@create_png
  008ed	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  008f0	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  008f3	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  008f6	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  008f9	2b 45 14	 sub	 eax, DWORD PTR _out_n$[ebp]
  008fc	8b 4d e0	 mov	 ecx, DWORD PTR _prior$2[ebp]
  008ff	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00903	52		 push	 edx
  00904	8b 45 e0	 mov	 eax, DWORD PTR _prior$2[ebp]
  00907	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  0090a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0090d	51		 push	 ecx
  0090e	8b 55 ec	 mov	 edx, DWORD PTR _k$[ebp]
  00911	2b 55 14	 sub	 edx, DWORD PTR _out_n$[ebp]
  00914	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00917	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0091b	51		 push	 ecx
  0091c	e8 00 00 00 00	 call	 ?paeth@@YAHHHH@Z	; paeth
  00921	83 c4 0c	 add	 esp, 12			; 0000000cH
  00924	03 d8		 add	 ebx, eax
  00926	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00929	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  0092c	88 1a		 mov	 BYTE PTR [edx], bl
  0092e	eb ac		 jmp	 SHORT $LN83@create_png
$LN84@create_png:
  00930	e9 6b ff ff ff	 jmp	 $LN80@create_png
$LN81@create_png:
  00935	e9 0c 01 00 00	 jmp	 $LN116@create_png
$LN129@create_png:

; 2272 :             CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;

  0093a	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  0093d	83 e8 01	 sub	 eax, 1
  00940	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00943	eb 2d		 jmp	 SHORT $LN88@create_png
$LN86@create_png:
  00945	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00948	83 e9 01	 sub	 ecx, 1
  0094b	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0094e	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  00951	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  00954	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
  00957	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  0095a	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  0095d	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  00960	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00963	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  00966	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  00969	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  0096c	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  0096f	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN88@create_png:
  00972	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  00976	72 40		 jb	 SHORT $LN87@create_png
  00978	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  0097f	eb 09		 jmp	 SHORT $LN91@create_png
$LN89@create_png:
  00981	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00984	83 c0 01	 add	 eax, 1
  00987	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN91@create_png:
  0098a	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  0098d	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  00990	7d 24		 jge	 SHORT $LN90@create_png
  00992	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00995	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00998	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0099b	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  0099e	2b 4d 14	 sub	 ecx, DWORD PTR _out_n$[ebp]
  009a1	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  009a4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  009a8	d1 f9		 sar	 ecx, 1
  009aa	03 c1		 add	 eax, ecx
  009ac	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  009af	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  009b2	88 02		 mov	 BYTE PTR [edx], al
  009b4	eb cb		 jmp	 SHORT $LN89@create_png
$LN90@create_png:
  009b6	eb 8d		 jmp	 SHORT $LN86@create_png
$LN87@create_png:
  009b8	e9 89 00 00 00	 jmp	 $LN116@create_png
$LN130@create_png:

; 2273 :             CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;

  009bd	8b 45 18	 mov	 eax, DWORD PTR _x$[ebp]
  009c0	83 e8 01	 sub	 eax, 1
  009c3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  009c6	eb 2d		 jmp	 SHORT $LN94@create_png
$LN92@create_png:
  009c8	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  009cb	83 e9 01	 sub	 ecx, 1
  009ce	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  009d1	8b 55 e4	 mov	 edx, DWORD PTR _cur$3[ebp]
  009d4	03 55 e8	 add	 edx, DWORD PTR _img_n$[ebp]
  009d7	c6 02 ff	 mov	 BYTE PTR [edx], 255	; 000000ffH
  009da	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  009dd	03 45 e8	 add	 eax, DWORD PTR _img_n$[ebp]
  009e0	89 45 0c	 mov	 DWORD PTR _raw$[ebp], eax
  009e3	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  009e6	03 4d 14	 add	 ecx, DWORD PTR _out_n$[ebp]
  009e9	89 4d e4	 mov	 DWORD PTR _cur$3[ebp], ecx
  009ec	8b 55 e0	 mov	 edx, DWORD PTR _prior$2[ebp]
  009ef	03 55 14	 add	 edx, DWORD PTR _out_n$[ebp]
  009f2	89 55 e0	 mov	 DWORD PTR _prior$2[ebp], edx
$LN94@create_png:
  009f5	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  009f9	72 4b		 jb	 SHORT $LN116@create_png
  009fb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00a02	eb 09		 jmp	 SHORT $LN97@create_png
$LN95@create_png:
  00a04	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00a07	83 c0 01	 add	 eax, 1
  00a0a	89 45 ec	 mov	 DWORD PTR _k$[ebp], eax
$LN97@create_png:
  00a0d	8b 4d ec	 mov	 ecx, DWORD PTR _k$[ebp]
  00a10	3b 4d e8	 cmp	 ecx, DWORD PTR _img_n$[ebp]
  00a13	7d 2f		 jge	 SHORT $LN96@create_png
  00a15	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00a18	03 55 ec	 add	 edx, DWORD PTR _k$[ebp]
  00a1b	0f b6 1a	 movzx	 ebx, BYTE PTR [edx]
  00a1e	6a 00		 push	 0
  00a20	6a 00		 push	 0
  00a22	8b 45 ec	 mov	 eax, DWORD PTR _k$[ebp]
  00a25	2b 45 14	 sub	 eax, DWORD PTR _out_n$[ebp]
  00a28	8b 4d e4	 mov	 ecx, DWORD PTR _cur$3[ebp]
  00a2b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00a2f	52		 push	 edx
  00a30	e8 00 00 00 00	 call	 ?paeth@@YAHHHH@Z	; paeth
  00a35	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a38	03 d8		 add	 ebx, eax
  00a3a	8b 45 e4	 mov	 eax, DWORD PTR _cur$3[ebp]
  00a3d	03 45 ec	 add	 eax, DWORD PTR _k$[ebp]
  00a40	88 18		 mov	 BYTE PTR [eax], bl
  00a42	eb c0		 jmp	 SHORT $LN95@create_png
$LN96@create_png:
  00a44	eb 82		 jmp	 SHORT $LN92@create_png
$LN116@create_png:

; 2274 :          }
; 2275 :          #undef CASE
; 2276 :       }
; 2277 :    }

  00a46	e9 e4 f6 ff ff	 jmp	 $LN2@create_png
$LN3@create_png:

; 2278 :    return 1;

  00a4b	b8 01 00 00 00	 mov	 eax, 1
$LN1@create_png:

; 2279 : }

  00a50	5f		 pop	 edi
  00a51	5e		 pop	 esi
  00a52	5b		 pop	 ebx
  00a53	83 c4 30	 add	 esp, 48			; 00000030H
  00a56	3b ec		 cmp	 ebp, esp
  00a58	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a5d	8b e5		 mov	 esp, ebp
  00a5f	5d		 pop	 ebp
  00a60	c3		 ret	 0
  00a61	0f 1f 00	 npad	 3
$LN134@create_png:
  00a64	00 00 00 00	 DD	 $LN107@create_png
  00a68	00 00 00 00	 DD	 $LN108@create_png
  00a6c	00 00 00 00	 DD	 $LN109@create_png
  00a70	00 00 00 00	 DD	 $LN110@create_png
  00a74	00 00 00 00	 DD	 $LN111@create_png
  00a78	00 00 00 00	 DD	 $LN112@create_png
  00a7c	00 00 00 00	 DD	 $LN113@create_png
$LN135@create_png:
  00a80	00 00 00 00	 DD	 $LN117@create_png
  00a84	00 00 00 00	 DD	 $LN118@create_png
  00a88	00 00 00 00	 DD	 $LN119@create_png
  00a8c	00 00 00 00	 DD	 $LN120@create_png
  00a90	00 00 00 00	 DD	 $LN121@create_png
  00a94	00 00 00 00	 DD	 $LN122@create_png
  00a98	00 00 00 00	 DD	 $LN123@create_png
$LN136@create_png:
  00a9c	00 00 00 00	 DD	 $LN124@create_png
  00aa0	00 00 00 00	 DD	 $LN125@create_png
  00aa4	00 00 00 00	 DD	 $LN126@create_png
  00aa8	00 00 00 00	 DD	 $LN127@create_png
  00aac	00 00 00 00	 DD	 $LN128@create_png
  00ab0	00 00 00 00	 DD	 $LN129@create_png
  00ab4	00 00 00 00	 DD	 $LN130@create_png
?create_png_image_raw@@YAHPAUpng@@PAEIHII@Z ENDP	; create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_y$1 = -176						; size = 4
_x$2 = -172						; size = 4
_j$3 = -168						; size = 4
_i$4 = -164						; size = 4
_yspc$5 = -156						; size = 28
_xspc$6 = -120						; size = 28
_yorig$7 = -84						; size = 28
_xorig$8 = -48						; size = 28
_save$ = -16						; size = 4
_p$ = -12						; size = 4
_final$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_raw$ = 12						; size = 4
_raw_len$ = 16						; size = 4
_out_n$ = 20						; size = 4
_interlaced$ = 24					; size = 4
?create_png_image@@YAHPAUpng@@PAEIHH@Z PROC		; create_png_image

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-176]
  00011	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2283 :    uint8 *final;
; 2284 :    int p;
; 2285 :    int save;
; 2286 :    if (!interlaced)

  00027	83 7d 18 00	 cmp	 DWORD PTR _interlaced$[ebp], 0
  0002b	75 2e		 jne	 SHORT $LN11@create_png

; 2287 :       return create_png_image_raw(a, raw, raw_len, out_n, a->s->img_x, a->s->img_y);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	52		 push	 edx
  0003e	8b 45 14	 mov	 eax, DWORD PTR _out_n$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _raw_len$[ebp]
  00045	51		 push	 ecx
  00046	8b 55 0c	 mov	 edx, DWORD PTR _raw$[ebp]
  00049	52		 push	 edx
  0004a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?create_png_image_raw@@YAHPAUpng@@PAEIHII@Z ; create_png_image_raw
  00053	83 c4 18	 add	 esp, 24			; 00000018H
  00056	e9 2b 03 00 00	 jmp	 $LN1@create_png
$LN11@create_png:

; 2288 :    save = stbi_png_partial;

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stbi_png_partial@@3HA ; stbi_png_partial
  00061	89 4d f0	 mov	 DWORD PTR _save$[ebp], ecx

; 2289 :    stbi_png_partial = 0;

  00064	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?stbi_png_partial@@3HA, 0 ; stbi_png_partial

; 2290 : 
; 2291 :    // de-interlacing
; 2292 :    final = (uint8 *) malloc(a->s->img_x * a->s->img_y * out_n);

  0006e	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00071	8b 02		 mov	 eax, DWORD PTR [edx]
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00076	8b 11		 mov	 edx, DWORD PTR [ecx]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0007e	0f af 45 14	 imul	 eax, DWORD PTR _out_n$[ebp]
  00082	8b f4		 mov	 esi, esp
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0008b	83 c4 04	 add	 esp, 4
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	89 45 f8	 mov	 DWORD PTR _final$[ebp], eax

; 2293 :    for (p=0; p < 7; ++p) {

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN4@create_png
$LN2@create_png:
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  000a4	83 c1 01	 add	 ecx, 1
  000a7	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx
$LN4@create_png:
  000aa	83 7d f4 07	 cmp	 DWORD PTR _p$[ebp], 7
  000ae	0f 8d bc 02 00
	00		 jge	 $LN3@create_png

; 2294 :       int xorig[] = { 0,4,0,2,0,1,0 };

  000b4	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp], 0
  000bb	c7 45 d4 04 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+4], 4
  000c2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+8], 0
  000c9	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+12], 2
  000d0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+16], 0
  000d7	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+20], 1
  000de	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _xorig$8[ebp+24], 0

; 2295 :       int yorig[] = { 0,0,4,0,2,0,1 };

  000e5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp], 0
  000ec	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+4], 0
  000f3	c7 45 b4 04 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+8], 4
  000fa	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+12], 0
  00101	c7 45 bc 02 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+16], 2
  00108	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+20], 0
  0010f	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _yorig$7[ebp+24], 1

; 2296 :       int xspc[]  = { 8,8,4,4,2,2,1 };

  00116	c7 45 88 08 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp], 8
  0011d	c7 45 8c 08 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+4], 8
  00124	c7 45 90 04 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+8], 4
  0012b	c7 45 94 04 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+12], 4
  00132	c7 45 98 02 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+16], 2
  00139	c7 45 9c 02 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+20], 2
  00140	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR _xspc$6[ebp+24], 1

; 2297 :       int yspc[]  = { 8,8,8,4,4,2,2 };

  00147	c7 85 64 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _yspc$5[ebp], 8
  00151	c7 85 68 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+4], 8
  0015b	c7 85 6c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+8], 8
  00165	c7 85 70 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+12], 4
  0016f	c7 85 74 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+16], 4
  00179	c7 85 78 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+20], 2
  00183	c7 85 7c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _yspc$5[ebp+24], 2

; 2298 :       int i,j,x,y;
; 2299 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 2300 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

  0018d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00190	8b 02		 mov	 eax, DWORD PTR [edx]
  00192	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00195	8b 10		 mov	 edx, DWORD PTR [eax]
  00197	2b 54 8d d0	 sub	 edx, DWORD PTR _xorig$8[ebp+ecx*4]
  0019b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0019e	8b 4c 85 88	 mov	 ecx, DWORD PTR _xspc$6[ebp+eax*4]
  001a2	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  001a6	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001a9	33 d2		 xor	 edx, edx
  001ab	f7 74 8d 88	 div	 DWORD PTR _xspc$6[ebp+ecx*4]
  001af	89 85 54 ff ff
	ff		 mov	 DWORD PTR _x$2[ebp], eax

; 2301 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

  001b5	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001b8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001bd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c0	2b 54 8d ac	 sub	 edx, DWORD PTR _yorig$7[ebp+ecx*4]
  001c4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001c7	8b 8c 85 64 ff
	ff ff		 mov	 ecx, DWORD PTR _yspc$5[ebp+eax*4]
  001ce	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  001d2	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  001d5	33 d2		 xor	 edx, edx
  001d7	f7 b4 8d 64 ff
	ff ff		 div	 DWORD PTR _yspc$5[ebp+ecx*4]
  001de	89 85 50 ff ff
	ff		 mov	 DWORD PTR _y$1[ebp], eax

; 2302 :       if (x && y) {

  001e4	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR _x$2[ebp], 0
  001eb	0f 84 7a 01 00
	00		 je	 $LN12@create_png
  001f1	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _y$1[ebp], 0
  001f8	0f 84 6d 01 00
	00		 je	 $LN12@create_png

; 2303 :          if (!create_png_image_raw(a, raw, raw_len, out_n, x, y)) {

  001fe	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _y$1[ebp]
  00204	52		 push	 edx
  00205	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _x$2[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 14	 mov	 ecx, DWORD PTR _out_n$[ebp]
  0020f	51		 push	 ecx
  00210	8b 55 10	 mov	 edx, DWORD PTR _raw_len$[ebp]
  00213	52		 push	 edx
  00214	8b 45 0c	 mov	 eax, DWORD PTR _raw$[ebp]
  00217	50		 push	 eax
  00218	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0021b	51		 push	 ecx
  0021c	e8 00 00 00 00	 call	 ?create_png_image_raw@@YAHPAUpng@@PAEIHII@Z ; create_png_image_raw
  00221	83 c4 18	 add	 esp, 24			; 00000018H
  00224	85 c0		 test	 eax, eax
  00226	75 1d		 jne	 SHORT $LN13@create_png

; 2304 :             free(final);

  00228	8b f4		 mov	 esi, esp
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _final$[ebp]
  0022d	52		 push	 edx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00234	83 c4 04	 add	 esp, 4
  00237	3b f4		 cmp	 esi, esp
  00239	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2305 :             return 0;

  0023e	33 c0		 xor	 eax, eax
  00240	e9 41 01 00 00	 jmp	 $LN1@create_png
$LN13@create_png:

; 2306 :          }
; 2307 :          for (j=0; j < y; ++j)

  00245	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$3[ebp], 0
  0024f	eb 0f		 jmp	 SHORT $LN7@create_png
$LN5@create_png:
  00251	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _j$3[ebp]
  00257	83 c0 01	 add	 eax, 1
  0025a	89 85 58 ff ff
	ff		 mov	 DWORD PTR _j$3[ebp], eax
$LN7@create_png:
  00260	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _j$3[ebp]
  00266	3b 8d 50 ff ff
	ff		 cmp	 ecx, DWORD PTR _y$1[ebp]
  0026c	0f 8d aa 00 00
	00		 jge	 $LN6@create_png

; 2308 :             for (i=0; i < x; ++i)

  00272	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$4[ebp], 0
  0027c	eb 0f		 jmp	 SHORT $LN10@create_png
$LN8@create_png:
  0027e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _i$4[ebp]
  00284	83 c2 01	 add	 edx, 1
  00287	89 95 5c ff ff
	ff		 mov	 DWORD PTR _i$4[ebp], edx
$LN10@create_png:
  0028d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _i$4[ebp]
  00293	3b 85 54 ff ff
	ff		 cmp	 eax, DWORD PTR _x$2[ebp]
  00299	7d 7c		 jge	 SHORT $LN9@create_png

; 2309 :                memcpy(final + (j*yspc[p]+yorig[p])*a->s->img_x*out_n + (i*xspc[p]+xorig[p])*out_n,

  0029b	8b f4		 mov	 esi, esp
  0029d	8b 4d 14	 mov	 ecx, DWORD PTR _out_n$[ebp]
  002a0	51		 push	 ecx
  002a1	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _j$3[ebp]
  002a7	0f af 95 54 ff
	ff ff		 imul	 edx, DWORD PTR _x$2[ebp]
  002ae	03 95 5c ff ff
	ff		 add	 edx, DWORD PTR _i$4[ebp]
  002b4	0f af 55 14	 imul	 edx, DWORD PTR _out_n$[ebp]
  002b8	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002bb	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  002be	52		 push	 edx
  002bf	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  002c2	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _j$3[ebp]
  002c8	0f af 94 8d 64
	ff ff ff	 imul	 edx, DWORD PTR _yspc$5[ebp+ecx*4]
  002d0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002d3	03 54 85 ac	 add	 edx, DWORD PTR _yorig$7[ebp+eax*4]
  002d7	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  002da	8b 01		 mov	 eax, DWORD PTR [ecx]
  002dc	0f af 10	 imul	 edx, DWORD PTR [eax]
  002df	0f af 55 14	 imul	 edx, DWORD PTR _out_n$[ebp]
  002e3	03 55 f8	 add	 edx, DWORD PTR _final$[ebp]
  002e6	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  002e9	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _i$4[ebp]
  002ef	0f af 44 8d 88	 imul	 eax, DWORD PTR _xspc$6[ebp+ecx*4]
  002f4	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  002f7	03 44 8d d0	 add	 eax, DWORD PTR _xorig$8[ebp+ecx*4]
  002fb	0f af 45 14	 imul	 eax, DWORD PTR _out_n$[ebp]
  002ff	03 d0		 add	 edx, eax
  00301	52		 push	 edx
  00302	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030b	3b f4		 cmp	 esi, esp
  0030d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00312	e9 67 ff ff ff	 jmp	 $LN8@create_png
$LN9@create_png:

; 2310 :                       a->out + (j*x+i)*out_n, out_n);

  00317	e9 35 ff ff ff	 jmp	 $LN5@create_png
$LN6@create_png:

; 2311 :          free(a->out);

  0031c	8b f4		 mov	 esi, esp
  0031e	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00321	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0032b	83 c4 04	 add	 esp, 4
  0032e	3b f4		 cmp	 esi, esp
  00330	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2312 :          raw += (x*out_n+1)*y;

  00335	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _x$2[ebp]
  0033b	0f af 4d 14	 imul	 ecx, DWORD PTR _out_n$[ebp]
  0033f	83 c1 01	 add	 ecx, 1
  00342	0f af 8d 50 ff
	ff ff		 imul	 ecx, DWORD PTR _y$1[ebp]
  00349	03 4d 0c	 add	 ecx, DWORD PTR _raw$[ebp]
  0034c	89 4d 0c	 mov	 DWORD PTR _raw$[ebp], ecx

; 2313 :          raw_len -= (x*out_n+1)*y;

  0034f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _x$2[ebp]
  00355	0f af 55 14	 imul	 edx, DWORD PTR _out_n$[ebp]
  00359	83 c2 01	 add	 edx, 1
  0035c	0f af 95 50 ff
	ff ff		 imul	 edx, DWORD PTR _y$1[ebp]
  00363	8b 45 10	 mov	 eax, DWORD PTR _raw_len$[ebp]
  00366	2b c2		 sub	 eax, edx
  00368	89 45 10	 mov	 DWORD PTR _raw_len$[ebp], eax
$LN12@create_png:

; 2314 :       }
; 2315 :    }

  0036b	e9 31 fd ff ff	 jmp	 $LN2@create_png
$LN3@create_png:

; 2316 :    a->out = final;

  00370	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00373	8b 55 f8	 mov	 edx, DWORD PTR _final$[ebp]
  00376	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 2317 : 
; 2318 :    stbi_png_partial = save;

  00379	8b 45 f0	 mov	 eax, DWORD PTR _save$[ebp]
  0037c	a3 00 00 00 00	 mov	 DWORD PTR ?stbi_png_partial@@3HA, eax ; stbi_png_partial

; 2319 :    return 1;

  00381	b8 01 00 00 00	 mov	 eax, 1
$LN1@create_png:

; 2320 : }

  00386	52		 push	 edx
  00387	8b cd		 mov	 ecx, ebp
  00389	50		 push	 eax
  0038a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@create_png
  00390	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00395	58		 pop	 eax
  00396	5a		 pop	 edx
  00397	5f		 pop	 edi
  00398	5e		 pop	 esi
  00399	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039c	33 cd		 xor	 ecx, ebp
  0039e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a3	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  003a9	3b ec		 cmp	 ebp, esp
  003ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003b0	8b e5		 mov	 esp, ebp
  003b2	5d		 pop	 ebp
  003b3	c3		 ret	 0
$LN20@create_png:
  003b4	04 00 00 00	 DD	 4
  003b8	00 00 00 00	 DD	 $LN19@create_png
$LN19@create_png:
  003bc	d0 ff ff ff	 DD	 -48			; ffffffd0H
  003c0	1c 00 00 00	 DD	 28			; 0000001cH
  003c4	00 00 00 00	 DD	 $LN15@create_png
  003c8	ac ff ff ff	 DD	 -84			; ffffffacH
  003cc	1c 00 00 00	 DD	 28			; 0000001cH
  003d0	00 00 00 00	 DD	 $LN16@create_png
  003d4	88 ff ff ff	 DD	 -120			; ffffff88H
  003d8	1c 00 00 00	 DD	 28			; 0000001cH
  003dc	00 00 00 00	 DD	 $LN17@create_png
  003e0	64 ff ff ff	 DD	 -156			; ffffff64H
  003e4	1c 00 00 00	 DD	 28			; 0000001cH
  003e8	00 00 00 00	 DD	 $LN18@create_png
$LN18@create_png:
  003ec	79		 DB	 121			; 00000079H
  003ed	73		 DB	 115			; 00000073H
  003ee	70		 DB	 112			; 00000070H
  003ef	63		 DB	 99			; 00000063H
  003f0	00		 DB	 0
$LN17@create_png:
  003f1	78		 DB	 120			; 00000078H
  003f2	73		 DB	 115			; 00000073H
  003f3	70		 DB	 112			; 00000070H
  003f4	63		 DB	 99			; 00000063H
  003f5	00		 DB	 0
$LN16@create_png:
  003f6	79		 DB	 121			; 00000079H
  003f7	6f		 DB	 111			; 0000006fH
  003f8	72		 DB	 114			; 00000072H
  003f9	69		 DB	 105			; 00000069H
  003fa	67		 DB	 103			; 00000067H
  003fb	00		 DB	 0
$LN15@create_png:
  003fc	78		 DB	 120			; 00000078H
  003fd	6f		 DB	 111			; 0000006fH
  003fe	72		 DB	 114			; 00000072H
  003ff	69		 DB	 105			; 00000069H
  00400	67		 DB	 103			; 00000067H
  00401	00		 DB	 0
?create_png_image@@YAHPAUpng@@PAEIHH@Z ENDP		; create_png_image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv87 = -20						; size = 4
_p$ = -16						; size = 4
_pixel_count$ = -12					; size = 4
_i$ = -8						; size = 4
_s$ = -4						; size = 4
_z$ = 8							; size = 4
_tc$ = 12						; size = 4
_out_n$ = 16						; size = 4
?compute_transparency@@YAHPAUpng@@QAEH@Z PROC		; compute_transparency

; 2323 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2324 :    stbi *s = z->s;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 2325 :    uint32 i, pixel_count = s->img_x * s->img_y;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00026	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0002f	89 4d f4	 mov	 DWORD PTR _pixel_count$[ebp], ecx

; 2326 :    uint8 *p = z->out;

  00032	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2327 : 
; 2328 :    // compute color-based transparency, assuming we've
; 2329 :    // already got 255 as the alpha value in the output
; 2330 :    assert(out_n == 2 || out_n == 4);

  0003b	83 7d 10 02	 cmp	 DWORD PTR _out_n$[ebp], 2
  0003f	74 27		 je	 SHORT $LN12@compute_tr
  00041	83 7d 10 04	 cmp	 DWORD PTR _out_n$[ebp], 4
  00045	74 21		 je	 SHORT $LN12@compute_tr
  00047	8b f4		 mov	 esi, esp
  00049	68 1a 09 00 00	 push	 2330			; 0000091aH
  0004e	68 00 00 00 00	 push	 OFFSET $SG4294820195
  00053	68 00 00 00 00	 push	 OFFSET $SG4294820194
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@compute_tr:

; 2331 : 
; 2332 :    if (out_n == 2) {

  00068	83 7d 10 02	 cmp	 DWORD PTR _out_n$[ebp], 2
  0006c	75 6d		 jne	 SHORT $LN8@compute_tr

; 2333 :       for (i=0; i < pixel_count; ++i) {

  0006e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00075	eb 09		 jmp	 SHORT $LN4@compute_tr
$LN2@compute_tr:
  00077	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0007a	83 c2 01	 add	 edx, 1
  0007d	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@compute_tr:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00083	3b 45 f4	 cmp	 eax, DWORD PTR _pixel_count$[ebp]
  00086	73 4e		 jae	 SHORT $LN3@compute_tr

; 2334 :          p[1] = (p[0] == tc[0] ? 0 : 255);

  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	6b d1 00	 imul	 edx, ecx, 0
  00090	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00093	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00097	ba 01 00 00 00	 mov	 edx, 1
  0009c	6b c2 00	 imul	 eax, edx, 0
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _tc$[ebp]
  000a2	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  000a6	3b c8		 cmp	 ecx, eax
  000a8	75 09		 jne	 SHORT $LN13@compute_tr
  000aa	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  000b1	eb 07		 jmp	 SHORT $LN14@compute_tr
$LN13@compute_tr:
  000b3	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR tv87[ebp], 255 ; 000000ffH
$LN14@compute_tr:
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	c1 e1 00	 shl	 ecx, 0
  000c2	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  000c5	8a 45 ec	 mov	 al, BYTE PTR tv87[ebp]
  000c8	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2335 :          p += 2;

  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  000ce	83 c1 02	 add	 ecx, 2
  000d1	89 4d f0	 mov	 DWORD PTR _p$[ebp], ecx

; 2336 :       }

  000d4	eb a1		 jmp	 SHORT $LN2@compute_tr
$LN3@compute_tr:

; 2337 :    } else {

  000d6	e9 9f 00 00 00	 jmp	 $LN9@compute_tr
$LN8@compute_tr:

; 2338 :       for (i=0; i < pixel_count; ++i) {

  000db	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e2	eb 09		 jmp	 SHORT $LN7@compute_tr
$LN5@compute_tr:
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000e7	83 c2 01	 add	 edx, 1
  000ea	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN7@compute_tr:
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f0	3b 45 f4	 cmp	 eax, DWORD PTR _pixel_count$[ebp]
  000f3	0f 83 81 00 00
	00		 jae	 $LN9@compute_tr

; 2339 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	6b d1 00	 imul	 edx, ecx, 0
  00101	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00104	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00108	ba 01 00 00 00	 mov	 edx, 1
  0010d	6b c2 00	 imul	 eax, edx, 0
  00110	8b 55 0c	 mov	 edx, DWORD PTR _tc$[ebp]
  00113	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00117	3b c8		 cmp	 ecx, eax
  00119	75 51		 jne	 SHORT $LN10@compute_tr
  0011b	b9 01 00 00 00	 mov	 ecx, 1
  00120	c1 e1 00	 shl	 ecx, 0
  00123	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00126	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	c1 e1 00	 shl	 ecx, 0
  00132	8b 55 0c	 mov	 edx, DWORD PTR _tc$[ebp]
  00135	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00139	3b c1		 cmp	 eax, ecx
  0013b	75 2f		 jne	 SHORT $LN10@compute_tr
  0013d	ba 01 00 00 00	 mov	 edx, 1
  00142	d1 e2		 shl	 edx, 1
  00144	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00147	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0014b	ba 01 00 00 00	 mov	 edx, 1
  00150	d1 e2		 shl	 edx, 1
  00152	8b 45 0c	 mov	 eax, DWORD PTR _tc$[ebp]
  00155	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00159	3b ca		 cmp	 ecx, edx
  0015b	75 0f		 jne	 SHORT $LN10@compute_tr

; 2340 :             p[3] = 0;

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	6b c8 03	 imul	 ecx, eax, 3
  00165	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00168	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
$LN10@compute_tr:

; 2341 :          p += 4;

  0016c	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0016f	83 c0 04	 add	 eax, 4
  00172	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2342 :       }

  00175	e9 6a ff ff ff	 jmp	 $LN5@compute_tr
$LN9@compute_tr:

; 2343 :    }
; 2344 :    return 1;

  0017a	b8 01 00 00 00	 mov	 eax, 1

; 2345 : }

  0017f	5e		 pop	 esi
  00180	83 c4 14	 add	 esp, 20			; 00000014H
  00183	3b ec		 cmp	 ebp, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?compute_transparency@@YAHPAUpng@@QAEH@Z ENDP		; compute_transparency
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_n$1 = -28						; size = 4
_n$2 = -24						; size = 4
_orig$ = -20						; size = 4
_temp_out$ = -16					; size = 4
_p$ = -12						; size = 4
_pixel_count$ = -8					; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_palette$ = 12						; size = 4
_len$ = 16						; size = 4
_pal_img_n$ = 20					; size = 4
?expand_palette@@YAHPAUpng@@PAEHH@Z PROC		; expand_palette

; 2348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2349 :    uint32 i, pixel_count = a->s->img_x * a->s->img_y;

  00021	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002d	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  00031	89 4d f8	 mov	 DWORD PTR _pixel_count$[ebp], ecx

; 2350 :    uint8 *p, *temp_out, *orig = a->out;

  00034	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00037	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003a	89 45 ec	 mov	 DWORD PTR _orig$[ebp], eax

; 2351 : 
; 2352 :    p = (uint8 *) malloc(pixel_count * pal_img_n);

  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _pixel_count$[ebp]
  00040	0f af 4d 14	 imul	 ecx, DWORD PTR _pal_img_n$[ebp]
  00044	8b f4		 mov	 esi, esp
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 2353 :    if (p == NULL) return e("outofmem", "Out of memory");

  0005a	83 7d f4 00	 cmp	 DWORD PTR _p$[ebp], 0
  0005e	75 12		 jne	 SHORT $LN8@expand_pal
  00060	68 00 00 00 00	 push	 OFFSET $SG4294820193
  00065	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006a	83 c4 04	 add	 esp, 4
  0006d	e9 40 01 00 00	 jmp	 $LN1@expand_pal
$LN8@expand_pal:

; 2354 : 
; 2355 :    // between here and free(out) below, exitting would leak
; 2356 :    temp_out = p;

  00072	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00075	89 55 f0	 mov	 DWORD PTR _temp_out$[ebp], edx

; 2357 : 
; 2358 :    if (pal_img_n == 3) {

  00078	83 7d 14 03	 cmp	 DWORD PTR _pal_img_n$[ebp], 3
  0007c	75 7c		 jne	 SHORT $LN9@expand_pal

; 2359 :       for (i=0; i < pixel_count; ++i) {

  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN4@expand_pal
$LN2@expand_pal:
  00087	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@expand_pal:
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	3b 4d f8	 cmp	 ecx, DWORD PTR _pixel_count$[ebp]
  00096	73 5d		 jae	 SHORT $LN3@expand_pal

; 2360 :          int n = orig[i]*4;

  00098	8b 55 ec	 mov	 edx, DWORD PTR _orig$[ebp]
  0009b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0009e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000a1	c1 e0 02	 shl	 eax, 2
  000a4	89 45 e8	 mov	 DWORD PTR _n$2[ebp], eax

; 2361 :          p[0] = palette[n  ];

  000a7	b9 01 00 00 00	 mov	 ecx, 1
  000ac	6b d1 00	 imul	 edx, ecx, 0
  000af	8b 45 0c	 mov	 eax, DWORD PTR _palette$[ebp]
  000b2	03 45 e8	 add	 eax, DWORD PTR _n$2[ebp]
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  000b8	8a 00		 mov	 al, BYTE PTR [eax]
  000ba	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 2362 :          p[1] = palette[n+1];

  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	c1 e1 00	 shl	 ecx, 0
  000c5	8b 55 0c	 mov	 edx, DWORD PTR _palette$[ebp]
  000c8	03 55 e8	 add	 edx, DWORD PTR _n$2[ebp]
  000cb	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000ce	8a 52 01	 mov	 dl, BYTE PTR [edx+1]
  000d1	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2363 :          p[2] = palette[n+2];

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	d1 e0		 shl	 eax, 1
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _palette$[ebp]
  000de	03 4d e8	 add	 ecx, DWORD PTR _n$2[ebp]
  000e1	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  000e4	8a 49 02	 mov	 cl, BYTE PTR [ecx+2]
  000e7	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2364 :          p += 3;

  000ea	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  000ed	83 c2 03	 add	 edx, 3
  000f0	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 2365 :       }

  000f3	eb 92		 jmp	 SHORT $LN2@expand_pal
$LN3@expand_pal:

; 2366 :    } else {

  000f5	e9 91 00 00 00	 jmp	 $LN10@expand_pal
$LN9@expand_pal:

; 2367 :       for (i=0; i < pixel_count; ++i) {

  000fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00101	eb 09		 jmp	 SHORT $LN7@expand_pal
$LN5@expand_pal:
  00103	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00106	83 c0 01	 add	 eax, 1
  00109	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@expand_pal:
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010f	3b 4d f8	 cmp	 ecx, DWORD PTR _pixel_count$[ebp]
  00112	73 77		 jae	 SHORT $LN10@expand_pal

; 2368 :          int n = orig[i]*4;

  00114	8b 55 ec	 mov	 edx, DWORD PTR _orig$[ebp]
  00117	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0011a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0011d	c1 e0 02	 shl	 eax, 2
  00120	89 45 e4	 mov	 DWORD PTR _n$1[ebp], eax

; 2369 :          p[0] = palette[n  ];

  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	6b d1 00	 imul	 edx, ecx, 0
  0012b	8b 45 0c	 mov	 eax, DWORD PTR _palette$[ebp]
  0012e	03 45 e4	 add	 eax, DWORD PTR _n$1[ebp]
  00131	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00134	8a 00		 mov	 al, BYTE PTR [eax]
  00136	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 2370 :          p[1] = palette[n+1];

  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	c1 e1 00	 shl	 ecx, 0
  00141	8b 55 0c	 mov	 edx, DWORD PTR _palette$[ebp]
  00144	03 55 e4	 add	 edx, DWORD PTR _n$1[ebp]
  00147	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0014a	8a 52 01	 mov	 dl, BYTE PTR [edx+1]
  0014d	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2371 :          p[2] = palette[n+2];

  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	d1 e0		 shl	 eax, 1
  00157	8b 4d 0c	 mov	 ecx, DWORD PTR _palette$[ebp]
  0015a	03 4d e4	 add	 ecx, DWORD PTR _n$1[ebp]
  0015d	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00160	8a 49 02	 mov	 cl, BYTE PTR [ecx+2]
  00163	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2372 :          p[3] = palette[n+3];

  00166	ba 01 00 00 00	 mov	 edx, 1
  0016b	6b c2 03	 imul	 eax, edx, 3
  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR _palette$[ebp]
  00171	03 4d e4	 add	 ecx, DWORD PTR _n$1[ebp]
  00174	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00177	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  0017a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2373 :          p += 4;

  0017d	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00180	83 c2 04	 add	 edx, 4
  00183	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 2374 :       }

  00186	e9 78 ff ff ff	 jmp	 $LN5@expand_pal
$LN10@expand_pal:

; 2375 :    }
; 2376 :    free(a->out);

  0018b	8b f4		 mov	 esi, esp
  0018d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00190	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00193	51		 push	 ecx
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0019a	83 c4 04	 add	 esp, 4
  0019d	3b f4		 cmp	 esi, esp
  0019f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2377 :    a->out = temp_out;

  001a4	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  001a7	8b 45 f0	 mov	 eax, DWORD PTR _temp_out$[ebp]
  001aa	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2378 : 
; 2379 :    STBI_NOTUSED(len);
; 2380 : 
; 2381 :    return 1;

  001ad	b8 01 00 00 00	 mov	 eax, 1
$LN1@expand_pal:

; 2382 : }

  001b2	5e		 pop	 esi
  001b3	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b6	3b ec		 cmp	 ebp, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
?expand_palette@@YAHPAUpng@@PAEHH@Z ENDP		; expand_palette
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_flag_true_if_should_unpremultiply$ = 8			; size = 4
_stbi_set_unpremultiply_on_load PROC

; 2388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2389 :    stbi_unpremultiply_on_load = flag_true_if_should_unpremultiply;

  00003	8b 45 08	 mov	 eax, DWORD PTR _flag_true_if_should_unpremultiply$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?stbi_unpremultiply_on_load@@3HA, eax

; 2390 : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_flag_true_if_should_convert$ = 8			; size = 4
_stbi_convert_iphone_png_to_rgb PROC

; 2392 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2393 :    stbi_de_iphone_flag = flag_true_if_should_convert;

  00003	8b 45 08	 mov	 eax, DWORD PTR _flag_true_if_should_convert$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?stbi_de_iphone_flag@@3HA, eax

; 2394 : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_t$1 = -20						; size = 1
_t$2 = -19						; size = 1
_a$3 = -18						; size = 1
_t$4 = -17						; size = 1
_p$ = -16						; size = 4
_pixel_count$ = -12					; size = 4
_i$ = -8						; size = 4
_s$ = -4						; size = 4
_z$ = 8							; size = 4
?stbi_de_iphone@@YAXPAUpng@@@Z PROC			; stbi_de_iphone

; 2397 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2398 :    stbi *s = z->s;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 2399 :    uint32 i, pixel_count = s->img_x * s->img_y;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00026	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0002f	89 4d f4	 mov	 DWORD PTR _pixel_count$[ebp], ecx

; 2400 :    uint8 *p = z->out;

  00032	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2401 : 
; 2402 :    if (s->img_out_n == 3) {  // convert bgr to rgb

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0003e	83 79 0c 03	 cmp	 DWORD PTR [ecx+12], 3
  00042	75 66		 jne	 SHORT $LN11@stbi_de_ip

; 2403 :       for (i=0; i < pixel_count; ++i) {

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@stbi_de_ip
$LN2@stbi_de_ip:
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00050	83 c2 01	 add	 edx, 1
  00053	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@stbi_de_ip:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00059	3b 45 f4	 cmp	 eax, DWORD PTR _pixel_count$[ebp]
  0005c	73 47		 jae	 SHORT $LN3@stbi_de_ip

; 2404 :          uint8 t = p[0];

  0005e	b9 01 00 00 00	 mov	 ecx, 1
  00063	6b d1 00	 imul	 edx, ecx, 0
  00066	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00069	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  0006c	88 4d ef	 mov	 BYTE PTR _t$4[ebp], cl

; 2405 :          p[0] = p[2];

  0006f	ba 01 00 00 00	 mov	 edx, 1
  00074	d1 e2		 shl	 edx, 1
  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	6b c8 00	 imul	 ecx, eax, 0
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00081	8b 75 f0	 mov	 esi, DWORD PTR _p$[ebp]
  00084	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00087	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2406 :          p[2] = t;

  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	d1 e0		 shl	 eax, 1
  00091	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00094	8a 55 ef	 mov	 dl, BYTE PTR _t$4[ebp]
  00097	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2407 :          p += 3;

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0009d	83 c0 03	 add	 eax, 3
  000a0	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2408 :       }

  000a3	eb a8		 jmp	 SHORT $LN2@stbi_de_ip
$LN3@stbi_de_ip:

; 2409 :    } else {

  000a5	e9 8e 01 00 00	 jmp	 $LN1@stbi_de_ip
$LN11@stbi_de_ip:

; 2410 :       assert(s->img_out_n == 4);

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000ad	83 79 0c 04	 cmp	 DWORD PTR [ecx+12], 4
  000b1	74 21		 je	 SHORT $LN18@stbi_de_ip
  000b3	8b f4		 mov	 esi, esp
  000b5	68 6a 09 00 00	 push	 2410			; 0000096aH
  000ba	68 00 00 00 00	 push	 OFFSET $SG4294820192
  000bf	68 00 00 00 00	 push	 OFFSET $SG4294820191
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cd	3b f4		 cmp	 esi, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN18@stbi_de_ip:

; 2411 :       if (stbi_unpremultiply_on_load) {

  000d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?stbi_unpremultiply_on_load@@3HA, 0
  000db	0f 84 f6 00 00
	00		 je	 $LN13@stbi_de_ip

; 2412 :          // convert bgr to rgb and unpremultiply
; 2413 :          for (i=0; i < pixel_count; ++i) {

  000e1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e8	eb 09		 jmp	 SHORT $LN7@stbi_de_ip
$LN5@stbi_de_ip:
  000ea	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@stbi_de_ip:
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000f6	3b 4d f4	 cmp	 ecx, DWORD PTR _pixel_count$[ebp]
  000f9	0f 83 d6 00 00
	00		 jae	 $LN6@stbi_de_ip

; 2414 :             uint8 a = p[3];

  000ff	ba 01 00 00 00	 mov	 edx, 1
  00104	6b c2 03	 imul	 eax, edx, 3
  00107	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0010a	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0010d	88 55 ee	 mov	 BYTE PTR _a$3[ebp], dl

; 2415 :             uint8 t = p[0];

  00110	b8 01 00 00 00	 mov	 eax, 1
  00115	6b c8 00	 imul	 ecx, eax, 0
  00118	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0011b	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  0011e	88 45 ed	 mov	 BYTE PTR _t$2[ebp], al

; 2416 :             if (a) {

  00121	0f b6 4d ee	 movzx	 ecx, BYTE PTR _a$3[ebp]
  00125	85 c9		 test	 ecx, ecx
  00127	74 73		 je	 SHORT $LN15@stbi_de_ip

; 2417 :                p[0] = p[2] * 255 / a;

  00129	ba 01 00 00 00	 mov	 edx, 1
  0012e	d1 e2		 shl	 edx, 1
  00130	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00133	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00137	69 c1 ff 00 00
	00		 imul	 eax, ecx, 255
  0013d	0f b6 4d ee	 movzx	 ecx, BYTE PTR _a$3[ebp]
  00141	99		 cdq
  00142	f7 f9		 idiv	 ecx
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	6b ca 00	 imul	 ecx, edx, 0
  0014c	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0014f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2418 :                p[1] = p[1] * 255 / a;

  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	c1 e0 00	 shl	 eax, 0
  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0015d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00161	69 c2 ff 00 00
	00		 imul	 eax, edx, 255
  00167	0f b6 4d ee	 movzx	 ecx, BYTE PTR _a$3[ebp]
  0016b	99		 cdq
  0016c	f7 f9		 idiv	 ecx
  0016e	ba 01 00 00 00	 mov	 edx, 1
  00173	c1 e2 00	 shl	 edx, 0
  00176	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00179	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 2419 :                p[2] =  t   * 255 / a;

  0017c	0f b6 55 ed	 movzx	 edx, BYTE PTR _t$2[ebp]
  00180	69 c2 ff 00 00
	00		 imul	 eax, edx, 255
  00186	0f b6 4d ee	 movzx	 ecx, BYTE PTR _a$3[ebp]
  0018a	99		 cdq
  0018b	f7 f9		 idiv	 ecx
  0018d	ba 01 00 00 00	 mov	 edx, 1
  00192	d1 e2		 shl	 edx, 1
  00194	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00197	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 2420 :             } else {

  0019a	eb 2b		 jmp	 SHORT $LN16@stbi_de_ip
$LN15@stbi_de_ip:

; 2421 :                p[0] = p[2];

  0019c	ba 01 00 00 00	 mov	 edx, 1
  001a1	d1 e2		 shl	 edx, 1
  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	6b c8 00	 imul	 ecx, eax, 0
  001ab	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  001ae	8b 75 f0	 mov	 esi, DWORD PTR _p$[ebp]
  001b1	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  001b4	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2422 :                p[2] = t;

  001b7	b8 01 00 00 00	 mov	 eax, 1
  001bc	d1 e0		 shl	 eax, 1
  001be	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  001c1	8a 55 ed	 mov	 dl, BYTE PTR _t$2[ebp]
  001c4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
$LN16@stbi_de_ip:

; 2423 :             } 
; 2424 :             p += 4;

  001c7	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  001ca	83 c0 04	 add	 eax, 4
  001cd	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2425 :          }

  001d0	e9 15 ff ff ff	 jmp	 $LN5@stbi_de_ip
$LN6@stbi_de_ip:

; 2426 :       } else {

  001d5	eb 61		 jmp	 SHORT $LN1@stbi_de_ip
$LN13@stbi_de_ip:

; 2427 :          // convert bgr to rgb
; 2428 :          for (i=0; i < pixel_count; ++i) {

  001d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001de	eb 09		 jmp	 SHORT $LN10@stbi_de_ip
$LN8@stbi_de_ip:
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001e3	83 c1 01	 add	 ecx, 1
  001e6	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN10@stbi_de_ip:
  001e9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  001ec	3b 55 f4	 cmp	 edx, DWORD PTR _pixel_count$[ebp]
  001ef	73 47		 jae	 SHORT $LN1@stbi_de_ip

; 2429 :             uint8 t = p[0];

  001f1	b8 01 00 00 00	 mov	 eax, 1
  001f6	6b c8 00	 imul	 ecx, eax, 0
  001f9	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  001fc	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  001ff	88 45 ec	 mov	 BYTE PTR _t$1[ebp], al

; 2430 :             p[0] = p[2];

  00202	b9 01 00 00 00	 mov	 ecx, 1
  00207	d1 e1		 shl	 ecx, 1
  00209	ba 01 00 00 00	 mov	 edx, 1
  0020e	6b c2 00	 imul	 eax, edx, 0
  00211	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00214	8b 75 f0	 mov	 esi, DWORD PTR _p$[ebp]
  00217	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  0021a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2431 :             p[2] = t;

  0021d	ba 01 00 00 00	 mov	 edx, 1
  00222	d1 e2		 shl	 edx, 1
  00224	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00227	8a 4d ec	 mov	 cl, BYTE PTR _t$1[ebp]
  0022a	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 2432 :             p += 4;

  0022d	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00230	83 c2 04	 add	 edx, 4
  00233	89 55 f0	 mov	 DWORD PTR _p$[ebp], edx

; 2433 :          }

  00236	eb a8		 jmp	 SHORT $LN8@stbi_de_ip
$LN1@stbi_de_ip:

; 2434 :       }
; 2435 :    }
; 2436 : }

  00238	5e		 pop	 esi
  00239	83 c4 14	 add	 esp, 20			; 00000014H
  0023c	3b ec		 cmp	 ebp, esp
  0023e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
?stbi_de_iphone@@YAXPAUpng@@@Z ENDP			; stbi_de_iphone
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv321 = -1164						; size = 4
tv285 = -1160						; size = 4
tv173 = -1156						; size = 4
tv170 = -1152						; size = 4
tv74 = -1148						; size = 4
$T1 = -1144						; size = 8
_raw_len$2 = -1132					; size = 4
_p$3 = -1124						; size = 4
_filter$4 = -1120					; size = 4
_comp$5 = -1116						; size = 4
_color$6 = -1112					; size = 4
_depth$7 = -1108					; size = 4
_c$8 = -1100						; size = 8
_s$ = -1088						; size = 4
_iphone$ = -1084					; size = 4
_interlace$ = -1080					; size = 4
_k$ = -1076						; size = 4
_first$ = -1072						; size = 4
_pal_len$ = -1068					; size = 4
_i$ = -1064						; size = 4
_idata_limit$ = -1060					; size = 4
_ioff$ = -1056						; size = 4
_tc$ = -1048						; size = 3
_has_trans$ = -1038					; size = 1
_pal_img_n$ = -1037					; size = 1
_palette$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_z$ = 8							; size = 4
_scan$ = 12						; size = 4
_req_comp$ = 16						; size = 4
?parse_png_file@@YAHPAUpng@@HH@Z PROC			; parse_png_file

; 2439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 04 00
	00		 sub	 esp, 1164		; 0000048cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1164]
  00011	b9 23 01 00 00	 mov	 ecx, 291		; 00000123H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2440 :    uint8 palette[1024], pal_img_n=0;

  00027	c6 85 f3 fb ff
	ff 00		 mov	 BYTE PTR _pal_img_n$[ebp], 0

; 2441 :    uint8 has_trans=0, tc[3];

  0002e	c6 85 f2 fb ff
	ff 00		 mov	 BYTE PTR _has_trans$[ebp], 0

; 2442 :    uint32 ioff=0, idata_limit=0, i, pal_len=0;

  00035	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _ioff$[ebp], 0
  0003f	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _idata_limit$[ebp], 0
  00049	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _pal_len$[ebp], 0

; 2443 :    int first=1,k,interlace=0, iphone=0;

  00053	c7 85 d0 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _first$[ebp], 1
  0005d	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _interlace$[ebp], 0
  00067	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iphone$[ebp], 0

; 2444 :    stbi *s = z->s;

  00071	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	89 8d c0 fb ff
	ff		 mov	 DWORD PTR _s$[ebp], ecx

; 2445 : 
; 2446 :    z->expanded = NULL;

  0007c	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0007f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 2447 :    z->idata = NULL;

  00086	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00089	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2448 :    z->out = NULL;

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00093	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 2449 : 
; 2450 :    if (!check_png_header(s)) return 0;

  0009a	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?check_png_header@@YAHPAUstbi@@@Z ; check_png_header
  000a6	83 c4 04	 add	 esp, 4
  000a9	85 c0		 test	 eax, eax
  000ab	75 07		 jne	 SHORT $LN18@parse_png_
  000ad	33 c0		 xor	 eax, eax
  000af	e9 c8 0a 00 00	 jmp	 $LN1@parse_png_
$LN18@parse_png_:

; 2451 : 
; 2452 :    if (scan == SCAN_type) return 1;

  000b4	83 7d 0c 01	 cmp	 DWORD PTR _scan$[ebp], 1
  000b8	75 0a		 jne	 SHORT $LN4@parse_png_
  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	e9 b8 0a 00 00	 jmp	 $LN1@parse_png_
$LN4@parse_png_:

; 2453 : 
; 2454 :    for (;;) {
; 2455 :       chunk c = get_chunk_header(s);

  000c4	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?get_chunk_header@@YA?AUchunk@@PAUstbi@@@Z ; get_chunk_header
  000d0	83 c4 04	 add	 esp, 4
  000d3	89 85 88 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  000d9	89 95 8c fb ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  000df	8b 8d 88 fb ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  000e5	89 8d b4 fb ff
	ff		 mov	 DWORD PTR _c$8[ebp], ecx
  000eb	8b 95 8c fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp+4]
  000f1	89 95 b8 fb ff
	ff		 mov	 DWORD PTR _c$8[ebp+4], edx

; 2456 :       switch (c.type) {

  000f7	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp+4]
  000fd	89 85 84 fb ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00103	81 bd 84 fb ff
	ff 52 44 48 49	 cmp	 DWORD PTR tv74[ebp], 1229472850 ; 49484452H
  0010d	77 3d		 ja	 SHORT $LN91@parse_png_
  0010f	81 bd 84 fb ff
	ff 52 44 48 49	 cmp	 DWORD PTR tv74[ebp], 1229472850 ; 49484452H
  00119	74 7d		 je	 SHORT $LN21@parse_png_
  0011b	81 bd 84 fb ff
	ff 49 42 67 43	 cmp	 DWORD PTR tv74[ebp], 1130840649 ; 43674249H
  00125	74 4a		 je	 SHORT $LN20@parse_png_
  00127	81 bd 84 fb ff
	ff 54 41 44 49	 cmp	 DWORD PTR tv74[ebp], 1229209940 ; 49444154H
  00131	0f 84 d8 05 00
	00		 je	 $LN55@parse_png_
  00137	81 bd 84 fb ff
	ff 44 4e 45 49	 cmp	 DWORD PTR tv74[ebp], 1229278788 ; 49454e44H
  00141	0f 84 3b 07 00
	00		 je	 $LN63@parse_png_
  00147	e9 76 09 00 00	 jmp	 $LN79@parse_png_
$LN91@parse_png_:
  0014c	81 bd 84 fb ff
	ff 45 54 4c 50	 cmp	 DWORD PTR tv74[ebp], 1347179589 ; 504c5445H
  00156	0f 84 24 03 00
	00		 je	 $LN41@parse_png_
  0015c	81 bd 84 fb ff
	ff 53 4e 52 74	 cmp	 DWORD PTR tv74[ebp], 1951551059 ; 74524e53H
  00166	0f 84 18 04 00
	00		 je	 $LN45@parse_png_
  0016c	e9 51 09 00 00	 jmp	 $LN79@parse_png_
$LN20@parse_png_:

; 2457 :          case PNG_TYPE('C','g','B','I'):
; 2458 :             iphone = stbi_de_iphone_flag;

  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stbi_de_iphone_flag@@3HA
  00177	89 8d c4 fb ff
	ff		 mov	 DWORD PTR _iphone$[ebp], ecx

; 2459 :             skip(s, c.length);

  0017d	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR _c$8[ebp]
  00183	52		 push	 edx
  00184	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00190	83 c4 08	 add	 esp, 8

; 2460 :             break;

  00193	e9 d0 09 00 00	 jmp	 $LN5@parse_png_
$LN21@parse_png_:

; 2461 :          case PNG_TYPE('I','H','D','R'): {
; 2462 :             int depth,color,comp,filter;
; 2463 :             if (!first) return e("multiple IHDR","Corrupt PNG");

  00198	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  0019f	75 12		 jne	 SHORT $LN22@parse_png_
  001a1	68 00 00 00 00	 push	 OFFSET $SG4294820190
  001a6	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001ab	83 c4 04	 add	 esp, 4
  001ae	e9 c9 09 00 00	 jmp	 $LN1@parse_png_
$LN22@parse_png_:

; 2464 :             first = 0;

  001b3	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _first$[ebp], 0

; 2465 :             if (c.length != 13) return e("bad IHDR len","Corrupt PNG");

  001bd	83 bd b4 fb ff
	ff 0d		 cmp	 DWORD PTR _c$8[ebp], 13	; 0000000dH
  001c4	74 12		 je	 SHORT $LN23@parse_png_
  001c6	68 00 00 00 00	 push	 OFFSET $SG4294820189
  001cb	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001d0	83 c4 04	 add	 esp, 4
  001d3	e9 a4 09 00 00	 jmp	 $LN1@parse_png_
$LN23@parse_png_:

; 2466 :             s->img_x = get32(s); if (s->img_x > (1 << 24)) return e("too large","Very large image (corrupt?)");

  001d8	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  001e4	83 c4 04	 add	 esp, 4
  001e7	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  001ed	89 02		 mov	 DWORD PTR [edx], eax
  001ef	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  001f5	81 38 00 00 00
	01		 cmp	 DWORD PTR [eax], 16777216 ; 01000000H
  001fb	76 12		 jbe	 SHORT $LN24@parse_png_
  001fd	68 00 00 00 00	 push	 OFFSET $SG4294820188
  00202	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00207	83 c4 04	 add	 esp, 4
  0020a	e9 6d 09 00 00	 jmp	 $LN1@parse_png_
$LN24@parse_png_:

; 2467 :             s->img_y = get32(s); if (s->img_y > (1 << 24)) return e("too large","Very large image (corrupt?)");

  0020f	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  0021b	83 c4 04	 add	 esp, 4
  0021e	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00224	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00227	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0022d	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [eax+4], 16777216 ; 01000000H
  00234	76 12		 jbe	 SHORT $LN25@parse_png_
  00236	68 00 00 00 00	 push	 OFFSET $SG4294820187
  0023b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00240	83 c4 04	 add	 esp, 4
  00243	e9 34 09 00 00	 jmp	 $LN1@parse_png_
$LN25@parse_png_:

; 2468 :             depth = get8(s);  if (depth != 8)        return e("8bit only","PNG not supported: 8-bit only");

  00248	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00254	83 c4 04	 add	 esp, 4
  00257	89 85 ac fb ff
	ff		 mov	 DWORD PTR _depth$7[ebp], eax
  0025d	83 bd ac fb ff
	ff 08		 cmp	 DWORD PTR _depth$7[ebp], 8
  00264	74 12		 je	 SHORT $LN26@parse_png_
  00266	68 00 00 00 00	 push	 OFFSET $SG4294820186
  0026b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00270	83 c4 04	 add	 esp, 4
  00273	e9 04 09 00 00	 jmp	 $LN1@parse_png_
$LN26@parse_png_:

; 2469 :             color = get8(s);  if (color > 6)         return e("bad ctype","Corrupt PNG");

  00278	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0027e	52		 push	 edx
  0027f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00284	83 c4 04	 add	 esp, 4
  00287	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _color$6[ebp], eax
  0028d	83 bd a8 fb ff
	ff 06		 cmp	 DWORD PTR _color$6[ebp], 6
  00294	7e 12		 jle	 SHORT $LN27@parse_png_
  00296	68 00 00 00 00	 push	 OFFSET $SG4294820185
  0029b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002a0	83 c4 04	 add	 esp, 4
  002a3	e9 d4 08 00 00	 jmp	 $LN1@parse_png_
$LN27@parse_png_:

; 2470 :             if (color == 3) pal_img_n = 3; else if (color & 1) return e("bad ctype","Corrupt PNG");

  002a8	83 bd a8 fb ff
	ff 03		 cmp	 DWORD PTR _color$6[ebp], 3
  002af	75 09		 jne	 SHORT $LN28@parse_png_
  002b1	c6 85 f3 fb ff
	ff 03		 mov	 BYTE PTR _pal_img_n$[ebp], 3
  002b8	eb 1d		 jmp	 SHORT $LN29@parse_png_
$LN28@parse_png_:
  002ba	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _color$6[ebp]
  002c0	83 e0 01	 and	 eax, 1
  002c3	74 12		 je	 SHORT $LN29@parse_png_
  002c5	68 00 00 00 00	 push	 OFFSET $SG4294820184
  002ca	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002cf	83 c4 04	 add	 esp, 4
  002d2	e9 a5 08 00 00	 jmp	 $LN1@parse_png_
$LN29@parse_png_:

; 2471 :             comp  = get8(s);  if (comp) return e("bad comp method","Corrupt PNG");

  002d7	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  002e3	83 c4 04	 add	 esp, 4
  002e6	89 85 a4 fb ff
	ff		 mov	 DWORD PTR _comp$5[ebp], eax
  002ec	83 bd a4 fb ff
	ff 00		 cmp	 DWORD PTR _comp$5[ebp], 0
  002f3	74 12		 je	 SHORT $LN31@parse_png_
  002f5	68 00 00 00 00	 push	 OFFSET $SG4294820183
  002fa	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002ff	83 c4 04	 add	 esp, 4
  00302	e9 75 08 00 00	 jmp	 $LN1@parse_png_
$LN31@parse_png_:

; 2472 :             filter= get8(s);  if (filter) return e("bad filter method","Corrupt PNG");

  00307	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0030d	52		 push	 edx
  0030e	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00313	83 c4 04	 add	 esp, 4
  00316	89 85 a0 fb ff
	ff		 mov	 DWORD PTR _filter$4[ebp], eax
  0031c	83 bd a0 fb ff
	ff 00		 cmp	 DWORD PTR _filter$4[ebp], 0
  00323	74 12		 je	 SHORT $LN32@parse_png_
  00325	68 00 00 00 00	 push	 OFFSET $SG4294820182
  0032a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0032f	83 c4 04	 add	 esp, 4
  00332	e9 45 08 00 00	 jmp	 $LN1@parse_png_
$LN32@parse_png_:

; 2473 :             interlace = get8(s); if (interlace>1) return e("bad interlace method","Corrupt PNG");

  00337	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00343	83 c4 04	 add	 esp, 4
  00346	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _interlace$[ebp], eax
  0034c	83 bd c8 fb ff
	ff 01		 cmp	 DWORD PTR _interlace$[ebp], 1
  00353	7e 12		 jle	 SHORT $LN33@parse_png_
  00355	68 00 00 00 00	 push	 OFFSET $SG4294820181
  0035a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0035f	83 c4 04	 add	 esp, 4
  00362	e9 15 08 00 00	 jmp	 $LN1@parse_png_
$LN33@parse_png_:

; 2474 :             if (!s->img_x || !s->img_y) return e("0-pixel image","Corrupt PNG");

  00367	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0036d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00370	74 0c		 je	 SHORT $LN35@parse_png_
  00372	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00378	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0037c	75 12		 jne	 SHORT $LN34@parse_png_
$LN35@parse_png_:
  0037e	68 00 00 00 00	 push	 OFFSET $SG4294820180
  00383	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00388	83 c4 04	 add	 esp, 4
  0038b	e9 ec 07 00 00	 jmp	 $LN1@parse_png_
$LN34@parse_png_:

; 2475 :             if (!pal_img_n) {

  00390	0f b6 85 f3 fb
	ff ff		 movzx	 eax, BYTE PTR _pal_img_n$[ebp]
  00397	85 c0		 test	 eax, eax
  00399	0f 85 a0 00 00
	00		 jne	 $LN36@parse_png_

; 2476 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

  0039f	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _color$6[ebp]
  003a5	83 e1 02	 and	 ecx, 2
  003a8	74 0c		 je	 SHORT $LN83@parse_png_
  003aa	c7 85 80 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR tv170[ebp], 3
  003b4	eb 0a		 jmp	 SHORT $LN84@parse_png_
$LN83@parse_png_:
  003b6	c7 85 80 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv170[ebp], 1
$LN84@parse_png_:
  003c0	8b 95 a8 fb ff
	ff		 mov	 edx, DWORD PTR _color$6[ebp]
  003c6	83 e2 04	 and	 edx, 4
  003c9	74 0c		 je	 SHORT $LN85@parse_png_
  003cb	c7 85 7c fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv173[ebp], 1
  003d5	eb 0a		 jmp	 SHORT $LN86@parse_png_
$LN85@parse_png_:
  003d7	c7 85 7c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv173[ebp], 0
$LN86@parse_png_:
  003e1	8b 85 80 fb ff
	ff		 mov	 eax, DWORD PTR tv170[ebp]
  003e7	03 85 7c fb ff
	ff		 add	 eax, DWORD PTR tv173[ebp]
  003ed	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  003f3	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2477 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");

  003f6	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  003fc	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00401	33 d2		 xor	 edx, edx
  00403	f7 31		 div	 DWORD PTR [ecx]
  00405	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0040b	33 d2		 xor	 edx, edx
  0040d	f7 71 08	 div	 DWORD PTR [ecx+8]
  00410	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00416	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00419	73 12		 jae	 SHORT $LN38@parse_png_
  0041b	68 00 00 00 00	 push	 OFFSET $SG4294820179
  00420	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00425	83 c4 04	 add	 esp, 4
  00428	e9 4f 07 00 00	 jmp	 $LN1@parse_png_
$LN38@parse_png_:

; 2478 :                if (scan == SCAN_header) return 1;

  0042d	83 7d 0c 02	 cmp	 DWORD PTR _scan$[ebp], 2
  00431	75 0a		 jne	 SHORT $LN39@parse_png_
  00433	b8 01 00 00 00	 mov	 eax, 1
  00438	e9 3f 07 00 00	 jmp	 $LN1@parse_png_
$LN39@parse_png_:

; 2479 :             } else {

  0043d	eb 3c		 jmp	 SHORT $LN37@parse_png_
$LN36@parse_png_:

; 2480 :                // if paletted, then pal_n is our final components, and
; 2481 :                // img_n is # components to decompress/filter.
; 2482 :                s->img_n = 1;

  0043f	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00445	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 2483 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return e("too large","Corrupt PNG");

  0044c	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00452	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00457	33 d2		 xor	 edx, edx
  00459	f7 31		 div	 DWORD PTR [ecx]
  0045b	c1 e8 02	 shr	 eax, 2
  0045e	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00464	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00467	73 12		 jae	 SHORT $LN37@parse_png_
  00469	68 00 00 00 00	 push	 OFFSET $SG4294820178
  0046e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00473	83 c4 04	 add	 esp, 4
  00476	e9 01 07 00 00	 jmp	 $LN1@parse_png_
$LN37@parse_png_:

; 2484 :                // if SCAN_header, have to scan to see if we have a tRNS
; 2485 :             }
; 2486 :             break;

  0047b	e9 e8 06 00 00	 jmp	 $LN5@parse_png_
$LN41@parse_png_:

; 2487 :          }
; 2488 : 
; 2489 :          case PNG_TYPE('P','L','T','E'):  {
; 2490 :             if (first) return e("first not IHDR", "Corrupt PNG");

  00480	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  00487	74 12		 je	 SHORT $LN42@parse_png_
  00489	68 00 00 00 00	 push	 OFFSET $SG4294820177
  0048e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00493	83 c4 04	 add	 esp, 4
  00496	e9 e1 06 00 00	 jmp	 $LN1@parse_png_
$LN42@parse_png_:

; 2491 :             if (c.length > 256*3) return e("invalid PLTE","Corrupt PNG");

  0049b	81 bd b4 fb ff
	ff 00 03 00 00	 cmp	 DWORD PTR _c$8[ebp], 768 ; 00000300H
  004a5	76 12		 jbe	 SHORT $LN43@parse_png_
  004a7	68 00 00 00 00	 push	 OFFSET $SG4294820176
  004ac	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  004b1	83 c4 04	 add	 esp, 4
  004b4	e9 c3 06 00 00	 jmp	 $LN1@parse_png_
$LN43@parse_png_:

; 2492 :             pal_len = c.length / 3;

  004b9	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp]
  004bf	33 d2		 xor	 edx, edx
  004c1	b9 03 00 00 00	 mov	 ecx, 3
  004c6	f7 f1		 div	 ecx
  004c8	89 85 d4 fb ff
	ff		 mov	 DWORD PTR _pal_len$[ebp], eax

; 2493 :             if (pal_len * 3 != c.length) return e("invalid PLTE","Corrupt PNG");

  004ce	6b 95 d4 fb ff
	ff 03		 imul	 edx, DWORD PTR _pal_len$[ebp], 3
  004d5	3b 95 b4 fb ff
	ff		 cmp	 edx, DWORD PTR _c$8[ebp]
  004db	74 12		 je	 SHORT $LN44@parse_png_
  004dd	68 00 00 00 00	 push	 OFFSET $SG4294820175
  004e2	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  004e7	83 c4 04	 add	 esp, 4
  004ea	e9 8d 06 00 00	 jmp	 $LN1@parse_png_
$LN44@parse_png_:

; 2494 :             for (i=0; i < pal_len; ++i) {

  004ef	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  004f9	eb 0f		 jmp	 SHORT $LN9@parse_png_
$LN7@parse_png_:
  004fb	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00501	83 c0 01	 add	 eax, 1
  00504	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN9@parse_png_:
  0050a	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00510	3b 8d d4 fb ff
	ff		 cmp	 ecx, DWORD PTR _pal_len$[ebp]
  00516	73 67		 jae	 SHORT $LN8@parse_png_

; 2495 :                palette[i*4+0] = get8u(s);

  00518	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0051e	52		 push	 edx
  0051f	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00524	83 c4 04	 add	 esp, 4
  00527	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0052d	88 84 8d f8 fb
	ff ff		 mov	 BYTE PTR _palette$[ebp+ecx*4], al

; 2496 :                palette[i*4+1] = get8u(s);

  00534	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0053a	52		 push	 edx
  0053b	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00540	83 c4 04	 add	 esp, 4
  00543	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00549	88 84 8d f9 fb
	ff ff		 mov	 BYTE PTR _palette$[ebp+ecx*4+1], al

; 2497 :                palette[i*4+2] = get8u(s);

  00550	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00556	52		 push	 edx
  00557	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0055c	83 c4 04	 add	 esp, 4
  0055f	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00565	88 84 8d fa fb
	ff ff		 mov	 BYTE PTR _palette$[ebp+ecx*4+2], al

; 2498 :                palette[i*4+3] = 255;

  0056c	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00572	c6 84 95 fb fb
	ff ff ff	 mov	 BYTE PTR _palette$[ebp+edx*4+3], 255 ; 000000ffH

; 2499 :             }

  0057a	e9 7c ff ff ff	 jmp	 $LN7@parse_png_
$LN8@parse_png_:

; 2500 :             break;

  0057f	e9 e4 05 00 00	 jmp	 $LN5@parse_png_
$LN45@parse_png_:

; 2501 :          }
; 2502 : 
; 2503 :          case PNG_TYPE('t','R','N','S'): {
; 2504 :             if (first) return e("first not IHDR", "Corrupt PNG");

  00584	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  0058b	74 12		 je	 SHORT $LN46@parse_png_
  0058d	68 00 00 00 00	 push	 OFFSET $SG4294820174
  00592	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00597	83 c4 04	 add	 esp, 4
  0059a	e9 dd 05 00 00	 jmp	 $LN1@parse_png_
$LN46@parse_png_:

; 2505 :             if (z->idata) return e("tRNS after IDAT","Corrupt PNG");

  0059f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  005a2	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  005a6	74 12		 je	 SHORT $LN47@parse_png_
  005a8	68 00 00 00 00	 push	 OFFSET $SG4294820173
  005ad	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  005b2	83 c4 04	 add	 esp, 4
  005b5	e9 c2 05 00 00	 jmp	 $LN1@parse_png_
$LN47@parse_png_:

; 2506 :             if (pal_img_n) {

  005ba	0f b6 8d f3 fb
	ff ff		 movzx	 ecx, BYTE PTR _pal_img_n$[ebp]
  005c1	85 c9		 test	 ecx, ecx
  005c3	0f 84 ab 00 00
	00		 je	 $LN48@parse_png_

; 2507 :                if (scan == SCAN_header) { s->img_n = 4; return 1; }

  005c9	83 7d 0c 02	 cmp	 DWORD PTR _scan$[ebp], 2
  005cd	75 17		 jne	 SHORT $LN50@parse_png_
  005cf	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  005d5	c7 42 08 04 00
	00 00		 mov	 DWORD PTR [edx+8], 4
  005dc	b8 01 00 00 00	 mov	 eax, 1
  005e1	e9 96 05 00 00	 jmp	 $LN1@parse_png_
$LN50@parse_png_:

; 2508 :                if (pal_len == 0) return e("tRNS before PLTE","Corrupt PNG");

  005e6	83 bd d4 fb ff
	ff 00		 cmp	 DWORD PTR _pal_len$[ebp], 0
  005ed	75 12		 jne	 SHORT $LN51@parse_png_
  005ef	68 00 00 00 00	 push	 OFFSET $SG4294820172
  005f4	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  005f9	83 c4 04	 add	 esp, 4
  005fc	e9 7b 05 00 00	 jmp	 $LN1@parse_png_
$LN51@parse_png_:

; 2509 :                if (c.length > pal_len) return e("bad tRNS len","Corrupt PNG");

  00601	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp]
  00607	3b 85 d4 fb ff
	ff		 cmp	 eax, DWORD PTR _pal_len$[ebp]
  0060d	76 12		 jbe	 SHORT $LN52@parse_png_
  0060f	68 00 00 00 00	 push	 OFFSET $SG4294820171
  00614	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00619	83 c4 04	 add	 esp, 4
  0061c	e9 5b 05 00 00	 jmp	 $LN1@parse_png_
$LN52@parse_png_:

; 2510 :                pal_img_n = 4;

  00621	c6 85 f3 fb ff
	ff 04		 mov	 BYTE PTR _pal_img_n$[ebp], 4

; 2511 :                for (i=0; i < c.length; ++i)

  00628	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00632	eb 0f		 jmp	 SHORT $LN12@parse_png_
$LN10@parse_png_:
  00634	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0063a	83 c1 01	 add	 ecx, 1
  0063d	89 8d d8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN12@parse_png_:
  00643	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00649	3b 95 b4 fb ff
	ff		 cmp	 edx, DWORD PTR _c$8[ebp]
  0064f	73 1e		 jae	 SHORT $LN11@parse_png_

; 2512 :                   palette[i*4+3] = get8u(s);

  00651	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00657	50		 push	 eax
  00658	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0065d	83 c4 04	 add	 esp, 4
  00660	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00666	88 84 8d fb fb
	ff ff		 mov	 BYTE PTR _palette$[ebp+ecx*4+3], al
  0066d	eb c5		 jmp	 SHORT $LN10@parse_png_
$LN11@parse_png_:

; 2513 :             } else {

  0066f	e9 96 00 00 00	 jmp	 $LN49@parse_png_
$LN48@parse_png_:

; 2514 :                if (!(s->img_n & 1)) return e("tRNS with alpha","Corrupt PNG");

  00674	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0067a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0067d	83 e0 01	 and	 eax, 1
  00680	75 12		 jne	 SHORT $LN53@parse_png_
  00682	68 00 00 00 00	 push	 OFFSET $SG4294820170
  00687	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0068c	83 c4 04	 add	 esp, 4
  0068f	e9 e8 04 00 00	 jmp	 $LN1@parse_png_
$LN53@parse_png_:

; 2515 :                if (c.length != (uint32) s->img_n*2) return e("bad tRNS len","Corrupt PNG");

  00694	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0069a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0069d	d1 e2		 shl	 edx, 1
  0069f	39 95 b4 fb ff
	ff		 cmp	 DWORD PTR _c$8[ebp], edx
  006a5	74 12		 je	 SHORT $LN54@parse_png_
  006a7	68 00 00 00 00	 push	 OFFSET $SG4294820169
  006ac	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  006b1	83 c4 04	 add	 esp, 4
  006b4	e9 c3 04 00 00	 jmp	 $LN1@parse_png_
$LN54@parse_png_:

; 2516 :                has_trans = 1;

  006b9	c6 85 f2 fb ff
	ff 01		 mov	 BYTE PTR _has_trans$[ebp], 1

; 2517 :                for (k=0; k < s->img_n; ++k)

  006c0	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0
  006ca	eb 0f		 jmp	 SHORT $LN15@parse_png_
$LN13@parse_png_:
  006cc	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _k$[ebp]
  006d2	83 c0 01	 add	 eax, 1
  006d5	89 85 cc fb ff
	ff		 mov	 DWORD PTR _k$[ebp], eax
$LN15@parse_png_:
  006db	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  006e1	8b 95 cc fb ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  006e7	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  006ea	7d 1e		 jge	 SHORT $LN49@parse_png_

; 2518 :                   tc[k] = (uint8) get16(s); // non 8-bit images will be larger

  006ec	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  006f2	50		 push	 eax
  006f3	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  006f8	83 c4 04	 add	 esp, 4
  006fb	8b 8d cc fb ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  00701	88 84 0d e8 fb
	ff ff		 mov	 BYTE PTR _tc$[ebp+ecx], al
  00708	eb c2		 jmp	 SHORT $LN13@parse_png_
$LN49@parse_png_:

; 2519 :             }
; 2520 :             break;

  0070a	e9 59 04 00 00	 jmp	 $LN5@parse_png_
$LN55@parse_png_:

; 2521 :          }
; 2522 : 
; 2523 :          case PNG_TYPE('I','D','A','T'): {
; 2524 :             if (first) return e("first not IHDR", "Corrupt PNG");

  0070f	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  00716	74 12		 je	 SHORT $LN56@parse_png_
  00718	68 00 00 00 00	 push	 OFFSET $SG4294820168
  0071d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00722	83 c4 04	 add	 esp, 4
  00725	e9 52 04 00 00	 jmp	 $LN1@parse_png_
$LN56@parse_png_:

; 2525 :             if (pal_img_n && !pal_len) return e("no PLTE","Corrupt PNG");

  0072a	0f b6 95 f3 fb
	ff ff		 movzx	 edx, BYTE PTR _pal_img_n$[ebp]
  00731	85 d2		 test	 edx, edx
  00733	74 1b		 je	 SHORT $LN57@parse_png_
  00735	83 bd d4 fb ff
	ff 00		 cmp	 DWORD PTR _pal_len$[ebp], 0
  0073c	75 12		 jne	 SHORT $LN57@parse_png_
  0073e	68 00 00 00 00	 push	 OFFSET $SG4294820167
  00743	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00748	83 c4 04	 add	 esp, 4
  0074b	e9 2c 04 00 00	 jmp	 $LN1@parse_png_
$LN57@parse_png_:

; 2526 :             if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }

  00750	83 7d 0c 02	 cmp	 DWORD PTR _scan$[ebp], 2
  00754	75 1a		 jne	 SHORT $LN58@parse_png_
  00756	0f b6 85 f3 fb
	ff ff		 movzx	 eax, BYTE PTR _pal_img_n$[ebp]
  0075d	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00763	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00766	b8 01 00 00 00	 mov	 eax, 1
  0076b	e9 0c 04 00 00	 jmp	 $LN1@parse_png_
$LN58@parse_png_:

; 2527 :             if (ioff + c.length > idata_limit) {

  00770	8b 95 e0 fb ff
	ff		 mov	 edx, DWORD PTR _ioff$[ebp]
  00776	03 95 b4 fb ff
	ff		 add	 edx, DWORD PTR _c$8[ebp]
  0077c	3b 95 dc fb ff
	ff		 cmp	 edx, DWORD PTR _idata_limit$[ebp]
  00782	0f 86 aa 00 00
	00		 jbe	 $LN59@parse_png_

; 2528 :                uint8 *p;
; 2529 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

  00788	83 bd dc fb ff
	ff 00		 cmp	 DWORD PTR _idata_limit$[ebp], 0
  0078f	75 30		 jne	 SHORT $LN16@parse_png_
  00791	81 bd b4 fb ff
	ff 00 10 00 00	 cmp	 DWORD PTR _c$8[ebp], 4096 ; 00001000H
  0079b	76 0e		 jbe	 SHORT $LN87@parse_png_
  0079d	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp]
  007a3	89 85 78 fb ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  007a9	eb 0a		 jmp	 SHORT $LN88@parse_png_
$LN87@parse_png_:
  007ab	c7 85 78 fb ff
	ff 00 10 00 00	 mov	 DWORD PTR tv285[ebp], 4096 ; 00001000H
$LN88@parse_png_:
  007b5	8b 8d 78 fb ff
	ff		 mov	 ecx, DWORD PTR tv285[ebp]
  007bb	89 8d dc fb ff
	ff		 mov	 DWORD PTR _idata_limit$[ebp], ecx
$LN16@parse_png_:

; 2530 :                while (ioff + c.length > idata_limit)

  007c1	8b 95 e0 fb ff
	ff		 mov	 edx, DWORD PTR _ioff$[ebp]
  007c7	03 95 b4 fb ff
	ff		 add	 edx, DWORD PTR _c$8[ebp]
  007cd	3b 95 dc fb ff
	ff		 cmp	 edx, DWORD PTR _idata_limit$[ebp]
  007d3	76 10		 jbe	 SHORT $LN17@parse_png_

; 2531 :                   idata_limit *= 2;

  007d5	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _idata_limit$[ebp]
  007db	d1 e0		 shl	 eax, 1
  007dd	89 85 dc fb ff
	ff		 mov	 DWORD PTR _idata_limit$[ebp], eax
  007e3	eb dc		 jmp	 SHORT $LN16@parse_png_
$LN17@parse_png_:

; 2532 :                p = (uint8 *) realloc(z->idata, idata_limit); if (p == NULL) return e("outofmem", "Out of memory");

  007e5	8b f4		 mov	 esi, esp
  007e7	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _idata_limit$[ebp]
  007ed	51		 push	 ecx
  007ee	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  007f1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  007f4	50		 push	 eax
  007f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  007fb	83 c4 08	 add	 esp, 8
  007fe	3b f4		 cmp	 esi, esp
  00800	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00805	89 85 9c fb ff
	ff		 mov	 DWORD PTR _p$3[ebp], eax
  0080b	83 bd 9c fb ff
	ff 00		 cmp	 DWORD PTR _p$3[ebp], 0
  00812	75 12		 jne	 SHORT $LN61@parse_png_
  00814	68 00 00 00 00	 push	 OFFSET $SG4294820166
  00819	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0081e	83 c4 04	 add	 esp, 4
  00821	e9 56 03 00 00	 jmp	 $LN1@parse_png_
$LN61@parse_png_:

; 2533 :                z->idata = p;

  00826	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00829	8b 95 9c fb ff
	ff		 mov	 edx, DWORD PTR _p$3[ebp]
  0082f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN59@parse_png_:

; 2534 :             }
; 2535 :             if (!getn(s, z->idata+ioff,c.length)) return e("outofdata","Corrupt PNG");

  00832	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp]
  00838	50		 push	 eax
  00839	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0083c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0083f	03 95 e0 fb ff
	ff		 add	 edx, DWORD PTR _ioff$[ebp]
  00845	52		 push	 edx
  00846	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0084c	50		 push	 eax
  0084d	e8 00 00 00 00	 call	 ?getn@@YAHPAUstbi@@PAEH@Z ; getn
  00852	83 c4 0c	 add	 esp, 12			; 0000000cH
  00855	85 c0		 test	 eax, eax
  00857	75 12		 jne	 SHORT $LN62@parse_png_
  00859	68 00 00 00 00	 push	 OFFSET $SG4294820165
  0085e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00863	83 c4 04	 add	 esp, 4
  00866	e9 11 03 00 00	 jmp	 $LN1@parse_png_
$LN62@parse_png_:

; 2536 :             ioff += c.length;

  0086b	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _ioff$[ebp]
  00871	03 8d b4 fb ff
	ff		 add	 ecx, DWORD PTR _c$8[ebp]
  00877	89 8d e0 fb ff
	ff		 mov	 DWORD PTR _ioff$[ebp], ecx

; 2537 :             break;

  0087d	e9 e6 02 00 00	 jmp	 $LN5@parse_png_
$LN63@parse_png_:

; 2538 :          }
; 2539 : 
; 2540 :          case PNG_TYPE('I','E','N','D'): {
; 2541 :             uint32 raw_len;
; 2542 :             if (first) return e("first not IHDR", "Corrupt PNG");

  00882	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  00889	74 12		 je	 SHORT $LN64@parse_png_
  0088b	68 00 00 00 00	 push	 OFFSET $SG4294820164
  00890	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00895	83 c4 04	 add	 esp, 4
  00898	e9 df 02 00 00	 jmp	 $LN1@parse_png_
$LN64@parse_png_:

; 2543 :             if (scan != SCAN_load) return 1;

  0089d	83 7d 0c 00	 cmp	 DWORD PTR _scan$[ebp], 0
  008a1	74 0a		 je	 SHORT $LN65@parse_png_
  008a3	b8 01 00 00 00	 mov	 eax, 1
  008a8	e9 cf 02 00 00	 jmp	 $LN1@parse_png_
$LN65@parse_png_:

; 2544 :             if (z->idata == NULL) return e("no IDAT","Corrupt PNG");

  008ad	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  008b0	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  008b4	75 12		 jne	 SHORT $LN66@parse_png_
  008b6	68 00 00 00 00	 push	 OFFSET $SG4294820163
  008bb	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  008c0	83 c4 04	 add	 esp, 4
  008c3	e9 b4 02 00 00	 jmp	 $LN1@parse_png_
$LN66@parse_png_:

; 2545 :             z->expanded = (uint8 *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, 16384, (int *) &raw_len, !iphone);

  008c8	83 bd c4 fb ff
	ff 00		 cmp	 DWORD PTR _iphone$[ebp], 0
  008cf	75 0c		 jne	 SHORT $LN89@parse_png_
  008d1	c7 85 74 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv321[ebp], 1
  008db	eb 0a		 jmp	 SHORT $LN90@parse_png_
$LN89@parse_png_:
  008dd	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv321[ebp], 0
$LN90@parse_png_:
  008e7	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR tv321[ebp]
  008ed	50		 push	 eax
  008ee	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _raw_len$2[ebp]
  008f4	51		 push	 ecx
  008f5	68 00 40 00 00	 push	 16384			; 00004000H
  008fa	8b 95 e0 fb ff
	ff		 mov	 edx, DWORD PTR _ioff$[ebp]
  00900	52		 push	 edx
  00901	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00904	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00907	51		 push	 ecx
  00908	e8 00 00 00 00	 call	 ?stbi_zlib_decode_malloc_guesssize_headerflag@@YAPADPBDHHPAHH@Z ; stbi_zlib_decode_malloc_guesssize_headerflag
  0090d	83 c4 14	 add	 esp, 20			; 00000014H
  00910	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00913	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2546 :             if (z->expanded == NULL) return 0; // zlib should set error

  00916	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00919	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0091d	75 07		 jne	 SHORT $LN67@parse_png_
  0091f	33 c0		 xor	 eax, eax
  00921	e9 56 02 00 00	 jmp	 $LN1@parse_png_
$LN67@parse_png_:

; 2547 :             free(z->idata); z->idata = NULL;

  00926	8b f4		 mov	 esi, esp
  00928	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  0092b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0092e	52		 push	 edx
  0092f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00935	83 c4 04	 add	 esp, 4
  00938	3b f4		 cmp	 esi, esp
  0093a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0093f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00942	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2548 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

  00949	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0094f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00952	83 c2 01	 add	 edx, 1
  00955	39 55 10	 cmp	 DWORD PTR _req_comp$[ebp], edx
  00958	75 11		 jne	 SHORT $LN71@parse_png_
  0095a	83 7d 10 03	 cmp	 DWORD PTR _req_comp$[ebp], 3
  0095e	74 0b		 je	 SHORT $LN71@parse_png_
  00960	0f b6 85 f3 fb
	ff ff		 movzx	 eax, BYTE PTR _pal_img_n$[ebp]
  00967	85 c0		 test	 eax, eax
  00969	74 0b		 je	 SHORT $LN70@parse_png_
$LN71@parse_png_:
  0096b	0f b6 8d f2 fb
	ff ff		 movzx	 ecx, BYTE PTR _has_trans$[ebp]
  00972	85 c9		 test	 ecx, ecx
  00974	74 17		 je	 SHORT $LN68@parse_png_
$LN70@parse_png_:

; 2549 :                s->img_out_n = s->img_n+1;

  00976	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  0097c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0097f	83 c0 01	 add	 eax, 1
  00982	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00988	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2550 :             else

  0098b	eb 12		 jmp	 SHORT $LN69@parse_png_
$LN68@parse_png_:

; 2551 :                s->img_out_n = s->img_n;

  0098d	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00993	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00999	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0099c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN69@parse_png_:

; 2552 :             if (!create_png_image(z, z->expanded, raw_len, s->img_out_n, interlace)) return 0;

  0099f	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _interlace$[ebp]
  009a5	52		 push	 edx
  009a6	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  009ac	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  009af	51		 push	 ecx
  009b0	8b 95 94 fb ff
	ff		 mov	 edx, DWORD PTR _raw_len$2[ebp]
  009b6	52		 push	 edx
  009b7	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  009ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009bd	51		 push	 ecx
  009be	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  009c1	52		 push	 edx
  009c2	e8 00 00 00 00	 call	 ?create_png_image@@YAHPAUpng@@PAEIHH@Z ; create_png_image
  009c7	83 c4 14	 add	 esp, 20			; 00000014H
  009ca	85 c0		 test	 eax, eax
  009cc	75 07		 jne	 SHORT $LN72@parse_png_
  009ce	33 c0		 xor	 eax, eax
  009d0	e9 a7 01 00 00	 jmp	 $LN1@parse_png_
$LN72@parse_png_:

; 2553 :             if (has_trans)

  009d5	0f b6 85 f2 fb
	ff ff		 movzx	 eax, BYTE PTR _has_trans$[ebp]
  009dc	85 c0		 test	 eax, eax
  009de	74 28		 je	 SHORT $LN73@parse_png_

; 2554 :                if (!compute_transparency(z, tc, s->img_out_n)) return 0;

  009e0	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  009e6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  009e9	52		 push	 edx
  009ea	8d 85 e8 fb ff
	ff		 lea	 eax, DWORD PTR _tc$[ebp]
  009f0	50		 push	 eax
  009f1	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  009f4	51		 push	 ecx
  009f5	e8 00 00 00 00	 call	 ?compute_transparency@@YAHPAUpng@@QAEH@Z ; compute_transparency
  009fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  009fd	85 c0		 test	 eax, eax
  009ff	75 07		 jne	 SHORT $LN73@parse_png_
  00a01	33 c0		 xor	 eax, eax
  00a03	e9 74 01 00 00	 jmp	 $LN1@parse_png_
$LN73@parse_png_:

; 2555 :             if (iphone && s->img_out_n > 2)

  00a08	83 bd c4 fb ff
	ff 00		 cmp	 DWORD PTR _iphone$[ebp], 0
  00a0f	74 18		 je	 SHORT $LN75@parse_png_
  00a11	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00a17	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  00a1b	7e 0c		 jle	 SHORT $LN75@parse_png_

; 2556 :                stbi_de_iphone(z);

  00a1d	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00a20	50		 push	 eax
  00a21	e8 00 00 00 00	 call	 ?stbi_de_iphone@@YAXPAUpng@@@Z ; stbi_de_iphone
  00a26	83 c4 04	 add	 esp, 4
$LN75@parse_png_:

; 2557 :             if (pal_img_n) {

  00a29	0f b6 8d f3 fb
	ff ff		 movzx	 ecx, BYTE PTR _pal_img_n$[ebp]
  00a30	85 c9		 test	 ecx, ecx
  00a32	74 61		 je	 SHORT $LN76@parse_png_

; 2558 :                // pal_img_n == 3 or 4
; 2559 :                s->img_n = pal_img_n; // record the actual colors we had

  00a34	0f b6 95 f3 fb
	ff ff		 movzx	 edx, BYTE PTR _pal_img_n$[ebp]
  00a3b	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00a41	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2560 :                s->img_out_n = pal_img_n;

  00a44	0f b6 8d f3 fb
	ff ff		 movzx	 ecx, BYTE PTR _pal_img_n$[ebp]
  00a4b	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00a51	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 2561 :                if (req_comp >= 3) s->img_out_n = req_comp;

  00a54	83 7d 10 03	 cmp	 DWORD PTR _req_comp$[ebp], 3
  00a58	7c 0c		 jl	 SHORT $LN77@parse_png_
  00a5a	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00a60	8b 4d 10	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00a63	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN77@parse_png_:

; 2562 :                if (!expand_palette(z, palette, pal_len, s->img_out_n))

  00a66	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00a6c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00a6f	50		 push	 eax
  00a70	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _pal_len$[ebp]
  00a76	51		 push	 ecx
  00a77	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _palette$[ebp]
  00a7d	52		 push	 edx
  00a7e	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00a81	50		 push	 eax
  00a82	e8 00 00 00 00	 call	 ?expand_palette@@YAHPAUpng@@PAEHH@Z ; expand_palette
  00a87	83 c4 10	 add	 esp, 16			; 00000010H
  00a8a	85 c0		 test	 eax, eax
  00a8c	75 07		 jne	 SHORT $LN76@parse_png_

; 2563 :                   return 0;

  00a8e	33 c0		 xor	 eax, eax
  00a90	e9 e7 00 00 00	 jmp	 $LN1@parse_png_
$LN76@parse_png_:

; 2564 :             }
; 2565 :             free(z->expanded); z->expanded = NULL;

  00a95	8b f4		 mov	 esi, esp
  00a97	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00a9a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00a9d	52		 push	 edx
  00a9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00aa4	83 c4 04	 add	 esp, 4
  00aa7	3b f4		 cmp	 esi, esp
  00aa9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00aae	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00ab1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 2566 :             return 1;

  00ab8	b8 01 00 00 00	 mov	 eax, 1
  00abd	e9 ba 00 00 00	 jmp	 $LN1@parse_png_
$LN79@parse_png_:

; 2567 :          }
; 2568 : 
; 2569 :          default:
; 2570 :             // if critical, fail
; 2571 :             if (first) return e("first not IHDR", "Corrupt PNG");

  00ac2	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR _first$[ebp], 0
  00ac9	74 12		 je	 SHORT $LN80@parse_png_
  00acb	68 00 00 00 00	 push	 OFFSET $SG4294820162
  00ad0	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00ad5	83 c4 04	 add	 esp, 4
  00ad8	e9 9f 00 00 00	 jmp	 $LN1@parse_png_
$LN80@parse_png_:

; 2572 :             if ((c.type & (1 << 29)) == 0) {

  00add	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _c$8[ebp+4]
  00ae3	81 e1 00 00 00
	20		 and	 ecx, 536870912		; 20000000H
  00ae9	75 67		 jne	 SHORT $LN81@parse_png_

; 2573 :                #ifndef STBI_NO_FAILURE_STRINGS
; 2574 :                // not threadsafe
; 2575 :                static char invalid_chunk[] = "XXXX chunk not known";
; 2576 :                invalid_chunk[0] = (uint8) (c.type >> 24);

  00aeb	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _c$8[ebp+4]
  00af1	c1 ea 18	 shr	 edx, 24			; 00000018H
  00af4	b8 01 00 00 00	 mov	 eax, 1
  00af9	6b c8 00	 imul	 ecx, eax, 0
  00afc	88 91 00 00 00
	00		 mov	 BYTE PTR ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA[ecx], dl

; 2577 :                invalid_chunk[1] = (uint8) (c.type >> 16);

  00b02	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _c$8[ebp+4]
  00b08	c1 ea 10	 shr	 edx, 16			; 00000010H
  00b0b	b8 01 00 00 00	 mov	 eax, 1
  00b10	c1 e0 00	 shl	 eax, 0
  00b13	88 90 00 00 00
	00		 mov	 BYTE PTR ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA[eax], dl

; 2578 :                invalid_chunk[2] = (uint8) (c.type >>  8);

  00b19	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _c$8[ebp+4]
  00b1f	c1 e9 08	 shr	 ecx, 8
  00b22	ba 01 00 00 00	 mov	 edx, 1
  00b27	d1 e2		 shl	 edx, 1
  00b29	88 8a 00 00 00
	00		 mov	 BYTE PTR ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA[edx], cl

; 2579 :                invalid_chunk[3] = (uint8) (c.type >>  0);

  00b2f	b8 01 00 00 00	 mov	 eax, 1
  00b34	6b c8 03	 imul	 ecx, eax, 3
  00b37	8a 95 b8 fb ff
	ff		 mov	 dl, BYTE PTR _c$8[ebp+4]
  00b3d	88 91 00 00 00
	00		 mov	 BYTE PTR ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA[ecx], dl

; 2580 :                #endif
; 2581 :                return e(invalid_chunk, "PNG not supported: unknown chunk type");

  00b43	68 00 00 00 00	 push	 OFFSET ?invalid_chunk@?IB@??parse_png_file@@YAHPAUpng@@HH@Z@4PADA
  00b48	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00b4d	83 c4 04	 add	 esp, 4
  00b50	eb 2a		 jmp	 SHORT $LN1@parse_png_
$LN81@parse_png_:

; 2582 :             }
; 2583 :             skip(s, c.length);

  00b52	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _c$8[ebp]
  00b58	50		 push	 eax
  00b59	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00b5f	51		 push	 ecx
  00b60	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00b65	83 c4 08	 add	 esp, 8
$LN5@parse_png_:

; 2584 :             break;
; 2585 :       }
; 2586 :       // end of chunk, read and skip CRC
; 2587 :       get32(s);

  00b68	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00b6e	52		 push	 edx
  00b6f	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00b74	83 c4 04	 add	 esp, 4

; 2588 :    }

  00b77	e9 48 f5 ff ff	 jmp	 $LN4@parse_png_
$LN1@parse_png_:

; 2589 : }

  00b7c	52		 push	 edx
  00b7d	8b cd		 mov	 ecx, ebp
  00b7f	50		 push	 eax
  00b80	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN97@parse_png_
  00b86	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b8b	58		 pop	 eax
  00b8c	5a		 pop	 edx
  00b8d	5f		 pop	 edi
  00b8e	5e		 pop	 esi
  00b8f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b92	33 cd		 xor	 ecx, ebp
  00b94	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b99	81 c4 8c 04 00
	00		 add	 esp, 1164		; 0000048cH
  00b9f	3b ec		 cmp	 ebp, esp
  00ba1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ba6	8b e5		 mov	 esp, ebp
  00ba8	5d		 pop	 ebp
  00ba9	c3		 ret	 0
  00baa	66 90		 npad	 2
$LN97@parse_png_:
  00bac	04 00 00 00	 DD	 4
  00bb0	00 00 00 00	 DD	 $LN96@parse_png_
$LN96@parse_png_:
  00bb4	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  00bb8	00 04 00 00	 DD	 1024			; 00000400H
  00bbc	00 00 00 00	 DD	 $LN92@parse_png_
  00bc0	e8 fb ff ff	 DD	 -1048			; fffffbe8H
  00bc4	03 00 00 00	 DD	 3
  00bc8	00 00 00 00	 DD	 $LN93@parse_png_
  00bcc	b4 fb ff ff	 DD	 -1100			; fffffbb4H
  00bd0	08 00 00 00	 DD	 8
  00bd4	00 00 00 00	 DD	 $LN94@parse_png_
  00bd8	94 fb ff ff	 DD	 -1132			; fffffb94H
  00bdc	04 00 00 00	 DD	 4
  00be0	00 00 00 00	 DD	 $LN95@parse_png_
$LN95@parse_png_:
  00be4	72		 DB	 114			; 00000072H
  00be5	61		 DB	 97			; 00000061H
  00be6	77		 DB	 119			; 00000077H
  00be7	5f		 DB	 95			; 0000005fH
  00be8	6c		 DB	 108			; 0000006cH
  00be9	65		 DB	 101			; 00000065H
  00bea	6e		 DB	 110			; 0000006eH
  00beb	00		 DB	 0
$LN94@parse_png_:
  00bec	63		 DB	 99			; 00000063H
  00bed	00		 DB	 0
$LN93@parse_png_:
  00bee	74		 DB	 116			; 00000074H
  00bef	63		 DB	 99			; 00000063H
  00bf0	00		 DB	 0
$LN92@parse_png_:
  00bf1	70		 DB	 112			; 00000070H
  00bf2	61		 DB	 97			; 00000061H
  00bf3	6c		 DB	 108			; 0000006cH
  00bf4	65		 DB	 101			; 00000065H
  00bf5	74		 DB	 116			; 00000074H
  00bf6	74		 DB	 116			; 00000074H
  00bf7	65		 DB	 101			; 00000065H
  00bf8	00		 DB	 0
?parse_png_file@@YAHPAUpng@@HH@Z ENDP			; parse_png_file
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv69 = -8						; size = 4
_result$ = -4						; size = 4
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_n$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?do_png@@YAPAEPAUpng@@PAH11H@Z PROC			; do_png

; 2592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2593 :    unsigned char *result=NULL;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 2594 :    if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");

  0001c	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00020	7c 06		 jl	 SHORT $LN3@do_png
  00022	83 7d 18 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  00026	7e 29		 jle	 SHORT $LN2@do_png
$LN3@do_png:
  00028	68 00 00 00 00	 push	 OFFSET $SG4294820161
  0002d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	74 09		 je	 SHORT $LN9@do_png
  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00040	eb 07		 jmp	 SHORT $LN10@do_png
$LN9@do_png:
  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN10@do_png:
  00049	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0004c	e9 1e 01 00 00	 jmp	 $LN1@do_png
$LN2@do_png:

; 2595 :    if (parse_png_file(p, SCAN_load, req_comp)) {

  00051	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ?parse_png_file@@YAHPAUpng@@HH@Z ; parse_png_file
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	85 c0		 test	 eax, eax
  00065	0f 84 98 00 00
	00		 je	 $LN4@do_png

; 2596 :       result = p->out;

  0006b	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0006e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00071	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 2597 :       p->out = NULL;

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00077	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 2598 :       if (req_comp && req_comp != p->s->img_out_n) {

  0007e	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00082	74 53		 je	 SHORT $LN5@do_png
  00084	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  0008c	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0008f	74 46		 je	 SHORT $LN5@do_png

; 2599 :          result = convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00091	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00094	8b 02		 mov	 eax, DWORD PTR [edx]
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	51		 push	 ecx
  0009a	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0009d	8b 02		 mov	 eax, DWORD PTR [edx]
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	51		 push	 ecx
  000a2	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  000a5	52		 push	 edx
  000a6	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ab	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ae	52		 push	 edx
  000af	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?convert_format@@YAPAEPAEHHII@Z ; convert_format
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 2600 :          p->s->img_out_n = req_comp;

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c3	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  000c6	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2601 :          if (result == NULL) return result;

  000c9	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  000cd	75 08		 jne	 SHORT $LN5@do_png
  000cf	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  000d2	e9 98 00 00 00	 jmp	 $LN1@do_png
$LN5@do_png:

; 2602 :       }
; 2603 :       *x = p->s->img_x;

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000da	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dc	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  000df	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 2604 :       *y = p->s->img_y;

  000e3	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000e6	8b 02		 mov	 eax, DWORD PTR [edx]
  000e8	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  000eb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ee	89 11		 mov	 DWORD PTR [ecx], edx

; 2605 :       if (n) *n = p->s->img_n;

  000f0	83 7d 14 00	 cmp	 DWORD PTR _n$[ebp], 0
  000f4	74 0d		 je	 SHORT $LN4@do_png
  000f6	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	8b 55 14	 mov	 edx, DWORD PTR _n$[ebp]
  000fe	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00101	89 02		 mov	 DWORD PTR [edx], eax
$LN4@do_png:

; 2606 :    }
; 2607 :    free(p->out);      p->out      = NULL;

  00103	8b f4		 mov	 esi, esp
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00108	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0010b	52		 push	 edx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00112	83 c4 04	 add	 esp, 4
  00115	3b f4		 cmp	 esi, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0011f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 2608 :    free(p->expanded); p->expanded = NULL;

  00126	8b f4		 mov	 esi, esp
  00128	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0012b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012e	52		 push	 edx
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00135	83 c4 04	 add	 esp, 4
  00138	3b f4		 cmp	 esi, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00142	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 2609 :    free(p->idata);    p->idata    = NULL;

  00149	8b f4		 mov	 esi, esp
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0014e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00151	52		 push	 edx
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00158	83 c4 04	 add	 esp, 4
  0015b	3b f4		 cmp	 esi, esp
  0015d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00162	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00165	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2610 : 
; 2611 :    return result;

  0016c	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@do_png:

; 2612 : }

  0016f	5e		 pop	 esi
  00170	83 c4 08	 add	 esp, 8
  00173	3b ec		 cmp	 ebp, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
?do_png@@YAPAEPAUpng@@PAH11H@Z ENDP			; do_png
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = -20						; size = 16
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_png_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_png_load

; 2615 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2616 :    png p;
; 2617 :    p.s = s;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00020	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax

; 2618 :    return do_png(&p, x,y,comp,req_comp);

  00023	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00032	51		 push	 ecx
  00033	8d 55 ec	 lea	 edx, DWORD PTR _p$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?do_png@@YAPAEPAUpng@@PAH11H@Z ; do_png
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 2619 : }

  0003f	52		 push	 edx
  00040	8b cd		 mov	 ecx, ebp
  00042	50		 push	 eax
  00043	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_png_l
  00049	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004e	58		 pop	 eax
  0004f	5a		 pop	 edx
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
  0005e	66 90		 npad	 2
$LN5@stbi_png_l:
  00060	01 00 00 00	 DD	 1
  00064	00 00 00 00	 DD	 $LN4@stbi_png_l
$LN4@stbi_png_l:
  00068	ec ff ff ff	 DD	 -20			; ffffffecH
  0006c	10 00 00 00	 DD	 16			; 00000010H
  00070	00 00 00 00	 DD	 $LN3@stbi_png_l
$LN3@stbi_png_l:
  00074	70		 DB	 112			; 00000070H
  00075	00		 DB	 0
?stbi_png_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_png_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_png_test@@YAHPAUstbi@@@Z PROC			; stbi_png_test

; 2622 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2623 :    int r;
; 2624 :    r = check_png_header(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?check_png_header@@YAHPAUstbi@@@Z ; check_png_header
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 2625 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 2626 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 2627 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_png_test@@YAHPAUstbi@@@Z ENDP			; stbi_png_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_png_info_raw@@YAHPAUpng@@PAH11@Z PROC		; stbi_png_info_raw

; 2630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2631 :    if (!parse_png_file(p, SCAN_header, 0)) {

  00003	6a 00		 push	 0
  00005	6a 02		 push	 2
  00007	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?parse_png_file@@YAHPAUpng@@HH@Z ; parse_png_file
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
  00013	85 c0		 test	 eax, eax
  00015	75 12		 jne	 SHORT $LN2@stbi_png_i

; 2632 :       stbi_rewind( p->s );

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00022	83 c4 04	 add	 esp, 4

; 2633 :       return 0;

  00025	33 c0		 xor	 eax, eax
  00027	eb 3d		 jmp	 SHORT $LN1@stbi_png_i
$LN2@stbi_png_i:

; 2634 :    }
; 2635 :    if (x) *x = p->s->img_x;

  00029	83 7d 0c 00	 cmp	 DWORD PTR _x$[ebp], 0
  0002d	74 0c		 je	 SHORT $LN3@stbi_png_i
  0002f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	89 02		 mov	 DWORD PTR [edx], eax
$LN3@stbi_png_i:

; 2636 :    if (y) *y = p->s->img_y;

  0003b	83 7d 10 00	 cmp	 DWORD PTR _y$[ebp], 0
  0003f	74 0d		 je	 SHORT $LN4@stbi_png_i
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00049	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@stbi_png_i:

; 2637 :    if (comp) *comp = p->s->img_n;

  0004e	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  00052	74 0d		 je	 SHORT $LN5@stbi_png_i
  00054	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0005c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0005f	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@stbi_png_i:

; 2638 :    return 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_png_i:

; 2639 : }

  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?stbi_png_info_raw@@YAHPAUpng@@PAH11@Z ENDP		; stbi_png_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$ = -20						; size = 16
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_png_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_png_info

; 2642 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2643 :    png p;
; 2644 :    p.s = s;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00020	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax

; 2645 :    return stbi_png_info_raw(&p, x, y, comp);

  00023	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR _p$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?stbi_png_info_raw@@YAHPAUpng@@PAH11@Z ; stbi_png_info_raw
  00038	83 c4 10	 add	 esp, 16			; 00000010H

; 2646 : }

  0003b	52		 push	 edx
  0003c	8b cd		 mov	 ecx, ebp
  0003e	50		 push	 eax
  0003f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_png_i
  00045	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004a	58		 pop	 eax
  0004b	5a		 pop	 edx
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
  0005a	66 90		 npad	 2
$LN5@stbi_png_i:
  0005c	01 00 00 00	 DD	 1
  00060	00 00 00 00	 DD	 $LN4@stbi_png_i
$LN4@stbi_png_i:
  00064	ec ff ff ff	 DD	 -20			; ffffffecH
  00068	10 00 00 00	 DD	 16			; 00000010H
  0006c	00 00 00 00	 DD	 $LN3@stbi_png_i
$LN3@stbi_png_i:
  00070	70		 DB	 112			; 00000070H
  00071	00		 DB	 0
?stbi_png_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_png_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_sz$ = -4						; size = 4
_s$ = 8							; size = 4
?bmp_test@@YAHPAUstbi@@@Z PROC				; bmp_test

; 2651 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2652 :    int sz;
; 2653 :    if (get8(s) != 'B') return 0;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 42	 cmp	 eax, 66			; 00000042H
  0001a	74 04		 je	 SHORT $LN2@bmp_test
  0001c	33 c0		 xor	 eax, eax
  0001e	eb 75		 jmp	 SHORT $LN1@bmp_test
$LN2@bmp_test:

; 2654 :    if (get8(s) != 'M') return 0;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00029	83 c4 04	 add	 esp, 4
  0002c	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0002f	74 04		 je	 SHORT $LN3@bmp_test
  00031	33 c0		 xor	 eax, eax
  00033	eb 60		 jmp	 SHORT $LN1@bmp_test
$LN3@bmp_test:

; 2655 :    get32le(s); // discard filesize

  00035	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  0003e	83 c4 04	 add	 esp, 4

; 2656 :    get16le(s); // discard reserved

  00041	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  0004a	83 c4 04	 add	 esp, 4

; 2657 :    get16le(s); // discard reserved

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00056	83 c4 04	 add	 esp, 4

; 2658 :    get32le(s); // discard data offset

  00059	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00062	83 c4 04	 add	 esp, 4

; 2659 :    sz = get32le(s);

  00065	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  0006e	83 c4 04	 add	 esp, 4
  00071	89 45 fc	 mov	 DWORD PTR _sz$[ebp], eax

; 2660 :    if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;

  00074	83 7d fc 0c	 cmp	 DWORD PTR _sz$[ebp], 12	; 0000000cH
  00078	74 12		 je	 SHORT $LN5@bmp_test
  0007a	83 7d fc 28	 cmp	 DWORD PTR _sz$[ebp], 40	; 00000028H
  0007e	74 0c		 je	 SHORT $LN5@bmp_test
  00080	83 7d fc 38	 cmp	 DWORD PTR _sz$[ebp], 56	; 00000038H
  00084	74 06		 je	 SHORT $LN5@bmp_test
  00086	83 7d fc 6c	 cmp	 DWORD PTR _sz$[ebp], 108 ; 0000006cH
  0008a	75 07		 jne	 SHORT $LN4@bmp_test
$LN5@bmp_test:
  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	eb 02		 jmp	 SHORT $LN1@bmp_test
$LN4@bmp_test:

; 2661 :    return 0;

  00093	33 c0		 xor	 eax, eax
$LN1@bmp_test:

; 2662 : }

  00095	83 c4 04	 add	 esp, 4
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?bmp_test@@YAHPAUstbi@@@Z ENDP				; bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_bmp_test@@YAHPAUstbi@@@Z PROC			; stbi_bmp_test

; 2665 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2666 :    int r = bmp_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?bmp_test@@YAHPAUstbi@@@Z ; bmp_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 2667 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 2668 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 2669 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_bmp_test@@YAHPAUstbi@@@Z ENDP			; stbi_bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_z$ = 8							; size = 4
?high_bit@@YAHI@Z PROC					; high_bit

; 2674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2675 :    int n=0;

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2676 :    if (z == 0) return -1;

  00012	83 7d 08 00	 cmp	 DWORD PTR _z$[ebp], 0
  00016	75 08		 jne	 SHORT $LN2@high_bit
  00018	83 c8 ff	 or	 eax, -1
  0001b	e9 80 00 00 00	 jmp	 $LN1@high_bit
$LN2@high_bit:

; 2677 :    if (z >= 0x10000) n += 16, z >>= 16;

  00020	81 7d 08 00 00
	01 00		 cmp	 DWORD PTR _z$[ebp], 65536 ; 00010000H
  00027	72 12		 jb	 SHORT $LN3@high_bit
  00029	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002c	83 c0 10	 add	 eax, 16			; 00000010H
  0002f	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00035	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00038	89 4d 08	 mov	 DWORD PTR _z$[ebp], ecx
$LN3@high_bit:

; 2678 :    if (z >= 0x00100) n +=  8, z >>=  8;

  0003b	81 7d 08 00 01
	00 00		 cmp	 DWORD PTR _z$[ebp], 256	; 00000100H
  00042	72 12		 jb	 SHORT $LN4@high_bit
  00044	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00047	83 c2 08	 add	 edx, 8
  0004a	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00050	c1 e8 08	 shr	 eax, 8
  00053	89 45 08	 mov	 DWORD PTR _z$[ebp], eax
$LN4@high_bit:

; 2679 :    if (z >= 0x00010) n +=  4, z >>=  4;

  00056	83 7d 08 10	 cmp	 DWORD PTR _z$[ebp], 16	; 00000010H
  0005a	72 12		 jb	 SHORT $LN5@high_bit
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  0005f	83 c1 04	 add	 ecx, 4
  00062	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  00068	c1 ea 04	 shr	 edx, 4
  0006b	89 55 08	 mov	 DWORD PTR _z$[ebp], edx
$LN5@high_bit:

; 2680 :    if (z >= 0x00004) n +=  2, z >>=  2;

  0006e	83 7d 08 04	 cmp	 DWORD PTR _z$[ebp], 4
  00072	72 12		 jb	 SHORT $LN6@high_bit
  00074	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00077	83 c0 02	 add	 eax, 2
  0007a	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00080	c1 e9 02	 shr	 ecx, 2
  00083	89 4d 08	 mov	 DWORD PTR _z$[ebp], ecx
$LN6@high_bit:

; 2681 :    if (z >= 0x00002) n +=  1, z >>=  1;

  00086	83 7d 08 02	 cmp	 DWORD PTR _z$[ebp], 2
  0008a	72 11		 jb	 SHORT $LN7@high_bit
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  0008f	83 c2 01	 add	 edx, 1
  00092	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00098	d1 e8		 shr	 eax, 1
  0009a	89 45 08	 mov	 DWORD PTR _z$[ebp], eax
$LN7@high_bit:

; 2682 :    return n;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
$LN1@high_bit:

; 2683 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?high_bit@@YAHI@Z ENDP					; high_bit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
?bitcount@@YAHI@Z PROC					; bitcount

; 2686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2687 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	25 55 55 55 55	 and	 eax, 1431655765		; 55555555H
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0000e	d1 e9		 shr	 ecx, 1
  00010	81 e1 55 55 55
	55		 and	 ecx, 1431655765		; 55555555H
  00016	03 c1		 add	 eax, ecx
  00018	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 2688 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

  0001b	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0001e	81 e2 33 33 33
	33		 and	 edx, 858993459		; 33333333H
  00024	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00027	c1 e8 02	 shr	 eax, 2
  0002a	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  0002f	03 d0		 add	 edx, eax
  00031	89 55 08	 mov	 DWORD PTR _a$[ebp], edx

; 2689 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00037	c1 e9 04	 shr	 ecx, 4
  0003a	03 4d 08	 add	 ecx, DWORD PTR _a$[ebp]
  0003d	81 e1 0f 0f 0f
	0f		 and	 ecx, 252645135		; 0f0f0f0fH
  00043	89 4d 08	 mov	 DWORD PTR _a$[ebp], ecx

; 2690 :    a = (a + (a >> 8)); // max 16 per 8 bits

  00046	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00049	c1 ea 08	 shr	 edx, 8
  0004c	03 55 08	 add	 edx, DWORD PTR _a$[ebp]
  0004f	89 55 08	 mov	 DWORD PTR _a$[ebp], edx

; 2691 :    a = (a + (a >> 16)); // max 32 per 8 bits

  00052	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00055	c1 e8 10	 shr	 eax, 16			; 00000010H
  00058	03 45 08	 add	 eax, DWORD PTR _a$[ebp]
  0005b	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 2692 :    return a & 0xff;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00061	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 2693 : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?bitcount@@YAHI@Z ENDP					; bitcount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_z$ = -8						; size = 4
_result$ = -4						; size = 4
_v$ = 8							; size = 4
_shift$ = 12						; size = 4
_bits$ = 16						; size = 4
?shiftsigned@@YAHHHH@Z PROC				; shiftsigned

; 2696 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2697 :    int result;
; 2698 :    int z=0;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _z$[ebp], 0

; 2699 : 
; 2700 :    if (shift < 0) v <<= -shift;

  0001b	83 7d 0c 00	 cmp	 DWORD PTR _shift$[ebp], 0
  0001f	7d 0f		 jge	 SHORT $LN4@shiftsigne
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _shift$[ebp]
  00024	f7 d9		 neg	 ecx
  00026	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00029	d3 e0		 shl	 eax, cl
  0002b	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  0002e	eb 0b		 jmp	 SHORT $LN5@shiftsigne
$LN4@shiftsigne:

; 2701 :    else v >>= shift;

  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _shift$[ebp]
  00036	d3 fa		 sar	 edx, cl
  00038	89 55 08	 mov	 DWORD PTR _v$[ebp], edx
$LN5@shiftsigne:

; 2702 :    result = v;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003e	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 2703 : 
; 2704 :    z = bits;

  00041	8b 4d 10	 mov	 ecx, DWORD PTR _bits$[ebp]
  00044	89 4d f8	 mov	 DWORD PTR _z$[ebp], ecx
$LN2@shiftsigne:

; 2705 :    while (z < 8) {

  00047	83 7d f8 08	 cmp	 DWORD PTR _z$[ebp], 8
  0004b	7d 19		 jge	 SHORT $LN3@shiftsigne

; 2706 :       result += v >> z;

  0004d	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _z$[ebp]
  00053	d3 fa		 sar	 edx, cl
  00055	03 55 fc	 add	 edx, DWORD PTR _result$[ebp]
  00058	89 55 fc	 mov	 DWORD PTR _result$[ebp], edx

; 2707 :       z += bits;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  0005e	03 45 10	 add	 eax, DWORD PTR _bits$[ebp]
  00061	89 45 f8	 mov	 DWORD PTR _z$[ebp], eax

; 2708 :    }

  00064	eb e1		 jmp	 SHORT $LN2@shiftsigne
$LN3@shiftsigne:

; 2709 :    return result;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 2710 : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?shiftsigned@@YAHHHH@Z ENDP				; shiftsigned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv519 = -1252						; size = 4
tv485 = -1248						; size = 4
tv472 = -1244						; size = 4
tv425 = -1240						; size = 4
tv339 = -1236						; size = 4
tv294 = -1232						; size = 4
tv279 = -1228						; size = 4
tv249 = -1224						; size = 4
tv241 = -1220						; size = 4
tv224 = -1216						; size = 4
tv200 = -1212						; size = 4
tv196 = -1208						; size = 4
tv167 = -1204						; size = 4
tv150 = -1200						; size = 4
tv147 = -1196						; size = 4
tv140 = -1192						; size = 4
tv88 = -1188						; size = 4
tv73 = -1184						; size = 4
_p2$1 = -1180						; size = 4
_p1$2 = -1176						; size = 4
_t$3 = -1169						; size = 1
_a$4 = -1168						; size = 4
_v$5 = -1164						; size = 4
_a$6 = -1160						; size = 4
_easy$7 = -1156						; size = 4
_z$8 = -1152						; size = 4
_acount$9 = -1148					; size = 4
_bcount$10 = -1144					; size = 4
_gcount$11 = -1140					; size = 4
_rcount$12 = -1136					; size = 4
_ashift$13 = -1132					; size = 4
_bshift$14 = -1128					; size = 4
_gshift$15 = -1124					; size = 4
_rshift$16 = -1120					; size = 4
_v2$17 = -1116						; size = 4
_v$18 = -1112						; size = 4
_z$19 = -1108						; size = 4
_hsz$ = -1104						; size = 4
_offset$ = -1100					; size = 4
_target$ = -1096					; size = 4
_pad$ = -1092						; size = 4
_flip_vertically$ = -1088				; size = 4
_bpp$ = -1084						; size = 4
_width$ = -1080						; size = 4
_compress$ = -1076					; size = 4
_j$ = -1072						; size = 4
_i$ = -1068						; size = 4
_psize$ = -1064						; size = 4
_pal$ = -1056						; size = 1024
_fake_a$ = -28						; size = 4
_ma$ = -24						; size = 4
_mb$ = -20						; size = 4
_mg$ = -16						; size = 4
_mr$ = -12						; size = 4
_out$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?bmp_load@@YAPAEPAUstbi@@PAH11H@Z PROC			; bmp_load

; 2713 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 04 00
	00		 sub	 esp, 1252		; 000004e4H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 1c fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1252]
  00011	b9 39 01 00 00	 mov	 ecx, 313		; 00000139H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2714 :    uint8 *out;
; 2715 :    unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mr$[ebp], 0
  0002e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mg$[ebp], 0
  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mb$[ebp], 0
  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ma$[ebp], 0
  00043	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _fake_a$[ebp], 0

; 2716 :    stbi_uc pal[256][4];
; 2717 :    int psize=0,i,j,compress=0,width;

  0004a	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _psize$[ebp], 0
  00054	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _compress$[ebp], 0

; 2718 :    int bpp, flip_vertically, pad, target, offset, hsz;
; 2719 :    if (get8(s) != 'B' || get8(s) != 'M') return epuc("not BMP", "Corrupt BMP");

  0005e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00067	83 c4 04	 add	 esp, 4
  0006a	83 f8 42	 cmp	 eax, 66			; 00000042H
  0006d	75 11		 jne	 SHORT $LN30@bmp_load
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00078	83 c4 04	 add	 esp, 4
  0007b	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0007e	74 32		 je	 SHORT $LN29@bmp_load
$LN30@bmp_load:
  00080	68 00 00 00 00	 push	 OFFSET $SG4294820160
  00085	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0008a	83 c4 04	 add	 esp, 4
  0008d	85 c0		 test	 eax, eax
  0008f	74 0c		 je	 SHORT $LN91@bmp_load
  00091	c7 85 60 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
  0009b	eb 0a		 jmp	 SHORT $LN92@bmp_load
$LN91@bmp_load:
  0009d	c7 85 60 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN92@bmp_load:
  000a7	8b 85 60 fb ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  000ad	e9 3e 10 00 00	 jmp	 $LN1@bmp_load
$LN29@bmp_load:

; 2720 :    get32le(s); // discard filesize

  000b2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  000bb	83 c4 04	 add	 esp, 4

; 2721 :    get16le(s); // discard reserved

  000be	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000c7	83 c4 04	 add	 esp, 4

; 2722 :    get16le(s); // discard reserved

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000d3	83 c4 04	 add	 esp, 4

; 2723 :    offset = get32le(s);

  000d6	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  000df	83 c4 04	 add	 esp, 4
  000e2	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _offset$[ebp], eax

; 2724 :    hsz = get32le(s);

  000e8	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  000f1	83 c4 04	 add	 esp, 4
  000f4	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _hsz$[ebp], eax

; 2725 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) return epuc("unknown BMP", "BMP type not supported: unknown");

  000fa	83 bd b0 fb ff
	ff 0c		 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  00101	74 4d		 je	 SHORT $LN31@bmp_load
  00103	83 bd b0 fb ff
	ff 28		 cmp	 DWORD PTR _hsz$[ebp], 40 ; 00000028H
  0010a	74 44		 je	 SHORT $LN31@bmp_load
  0010c	83 bd b0 fb ff
	ff 38		 cmp	 DWORD PTR _hsz$[ebp], 56 ; 00000038H
  00113	74 3b		 je	 SHORT $LN31@bmp_load
  00115	83 bd b0 fb ff
	ff 6c		 cmp	 DWORD PTR _hsz$[ebp], 108 ; 0000006cH
  0011c	74 32		 je	 SHORT $LN31@bmp_load
  0011e	68 00 00 00 00	 push	 OFFSET $SG4294820159
  00123	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00128	83 c4 04	 add	 esp, 4
  0012b	85 c0		 test	 eax, eax
  0012d	74 0c		 je	 SHORT $LN93@bmp_load
  0012f	c7 85 5c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
  00139	eb 0a		 jmp	 SHORT $LN94@bmp_load
$LN93@bmp_load:
  0013b	c7 85 5c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
$LN94@bmp_load:
  00145	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR tv88[ebp]
  0014b	e9 a0 0f 00 00	 jmp	 $LN1@bmp_load
$LN31@bmp_load:

; 2726 :    if (hsz == 12) {

  00150	83 bd b0 fb ff
	ff 0c		 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  00157	75 25		 jne	 SHORT $LN32@bmp_load

; 2727 :       s->img_x = get16le(s);

  00159	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00162	83 c4 04	 add	 esp, 4
  00165	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00168	89 02		 mov	 DWORD PTR [edx], eax

; 2728 :       s->img_y = get16le(s);

  0016a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00173	83 c4 04	 add	 esp, 4
  00176	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00179	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2729 :    } else {

  0017c	eb 23		 jmp	 SHORT $LN33@bmp_load
$LN32@bmp_load:

; 2730 :       s->img_x = get32le(s);

  0017e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00187	83 c4 04	 add	 esp, 4
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0018d	89 01		 mov	 DWORD PTR [ecx], eax

; 2731 :       s->img_y = get32le(s);

  0018f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00198	83 c4 04	 add	 esp, 4
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0019e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN33@bmp_load:

; 2732 :    }
; 2733 :    if (get16le(s) != 1) return epuc("bad BMP", "bad BMP");

  001a1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  001aa	83 c4 04	 add	 esp, 4
  001ad	83 f8 01	 cmp	 eax, 1
  001b0	74 32		 je	 SHORT $LN34@bmp_load
  001b2	68 00 00 00 00	 push	 OFFSET $SG4294820158
  001b7	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	74 0c		 je	 SHORT $LN95@bmp_load
  001c3	c7 85 58 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
  001cd	eb 0a		 jmp	 SHORT $LN96@bmp_load
$LN95@bmp_load:
  001cf	c7 85 58 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN96@bmp_load:
  001d9	8b 85 58 fb ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  001df	e9 0c 0f 00 00	 jmp	 $LN1@bmp_load
$LN34@bmp_load:

; 2734 :    bpp = get16le(s);

  001e4	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  001ed	83 c4 04	 add	 esp, 4
  001f0	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _bpp$[ebp], eax

; 2735 :    if (bpp == 1) return epuc("monochrome", "BMP type not supported: 1-bit");

  001f6	83 bd c4 fb ff
	ff 01		 cmp	 DWORD PTR _bpp$[ebp], 1
  001fd	75 32		 jne	 SHORT $LN35@bmp_load
  001ff	68 00 00 00 00	 push	 OFFSET $SG4294820157
  00204	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00209	83 c4 04	 add	 esp, 4
  0020c	85 c0		 test	 eax, eax
  0020e	74 0c		 je	 SHORT $LN97@bmp_load
  00210	c7 85 54 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
  0021a	eb 0a		 jmp	 SHORT $LN98@bmp_load
$LN97@bmp_load:
  0021c	c7 85 54 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
$LN98@bmp_load:
  00226	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR tv147[ebp]
  0022c	e9 bf 0e 00 00	 jmp	 $LN1@bmp_load
$LN35@bmp_load:

; 2736 :    flip_vertically = ((int) s->img_y) > 0;

  00231	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00234	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00238	7e 0c		 jle	 SHORT $LN99@bmp_load
  0023a	c7 85 50 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv150[ebp], 1
  00244	eb 0a		 jmp	 SHORT $LN100@bmp_load
$LN99@bmp_load:
  00246	c7 85 50 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv150[ebp], 0
$LN100@bmp_load:
  00250	8b 95 50 fb ff
	ff		 mov	 edx, DWORD PTR tv150[ebp]
  00256	89 95 c0 fb ff
	ff		 mov	 DWORD PTR _flip_vertically$[ebp], edx

; 2737 :    s->img_y = abs((int) s->img_y);

  0025c	8b f4		 mov	 esi, esp
  0025e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00261	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00264	51		 push	 ecx
  00265	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abs
  0026b	83 c4 04	 add	 esp, 4
  0026e	3b f4		 cmp	 esi, esp
  00270	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00275	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00278	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 2738 :    if (hsz == 12) {

  0027b	83 bd b0 fb ff
	ff 0c		 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  00282	75 25		 jne	 SHORT $LN36@bmp_load

; 2739 :       if (bpp < 24)

  00284	83 bd c4 fb ff
	ff 18		 cmp	 DWORD PTR _bpp$[ebp], 24 ; 00000018H
  0028b	7d 17		 jge	 SHORT $LN38@bmp_load

; 2740 :          psize = (offset - 14 - 24) / 3;

  0028d	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _offset$[ebp]
  00293	83 e8 26	 sub	 eax, 38			; 00000026H
  00296	99		 cdq
  00297	b9 03 00 00 00	 mov	 ecx, 3
  0029c	f7 f9		 idiv	 ecx
  0029e	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _psize$[ebp], eax
$LN38@bmp_load:

; 2741 :    } else {

  002a4	e9 d1 02 00 00	 jmp	 $LN37@bmp_load
$LN36@bmp_load:

; 2742 :       compress = get32le(s);

  002a9	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  002b2	83 c4 04	 add	 esp, 4
  002b5	89 85 cc fb ff
	ff		 mov	 DWORD PTR _compress$[ebp], eax

; 2743 :       if (compress == 1 || compress == 2) return epuc("BMP RLE", "BMP type not supported: RLE");

  002bb	83 bd cc fb ff
	ff 01		 cmp	 DWORD PTR _compress$[ebp], 1
  002c2	74 09		 je	 SHORT $LN40@bmp_load
  002c4	83 bd cc fb ff
	ff 02		 cmp	 DWORD PTR _compress$[ebp], 2
  002cb	75 32		 jne	 SHORT $LN39@bmp_load
$LN40@bmp_load:
  002cd	68 00 00 00 00	 push	 OFFSET $SG4294820156
  002d2	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002d7	83 c4 04	 add	 esp, 4
  002da	85 c0		 test	 eax, eax
  002dc	74 0c		 je	 SHORT $LN101@bmp_load
  002de	c7 85 4c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv167[ebp], 0
  002e8	eb 0a		 jmp	 SHORT $LN102@bmp_load
$LN101@bmp_load:
  002ea	c7 85 4c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv167[ebp], 0
$LN102@bmp_load:
  002f4	8b 85 4c fb ff
	ff		 mov	 eax, DWORD PTR tv167[ebp]
  002fa	e9 f1 0d 00 00	 jmp	 $LN1@bmp_load
$LN39@bmp_load:

; 2744 :       get32le(s); // discard sizeof

  002ff	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00308	83 c4 04	 add	 esp, 4

; 2745 :       get32le(s); // discard hres

  0030b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00314	83 c4 04	 add	 esp, 4

; 2746 :       get32le(s); // discard vres

  00317	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0031a	52		 push	 edx
  0031b	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00320	83 c4 04	 add	 esp, 4

; 2747 :       get32le(s); // discard colorsused

  00323	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  0032c	83 c4 04	 add	 esp, 4

; 2748 :       get32le(s); // discard max important

  0032f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00332	51		 push	 ecx
  00333	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00338	83 c4 04	 add	 esp, 4

; 2749 :       if (hsz == 40 || hsz == 56) {

  0033b	83 bd b0 fb ff
	ff 28		 cmp	 DWORD PTR _hsz$[ebp], 40 ; 00000028H
  00342	74 0d		 je	 SHORT $LN43@bmp_load
  00344	83 bd b0 fb ff
	ff 38		 cmp	 DWORD PTR _hsz$[ebp], 56 ; 00000038H
  0034b	0f 85 64 01 00
	00		 jne	 $LN41@bmp_load
$LN43@bmp_load:

; 2750 :          if (hsz == 56) {

  00351	83 bd b0 fb ff
	ff 38		 cmp	 DWORD PTR _hsz$[ebp], 56 ; 00000038H
  00358	75 30		 jne	 SHORT $LN44@bmp_load

; 2751 :             get32le(s);

  0035a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0035d	52		 push	 edx
  0035e	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00363	83 c4 04	 add	 esp, 4

; 2752 :             get32le(s);

  00366	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  0036f	83 c4 04	 add	 esp, 4

; 2753 :             get32le(s);

  00372	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00375	51		 push	 ecx
  00376	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  0037b	83 c4 04	 add	 esp, 4

; 2754 :             get32le(s);

  0037e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00387	83 c4 04	 add	 esp, 4
$LN44@bmp_load:

; 2755 :          }
; 2756 :          if (bpp == 16 || bpp == 32) {

  0038a	83 bd c4 fb ff
	ff 10		 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  00391	74 0d		 je	 SHORT $LN46@bmp_load
  00393	83 bd c4 fb ff
	ff 20		 cmp	 DWORD PTR _bpp$[ebp], 32 ; 00000020H
  0039a	0f 85 10 01 00
	00		 jne	 $LN45@bmp_load
$LN46@bmp_load:

; 2757 :             mr = mg = mb = 0;

  003a0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mb$[ebp], 0
  003a7	8b 45 ec	 mov	 eax, DWORD PTR _mb$[ebp]
  003aa	89 45 f0	 mov	 DWORD PTR _mg$[ebp], eax
  003ad	8b 4d f0	 mov	 ecx, DWORD PTR _mg$[ebp]
  003b0	89 4d f4	 mov	 DWORD PTR _mr$[ebp], ecx

; 2758 :             if (compress == 0) {

  003b3	83 bd cc fb ff
	ff 00		 cmp	 DWORD PTR _compress$[ebp], 0
  003ba	75 48		 jne	 SHORT $LN47@bmp_load

; 2759 :                if (bpp == 32) {

  003bc	83 bd c4 fb ff
	ff 20		 cmp	 DWORD PTR _bpp$[ebp], 32 ; 00000020H
  003c3	75 25		 jne	 SHORT $LN49@bmp_load

; 2760 :                   mr = 0xffu << 16;

  003c5	c7 45 f4 00 00
	ff 00		 mov	 DWORD PTR _mr$[ebp], 16711680 ; 00ff0000H

; 2761 :                   mg = 0xffu <<  8;

  003cc	c7 45 f0 00 ff
	00 00		 mov	 DWORD PTR _mg$[ebp], 65280 ; 0000ff00H

; 2762 :                   mb = 0xffu <<  0;

  003d3	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR _mb$[ebp], 255 ; 000000ffH

; 2763 :                   ma = 0xffu << 24;

  003da	c7 45 e8 00 00
	00 ff		 mov	 DWORD PTR _ma$[ebp], -16777216 ; ff000000H

; 2764 :                   fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255

  003e1	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _fake_a$[ebp], 1

; 2765 :                } else {

  003e8	eb 15		 jmp	 SHORT $LN50@bmp_load
$LN49@bmp_load:

; 2766 :                   mr = 31u << 10;

  003ea	c7 45 f4 00 7c
	00 00		 mov	 DWORD PTR _mr$[ebp], 31744 ; 00007c00H

; 2767 :                   mg = 31u <<  5;

  003f1	c7 45 f0 e0 03
	00 00		 mov	 DWORD PTR _mg$[ebp], 992 ; 000003e0H

; 2768 :                   mb = 31u <<  0;

  003f8	c7 45 ec 1f 00
	00 00		 mov	 DWORD PTR _mb$[ebp], 31	; 0000001fH
$LN50@bmp_load:

; 2769 :                }

  003ff	e9 ac 00 00 00	 jmp	 $LN45@bmp_load
$LN47@bmp_load:

; 2770 :             } else if (compress == 3) {

  00404	83 bd cc fb ff
	ff 03		 cmp	 DWORD PTR _compress$[ebp], 3
  0040b	75 71		 jne	 SHORT $LN51@bmp_load

; 2771 :                mr = get32le(s);

  0040d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00410	52		 push	 edx
  00411	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00416	83 c4 04	 add	 esp, 4
  00419	89 45 f4	 mov	 DWORD PTR _mr$[ebp], eax

; 2772 :                mg = get32le(s);

  0041c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0041f	50		 push	 eax
  00420	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00425	83 c4 04	 add	 esp, 4
  00428	89 45 f0	 mov	 DWORD PTR _mg$[ebp], eax

; 2773 :                mb = get32le(s);

  0042b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0042e	51		 push	 ecx
  0042f	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00434	83 c4 04	 add	 esp, 4
  00437	89 45 ec	 mov	 DWORD PTR _mb$[ebp], eax

; 2774 :                // not documented, but generated by photoshop and handled by mspaint
; 2775 :                if (mr == mg && mg == mb) {

  0043a	8b 55 f4	 mov	 edx, DWORD PTR _mr$[ebp]
  0043d	3b 55 f0	 cmp	 edx, DWORD PTR _mg$[ebp]
  00440	75 3a		 jne	 SHORT $LN53@bmp_load
  00442	8b 45 f0	 mov	 eax, DWORD PTR _mg$[ebp]
  00445	3b 45 ec	 cmp	 eax, DWORD PTR _mb$[ebp]
  00448	75 32		 jne	 SHORT $LN53@bmp_load

; 2776 :                   // ?!?!?
; 2777 :                   return epuc("bad BMP", "bad BMP");

  0044a	68 00 00 00 00	 push	 OFFSET $SG4294820155
  0044f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00454	83 c4 04	 add	 esp, 4
  00457	85 c0		 test	 eax, eax
  00459	74 0c		 je	 SHORT $LN103@bmp_load
  0045b	c7 85 48 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
  00465	eb 0a		 jmp	 SHORT $LN104@bmp_load
$LN103@bmp_load:
  00467	c7 85 48 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN104@bmp_load:
  00471	8b 85 48 fb ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00477	e9 74 0c 00 00	 jmp	 $LN1@bmp_load
$LN53@bmp_load:

; 2778 :                }
; 2779 :             } else

  0047c	eb 32		 jmp	 SHORT $LN45@bmp_load
$LN51@bmp_load:

; 2780 :                return epuc("bad BMP", "bad BMP");

  0047e	68 00 00 00 00	 push	 OFFSET $SG4294820154
  00483	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00488	83 c4 04	 add	 esp, 4
  0048b	85 c0		 test	 eax, eax
  0048d	74 0c		 je	 SHORT $LN105@bmp_load
  0048f	c7 85 44 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv200[ebp], 0
  00499	eb 0a		 jmp	 SHORT $LN106@bmp_load
$LN105@bmp_load:
  0049b	c7 85 44 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv200[ebp], 0
$LN106@bmp_load:
  004a5	8b 85 44 fb ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  004ab	e9 40 0c 00 00	 jmp	 $LN1@bmp_load
$LN45@bmp_load:

; 2781 :          }
; 2782 :       } else {

  004b0	e9 a4 00 00 00	 jmp	 $LN42@bmp_load
$LN41@bmp_load:

; 2783 :          assert(hsz == 108);

  004b5	83 bd b0 fb ff
	ff 6c		 cmp	 DWORD PTR _hsz$[ebp], 108 ; 0000006cH
  004bc	74 21		 je	 SHORT $LN107@bmp_load
  004be	8b f4		 mov	 esi, esp
  004c0	68 df 0a 00 00	 push	 2783			; 00000adfH
  004c5	68 00 00 00 00	 push	 OFFSET $SG4294820153
  004ca	68 00 00 00 00	 push	 OFFSET $SG4294820152
  004cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  004d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d8	3b f4		 cmp	 esi, esp
  004da	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN107@bmp_load:

; 2784 :          mr = get32le(s);

  004df	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  004e2	52		 push	 edx
  004e3	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  004e8	83 c4 04	 add	 esp, 4
  004eb	89 45 f4	 mov	 DWORD PTR _mr$[ebp], eax

; 2785 :          mg = get32le(s);

  004ee	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  004f7	83 c4 04	 add	 esp, 4
  004fa	89 45 f0	 mov	 DWORD PTR _mg$[ebp], eax

; 2786 :          mb = get32le(s);

  004fd	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00500	51		 push	 ecx
  00501	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00506	83 c4 04	 add	 esp, 4
  00509	89 45 ec	 mov	 DWORD PTR _mb$[ebp], eax

; 2787 :          ma = get32le(s);

  0050c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0050f	52		 push	 edx
  00510	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00515	83 c4 04	 add	 esp, 4
  00518	89 45 e8	 mov	 DWORD PTR _ma$[ebp], eax

; 2788 :          get32le(s); // discard color space

  0051b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0051e	50		 push	 eax
  0051f	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00524	83 c4 04	 add	 esp, 4

; 2789 :          for (i=0; i < 12; ++i)

  00527	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00531	eb 0f		 jmp	 SHORT $LN4@bmp_load
$LN2@bmp_load:
  00533	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00539	83 c1 01	 add	 ecx, 1
  0053c	89 8d d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN4@bmp_load:
  00542	83 bd d4 fb ff
	ff 0c		 cmp	 DWORD PTR _i$[ebp], 12	; 0000000cH
  00549	7d 0e		 jge	 SHORT $LN42@bmp_load

; 2790 :             get32le(s); // discard color space parameters

  0054b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0054e	52		 push	 edx
  0054f	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00554	83 c4 04	 add	 esp, 4
  00557	eb da		 jmp	 SHORT $LN2@bmp_load
$LN42@bmp_load:

; 2791 :       }
; 2792 :       if (bpp < 16)

  00559	83 bd c4 fb ff
	ff 10		 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  00560	7d 18		 jge	 SHORT $LN37@bmp_load

; 2793 :          psize = (offset - 14 - hsz) >> 2;

  00562	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _offset$[ebp]
  00568	83 e8 0e	 sub	 eax, 14			; 0000000eH
  0056b	2b 85 b0 fb ff
	ff		 sub	 eax, DWORD PTR _hsz$[ebp]
  00571	c1 f8 02	 sar	 eax, 2
  00574	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _psize$[ebp], eax
$LN37@bmp_load:

; 2794 :    }
; 2795 :    s->img_n = ma ? 4 : 3;

  0057a	83 7d e8 00	 cmp	 DWORD PTR _ma$[ebp], 0
  0057e	74 0c		 je	 SHORT $LN108@bmp_load
  00580	c7 85 40 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR tv224[ebp], 4
  0058a	eb 0a		 jmp	 SHORT $LN109@bmp_load
$LN108@bmp_load:
  0058c	c7 85 40 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR tv224[ebp], 3
$LN109@bmp_load:
  00596	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00599	8b 95 40 fb ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  0059f	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2796 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

  005a2	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  005a6	74 11		 je	 SHORT $LN55@bmp_load
  005a8	83 7d 18 03	 cmp	 DWORD PTR _req_comp$[ebp], 3
  005ac	7c 0b		 jl	 SHORT $LN55@bmp_load

; 2797 :       target = req_comp;

  005ae	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  005b1	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _target$[ebp], eax

; 2798 :    else

  005b7	eb 0c		 jmp	 SHORT $LN56@bmp_load
$LN55@bmp_load:

; 2799 :       target = s->img_n; // if they want monochrome, we'll post-convert

  005b9	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  005bc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  005bf	89 95 b8 fb ff
	ff		 mov	 DWORD PTR _target$[ebp], edx
$LN56@bmp_load:

; 2800 :    out = (stbi_uc *) malloc(target * s->img_x * s->img_y);

  005c5	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  005c8	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _target$[ebp]
  005ce	0f af 08	 imul	 ecx, DWORD PTR [eax]
  005d1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  005d4	0f af 4a 04	 imul	 ecx, DWORD PTR [edx+4]
  005d8	8b f4		 mov	 esi, esp
  005da	51		 push	 ecx
  005db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005e1	83 c4 04	 add	 esp, 4
  005e4	3b f4		 cmp	 esi, esp
  005e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005eb	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 2801 :    if (!out) return epuc("outofmem", "Out of memory");

  005ee	83 7d f8 00	 cmp	 DWORD PTR _out$[ebp], 0
  005f2	75 32		 jne	 SHORT $LN57@bmp_load
  005f4	68 00 00 00 00	 push	 OFFSET $SG4294820151
  005f9	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  005fe	83 c4 04	 add	 esp, 4
  00601	85 c0		 test	 eax, eax
  00603	74 0c		 je	 SHORT $LN110@bmp_load
  00605	c7 85 3c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv241[ebp], 0
  0060f	eb 0a		 jmp	 SHORT $LN111@bmp_load
$LN110@bmp_load:
  00611	c7 85 3c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv241[ebp], 0
$LN111@bmp_load:
  0061b	8b 85 3c fb ff
	ff		 mov	 eax, DWORD PTR tv241[ebp]
  00621	e9 ca 0a 00 00	 jmp	 $LN1@bmp_load
$LN57@bmp_load:

; 2802 :    if (bpp < 16) {

  00626	83 bd c4 fb ff
	ff 10		 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  0062d	0f 8d 80 04 00
	00		 jge	 $LN58@bmp_load

; 2803 :       int z=0;

  00633	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$19[ebp], 0

; 2804 :       if (psize == 0 || psize > 256) { free(out); return epuc("invalid", "Corrupt BMP"); }

  0063d	83 bd d8 fb ff
	ff 00		 cmp	 DWORD PTR _psize$[ebp], 0
  00644	74 0c		 je	 SHORT $LN61@bmp_load
  00646	81 bd d8 fb ff
	ff 00 01 00 00	 cmp	 DWORD PTR _psize$[ebp], 256 ; 00000100H
  00650	7e 48		 jle	 SHORT $LN60@bmp_load
$LN61@bmp_load:
  00652	8b f4		 mov	 esi, esp
  00654	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00657	50		 push	 eax
  00658	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0065e	83 c4 04	 add	 esp, 4
  00661	3b f4		 cmp	 esi, esp
  00663	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00668	68 00 00 00 00	 push	 OFFSET $SG4294820150
  0066d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00672	83 c4 04	 add	 esp, 4
  00675	85 c0		 test	 eax, eax
  00677	74 0c		 je	 SHORT $LN112@bmp_load
  00679	c7 85 38 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv249[ebp], 0
  00683	eb 0a		 jmp	 SHORT $LN113@bmp_load
$LN112@bmp_load:
  00685	c7 85 38 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv249[ebp], 0
$LN113@bmp_load:
  0068f	8b 85 38 fb ff
	ff		 mov	 eax, DWORD PTR tv249[ebp]
  00695	e9 56 0a 00 00	 jmp	 $LN1@bmp_load
$LN60@bmp_load:

; 2805 :       for (i=0; i < psize; ++i) {

  0069a	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  006a4	eb 0f		 jmp	 SHORT $LN7@bmp_load
$LN5@bmp_load:
  006a6	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006ac	83 c1 01	 add	 ecx, 1
  006af	89 8d d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN7@bmp_load:
  006b5	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  006bb	3b 95 d8 fb ff
	ff		 cmp	 edx, DWORD PTR _psize$[ebp]
  006c1	0f 8d 9e 00 00
	00		 jge	 $LN6@bmp_load

; 2806 :          pal[i][2] = get8u(s);

  006c7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  006ca	50		 push	 eax
  006cb	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  006d0	83 c4 04	 add	 esp, 4
  006d3	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006d9	8d 94 8d e0 fb
	ff ff		 lea	 edx, DWORD PTR _pal$[ebp+ecx*4]
  006e0	b9 01 00 00 00	 mov	 ecx, 1
  006e5	d1 e1		 shl	 ecx, 1
  006e7	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2807 :          pal[i][1] = get8u(s);

  006ea	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  006ed	52		 push	 edx
  006ee	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  006f3	83 c4 04	 add	 esp, 4
  006f6	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006fc	8d 94 8d e0 fb
	ff ff		 lea	 edx, DWORD PTR _pal$[ebp+ecx*4]
  00703	b9 01 00 00 00	 mov	 ecx, 1
  00708	c1 e1 00	 shl	 ecx, 0
  0070b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2808 :          pal[i][0] = get8u(s);

  0070e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00711	52		 push	 edx
  00712	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00717	83 c4 04	 add	 esp, 4
  0071a	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00720	8d 94 8d e0 fb
	ff ff		 lea	 edx, DWORD PTR _pal$[ebp+ecx*4]
  00727	b9 01 00 00 00	 mov	 ecx, 1
  0072c	6b c9 00	 imul	 ecx, ecx, 0
  0072f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2809 :          if (hsz != 12) get8(s);

  00732	83 bd b0 fb ff
	ff 0c		 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  00739	74 0c		 je	 SHORT $LN62@bmp_load
  0073b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0073e	52		 push	 edx
  0073f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00744	83 c4 04	 add	 esp, 4
$LN62@bmp_load:

; 2810 :          pal[i][3] = 255;

  00747	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0074d	8d 8c 85 e0 fb
	ff ff		 lea	 ecx, DWORD PTR _pal$[ebp+eax*4]
  00754	ba 01 00 00 00	 mov	 edx, 1
  00759	6b c2 03	 imul	 eax, edx, 3
  0075c	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH

; 2811 :       }

  00760	e9 41 ff ff ff	 jmp	 $LN5@bmp_load
$LN6@bmp_load:

; 2812 :       skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));

  00765	83 bd b0 fb ff
	ff 0c		 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  0076c	75 0c		 jne	 SHORT $LN114@bmp_load
  0076e	c7 85 34 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR tv279[ebp], 3
  00778	eb 0a		 jmp	 SHORT $LN115@bmp_load
$LN114@bmp_load:
  0077a	c7 85 34 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR tv279[ebp], 4
$LN115@bmp_load:
  00784	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _offset$[ebp]
  0078a	83 e9 0e	 sub	 ecx, 14			; 0000000eH
  0078d	2b 8d b0 fb ff
	ff		 sub	 ecx, DWORD PTR _hsz$[ebp]
  00793	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _psize$[ebp]
  00799	0f af 95 34 fb
	ff ff		 imul	 edx, DWORD PTR tv279[ebp]
  007a0	2b ca		 sub	 ecx, edx
  007a2	51		 push	 ecx
  007a3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  007a6	50		 push	 eax
  007a7	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  007ac	83 c4 08	 add	 esp, 8

; 2813 :       if (bpp == 4) width = (s->img_x + 1) >> 1;

  007af	83 bd c4 fb ff
	ff 04		 cmp	 DWORD PTR _bpp$[ebp], 4
  007b6	75 12		 jne	 SHORT $LN63@bmp_load
  007b8	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  007bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  007bd	83 c2 01	 add	 edx, 1
  007c0	d1 ea		 shr	 edx, 1
  007c2	89 95 c8 fb ff
	ff		 mov	 DWORD PTR _width$[ebp], edx
  007c8	eb 5e		 jmp	 SHORT $LN64@bmp_load
$LN63@bmp_load:

; 2814 :       else if (bpp == 8) width = s->img_x;

  007ca	83 bd c4 fb ff
	ff 08		 cmp	 DWORD PTR _bpp$[ebp], 8
  007d1	75 0d		 jne	 SHORT $LN65@bmp_load
  007d3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  007d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  007d8	89 8d c8 fb ff
	ff		 mov	 DWORD PTR _width$[ebp], ecx
  007de	eb 48		 jmp	 SHORT $LN64@bmp_load
$LN65@bmp_load:

; 2815 :       else { free(out); return epuc("bad bpp", "Corrupt BMP"); }

  007e0	8b f4		 mov	 esi, esp
  007e2	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  007e5	52		 push	 edx
  007e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  007ec	83 c4 04	 add	 esp, 4
  007ef	3b f4		 cmp	 esi, esp
  007f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007f6	68 00 00 00 00	 push	 OFFSET $SG4294820149
  007fb	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00800	83 c4 04	 add	 esp, 4
  00803	85 c0		 test	 eax, eax
  00805	74 0c		 je	 SHORT $LN116@bmp_load
  00807	c7 85 30 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv294[ebp], 0
  00811	eb 0a		 jmp	 SHORT $LN117@bmp_load
$LN116@bmp_load:
  00813	c7 85 30 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv294[ebp], 0
$LN117@bmp_load:
  0081d	8b 85 30 fb ff
	ff		 mov	 eax, DWORD PTR tv294[ebp]
  00823	e9 c8 08 00 00	 jmp	 $LN1@bmp_load
$LN64@bmp_load:

; 2816 :       pad = (-width)&3;

  00828	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  0082e	f7 d8		 neg	 eax
  00830	83 e0 03	 and	 eax, 3
  00833	89 85 bc fb ff
	ff		 mov	 DWORD PTR _pad$[ebp], eax

; 2817 :       for (j=0; j < (int) s->img_y; ++j) {

  00839	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00843	eb 0f		 jmp	 SHORT $LN10@bmp_load
$LN8@bmp_load:
  00845	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0084b	83 c1 01	 add	 ecx, 1
  0084e	89 8d d0 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$LN10@bmp_load:
  00854	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00857	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  0085d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00860	0f 8d 48 02 00
	00		 jge	 $LN9@bmp_load

; 2818 :          for (i=0; i < (int) s->img_x; i += 2) {

  00866	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00870	eb 0f		 jmp	 SHORT $LN13@bmp_load
$LN11@bmp_load:
  00872	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00878	83 c1 02	 add	 ecx, 2
  0087b	89 8d d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN13@bmp_load:
  00881	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00884	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0088a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0088c	0f 8d 04 02 00
	00		 jge	 $LN12@bmp_load

; 2819 :             int v=get8(s),v2=0;

  00892	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00895	51		 push	 ecx
  00896	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0089b	83 c4 04	 add	 esp, 4
  0089e	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _v$18[ebp], eax
  008a4	c7 85 a4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _v2$17[ebp], 0

; 2820 :             if (bpp == 4) {

  008ae	83 bd c4 fb ff
	ff 04		 cmp	 DWORD PTR _bpp$[ebp], 4
  008b5	75 1e		 jne	 SHORT $LN67@bmp_load

; 2821 :                v2 = v & 15;

  008b7	8b 95 a8 fb ff
	ff		 mov	 edx, DWORD PTR _v$18[ebp]
  008bd	83 e2 0f	 and	 edx, 15			; 0000000fH
  008c0	89 95 a4 fb ff
	ff		 mov	 DWORD PTR _v2$17[ebp], edx

; 2822 :                v >>= 4;

  008c6	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _v$18[ebp]
  008cc	c1 f8 04	 sar	 eax, 4
  008cf	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _v$18[ebp], eax
$LN67@bmp_load:

; 2823 :             }
; 2824 :             out[z++] = pal[v][0];

  008d5	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _v$18[ebp]
  008db	8d 94 8d e0 fb
	ff ff		 lea	 edx, DWORD PTR _pal$[ebp+ecx*4]
  008e2	b8 01 00 00 00	 mov	 eax, 1
  008e7	6b c8 00	 imul	 ecx, eax, 0
  008ea	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  008ed	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  008f3	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  008f6	88 08		 mov	 BYTE PTR [eax], cl
  008f8	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  008fe	83 c2 01	 add	 edx, 1
  00901	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2825 :             out[z++] = pal[v][1];

  00907	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _v$18[ebp]
  0090d	8d 8c 85 e0 fb
	ff ff		 lea	 ecx, DWORD PTR _pal$[ebp+eax*4]
  00914	ba 01 00 00 00	 mov	 edx, 1
  00919	c1 e2 00	 shl	 edx, 0
  0091c	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  0091f	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  00925	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00928	88 08		 mov	 BYTE PTR [eax], cl
  0092a	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  00930	83 c2 01	 add	 edx, 1
  00933	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2826 :             out[z++] = pal[v][2];

  00939	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _v$18[ebp]
  0093f	8d 8c 85 e0 fb
	ff ff		 lea	 ecx, DWORD PTR _pal$[ebp+eax*4]
  00946	ba 01 00 00 00	 mov	 edx, 1
  0094b	d1 e2		 shl	 edx, 1
  0094d	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00950	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  00956	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00959	88 08		 mov	 BYTE PTR [eax], cl
  0095b	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  00961	83 c2 01	 add	 edx, 1
  00964	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2827 :             if (target == 4) out[z++] = 255;

  0096a	83 bd b8 fb ff
	ff 04		 cmp	 DWORD PTR _target$[ebp], 4
  00971	75 1b		 jne	 SHORT $LN68@bmp_load
  00973	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00976	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  0097c	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  0097f	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _z$19[ebp]
  00985	83 c1 01	 add	 ecx, 1
  00988	89 8d ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], ecx
$LN68@bmp_load:

; 2828 :             if (i+1 == (int) s->img_x) break;

  0098e	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00994	83 c2 01	 add	 edx, 1
  00997	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0099a	3b 10		 cmp	 edx, DWORD PTR [eax]
  0099c	75 05		 jne	 SHORT $LN69@bmp_load
  0099e	e9 f3 00 00 00	 jmp	 $LN12@bmp_load
$LN69@bmp_load:

; 2829 :             v = (bpp == 8) ? get8(s) : v2;

  009a3	83 bd c4 fb ff
	ff 08		 cmp	 DWORD PTR _bpp$[ebp], 8
  009aa	75 14		 jne	 SHORT $LN118@bmp_load
  009ac	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  009af	51		 push	 ecx
  009b0	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  009b5	83 c4 04	 add	 esp, 4
  009b8	89 85 2c fb ff
	ff		 mov	 DWORD PTR tv339[ebp], eax
  009be	eb 0c		 jmp	 SHORT $LN119@bmp_load
$LN118@bmp_load:
  009c0	8b 95 a4 fb ff
	ff		 mov	 edx, DWORD PTR _v2$17[ebp]
  009c6	89 95 2c fb ff
	ff		 mov	 DWORD PTR tv339[ebp], edx
$LN119@bmp_load:
  009cc	8b 85 2c fb ff
	ff		 mov	 eax, DWORD PTR tv339[ebp]
  009d2	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _v$18[ebp], eax

; 2830 :             out[z++] = pal[v][0];

  009d8	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _v$18[ebp]
  009de	8d 94 8d e0 fb
	ff ff		 lea	 edx, DWORD PTR _pal$[ebp+ecx*4]
  009e5	b8 01 00 00 00	 mov	 eax, 1
  009ea	6b c8 00	 imul	 ecx, eax, 0
  009ed	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  009f0	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  009f6	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  009f9	88 08		 mov	 BYTE PTR [eax], cl
  009fb	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  00a01	83 c2 01	 add	 edx, 1
  00a04	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2831 :             out[z++] = pal[v][1];

  00a0a	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _v$18[ebp]
  00a10	8d 8c 85 e0 fb
	ff ff		 lea	 ecx, DWORD PTR _pal$[ebp+eax*4]
  00a17	ba 01 00 00 00	 mov	 edx, 1
  00a1c	c1 e2 00	 shl	 edx, 0
  00a1f	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00a22	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  00a28	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00a2b	88 08		 mov	 BYTE PTR [eax], cl
  00a2d	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  00a33	83 c2 01	 add	 edx, 1
  00a36	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2832 :             out[z++] = pal[v][2];

  00a3c	8b 85 a8 fb ff
	ff		 mov	 eax, DWORD PTR _v$18[ebp]
  00a42	8d 8c 85 e0 fb
	ff ff		 lea	 ecx, DWORD PTR _pal$[ebp+eax*4]
  00a49	ba 01 00 00 00	 mov	 edx, 1
  00a4e	d1 e2		 shl	 edx, 1
  00a50	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00a53	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  00a59	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00a5c	88 08		 mov	 BYTE PTR [eax], cl
  00a5e	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _z$19[ebp]
  00a64	83 c2 01	 add	 edx, 1
  00a67	89 95 ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], edx

; 2833 :             if (target == 4) out[z++] = 255;

  00a6d	83 bd b8 fb ff
	ff 04		 cmp	 DWORD PTR _target$[ebp], 4
  00a74	75 1b		 jne	 SHORT $LN70@bmp_load
  00a76	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00a79	03 85 ac fb ff
	ff		 add	 eax, DWORD PTR _z$19[ebp]
  00a7f	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  00a82	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _z$19[ebp]
  00a88	83 c1 01	 add	 ecx, 1
  00a8b	89 8d ac fb ff
	ff		 mov	 DWORD PTR _z$19[ebp], ecx
$LN70@bmp_load:

; 2834 :          }

  00a91	e9 dc fd ff ff	 jmp	 $LN11@bmp_load
$LN12@bmp_load:

; 2835 :          skip(s, pad);

  00a96	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _pad$[ebp]
  00a9c	52		 push	 edx
  00a9d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00aa0	50		 push	 eax
  00aa1	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00aa6	83 c4 08	 add	 esp, 8

; 2836 :       }

  00aa9	e9 97 fd ff ff	 jmp	 $LN8@bmp_load
$LN9@bmp_load:

; 2837 :    } else {

  00aae	e9 da 04 00 00	 jmp	 $LN59@bmp_load
$LN58@bmp_load:

; 2838 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;

  00ab3	c7 85 a0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _rshift$16[ebp], 0
  00abd	c7 85 9c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _gshift$15[ebp], 0
  00ac7	c7 85 98 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _bshift$14[ebp], 0
  00ad1	c7 85 94 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _ashift$13[ebp], 0
  00adb	c7 85 90 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _rcount$12[ebp], 0
  00ae5	c7 85 8c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _gcount$11[ebp], 0
  00aef	c7 85 88 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _bcount$10[ebp], 0
  00af9	c7 85 84 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _acount$9[ebp], 0

; 2839 :       int z = 0;

  00b03	c7 85 80 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$8[ebp], 0

; 2840 :       int easy=0;

  00b0d	c7 85 7c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _easy$7[ebp], 0

; 2841 :       skip(s, offset - 14 - hsz);

  00b17	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _offset$[ebp]
  00b1d	83 e9 0e	 sub	 ecx, 14			; 0000000eH
  00b20	2b 8d b0 fb ff
	ff		 sub	 ecx, DWORD PTR _hsz$[ebp]
  00b26	51		 push	 ecx
  00b27	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00b2a	52		 push	 edx
  00b2b	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00b30	83 c4 08	 add	 esp, 8

; 2842 :       if (bpp == 24) width = 3 * s->img_x;

  00b33	83 bd c4 fb ff
	ff 18		 cmp	 DWORD PTR _bpp$[ebp], 24 ; 00000018H
  00b3a	75 0e		 jne	 SHORT $LN71@bmp_load
  00b3c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00b3f	6b 08 03	 imul	 ecx, DWORD PTR [eax], 3
  00b42	89 8d c8 fb ff
	ff		 mov	 DWORD PTR _width$[ebp], ecx
  00b48	eb 22		 jmp	 SHORT $LN72@bmp_load
$LN71@bmp_load:

; 2843 :       else if (bpp == 16) width = 2*s->img_x;

  00b4a	83 bd c4 fb ff
	ff 10		 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  00b51	75 0f		 jne	 SHORT $LN73@bmp_load
  00b53	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00b56	8b 02		 mov	 eax, DWORD PTR [edx]
  00b58	d1 e0		 shl	 eax, 1
  00b5a	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _width$[ebp], eax
  00b60	eb 0a		 jmp	 SHORT $LN72@bmp_load
$LN73@bmp_load:

; 2844 :       else /* bpp = 32 and pad = 0 */ width=0;

  00b62	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _width$[ebp], 0
$LN72@bmp_load:

; 2845 :       pad = (-width) & 3;

  00b6c	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _width$[ebp]
  00b72	f7 d9		 neg	 ecx
  00b74	83 e1 03	 and	 ecx, 3
  00b77	89 8d bc fb ff
	ff		 mov	 DWORD PTR _pad$[ebp], ecx

; 2846 :       if (bpp == 24) {

  00b7d	83 bd c4 fb ff
	ff 18		 cmp	 DWORD PTR _bpp$[ebp], 24 ; 00000018H
  00b84	75 0c		 jne	 SHORT $LN75@bmp_load

; 2847 :          easy = 1;

  00b86	c7 85 7c fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _easy$7[ebp], 1
  00b90	eb 37		 jmp	 SHORT $LN76@bmp_load
$LN75@bmp_load:

; 2848 :       } else if (bpp == 32) {

  00b92	83 bd c4 fb ff
	ff 20		 cmp	 DWORD PTR _bpp$[ebp], 32 ; 00000020H
  00b99	75 2e		 jne	 SHORT $LN76@bmp_load

; 2849 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

  00b9b	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _mb$[ebp], 255 ; 000000ffH
  00ba2	75 25		 jne	 SHORT $LN76@bmp_load
  00ba4	81 7d f0 00 ff
	00 00		 cmp	 DWORD PTR _mg$[ebp], 65280 ; 0000ff00H
  00bab	75 1c		 jne	 SHORT $LN76@bmp_load
  00bad	81 7d f4 00 00
	ff 00		 cmp	 DWORD PTR _mr$[ebp], 16711680 ; 00ff0000H
  00bb4	75 13		 jne	 SHORT $LN76@bmp_load
  00bb6	81 7d e8 00 00
	00 ff		 cmp	 DWORD PTR _ma$[ebp], -16777216 ; ff000000H
  00bbd	75 0a		 jne	 SHORT $LN76@bmp_load

; 2850 :             easy = 2;

  00bbf	c7 85 7c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _easy$7[ebp], 2
$LN76@bmp_load:

; 2851 :       }
; 2852 :       if (!easy) {

  00bc9	83 bd 7c fb ff
	ff 00		 cmp	 DWORD PTR _easy$7[ebp], 0
  00bd0	0f 85 f6 00 00
	00		 jne	 $LN79@bmp_load

; 2853 :          if (!mr || !mg || !mb) { free(out); return epuc("bad masks", "Corrupt BMP"); }

  00bd6	83 7d f4 00	 cmp	 DWORD PTR _mr$[ebp], 0
  00bda	74 0c		 je	 SHORT $LN81@bmp_load
  00bdc	83 7d f0 00	 cmp	 DWORD PTR _mg$[ebp], 0
  00be0	74 06		 je	 SHORT $LN81@bmp_load
  00be2	83 7d ec 00	 cmp	 DWORD PTR _mb$[ebp], 0
  00be6	75 48		 jne	 SHORT $LN80@bmp_load
$LN81@bmp_load:
  00be8	8b f4		 mov	 esi, esp
  00bea	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00bed	52		 push	 edx
  00bee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00bf4	83 c4 04	 add	 esp, 4
  00bf7	3b f4		 cmp	 esi, esp
  00bf9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bfe	68 00 00 00 00	 push	 OFFSET $SG4294820148
  00c03	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00c08	83 c4 04	 add	 esp, 4
  00c0b	85 c0		 test	 eax, eax
  00c0d	74 0c		 je	 SHORT $LN120@bmp_load
  00c0f	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv425[ebp], 0
  00c19	eb 0a		 jmp	 SHORT $LN121@bmp_load
$LN120@bmp_load:
  00c1b	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv425[ebp], 0
$LN121@bmp_load:
  00c25	8b 85 28 fb ff
	ff		 mov	 eax, DWORD PTR tv425[ebp]
  00c2b	e9 c0 04 00 00	 jmp	 $LN1@bmp_load
$LN80@bmp_load:

; 2854 :          // right shift amt to put high bit in position #7
; 2855 :          rshift = high_bit(mr)-7; rcount = bitcount(mr);

  00c30	8b 45 f4	 mov	 eax, DWORD PTR _mr$[ebp]
  00c33	50		 push	 eax
  00c34	e8 00 00 00 00	 call	 ?high_bit@@YAHI@Z	; high_bit
  00c39	83 c4 04	 add	 esp, 4
  00c3c	83 e8 07	 sub	 eax, 7
  00c3f	89 85 a0 fb ff
	ff		 mov	 DWORD PTR _rshift$16[ebp], eax
  00c45	8b 4d f4	 mov	 ecx, DWORD PTR _mr$[ebp]
  00c48	51		 push	 ecx
  00c49	e8 00 00 00 00	 call	 ?bitcount@@YAHI@Z	; bitcount
  00c4e	83 c4 04	 add	 esp, 4
  00c51	89 85 90 fb ff
	ff		 mov	 DWORD PTR _rcount$12[ebp], eax

; 2856 :          gshift = high_bit(mg)-7; gcount = bitcount(mr);

  00c57	8b 55 f0	 mov	 edx, DWORD PTR _mg$[ebp]
  00c5a	52		 push	 edx
  00c5b	e8 00 00 00 00	 call	 ?high_bit@@YAHI@Z	; high_bit
  00c60	83 c4 04	 add	 esp, 4
  00c63	83 e8 07	 sub	 eax, 7
  00c66	89 85 9c fb ff
	ff		 mov	 DWORD PTR _gshift$15[ebp], eax
  00c6c	8b 45 f4	 mov	 eax, DWORD PTR _mr$[ebp]
  00c6f	50		 push	 eax
  00c70	e8 00 00 00 00	 call	 ?bitcount@@YAHI@Z	; bitcount
  00c75	83 c4 04	 add	 esp, 4
  00c78	89 85 8c fb ff
	ff		 mov	 DWORD PTR _gcount$11[ebp], eax

; 2857 :          bshift = high_bit(mb)-7; bcount = bitcount(mr);

  00c7e	8b 4d ec	 mov	 ecx, DWORD PTR _mb$[ebp]
  00c81	51		 push	 ecx
  00c82	e8 00 00 00 00	 call	 ?high_bit@@YAHI@Z	; high_bit
  00c87	83 c4 04	 add	 esp, 4
  00c8a	83 e8 07	 sub	 eax, 7
  00c8d	89 85 98 fb ff
	ff		 mov	 DWORD PTR _bshift$14[ebp], eax
  00c93	8b 55 f4	 mov	 edx, DWORD PTR _mr$[ebp]
  00c96	52		 push	 edx
  00c97	e8 00 00 00 00	 call	 ?bitcount@@YAHI@Z	; bitcount
  00c9c	83 c4 04	 add	 esp, 4
  00c9f	89 85 88 fb ff
	ff		 mov	 DWORD PTR _bcount$10[ebp], eax

; 2858 :          ashift = high_bit(ma)-7; acount = bitcount(mr);

  00ca5	8b 45 e8	 mov	 eax, DWORD PTR _ma$[ebp]
  00ca8	50		 push	 eax
  00ca9	e8 00 00 00 00	 call	 ?high_bit@@YAHI@Z	; high_bit
  00cae	83 c4 04	 add	 esp, 4
  00cb1	83 e8 07	 sub	 eax, 7
  00cb4	89 85 94 fb ff
	ff		 mov	 DWORD PTR _ashift$13[ebp], eax
  00cba	8b 4d f4	 mov	 ecx, DWORD PTR _mr$[ebp]
  00cbd	51		 push	 ecx
  00cbe	e8 00 00 00 00	 call	 ?bitcount@@YAHI@Z	; bitcount
  00cc3	83 c4 04	 add	 esp, 4
  00cc6	89 85 84 fb ff
	ff		 mov	 DWORD PTR _acount$9[ebp], eax
$LN79@bmp_load:

; 2859 :       }
; 2860 :       for (j=0; j < (int) s->img_y; ++j) {

  00ccc	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00cd6	eb 0f		 jmp	 SHORT $LN16@bmp_load
$LN14@bmp_load:
  00cd8	8b 95 d0 fb ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00cde	83 c2 01	 add	 edx, 1
  00ce1	89 95 d0 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$LN16@bmp_load:
  00ce7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00cea	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00cf0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00cf3	0f 8d 94 02 00
	00		 jge	 $LN59@bmp_load

; 2861 :          if (easy) {

  00cf9	83 bd 7c fb ff
	ff 00		 cmp	 DWORD PTR _easy$7[ebp], 0
  00d00	0f 84 e8 00 00
	00		 je	 $LN82@bmp_load

; 2862 :             for (i=0; i < (int) s->img_x; ++i) {

  00d06	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00d10	eb 0f		 jmp	 SHORT $LN19@bmp_load
$LN17@bmp_load:
  00d12	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00d18	83 c2 01	 add	 edx, 1
  00d1b	89 95 d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN19@bmp_load:
  00d21	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00d24	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00d2a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00d2c	0f 8d b7 00 00
	00		 jge	 $LN18@bmp_load

; 2863 :                int a;
; 2864 :                out[z+2] = get8u(s);

  00d32	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00d35	52		 push	 edx
  00d36	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00d3b	83 c4 04	 add	 esp, 4
  00d3e	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00d41	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00d47	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 2865 :                out[z+1] = get8u(s);

  00d4a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00d4d	52		 push	 edx
  00d4e	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00d53	83 c4 04	 add	 esp, 4
  00d56	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00d59	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00d5f	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 2866 :                out[z+0] = get8u(s);

  00d62	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00d65	52		 push	 edx
  00d66	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00d6b	83 c4 04	 add	 esp, 4
  00d6e	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00d71	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00d77	88 01		 mov	 BYTE PTR [ecx], al

; 2867 :                z += 3;

  00d79	8b 95 80 fb ff
	ff		 mov	 edx, DWORD PTR _z$8[ebp]
  00d7f	83 c2 03	 add	 edx, 3
  00d82	89 95 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], edx

; 2868 :                a = (easy == 2 ? get8(s) : 255);

  00d88	83 bd 7c fb ff
	ff 02		 cmp	 DWORD PTR _easy$7[ebp], 2
  00d8f	75 14		 jne	 SHORT $LN122@bmp_load
  00d91	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00d94	50		 push	 eax
  00d95	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00d9a	83 c4 04	 add	 esp, 4
  00d9d	89 85 24 fb ff
	ff		 mov	 DWORD PTR tv472[ebp], eax
  00da3	eb 0a		 jmp	 SHORT $LN123@bmp_load
$LN122@bmp_load:
  00da5	c7 85 24 fb ff
	ff ff 00 00 00	 mov	 DWORD PTR tv472[ebp], 255 ; 000000ffH
$LN123@bmp_load:
  00daf	8b 8d 24 fb ff
	ff		 mov	 ecx, DWORD PTR tv472[ebp]
  00db5	89 8d 78 fb ff
	ff		 mov	 DWORD PTR _a$6[ebp], ecx

; 2869 :                if (target == 4) out[z++] = (uint8) a;

  00dbb	83 bd b8 fb ff
	ff 04		 cmp	 DWORD PTR _target$[ebp], 4
  00dc2	75 20		 jne	 SHORT $LN84@bmp_load
  00dc4	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00dc7	03 95 80 fb ff
	ff		 add	 edx, DWORD PTR _z$8[ebp]
  00dcd	8a 85 78 fb ff
	ff		 mov	 al, BYTE PTR _a$6[ebp]
  00dd3	88 02		 mov	 BYTE PTR [edx], al
  00dd5	8b 8d 80 fb ff
	ff		 mov	 ecx, DWORD PTR _z$8[ebp]
  00ddb	83 c1 01	 add	 ecx, 1
  00dde	89 8d 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], ecx
$LN84@bmp_load:

; 2870 :             }

  00de4	e9 29 ff ff ff	 jmp	 $LN17@bmp_load
$LN18@bmp_load:

; 2871 :          } else {

  00de9	e9 87 01 00 00	 jmp	 $LN83@bmp_load
$LN82@bmp_load:

; 2872 :             for (i=0; i < (int) s->img_x; ++i) {

  00dee	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00df8	eb 0f		 jmp	 SHORT $LN22@bmp_load
$LN20@bmp_load:
  00dfa	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00e00	83 c2 01	 add	 edx, 1
  00e03	89 95 d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN22@bmp_load:
  00e09	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00e0c	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00e12	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00e14	0f 8d 5b 01 00
	00		 jge	 $LN83@bmp_load

; 2873 :                uint32 v = (bpp == 16 ? get16le(s) : get32le(s));

  00e1a	83 bd c4 fb ff
	ff 10		 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  00e21	75 14		 jne	 SHORT $LN124@bmp_load
  00e23	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00e26	52		 push	 edx
  00e27	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00e2c	83 c4 04	 add	 esp, 4
  00e2f	89 85 20 fb ff
	ff		 mov	 DWORD PTR tv485[ebp], eax
  00e35	eb 12		 jmp	 SHORT $LN125@bmp_load
$LN124@bmp_load:
  00e37	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00e3a	50		 push	 eax
  00e3b	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00e40	83 c4 04	 add	 esp, 4
  00e43	89 85 20 fb ff
	ff		 mov	 DWORD PTR tv485[ebp], eax
$LN125@bmp_load:
  00e49	8b 8d 20 fb ff
	ff		 mov	 ecx, DWORD PTR tv485[ebp]
  00e4f	89 8d 74 fb ff
	ff		 mov	 DWORD PTR _v$5[ebp], ecx

; 2874 :                int a;
; 2875 :                out[z++] = (uint8) shiftsigned(v & mr, rshift, rcount);

  00e55	8b 95 90 fb ff
	ff		 mov	 edx, DWORD PTR _rcount$12[ebp]
  00e5b	52		 push	 edx
  00e5c	8b 85 a0 fb ff
	ff		 mov	 eax, DWORD PTR _rshift$16[ebp]
  00e62	50		 push	 eax
  00e63	8b 8d 74 fb ff
	ff		 mov	 ecx, DWORD PTR _v$5[ebp]
  00e69	23 4d f4	 and	 ecx, DWORD PTR _mr$[ebp]
  00e6c	51		 push	 ecx
  00e6d	e8 00 00 00 00	 call	 ?shiftsigned@@YAHHHH@Z	; shiftsigned
  00e72	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e75	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00e78	03 95 80 fb ff
	ff		 add	 edx, DWORD PTR _z$8[ebp]
  00e7e	88 02		 mov	 BYTE PTR [edx], al
  00e80	8b 85 80 fb ff
	ff		 mov	 eax, DWORD PTR _z$8[ebp]
  00e86	83 c0 01	 add	 eax, 1
  00e89	89 85 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], eax

; 2876 :                out[z++] = (uint8) shiftsigned(v & mg, gshift, gcount);

  00e8f	8b 8d 8c fb ff
	ff		 mov	 ecx, DWORD PTR _gcount$11[ebp]
  00e95	51		 push	 ecx
  00e96	8b 95 9c fb ff
	ff		 mov	 edx, DWORD PTR _gshift$15[ebp]
  00e9c	52		 push	 edx
  00e9d	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _v$5[ebp]
  00ea3	23 45 f0	 and	 eax, DWORD PTR _mg$[ebp]
  00ea6	50		 push	 eax
  00ea7	e8 00 00 00 00	 call	 ?shiftsigned@@YAHHHH@Z	; shiftsigned
  00eac	83 c4 0c	 add	 esp, 12			; 0000000cH
  00eaf	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00eb2	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00eb8	88 01		 mov	 BYTE PTR [ecx], al
  00eba	8b 95 80 fb ff
	ff		 mov	 edx, DWORD PTR _z$8[ebp]
  00ec0	83 c2 01	 add	 edx, 1
  00ec3	89 95 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], edx

; 2877 :                out[z++] = (uint8) shiftsigned(v & mb, bshift, bcount);

  00ec9	8b 85 88 fb ff
	ff		 mov	 eax, DWORD PTR _bcount$10[ebp]
  00ecf	50		 push	 eax
  00ed0	8b 8d 98 fb ff
	ff		 mov	 ecx, DWORD PTR _bshift$14[ebp]
  00ed6	51		 push	 ecx
  00ed7	8b 95 74 fb ff
	ff		 mov	 edx, DWORD PTR _v$5[ebp]
  00edd	23 55 ec	 and	 edx, DWORD PTR _mb$[ebp]
  00ee0	52		 push	 edx
  00ee1	e8 00 00 00 00	 call	 ?shiftsigned@@YAHHHH@Z	; shiftsigned
  00ee6	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ee9	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00eec	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00ef2	88 01		 mov	 BYTE PTR [ecx], al
  00ef4	8b 95 80 fb ff
	ff		 mov	 edx, DWORD PTR _z$8[ebp]
  00efa	83 c2 01	 add	 edx, 1
  00efd	89 95 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], edx

; 2878 :                a = (ma ? shiftsigned(v & ma, ashift, acount) : 255);

  00f03	83 7d e8 00	 cmp	 DWORD PTR _ma$[ebp], 0
  00f07	74 28		 je	 SHORT $LN126@bmp_load
  00f09	8b 85 84 fb ff
	ff		 mov	 eax, DWORD PTR _acount$9[ebp]
  00f0f	50		 push	 eax
  00f10	8b 8d 94 fb ff
	ff		 mov	 ecx, DWORD PTR _ashift$13[ebp]
  00f16	51		 push	 ecx
  00f17	8b 95 74 fb ff
	ff		 mov	 edx, DWORD PTR _v$5[ebp]
  00f1d	23 55 e8	 and	 edx, DWORD PTR _ma$[ebp]
  00f20	52		 push	 edx
  00f21	e8 00 00 00 00	 call	 ?shiftsigned@@YAHHHH@Z	; shiftsigned
  00f26	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f29	89 85 1c fb ff
	ff		 mov	 DWORD PTR tv519[ebp], eax
  00f2f	eb 0a		 jmp	 SHORT $LN127@bmp_load
$LN126@bmp_load:
  00f31	c7 85 1c fb ff
	ff ff 00 00 00	 mov	 DWORD PTR tv519[ebp], 255 ; 000000ffH
$LN127@bmp_load:
  00f3b	8b 85 1c fb ff
	ff		 mov	 eax, DWORD PTR tv519[ebp]
  00f41	89 85 70 fb ff
	ff		 mov	 DWORD PTR _a$4[ebp], eax

; 2879 :                if (target == 4) out[z++] = (uint8) a; 

  00f47	83 bd b8 fb ff
	ff 04		 cmp	 DWORD PTR _target$[ebp], 4
  00f4e	75 20		 jne	 SHORT $LN85@bmp_load
  00f50	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00f53	03 8d 80 fb ff
	ff		 add	 ecx, DWORD PTR _z$8[ebp]
  00f59	8a 95 70 fb ff
	ff		 mov	 dl, BYTE PTR _a$4[ebp]
  00f5f	88 11		 mov	 BYTE PTR [ecx], dl
  00f61	8b 85 80 fb ff
	ff		 mov	 eax, DWORD PTR _z$8[ebp]
  00f67	83 c0 01	 add	 eax, 1
  00f6a	89 85 80 fb ff
	ff		 mov	 DWORD PTR _z$8[ebp], eax
$LN85@bmp_load:

; 2880 :             }

  00f70	e9 85 fe ff ff	 jmp	 $LN20@bmp_load
$LN83@bmp_load:

; 2881 :          }
; 2882 :          skip(s, pad);

  00f75	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _pad$[ebp]
  00f7b	51		 push	 ecx
  00f7c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00f7f	52		 push	 edx
  00f80	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00f85	83 c4 08	 add	 esp, 8

; 2883 :       }

  00f88	e9 4b fd ff ff	 jmp	 $LN14@bmp_load
$LN59@bmp_load:

; 2884 :    }
; 2885 :    if (flip_vertically) {

  00f8d	83 bd c0 fb ff
	ff 00		 cmp	 DWORD PTR _flip_vertically$[ebp], 0
  00f94	0f 84 ea 00 00
	00		 je	 $LN86@bmp_load

; 2886 :       stbi_uc t;
; 2887 :       for (j=0; j < (int) s->img_y>>1; ++j) {

  00f9a	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00fa4	eb 0f		 jmp	 SHORT $LN25@bmp_load
$LN23@bmp_load:
  00fa6	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00fac	83 c0 01	 add	 eax, 1
  00faf	89 85 d0 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN25@bmp_load:
  00fb5	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00fb8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00fbb	d1 fa		 sar	 edx, 1
  00fbd	39 95 d0 fb ff
	ff		 cmp	 DWORD PTR _j$[ebp], edx
  00fc3	0f 8d bb 00 00
	00		 jge	 $LN86@bmp_load

; 2888 :          stbi_uc *p1 = out +      j     *s->img_x*target;

  00fc9	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00fcc	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00fd2	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00fd5	0f af 8d b8 fb
	ff ff		 imul	 ecx, DWORD PTR _target$[ebp]
  00fdc	03 4d f8	 add	 ecx, DWORD PTR _out$[ebp]
  00fdf	89 8d 68 fb ff
	ff		 mov	 DWORD PTR _p1$2[ebp], ecx

; 2889 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

  00fe5	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00fe8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00feb	83 e8 01	 sub	 eax, 1
  00fee	2b 85 d0 fb ff
	ff		 sub	 eax, DWORD PTR _j$[ebp]
  00ff4	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00ff7	0f af 01	 imul	 eax, DWORD PTR [ecx]
  00ffa	0f af 85 b8 fb
	ff ff		 imul	 eax, DWORD PTR _target$[ebp]
  01001	03 45 f8	 add	 eax, DWORD PTR _out$[ebp]
  01004	89 85 64 fb ff
	ff		 mov	 DWORD PTR _p2$1[ebp], eax

; 2890 :          for (i=0; i < (int) s->img_x*target; ++i) {

  0100a	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  01014	eb 0f		 jmp	 SHORT $LN28@bmp_load
$LN26@bmp_load:
  01016	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0101c	83 c2 01	 add	 edx, 1
  0101f	89 95 d4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN28@bmp_load:
  01025	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  01028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0102a	0f af 8d b8 fb
	ff ff		 imul	 ecx, DWORD PTR _target$[ebp]
  01031	39 8d d4 fb ff
	ff		 cmp	 DWORD PTR _i$[ebp], ecx
  01037	7d 46		 jge	 SHORT $LN27@bmp_load

; 2891 :             t = p1[i], p1[i] = p2[i], p2[i] = t;

  01039	8b 95 68 fb ff
	ff		 mov	 edx, DWORD PTR _p1$2[ebp]
  0103f	03 95 d4 fb ff
	ff		 add	 edx, DWORD PTR _i$[ebp]
  01045	8a 02		 mov	 al, BYTE PTR [edx]
  01047	88 85 6f fb ff
	ff		 mov	 BYTE PTR _t$3[ebp], al
  0104d	8b 8d 68 fb ff
	ff		 mov	 ecx, DWORD PTR _p1$2[ebp]
  01053	03 8d d4 fb ff
	ff		 add	 ecx, DWORD PTR _i$[ebp]
  01059	8b 95 64 fb ff
	ff		 mov	 edx, DWORD PTR _p2$1[ebp]
  0105f	03 95 d4 fb ff
	ff		 add	 edx, DWORD PTR _i$[ebp]
  01065	8a 02		 mov	 al, BYTE PTR [edx]
  01067	88 01		 mov	 BYTE PTR [ecx], al
  01069	8b 8d 64 fb ff
	ff		 mov	 ecx, DWORD PTR _p2$1[ebp]
  0106f	03 8d d4 fb ff
	ff		 add	 ecx, DWORD PTR _i$[ebp]
  01075	8a 95 6f fb ff
	ff		 mov	 dl, BYTE PTR _t$3[ebp]
  0107b	88 11		 mov	 BYTE PTR [ecx], dl

; 2892 :          }

  0107d	eb 97		 jmp	 SHORT $LN26@bmp_load
$LN27@bmp_load:

; 2893 :       }

  0107f	e9 22 ff ff ff	 jmp	 $LN23@bmp_load
$LN86@bmp_load:

; 2894 :    }
; 2895 : 
; 2896 :    if (req_comp && req_comp != target) {

  01084	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  01088	74 3d		 je	 SHORT $LN87@bmp_load
  0108a	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  0108d	3b 85 b8 fb ff
	ff		 cmp	 eax, DWORD PTR _target$[ebp]
  01093	74 32		 je	 SHORT $LN87@bmp_load

; 2897 :       out = convert_format(out, target, req_comp, s->img_x, s->img_y);

  01095	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  01098	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0109b	52		 push	 edx
  0109c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0109f	8b 08		 mov	 ecx, DWORD PTR [eax]
  010a1	51		 push	 ecx
  010a2	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  010a5	52		 push	 edx
  010a6	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _target$[ebp]
  010ac	50		 push	 eax
  010ad	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  010b0	51		 push	 ecx
  010b1	e8 00 00 00 00	 call	 ?convert_format@@YAPAEPAEHHII@Z ; convert_format
  010b6	83 c4 14	 add	 esp, 20			; 00000014H
  010b9	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 2898 :       if (out == NULL) return out; // convert_format frees input on failure

  010bc	83 7d f8 00	 cmp	 DWORD PTR _out$[ebp], 0
  010c0	75 05		 jne	 SHORT $LN87@bmp_load
  010c2	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  010c5	eb 29		 jmp	 SHORT $LN1@bmp_load
$LN87@bmp_load:

; 2899 :    }
; 2900 : 
; 2901 :    *x = s->img_x;

  010c7	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  010ca	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  010cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  010cf	89 0a		 mov	 DWORD PTR [edx], ecx

; 2902 :    *y = s->img_y;

  010d1	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  010d4	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  010d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  010da	89 0a		 mov	 DWORD PTR [edx], ecx

; 2903 :    if (comp) *comp = s->img_n;

  010dc	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  010e0	74 0b		 je	 SHORT $LN89@bmp_load
  010e2	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  010e5	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  010e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  010eb	89 0a		 mov	 DWORD PTR [edx], ecx
$LN89@bmp_load:

; 2904 :    return out;

  010ed	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@bmp_load:

; 2905 : }

  010f0	52		 push	 edx
  010f1	8b cd		 mov	 ecx, ebp
  010f3	50		 push	 eax
  010f4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN130@bmp_load
  010fa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  010ff	58		 pop	 eax
  01100	5a		 pop	 edx
  01101	5f		 pop	 edi
  01102	5e		 pop	 esi
  01103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01106	33 cd		 xor	 ecx, ebp
  01108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0110d	81 c4 e4 04 00
	00		 add	 esp, 1252		; 000004e4H
  01113	3b ec		 cmp	 ebp, esp
  01115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0111a	8b e5		 mov	 esp, ebp
  0111c	5d		 pop	 ebp
  0111d	c3		 ret	 0
  0111e	66 90		 npad	 2
$LN130@bmp_load:
  01120	01 00 00 00	 DD	 1
  01124	00 00 00 00	 DD	 $LN129@bmp_load
$LN129@bmp_load:
  01128	e0 fb ff ff	 DD	 -1056			; fffffbe0H
  0112c	00 04 00 00	 DD	 1024			; 00000400H
  01130	00 00 00 00	 DD	 $LN128@bmp_load
$LN128@bmp_load:
  01134	70		 DB	 112			; 00000070H
  01135	61		 DB	 97			; 00000061H
  01136	6c		 DB	 108			; 0000006cH
  01137	00		 DB	 0
?bmp_load@@YAPAEPAUstbi@@PAH11H@Z ENDP			; bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_bmp_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_bmp_load

; 2908 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2909 :    return bmp_load(s, x,y,comp,req_comp);

  00003	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?bmp_load@@YAPAEPAUstbi@@PAH11H@Z ; bmp_load
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 2910 : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?stbi_bmp_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_sz$ = -16						; size = 4
_tga_comp$ = -12					; size = 4
_tga_h$ = -8						; size = 4
_tga_w$ = -4						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?tga_info@@YAHPAUstbi@@PAH11@Z PROC			; tga_info

; 2917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2918 :     int tga_w, tga_h, tga_comp;
; 2919 :     int sz;
; 2920 :     get8u(s);                   // discard Offset

  00017	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00020	83 c4 04	 add	 esp, 4

; 2921 :     sz = get8u(s);              // color type

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0002c	83 c4 04	 add	 esp, 4
  0002f	0f b6 d0	 movzx	 edx, al
  00032	89 55 f0	 mov	 DWORD PTR _sz$[ebp], edx

; 2922 :     if( sz > 1 ) {

  00035	83 7d f0 01	 cmp	 DWORD PTR _sz$[ebp], 1
  00039	7e 13		 jle	 SHORT $LN2@tga_info

; 2923 :         stbi_rewind(s);

  0003b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00044	83 c4 04	 add	 esp, 4

; 2924 :         return 0;      // only RGB or indexed allowed

  00047	33 c0		 xor	 eax, eax
  00049	e9 0d 01 00 00	 jmp	 $LN1@tga_info
$LN2@tga_info:

; 2925 :     }
; 2926 :     sz = get8u(s);              // image type

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00057	83 c4 04	 add	 esp, 4
  0005a	0f b6 d0	 movzx	 edx, al
  0005d	89 55 f0	 mov	 DWORD PTR _sz$[ebp], edx

; 2927 :     // only RGB or grey allowed, +/- RLE
; 2928 :     if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;

  00060	83 7d f0 01	 cmp	 DWORD PTR _sz$[ebp], 1
  00064	74 25		 je	 SHORT $LN3@tga_info
  00066	83 7d f0 02	 cmp	 DWORD PTR _sz$[ebp], 2
  0006a	74 1f		 je	 SHORT $LN3@tga_info
  0006c	83 7d f0 03	 cmp	 DWORD PTR _sz$[ebp], 3
  00070	74 19		 je	 SHORT $LN3@tga_info
  00072	83 7d f0 09	 cmp	 DWORD PTR _sz$[ebp], 9
  00076	74 13		 je	 SHORT $LN3@tga_info
  00078	83 7d f0 0a	 cmp	 DWORD PTR _sz$[ebp], 10	; 0000000aH
  0007c	74 0d		 je	 SHORT $LN3@tga_info
  0007e	83 7d f0 0b	 cmp	 DWORD PTR _sz$[ebp], 11	; 0000000bH
  00082	74 07		 je	 SHORT $LN3@tga_info
  00084	33 c0		 xor	 eax, eax
  00086	e9 d0 00 00 00	 jmp	 $LN1@tga_info
$LN3@tga_info:

; 2929 :     skip(s,9);

  0008b	6a 09		 push	 9
  0008d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00096	83 c4 08	 add	 esp, 8

; 2930 :     tga_w = get16le(s);

  00099	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 45 fc	 mov	 DWORD PTR _tga_w$[ebp], eax

; 2931 :     if( tga_w < 1 ) {

  000a8	83 7d fc 01	 cmp	 DWORD PTR _tga_w$[ebp], 1
  000ac	7d 13		 jge	 SHORT $LN4@tga_info

; 2932 :         stbi_rewind(s);

  000ae	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000b7	83 c4 04	 add	 esp, 4

; 2933 :         return 0;   // test width

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 9a 00 00 00	 jmp	 $LN1@tga_info
$LN4@tga_info:

; 2934 :     }
; 2935 :     tga_h = get16le(s);

  000c1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000ca	83 c4 04	 add	 esp, 4
  000cd	89 45 f8	 mov	 DWORD PTR _tga_h$[ebp], eax

; 2936 :     if( tga_h < 1 ) {

  000d0	83 7d f8 01	 cmp	 DWORD PTR _tga_h$[ebp], 1
  000d4	7d 10		 jge	 SHORT $LN5@tga_info

; 2937 :         stbi_rewind(s);

  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000df	83 c4 04	 add	 esp, 4

; 2938 :         return 0;   // test height

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 75		 jmp	 SHORT $LN1@tga_info
$LN5@tga_info:

; 2939 :     }
; 2940 :     sz = get8(s);               // bits per pixel

  000e6	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000ef	83 c4 04	 add	 esp, 4
  000f2	89 45 f0	 mov	 DWORD PTR _sz$[ebp], eax

; 2941 :     // only RGB or RGBA or grey allowed
; 2942 :     if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {

  000f5	83 7d f0 08	 cmp	 DWORD PTR _sz$[ebp], 8
  000f9	74 22		 je	 SHORT $LN6@tga_info
  000fb	83 7d f0 10	 cmp	 DWORD PTR _sz$[ebp], 16	; 00000010H
  000ff	74 1c		 je	 SHORT $LN6@tga_info
  00101	83 7d f0 18	 cmp	 DWORD PTR _sz$[ebp], 24	; 00000018H
  00105	74 16		 je	 SHORT $LN6@tga_info
  00107	83 7d f0 20	 cmp	 DWORD PTR _sz$[ebp], 32	; 00000020H
  0010b	74 10		 je	 SHORT $LN6@tga_info

; 2943 :         stbi_rewind(s);

  0010d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00116	83 c4 04	 add	 esp, 4

; 2944 :         return 0;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 3e		 jmp	 SHORT $LN1@tga_info
$LN6@tga_info:

; 2945 :     }
; 2946 :     tga_comp = sz;

  0011d	8b 4d f0	 mov	 ecx, DWORD PTR _sz$[ebp]
  00120	89 4d f4	 mov	 DWORD PTR _tga_comp$[ebp], ecx

; 2947 :     if (x) *x = tga_w;

  00123	83 7d 0c 00	 cmp	 DWORD PTR _x$[ebp], 0
  00127	74 08		 je	 SHORT $LN7@tga_info
  00129	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0012c	8b 45 fc	 mov	 eax, DWORD PTR _tga_w$[ebp]
  0012f	89 02		 mov	 DWORD PTR [edx], eax
$LN7@tga_info:

; 2948 :     if (y) *y = tga_h;

  00131	83 7d 10 00	 cmp	 DWORD PTR _y$[ebp], 0
  00135	74 08		 je	 SHORT $LN8@tga_info
  00137	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0013a	8b 55 f8	 mov	 edx, DWORD PTR _tga_h$[ebp]
  0013d	89 11		 mov	 DWORD PTR [ecx], edx
$LN8@tga_info:

; 2949 :     if (comp) *comp = tga_comp / 8;

  0013f	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  00143	74 11		 je	 SHORT $LN9@tga_info
  00145	8b 45 f4	 mov	 eax, DWORD PTR _tga_comp$[ebp]
  00148	99		 cdq
  00149	83 e2 07	 and	 edx, 7
  0014c	03 c2		 add	 eax, edx
  0014e	c1 f8 03	 sar	 eax, 3
  00151	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00154	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@tga_info:

; 2950 :     return 1;                   // seems to have passed everything

  00156	b8 01 00 00 00	 mov	 eax, 1
$LN1@tga_info:

; 2951 : }

  0015b	83 c4 10	 add	 esp, 16			; 00000010H
  0015e	3b ec		 cmp	 ebp, esp
  00160	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
?tga_info@@YAHPAUstbi@@PAH11@Z ENDP			; tga_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_tga_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_tga_info

; 2954 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2955 :     return tga_info(s, x, y, comp);

  00003	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?tga_info@@YAHPAUstbi@@PAH11@Z ; tga_info
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 2956 : }

  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?stbi_tga_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_tga_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_sz$ = -4						; size = 4
_s$ = 8							; size = 4
?tga_test@@YAHPAUstbi@@@Z PROC				; tga_test

; 2959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2960 :    int sz;
; 2961 :    get8u(s);      //   discard Offset

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00014	83 c4 04	 add	 esp, 4

; 2962 :    sz = get8u(s);   //   color type

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00020	83 c4 04	 add	 esp, 4
  00023	0f b6 d0	 movzx	 edx, al
  00026	89 55 fc	 mov	 DWORD PTR _sz$[ebp], edx

; 2963 :    if ( sz > 1 ) return 0;   //   only RGB or indexed allowed

  00029	83 7d fc 01	 cmp	 DWORD PTR _sz$[ebp], 1
  0002d	7e 07		 jle	 SHORT $LN2@tga_test
  0002f	33 c0		 xor	 eax, eax
  00031	e9 d3 00 00 00	 jmp	 $LN1@tga_test
$LN2@tga_test:

; 2964 :    sz = get8u(s);   //   image type

  00036	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0003f	83 c4 04	 add	 esp, 4
  00042	0f b6 c8	 movzx	 ecx, al
  00045	89 4d fc	 mov	 DWORD PTR _sz$[ebp], ecx

; 2965 :    if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE

  00048	83 7d fc 01	 cmp	 DWORD PTR _sz$[ebp], 1
  0004c	74 25		 je	 SHORT $LN3@tga_test
  0004e	83 7d fc 02	 cmp	 DWORD PTR _sz$[ebp], 2
  00052	74 1f		 je	 SHORT $LN3@tga_test
  00054	83 7d fc 03	 cmp	 DWORD PTR _sz$[ebp], 3
  00058	74 19		 je	 SHORT $LN3@tga_test
  0005a	83 7d fc 09	 cmp	 DWORD PTR _sz$[ebp], 9
  0005e	74 13		 je	 SHORT $LN3@tga_test
  00060	83 7d fc 0a	 cmp	 DWORD PTR _sz$[ebp], 10	; 0000000aH
  00064	74 0d		 je	 SHORT $LN3@tga_test
  00066	83 7d fc 0b	 cmp	 DWORD PTR _sz$[ebp], 11	; 0000000bH
  0006a	74 07		 je	 SHORT $LN3@tga_test
  0006c	33 c0		 xor	 eax, eax
  0006e	e9 96 00 00 00	 jmp	 $LN1@tga_test
$LN3@tga_test:

; 2966 :    get16(s);      //   discard palette start

  00073	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0007c	83 c4 04	 add	 esp, 4

; 2967 :    get16(s);      //   discard palette length

  0007f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00088	83 c4 04	 add	 esp, 4

; 2968 :    get8(s);         //   discard bits per palette color entry

  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00094	83 c4 04	 add	 esp, 4

; 2969 :    get16(s);      //   discard x origin

  00097	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000a0	83 c4 04	 add	 esp, 4

; 2970 :    get16(s);      //   discard y origin

  000a3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000ac	83 c4 04	 add	 esp, 4

; 2971 :    if ( get16(s) < 1 ) return 0;      //   test width

  000af	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000b8	83 c4 04	 add	 esp, 4
  000bb	83 f8 01	 cmp	 eax, 1
  000be	7d 04		 jge	 SHORT $LN4@tga_test
  000c0	33 c0		 xor	 eax, eax
  000c2	eb 45		 jmp	 SHORT $LN1@tga_test
$LN4@tga_test:

; 2972 :    if ( get16(s) < 1 ) return 0;      //   test height

  000c4	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000cd	83 c4 04	 add	 esp, 4
  000d0	83 f8 01	 cmp	 eax, 1
  000d3	7d 04		 jge	 SHORT $LN5@tga_test
  000d5	33 c0		 xor	 eax, eax
  000d7	eb 30		 jmp	 SHORT $LN1@tga_test
$LN5@tga_test:

; 2973 :    sz = get8(s);   //   bits per pixel

  000d9	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000e2	83 c4 04	 add	 esp, 4
  000e5	89 45 fc	 mov	 DWORD PTR _sz$[ebp], eax

; 2974 :    if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;   //   only RGB or RGBA or grey allowed

  000e8	83 7d fc 08	 cmp	 DWORD PTR _sz$[ebp], 8
  000ec	74 16		 je	 SHORT $LN6@tga_test
  000ee	83 7d fc 10	 cmp	 DWORD PTR _sz$[ebp], 16	; 00000010H
  000f2	74 10		 je	 SHORT $LN6@tga_test
  000f4	83 7d fc 18	 cmp	 DWORD PTR _sz$[ebp], 24	; 00000018H
  000f8	74 0a		 je	 SHORT $LN6@tga_test
  000fa	83 7d fc 20	 cmp	 DWORD PTR _sz$[ebp], 32	; 00000020H
  000fe	74 04		 je	 SHORT $LN6@tga_test
  00100	33 c0		 xor	 eax, eax
  00102	eb 05		 jmp	 SHORT $LN1@tga_test
$LN6@tga_test:

; 2975 :    return 1;      //   seems to have passed everything

  00104	b8 01 00 00 00	 mov	 eax, 1
$LN1@tga_test:

; 2976 : }

  00109	83 c4 04	 add	 esp, 4
  0010c	3b ec		 cmp	 ebp, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
?tga_test@@YAHPAUstbi@@@Z ENDP				; tga_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_res$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_tga_test@@YAHPAUstbi@@@Z PROC			; stbi_tga_test

; 2979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2980 :    int res = tga_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?tga_test@@YAHPAUstbi@@@Z ; tga_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _res$[ebp], eax

; 2981 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 2982 :    return res;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _res$[ebp]

; 2983 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_tga_test@@YAHPAUstbi@@@Z ENDP			; stbi_tga_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv293 = -148						; size = 4
tv230 = -144						; size = 4
tv185 = -140						; size = 4
tv172 = -136						; size = 4
tv155 = -132						; size = 4
$T1 = -128						; size = 4
_temp$2 = -121						; size = 1
_index2$3 = -120					; size = 4
_index1$4 = -116					; size = 4
_pal_idx$5 = -112					; size = 4
_RLE_cmd$6 = -108					; size = 4
_read_next_pixel$ = -104				; size = 4
_RLE_repeating$ = -100					; size = 4
_RLE_count$ = -96					; size = 4
_trans_data$ = -88					; size = 4
_raw_data$ = -76					; size = 4
_j$ = -68						; size = 4
_i$ = -64						; size = 4
_tga_palette$ = -60					; size = 4
_tga_data$ = -56					; size = 4
_tga_inverted$ = -52					; size = 4
_tga_bits_per_pixel$ = -48				; size = 4
_tga_height$ = -44					; size = 4
_tga_width$ = -40					; size = 4
_tga_y_origin$ = -36					; size = 4
_tga_x_origin$ = -32					; size = 4
_tga_palette_bits$ = -28				; size = 4
_tga_palette_len$ = -24					; size = 4
_tga_palette_start$ = -20				; size = 4
_tga_is_RLE$ = -16					; size = 4
_tga_image_type$ = -12					; size = 4
_tga_indexed$ = -8					; size = 4
_tga_offset$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?tga_load@@YAPAEPAUstbi@@PAH11H@Z PROC			; tga_load

; 2986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-148]
  00011	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd

; 2987 :    //   read in the TGA header stuff
; 2988 :    int tga_offset = get8u(s);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00026	83 c4 04	 add	 esp, 4
  00029	0f b6 c8	 movzx	 ecx, al
  0002c	89 4d fc	 mov	 DWORD PTR _tga_offset$[ebp], ecx

; 2989 :    int tga_indexed = get8u(s);

  0002f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00038	83 c4 04	 add	 esp, 4
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	89 45 f8	 mov	 DWORD PTR _tga_indexed$[ebp], eax

; 2990 :    int tga_image_type = get8u(s);

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0004a	83 c4 04	 add	 esp, 4
  0004d	0f b6 d0	 movzx	 edx, al
  00050	89 55 f4	 mov	 DWORD PTR _tga_image_type$[ebp], edx

; 2991 :    int tga_is_RLE = 0;

  00053	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tga_is_RLE$[ebp], 0

; 2992 :    int tga_palette_start = get16le(s);

  0005a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00063	83 c4 04	 add	 esp, 4
  00066	89 45 ec	 mov	 DWORD PTR _tga_palette_start$[ebp], eax

; 2993 :    int tga_palette_len = get16le(s);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 e8	 mov	 DWORD PTR _tga_palette_len$[ebp], eax

; 2994 :    int tga_palette_bits = get8u(s);

  00078	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00081	83 c4 04	 add	 esp, 4
  00084	0f b6 c0	 movzx	 eax, al
  00087	89 45 e4	 mov	 DWORD PTR _tga_palette_bits$[ebp], eax

; 2995 :    int tga_x_origin = get16le(s);

  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00093	83 c4 04	 add	 esp, 4
  00096	89 45 e0	 mov	 DWORD PTR _tga_x_origin$[ebp], eax

; 2996 :    int tga_y_origin = get16le(s);

  00099	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 45 dc	 mov	 DWORD PTR _tga_y_origin$[ebp], eax

; 2997 :    int tga_width = get16le(s);

  000a8	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000b1	83 c4 04	 add	 esp, 4
  000b4	89 45 d8	 mov	 DWORD PTR _tga_width$[ebp], eax

; 2998 :    int tga_height = get16le(s);

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000c0	83 c4 04	 add	 esp, 4
  000c3	89 45 d4	 mov	 DWORD PTR _tga_height$[ebp], eax

; 2999 :    int tga_bits_per_pixel = get8u(s);

  000c6	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000cf	83 c4 04	 add	 esp, 4
  000d2	0f b6 c0	 movzx	 eax, al
  000d5	89 45 d0	 mov	 DWORD PTR _tga_bits_per_pixel$[ebp], eax

; 3000 :    int tga_inverted = get8u(s);

  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000e1	83 c4 04	 add	 esp, 4
  000e4	0f b6 d0	 movzx	 edx, al
  000e7	89 55 cc	 mov	 DWORD PTR _tga_inverted$[ebp], edx

; 3001 :    //   image data
; 3002 :    unsigned char *tga_data;
; 3003 :    unsigned char *tga_palette = NULL;

  000ea	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _tga_palette$[ebp], 0

; 3004 :    int i, j;
; 3005 :    unsigned char raw_data[4];
; 3006 :    unsigned char trans_data[4];
; 3007 :    int RLE_count = 0;

  000f1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _RLE_count$[ebp], 0

; 3008 :    int RLE_repeating = 0;

  000f8	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _RLE_repeating$[ebp], 0

; 3009 :    int read_next_pixel = 1;

  000ff	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _read_next_pixel$[ebp], 1

; 3010 : 
; 3011 :    //   do a tiny bit of precessing
; 3012 :    if ( tga_image_type >= 8 )

  00106	83 7d f4 08	 cmp	 DWORD PTR _tga_image_type$[ebp], 8
  0010a	7c 10		 jl	 SHORT $LN21@tga_load

; 3013 :    {
; 3014 :       tga_image_type -= 8;

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _tga_image_type$[ebp]
  0010f	83 e8 08	 sub	 eax, 8
  00112	89 45 f4	 mov	 DWORD PTR _tga_image_type$[ebp], eax

; 3015 :       tga_is_RLE = 1;

  00115	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _tga_is_RLE$[ebp], 1
$LN21@tga_load:

; 3016 :    }
; 3017 :    /* int tga_alpha_bits = tga_inverted & 15; */
; 3018 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR _tga_inverted$[ebp]
  0011f	c1 f9 05	 sar	 ecx, 5
  00122	83 e1 01	 and	 ecx, 1
  00125	ba 01 00 00 00	 mov	 edx, 1
  0012a	2b d1		 sub	 edx, ecx
  0012c	89 55 cc	 mov	 DWORD PTR _tga_inverted$[ebp], edx

; 3019 : 
; 3020 :    //   error check
; 3021 :    if ( //(tga_indexed) ||
; 3022 :       (tga_width < 1) || (tga_height < 1) ||
; 3023 :       (tga_image_type < 1) || (tga_image_type > 3) ||

  0012f	83 7d d8 01	 cmp	 DWORD PTR _tga_width$[ebp], 1
  00133	7c 2a		 jl	 SHORT $LN23@tga_load
  00135	83 7d d4 01	 cmp	 DWORD PTR _tga_height$[ebp], 1
  00139	7c 24		 jl	 SHORT $LN23@tga_load
  0013b	83 7d f4 01	 cmp	 DWORD PTR _tga_image_type$[ebp], 1
  0013f	7c 1e		 jl	 SHORT $LN23@tga_load
  00141	83 7d f4 03	 cmp	 DWORD PTR _tga_image_type$[ebp], 3
  00145	7f 18		 jg	 SHORT $LN23@tga_load
  00147	83 7d d0 08	 cmp	 DWORD PTR _tga_bits_per_pixel$[ebp], 8
  0014b	74 19		 je	 SHORT $LN22@tga_load
  0014d	83 7d d0 10	 cmp	 DWORD PTR _tga_bits_per_pixel$[ebp], 16 ; 00000010H
  00151	74 13		 je	 SHORT $LN22@tga_load
  00153	83 7d d0 18	 cmp	 DWORD PTR _tga_bits_per_pixel$[ebp], 24 ; 00000018H
  00157	74 0d		 je	 SHORT $LN22@tga_load
  00159	83 7d d0 20	 cmp	 DWORD PTR _tga_bits_per_pixel$[ebp], 32 ; 00000020H
  0015d	74 07		 je	 SHORT $LN22@tga_load
$LN23@tga_load:

; 3024 :       ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
; 3025 :       (tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
; 3026 :       )
; 3027 :    {
; 3028 :       return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA

  0015f	33 c0		 xor	 eax, eax
  00161	e9 3e 07 00 00	 jmp	 $LN51@tga_load
$LN22@tga_load:

; 3029 :    }
; 3030 : 
; 3031 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 3032 :    if ( tga_indexed )

  00166	83 7d f8 00	 cmp	 DWORD PTR _tga_indexed$[ebp], 0
  0016a	74 06		 je	 SHORT $LN24@tga_load

; 3033 :    {
; 3034 :       tga_bits_per_pixel = tga_palette_bits;

  0016c	8b 45 e4	 mov	 eax, DWORD PTR _tga_palette_bits$[ebp]
  0016f	89 45 d0	 mov	 DWORD PTR _tga_bits_per_pixel$[ebp], eax
$LN24@tga_load:

; 3035 :    }
; 3036 : 
; 3037 :    //   tga info
; 3038 :    *x = tga_width;

  00172	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00175	8b 55 d8	 mov	 edx, DWORD PTR _tga_width$[ebp]
  00178	89 11		 mov	 DWORD PTR [ecx], edx

; 3039 :    *y = tga_height;

  0017a	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0017d	8b 4d d4	 mov	 ecx, DWORD PTR _tga_height$[ebp]
  00180	89 08		 mov	 DWORD PTR [eax], ecx

; 3040 :    if ( (req_comp < 1) || (req_comp > 4) )

  00182	83 7d 18 01	 cmp	 DWORD PTR _req_comp$[ebp], 1
  00186	7c 06		 jl	 SHORT $LN27@tga_load
  00188	83 7d 18 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  0018c	7e 19		 jle	 SHORT $LN25@tga_load
$LN27@tga_load:

; 3041 :    {
; 3042 :       //   just use whatever the file was
; 3043 :       req_comp = tga_bits_per_pixel / 8;

  0018e	8b 45 d0	 mov	 eax, DWORD PTR _tga_bits_per_pixel$[ebp]
  00191	99		 cdq
  00192	83 e2 07	 and	 edx, 7
  00195	03 c2		 add	 eax, edx
  00197	c1 f8 03	 sar	 eax, 3
  0019a	89 45 18	 mov	 DWORD PTR _req_comp$[ebp], eax

; 3044 :       *comp = req_comp;

  0019d	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  001a0	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  001a3	89 02		 mov	 DWORD PTR [edx], eax

; 3045 :    } else

  001a5	eb 11		 jmp	 SHORT $LN26@tga_load
$LN25@tga_load:

; 3046 :    {
; 3047 :       //   force a new number of components
; 3048 :       *comp = tga_bits_per_pixel/8;

  001a7	8b 45 d0	 mov	 eax, DWORD PTR _tga_bits_per_pixel$[ebp]
  001aa	99		 cdq
  001ab	83 e2 07	 and	 edx, 7
  001ae	03 c2		 add	 eax, edx
  001b0	c1 f8 03	 sar	 eax, 3
  001b3	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  001b6	89 01		 mov	 DWORD PTR [ecx], eax
$LN26@tga_load:

; 3049 :    }
; 3050 :    tga_data = (unsigned char*)malloc( tga_width * tga_height * req_comp );

  001b8	8b 55 d8	 mov	 edx, DWORD PTR _tga_width$[ebp]
  001bb	0f af 55 d4	 imul	 edx, DWORD PTR _tga_height$[ebp]
  001bf	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  001c3	8b f4		 mov	 esi, esp
  001c5	52		 push	 edx
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001cc	83 c4 04	 add	 esp, 4
  001cf	3b f4		 cmp	 esi, esp
  001d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d6	89 45 c8	 mov	 DWORD PTR _tga_data$[ebp], eax

; 3051 :    if (!tga_data) return epuc("outofmem", "Out of memory");

  001d9	83 7d c8 00	 cmp	 DWORD PTR _tga_data$[ebp], 0
  001dd	75 32		 jne	 SHORT $LN28@tga_load
  001df	68 00 00 00 00	 push	 OFFSET $SG4294820147
  001e4	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001e9	83 c4 04	 add	 esp, 4
  001ec	85 c0		 test	 eax, eax
  001ee	74 0c		 je	 SHORT $LN52@tga_load
  001f0	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv155[ebp], 0
  001fa	eb 0a		 jmp	 SHORT $LN53@tga_load
$LN52@tga_load:
  001fc	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv155[ebp], 0
$LN53@tga_load:
  00206	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv155[ebp]
  0020c	e9 93 06 00 00	 jmp	 $LN51@tga_load
$LN28@tga_load:

; 3052 : 
; 3053 :    //   skip to the data's starting position (offset usually = 0)
; 3054 :    skip(s, tga_offset );

  00211	8b 45 fc	 mov	 eax, DWORD PTR _tga_offset$[ebp]
  00214	50		 push	 eax
  00215	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00218	51		 push	 ecx
  00219	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  0021e	83 c4 08	 add	 esp, 8

; 3055 :    //   do I need to load a palette?
; 3056 :    if ( tga_indexed )

  00221	83 7d f8 00	 cmp	 DWORD PTR _tga_indexed$[ebp], 0
  00225	0f 84 f1 00 00
	00		 je	 $LN29@tga_load

; 3057 :    {
; 3058 :       //   any data to skip? (offset usually = 0)
; 3059 :       skip(s, tga_palette_start );

  0022b	8b 55 ec	 mov	 edx, DWORD PTR _tga_palette_start$[ebp]
  0022e	52		 push	 edx
  0022f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00238	83 c4 08	 add	 esp, 8

; 3060 :       //   load the palette
; 3061 :       tga_palette = (unsigned char*)malloc( tga_palette_len * tga_palette_bits / 8 );

  0023b	8b 45 e8	 mov	 eax, DWORD PTR _tga_palette_len$[ebp]
  0023e	0f af 45 e4	 imul	 eax, DWORD PTR _tga_palette_bits$[ebp]
  00242	99		 cdq
  00243	83 e2 07	 and	 edx, 7
  00246	03 c2		 add	 eax, edx
  00248	c1 f8 03	 sar	 eax, 3
  0024b	8b f4		 mov	 esi, esp
  0024d	50		 push	 eax
  0024e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00254	83 c4 04	 add	 esp, 4
  00257	3b f4		 cmp	 esi, esp
  00259	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025e	89 45 c4	 mov	 DWORD PTR _tga_palette$[ebp], eax

; 3062 :       if (!tga_palette) return epuc("outofmem", "Out of memory");

  00261	83 7d c4 00	 cmp	 DWORD PTR _tga_palette$[ebp], 0
  00265	75 32		 jne	 SHORT $LN30@tga_load
  00267	68 00 00 00 00	 push	 OFFSET $SG4294820146
  0026c	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00271	83 c4 04	 add	 esp, 4
  00274	85 c0		 test	 eax, eax
  00276	74 0c		 je	 SHORT $LN54@tga_load
  00278	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
  00282	eb 0a		 jmp	 SHORT $LN55@tga_load
$LN54@tga_load:
  00284	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
$LN55@tga_load:
  0028e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  00294	e9 0b 06 00 00	 jmp	 $LN51@tga_load
$LN30@tga_load:

; 3063 :       if (!getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {

  00299	8b 45 e8	 mov	 eax, DWORD PTR _tga_palette_len$[ebp]
  0029c	0f af 45 e4	 imul	 eax, DWORD PTR _tga_palette_bits$[ebp]
  002a0	99		 cdq
  002a1	83 e2 07	 and	 edx, 7
  002a4	03 c2		 add	 eax, edx
  002a6	c1 f8 03	 sar	 eax, 3
  002a9	50		 push	 eax
  002aa	8b 4d c4	 mov	 ecx, DWORD PTR _tga_palette$[ebp]
  002ad	51		 push	 ecx
  002ae	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  002b1	52		 push	 edx
  002b2	e8 00 00 00 00	 call	 ?getn@@YAHPAUstbi@@PAEH@Z ; getn
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ba	85 c0		 test	 eax, eax
  002bc	75 5e		 jne	 SHORT $LN29@tga_load

; 3064 :          free(tga_data);

  002be	8b f4		 mov	 esi, esp
  002c0	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  002c3	50		 push	 eax
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002ca	83 c4 04	 add	 esp, 4
  002cd	3b f4		 cmp	 esi, esp
  002cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3065 :          free(tga_palette);

  002d4	8b f4		 mov	 esi, esp
  002d6	8b 4d c4	 mov	 ecx, DWORD PTR _tga_palette$[ebp]
  002d9	51		 push	 ecx
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002e0	83 c4 04	 add	 esp, 4
  002e3	3b f4		 cmp	 esi, esp
  002e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3066 :          return epuc("bad palette", "Corrupt TGA");

  002ea	68 00 00 00 00	 push	 OFFSET $SG4294820145
  002ef	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002f4	83 c4 04	 add	 esp, 4
  002f7	85 c0		 test	 eax, eax
  002f9	74 0c		 je	 SHORT $LN56@tga_load
  002fb	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv185[ebp], 0
  00305	eb 0a		 jmp	 SHORT $LN57@tga_load
$LN56@tga_load:
  00307	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv185[ebp], 0
$LN57@tga_load:
  00311	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv185[ebp]
  00317	e9 88 05 00 00	 jmp	 $LN51@tga_load
$LN29@tga_load:

; 3067 :       }
; 3068 :    }
; 3069 :    //   load the data
; 3070 :    trans_data[0] = trans_data[1] = trans_data[2] = trans_data[3] = 0;

  0031c	ba 01 00 00 00	 mov	 edx, 1
  00321	6b c2 03	 imul	 eax, edx, 3
  00324	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
  00327	83 7d 80 04	 cmp	 DWORD PTR $T1[ebp], 4
  0032b	73 02		 jae	 SHORT $LN58@tga_load
  0032d	eb 05		 jmp	 SHORT $LN59@tga_load
$LN58@tga_load:
  0032f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN59@tga_load:
  00334	8b 4d 80	 mov	 ecx, DWORD PTR $T1[ebp]
  00337	c6 44 0d a8 00	 mov	 BYTE PTR _trans_data$[ebp+ecx], 0
  0033c	ba 01 00 00 00	 mov	 edx, 1
  00341	d1 e2		 shl	 edx, 1
  00343	c6 44 15 a8 00	 mov	 BYTE PTR _trans_data$[ebp+edx], 0
  00348	b8 01 00 00 00	 mov	 eax, 1
  0034d	c1 e0 00	 shl	 eax, 0
  00350	c6 44 05 a8 00	 mov	 BYTE PTR _trans_data$[ebp+eax], 0
  00355	b9 01 00 00 00	 mov	 ecx, 1
  0035a	6b d1 00	 imul	 edx, ecx, 0
  0035d	c6 44 15 a8 00	 mov	 BYTE PTR _trans_data$[ebp+edx], 0

; 3071 :    for (i=0; i < tga_width * tga_height; ++i)

  00362	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00369	eb 09		 jmp	 SHORT $LN4@tga_load
$LN2@tga_load:
  0036b	8b 45 c0	 mov	 eax, DWORD PTR _i$[ebp]
  0036e	83 c0 01	 add	 eax, 1
  00371	89 45 c0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@tga_load:
  00374	8b 4d d8	 mov	 ecx, DWORD PTR _tga_width$[ebp]
  00377	0f af 4d d4	 imul	 ecx, DWORD PTR _tga_height$[ebp]
  0037b	39 4d c0	 cmp	 DWORD PTR _i$[ebp], ecx
  0037e	0f 8d 40 04 00
	00		 jge	 $LN3@tga_load

; 3072 :    {
; 3073 :       //   if I'm in RLE mode, do I need to get a RLE chunk?
; 3074 :       if ( tga_is_RLE )

  00384	83 7d f0 00	 cmp	 DWORD PTR _tga_is_RLE$[ebp], 0
  00388	74 45		 je	 SHORT $LN32@tga_load

; 3075 :       {
; 3076 :          if ( RLE_count == 0 )

  0038a	83 7d a0 00	 cmp	 DWORD PTR _RLE_count$[ebp], 0
  0038e	75 30		 jne	 SHORT $LN34@tga_load

; 3077 :          {
; 3078 :             //   yep, get the next byte as a RLE command
; 3079 :             int RLE_cmd = get8u(s);

  00390	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00393	52		 push	 edx
  00394	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00399	83 c4 04	 add	 esp, 4
  0039c	0f b6 c0	 movzx	 eax, al
  0039f	89 45 94	 mov	 DWORD PTR _RLE_cmd$6[ebp], eax

; 3080 :             RLE_count = 1 + (RLE_cmd & 127);

  003a2	8b 4d 94	 mov	 ecx, DWORD PTR _RLE_cmd$6[ebp]
  003a5	83 e1 7f	 and	 ecx, 127		; 0000007fH
  003a8	83 c1 01	 add	 ecx, 1
  003ab	89 4d a0	 mov	 DWORD PTR _RLE_count$[ebp], ecx

; 3081 :             RLE_repeating = RLE_cmd >> 7;

  003ae	8b 55 94	 mov	 edx, DWORD PTR _RLE_cmd$6[ebp]
  003b1	c1 fa 07	 sar	 edx, 7
  003b4	89 55 9c	 mov	 DWORD PTR _RLE_repeating$[ebp], edx

; 3082 :             read_next_pixel = 1;

  003b7	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _read_next_pixel$[ebp], 1
  003be	eb 0d		 jmp	 SHORT $LN35@tga_load
$LN34@tga_load:

; 3083 :          } else if ( !RLE_repeating )

  003c0	83 7d 9c 00	 cmp	 DWORD PTR _RLE_repeating$[ebp], 0
  003c4	75 07		 jne	 SHORT $LN35@tga_load

; 3084 :          {
; 3085 :             read_next_pixel = 1;

  003c6	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _read_next_pixel$[ebp], 1
$LN35@tga_load:

; 3086 :          }
; 3087 :       } else

  003cd	eb 07		 jmp	 SHORT $LN33@tga_load
$LN32@tga_load:

; 3088 :       {
; 3089 :          read_next_pixel = 1;

  003cf	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _read_next_pixel$[ebp], 1
$LN33@tga_load:

; 3090 :       }
; 3091 :       //   OK, if I need to read a pixel, do it now
; 3092 :       if ( read_next_pixel )

  003d6	83 7d 98 00	 cmp	 DWORD PTR _read_next_pixel$[ebp], 0
  003da	0f 84 50 02 00
	00		 je	 $LN37@tga_load

; 3093 :       {
; 3094 :          //   load however much data we did have
; 3095 :          if ( tga_indexed )

  003e0	83 7d f8 00	 cmp	 DWORD PTR _tga_indexed$[ebp], 0
  003e4	74 68		 je	 SHORT $LN38@tga_load

; 3096 :          {
; 3097 :             //   read in 1 byte, then perform the lookup
; 3098 :             int pal_idx = get8u(s);

  003e6	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  003ef	83 c4 04	 add	 esp, 4
  003f2	0f b6 c8	 movzx	 ecx, al
  003f5	89 4d 90	 mov	 DWORD PTR _pal_idx$5[ebp], ecx

; 3099 :             if ( pal_idx >= tga_palette_len )

  003f8	8b 55 90	 mov	 edx, DWORD PTR _pal_idx$5[ebp]
  003fb	3b 55 e8	 cmp	 edx, DWORD PTR _tga_palette_len$[ebp]
  003fe	7c 07		 jl	 SHORT $LN40@tga_load

; 3100 :             {
; 3101 :                //   invalid index
; 3102 :                pal_idx = 0;

  00400	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _pal_idx$5[ebp], 0
$LN40@tga_load:

; 3103 :             }
; 3104 :             pal_idx *= tga_bits_per_pixel / 8;

  00407	8b 45 d0	 mov	 eax, DWORD PTR _tga_bits_per_pixel$[ebp]
  0040a	99		 cdq
  0040b	83 e2 07	 and	 edx, 7
  0040e	03 c2		 add	 eax, edx
  00410	c1 f8 03	 sar	 eax, 3
  00413	0f af 45 90	 imul	 eax, DWORD PTR _pal_idx$5[ebp]
  00417	89 45 90	 mov	 DWORD PTR _pal_idx$5[ebp], eax

; 3105 :             for (j = 0; j*8 < tga_bits_per_pixel; ++j)

  0041a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00421	eb 09		 jmp	 SHORT $LN7@tga_load
$LN5@tga_load:
  00423	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  00426	83 c0 01	 add	 eax, 1
  00429	89 45 bc	 mov	 DWORD PTR _j$[ebp], eax
$LN7@tga_load:
  0042c	8b 4d bc	 mov	 ecx, DWORD PTR _j$[ebp]
  0042f	c1 e1 03	 shl	 ecx, 3
  00432	3b 4d d0	 cmp	 ecx, DWORD PTR _tga_bits_per_pixel$[ebp]
  00435	7d 15		 jge	 SHORT $LN6@tga_load

; 3106 :             {
; 3107 :                raw_data[j] = tga_palette[pal_idx+j];

  00437	8b 55 90	 mov	 edx, DWORD PTR _pal_idx$5[ebp]
  0043a	03 55 bc	 add	 edx, DWORD PTR _j$[ebp]
  0043d	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  00440	8b 4d c4	 mov	 ecx, DWORD PTR _tga_palette$[ebp]
  00443	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00446	88 54 05 b4	 mov	 BYTE PTR _raw_data$[ebp+eax], dl

; 3108 :             }

  0044a	eb d7		 jmp	 SHORT $LN5@tga_load
$LN6@tga_load:

; 3109 :          } else

  0044c	eb 32		 jmp	 SHORT $LN39@tga_load
$LN38@tga_load:

; 3110 :          {
; 3111 :             //   read in the data raw
; 3112 :             for (j = 0; j*8 < tga_bits_per_pixel; ++j)

  0044e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00455	eb 09		 jmp	 SHORT $LN10@tga_load
$LN8@tga_load:
  00457	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  0045a	83 c0 01	 add	 eax, 1
  0045d	89 45 bc	 mov	 DWORD PTR _j$[ebp], eax
$LN10@tga_load:
  00460	8b 4d bc	 mov	 ecx, DWORD PTR _j$[ebp]
  00463	c1 e1 03	 shl	 ecx, 3
  00466	3b 4d d0	 cmp	 ecx, DWORD PTR _tga_bits_per_pixel$[ebp]
  00469	7d 15		 jge	 SHORT $LN39@tga_load

; 3113 :             {
; 3114 :                raw_data[j] = get8u(s);

  0046b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0046e	52		 push	 edx
  0046f	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00474	83 c4 04	 add	 esp, 4
  00477	8b 4d bc	 mov	 ecx, DWORD PTR _j$[ebp]
  0047a	88 44 0d b4	 mov	 BYTE PTR _raw_data$[ebp+ecx], al

; 3115 :             }

  0047e	eb d7		 jmp	 SHORT $LN8@tga_load
$LN39@tga_load:

; 3116 :          }
; 3117 :          //   convert raw to the intermediate format
; 3118 :          switch (tga_bits_per_pixel)

  00480	8b 55 d0	 mov	 edx, DWORD PTR _tga_bits_per_pixel$[ebp]
  00483	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv230[ebp], edx
  00489	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  0048f	83 e8 08	 sub	 eax, 8
  00492	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv230[ebp], eax
  00498	83 bd 70 ff ff
	ff 18		 cmp	 DWORD PTR tv230[ebp], 24 ; 00000018H
  0049f	0f 87 84 01 00
	00		 ja	 $LN11@tga_load
  004a5	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv230[ebp]
  004ab	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN60@tga_load[ecx]
  004b2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN65@tga_load[edx*4]
$LN41@tga_load:

; 3119 :          {
; 3120 :          case 8:
; 3121 :             //   Luminous => RGBA
; 3122 :             trans_data[0] = raw_data[0];

  004b9	b8 01 00 00 00	 mov	 eax, 1
  004be	6b c8 00	 imul	 ecx, eax, 0
  004c1	ba 01 00 00 00	 mov	 edx, 1
  004c6	6b c2 00	 imul	 eax, edx, 0
  004c9	8a 4c 0d b4	 mov	 cl, BYTE PTR _raw_data$[ebp+ecx]
  004cd	88 4c 05 a8	 mov	 BYTE PTR _trans_data$[ebp+eax], cl

; 3123 :             trans_data[1] = raw_data[0];

  004d1	ba 01 00 00 00	 mov	 edx, 1
  004d6	6b c2 00	 imul	 eax, edx, 0
  004d9	b9 01 00 00 00	 mov	 ecx, 1
  004de	c1 e1 00	 shl	 ecx, 0
  004e1	8a 54 05 b4	 mov	 dl, BYTE PTR _raw_data$[ebp+eax]
  004e5	88 54 0d a8	 mov	 BYTE PTR _trans_data$[ebp+ecx], dl

; 3124 :             trans_data[2] = raw_data[0];

  004e9	b8 01 00 00 00	 mov	 eax, 1
  004ee	6b c8 00	 imul	 ecx, eax, 0
  004f1	ba 01 00 00 00	 mov	 edx, 1
  004f6	d1 e2		 shl	 edx, 1
  004f8	8a 44 0d b4	 mov	 al, BYTE PTR _raw_data$[ebp+ecx]
  004fc	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al

; 3125 :             trans_data[3] = 255;

  00500	b9 01 00 00 00	 mov	 ecx, 1
  00505	6b d1 03	 imul	 edx, ecx, 3
  00508	c6 44 15 a8 ff	 mov	 BYTE PTR _trans_data$[ebp+edx], 255 ; 000000ffH

; 3126 :             break;

  0050d	e9 17 01 00 00	 jmp	 $LN11@tga_load
$LN42@tga_load:

; 3127 :          case 16:
; 3128 :             //   Luminous,Alpha => RGBA
; 3129 :             trans_data[0] = raw_data[0];

  00512	b8 01 00 00 00	 mov	 eax, 1
  00517	6b c8 00	 imul	 ecx, eax, 0
  0051a	ba 01 00 00 00	 mov	 edx, 1
  0051f	6b c2 00	 imul	 eax, edx, 0
  00522	8a 4c 0d b4	 mov	 cl, BYTE PTR _raw_data$[ebp+ecx]
  00526	88 4c 05 a8	 mov	 BYTE PTR _trans_data$[ebp+eax], cl

; 3130 :             trans_data[1] = raw_data[0];

  0052a	ba 01 00 00 00	 mov	 edx, 1
  0052f	6b c2 00	 imul	 eax, edx, 0
  00532	b9 01 00 00 00	 mov	 ecx, 1
  00537	c1 e1 00	 shl	 ecx, 0
  0053a	8a 54 05 b4	 mov	 dl, BYTE PTR _raw_data$[ebp+eax]
  0053e	88 54 0d a8	 mov	 BYTE PTR _trans_data$[ebp+ecx], dl

; 3131 :             trans_data[2] = raw_data[0];

  00542	b8 01 00 00 00	 mov	 eax, 1
  00547	6b c8 00	 imul	 ecx, eax, 0
  0054a	ba 01 00 00 00	 mov	 edx, 1
  0054f	d1 e2		 shl	 edx, 1
  00551	8a 44 0d b4	 mov	 al, BYTE PTR _raw_data$[ebp+ecx]
  00555	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al

; 3132 :             trans_data[3] = raw_data[1];

  00559	b9 01 00 00 00	 mov	 ecx, 1
  0055e	c1 e1 00	 shl	 ecx, 0
  00561	ba 01 00 00 00	 mov	 edx, 1
  00566	6b c2 03	 imul	 eax, edx, 3
  00569	8a 4c 0d b4	 mov	 cl, BYTE PTR _raw_data$[ebp+ecx]
  0056d	88 4c 05 a8	 mov	 BYTE PTR _trans_data$[ebp+eax], cl

; 3133 :             break;

  00571	e9 b3 00 00 00	 jmp	 $LN11@tga_load
$LN43@tga_load:

; 3134 :          case 24:
; 3135 :             //   BGR => RGBA
; 3136 :             trans_data[0] = raw_data[2];

  00576	ba 01 00 00 00	 mov	 edx, 1
  0057b	d1 e2		 shl	 edx, 1
  0057d	b8 01 00 00 00	 mov	 eax, 1
  00582	6b c8 00	 imul	 ecx, eax, 0
  00585	8a 54 15 b4	 mov	 dl, BYTE PTR _raw_data$[ebp+edx]
  00589	88 54 0d a8	 mov	 BYTE PTR _trans_data$[ebp+ecx], dl

; 3137 :             trans_data[1] = raw_data[1];

  0058d	b8 01 00 00 00	 mov	 eax, 1
  00592	c1 e0 00	 shl	 eax, 0
  00595	b9 01 00 00 00	 mov	 ecx, 1
  0059a	c1 e1 00	 shl	 ecx, 0
  0059d	8a 54 05 b4	 mov	 dl, BYTE PTR _raw_data$[ebp+eax]
  005a1	88 54 0d a8	 mov	 BYTE PTR _trans_data$[ebp+ecx], dl

; 3138 :             trans_data[2] = raw_data[0];

  005a5	b8 01 00 00 00	 mov	 eax, 1
  005aa	6b c8 00	 imul	 ecx, eax, 0
  005ad	ba 01 00 00 00	 mov	 edx, 1
  005b2	d1 e2		 shl	 edx, 1
  005b4	8a 44 0d b4	 mov	 al, BYTE PTR _raw_data$[ebp+ecx]
  005b8	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al

; 3139 :             trans_data[3] = 255;

  005bc	b9 01 00 00 00	 mov	 ecx, 1
  005c1	6b d1 03	 imul	 edx, ecx, 3
  005c4	c6 44 15 a8 ff	 mov	 BYTE PTR _trans_data$[ebp+edx], 255 ; 000000ffH

; 3140 :             break;

  005c9	eb 5e		 jmp	 SHORT $LN11@tga_load
$LN44@tga_load:

; 3141 :          case 32:
; 3142 :             //   BGRA => RGBA
; 3143 :             trans_data[0] = raw_data[2];

  005cb	b8 01 00 00 00	 mov	 eax, 1
  005d0	d1 e0		 shl	 eax, 1
  005d2	b9 01 00 00 00	 mov	 ecx, 1
  005d7	6b d1 00	 imul	 edx, ecx, 0
  005da	8a 44 05 b4	 mov	 al, BYTE PTR _raw_data$[ebp+eax]
  005de	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al

; 3144 :             trans_data[1] = raw_data[1];

  005e2	b9 01 00 00 00	 mov	 ecx, 1
  005e7	c1 e1 00	 shl	 ecx, 0
  005ea	ba 01 00 00 00	 mov	 edx, 1
  005ef	c1 e2 00	 shl	 edx, 0
  005f2	8a 44 0d b4	 mov	 al, BYTE PTR _raw_data$[ebp+ecx]
  005f6	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al

; 3145 :             trans_data[2] = raw_data[0];

  005fa	b9 01 00 00 00	 mov	 ecx, 1
  005ff	6b d1 00	 imul	 edx, ecx, 0
  00602	b8 01 00 00 00	 mov	 eax, 1
  00607	d1 e0		 shl	 eax, 1
  00609	8a 4c 15 b4	 mov	 cl, BYTE PTR _raw_data$[ebp+edx]
  0060d	88 4c 05 a8	 mov	 BYTE PTR _trans_data$[ebp+eax], cl

; 3146 :             trans_data[3] = raw_data[3];

  00611	ba 01 00 00 00	 mov	 edx, 1
  00616	6b c2 03	 imul	 eax, edx, 3
  00619	b9 01 00 00 00	 mov	 ecx, 1
  0061e	6b d1 03	 imul	 edx, ecx, 3
  00621	8a 44 05 b4	 mov	 al, BYTE PTR _raw_data$[ebp+eax]
  00625	88 44 15 a8	 mov	 BYTE PTR _trans_data$[ebp+edx], al
$LN11@tga_load:

; 3147 :             break;
; 3148 :          }
; 3149 :          //   clear the reading flag for the next pixel
; 3150 :          read_next_pixel = 0;

  00629	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _read_next_pixel$[ebp], 0
$LN37@tga_load:

; 3151 :       } // end of reading a pixel
; 3152 :       //   convert to final format
; 3153 :       switch (req_comp)

  00630	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00633	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv293[ebp], ecx
  00639	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv293[ebp]
  0063f	83 ea 01	 sub	 edx, 1
  00642	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv293[ebp], edx
  00648	83 bd 6c ff ff
	ff 03		 cmp	 DWORD PTR tv293[ebp], 3
  0064f	0f 87 61 01 00
	00		 ja	 $LN13@tga_load
  00655	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv293[ebp]
  0065b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN66@tga_load[eax*4]
$LN45@tga_load:

; 3154 :       {
; 3155 :       case 1:
; 3156 :          //   RGBA => Luminance
; 3157 :          tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);

  00662	b9 01 00 00 00	 mov	 ecx, 1
  00667	d1 e1		 shl	 ecx, 1
  00669	0f b6 54 0d a8	 movzx	 edx, BYTE PTR _trans_data$[ebp+ecx]
  0066e	52		 push	 edx
  0066f	b8 01 00 00 00	 mov	 eax, 1
  00674	c1 e0 00	 shl	 eax, 0
  00677	0f b6 4c 05 a8	 movzx	 ecx, BYTE PTR _trans_data$[ebp+eax]
  0067c	51		 push	 ecx
  0067d	ba 01 00 00 00	 mov	 edx, 1
  00682	6b c2 00	 imul	 eax, edx, 0
  00685	0f b6 4c 05 a8	 movzx	 ecx, BYTE PTR _trans_data$[ebp+eax]
  0068a	51		 push	 ecx
  0068b	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  00690	83 c4 0c	 add	 esp, 12			; 0000000cH
  00693	8b 55 c0	 mov	 edx, DWORD PTR _i$[ebp]
  00696	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  0069a	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  0069d	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3158 :          break;

  006a0	e9 11 01 00 00	 jmp	 $LN13@tga_load
$LN46@tga_load:

; 3159 :       case 2:
; 3160 :          //   RGBA => Luminance,Alpha
; 3161 :          tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);

  006a5	ba 01 00 00 00	 mov	 edx, 1
  006aa	d1 e2		 shl	 edx, 1
  006ac	0f b6 44 15 a8	 movzx	 eax, BYTE PTR _trans_data$[ebp+edx]
  006b1	50		 push	 eax
  006b2	b9 01 00 00 00	 mov	 ecx, 1
  006b7	c1 e1 00	 shl	 ecx, 0
  006ba	0f b6 54 0d a8	 movzx	 edx, BYTE PTR _trans_data$[ebp+ecx]
  006bf	52		 push	 edx
  006c0	b8 01 00 00 00	 mov	 eax, 1
  006c5	6b c8 00	 imul	 ecx, eax, 0
  006c8	0f b6 54 0d a8	 movzx	 edx, BYTE PTR _trans_data$[ebp+ecx]
  006cd	52		 push	 edx
  006ce	e8 00 00 00 00	 call	 ?compute_y@@YAEHHH@Z	; compute_y
  006d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d6	8b 4d c0	 mov	 ecx, DWORD PTR _i$[ebp]
  006d9	0f af 4d 18	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  006dd	8b 55 c8	 mov	 edx, DWORD PTR _tga_data$[ebp]
  006e0	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3162 :          tga_data[i*req_comp+1] = trans_data[3];

  006e3	b8 01 00 00 00	 mov	 eax, 1
  006e8	6b c8 03	 imul	 ecx, eax, 3
  006eb	8b 55 c0	 mov	 edx, DWORD PTR _i$[ebp]
  006ee	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  006f2	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  006f5	8a 4c 0d a8	 mov	 cl, BYTE PTR _trans_data$[ebp+ecx]
  006f9	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 3163 :          break;

  006fd	e9 b4 00 00 00	 jmp	 $LN13@tga_load
$LN47@tga_load:

; 3164 :       case 3:
; 3165 :          //   RGBA => RGB
; 3166 :          tga_data[i*req_comp+0] = trans_data[0];

  00702	ba 01 00 00 00	 mov	 edx, 1
  00707	6b c2 00	 imul	 eax, edx, 0
  0070a	8b 4d c0	 mov	 ecx, DWORD PTR _i$[ebp]
  0070d	0f af 4d 18	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  00711	8b 55 c8	 mov	 edx, DWORD PTR _tga_data$[ebp]
  00714	8a 44 05 a8	 mov	 al, BYTE PTR _trans_data$[ebp+eax]
  00718	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3167 :          tga_data[i*req_comp+1] = trans_data[1];

  0071b	b9 01 00 00 00	 mov	 ecx, 1
  00720	c1 e1 00	 shl	 ecx, 0
  00723	8b 55 c0	 mov	 edx, DWORD PTR _i$[ebp]
  00726	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  0072a	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  0072d	8a 4c 0d a8	 mov	 cl, BYTE PTR _trans_data$[ebp+ecx]
  00731	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 3168 :          tga_data[i*req_comp+2] = trans_data[2];

  00735	ba 01 00 00 00	 mov	 edx, 1
  0073a	d1 e2		 shl	 edx, 1
  0073c	8b 45 c0	 mov	 eax, DWORD PTR _i$[ebp]
  0073f	0f af 45 18	 imul	 eax, DWORD PTR _req_comp$[ebp]
  00743	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  00746	8a 54 15 a8	 mov	 dl, BYTE PTR _trans_data$[ebp+edx]
  0074a	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 3169 :          break;

  0074e	eb 66		 jmp	 SHORT $LN13@tga_load
$LN48@tga_load:

; 3170 :       case 4:
; 3171 :          //   RGBA => RGBA
; 3172 :          tga_data[i*req_comp+0] = trans_data[0];

  00750	b8 01 00 00 00	 mov	 eax, 1
  00755	6b c8 00	 imul	 ecx, eax, 0
  00758	8b 55 c0	 mov	 edx, DWORD PTR _i$[ebp]
  0075b	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  0075f	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  00762	8a 4c 0d a8	 mov	 cl, BYTE PTR _trans_data$[ebp+ecx]
  00766	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 3173 :          tga_data[i*req_comp+1] = trans_data[1];

  00769	ba 01 00 00 00	 mov	 edx, 1
  0076e	c1 e2 00	 shl	 edx, 0
  00771	8b 45 c0	 mov	 eax, DWORD PTR _i$[ebp]
  00774	0f af 45 18	 imul	 eax, DWORD PTR _req_comp$[ebp]
  00778	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  0077b	8a 54 15 a8	 mov	 dl, BYTE PTR _trans_data$[ebp+edx]
  0077f	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 3174 :          tga_data[i*req_comp+2] = trans_data[2];

  00783	b8 01 00 00 00	 mov	 eax, 1
  00788	d1 e0		 shl	 eax, 1
  0078a	8b 4d c0	 mov	 ecx, DWORD PTR _i$[ebp]
  0078d	0f af 4d 18	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  00791	8b 55 c8	 mov	 edx, DWORD PTR _tga_data$[ebp]
  00794	8a 44 05 a8	 mov	 al, BYTE PTR _trans_data$[ebp+eax]
  00798	88 44 0a 02	 mov	 BYTE PTR [edx+ecx+2], al

; 3175 :          tga_data[i*req_comp+3] = trans_data[3];

  0079c	b9 01 00 00 00	 mov	 ecx, 1
  007a1	6b d1 03	 imul	 edx, ecx, 3
  007a4	8b 45 c0	 mov	 eax, DWORD PTR _i$[ebp]
  007a7	0f af 45 18	 imul	 eax, DWORD PTR _req_comp$[ebp]
  007ab	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  007ae	8a 54 15 a8	 mov	 dl, BYTE PTR _trans_data$[ebp+edx]
  007b2	88 54 01 03	 mov	 BYTE PTR [ecx+eax+3], dl
$LN13@tga_load:

; 3176 :          break;
; 3177 :       }
; 3178 :       //   in case we're in RLE mode, keep counting down
; 3179 :       --RLE_count;

  007b6	8b 45 a0	 mov	 eax, DWORD PTR _RLE_count$[ebp]
  007b9	83 e8 01	 sub	 eax, 1
  007bc	89 45 a0	 mov	 DWORD PTR _RLE_count$[ebp], eax

; 3180 :    }

  007bf	e9 a7 fb ff ff	 jmp	 $LN2@tga_load
$LN3@tga_load:

; 3181 :    //   do I need to invert the image?
; 3182 :    if ( tga_inverted )

  007c4	83 7d cc 00	 cmp	 DWORD PTR _tga_inverted$[ebp], 0
  007c8	0f 84 98 00 00
	00		 je	 $LN49@tga_load

; 3183 :    {
; 3184 :       for (j = 0; j*2 < tga_height; ++j)

  007ce	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  007d5	eb 09		 jmp	 SHORT $LN17@tga_load
$LN15@tga_load:
  007d7	8b 4d bc	 mov	 ecx, DWORD PTR _j$[ebp]
  007da	83 c1 01	 add	 ecx, 1
  007dd	89 4d bc	 mov	 DWORD PTR _j$[ebp], ecx
$LN17@tga_load:
  007e0	8b 55 bc	 mov	 edx, DWORD PTR _j$[ebp]
  007e3	d1 e2		 shl	 edx, 1
  007e5	3b 55 d4	 cmp	 edx, DWORD PTR _tga_height$[ebp]
  007e8	7d 7c		 jge	 SHORT $LN49@tga_load

; 3185 :       {
; 3186 :          int index1 = j * tga_width * req_comp;

  007ea	8b 45 bc	 mov	 eax, DWORD PTR _j$[ebp]
  007ed	0f af 45 d8	 imul	 eax, DWORD PTR _tga_width$[ebp]
  007f1	0f af 45 18	 imul	 eax, DWORD PTR _req_comp$[ebp]
  007f5	89 45 8c	 mov	 DWORD PTR _index1$4[ebp], eax

; 3187 :          int index2 = (tga_height - 1 - j) * tga_width * req_comp;

  007f8	8b 4d d4	 mov	 ecx, DWORD PTR _tga_height$[ebp]
  007fb	83 e9 01	 sub	 ecx, 1
  007fe	2b 4d bc	 sub	 ecx, DWORD PTR _j$[ebp]
  00801	0f af 4d d8	 imul	 ecx, DWORD PTR _tga_width$[ebp]
  00805	0f af 4d 18	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  00809	89 4d 88	 mov	 DWORD PTR _index2$3[ebp], ecx

; 3188 :          for (i = tga_width * req_comp; i > 0; --i)

  0080c	8b 55 d8	 mov	 edx, DWORD PTR _tga_width$[ebp]
  0080f	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  00813	89 55 c0	 mov	 DWORD PTR _i$[ebp], edx
  00816	eb 09		 jmp	 SHORT $LN20@tga_load
$LN18@tga_load:
  00818	8b 45 c0	 mov	 eax, DWORD PTR _i$[ebp]
  0081b	83 e8 01	 sub	 eax, 1
  0081e	89 45 c0	 mov	 DWORD PTR _i$[ebp], eax
$LN20@tga_load:
  00821	83 7d c0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00825	7e 3a		 jle	 SHORT $LN19@tga_load

; 3189 :          {
; 3190 :             unsigned char temp = tga_data[index1];

  00827	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  0082a	03 4d 8c	 add	 ecx, DWORD PTR _index1$4[ebp]
  0082d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0082f	88 55 87	 mov	 BYTE PTR _temp$2[ebp], dl

; 3191 :             tga_data[index1] = tga_data[index2];

  00832	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  00835	03 45 8c	 add	 eax, DWORD PTR _index1$4[ebp]
  00838	8b 4d c8	 mov	 ecx, DWORD PTR _tga_data$[ebp]
  0083b	03 4d 88	 add	 ecx, DWORD PTR _index2$3[ebp]
  0083e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00840	88 10		 mov	 BYTE PTR [eax], dl

; 3192 :             tga_data[index2] = temp;

  00842	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
  00845	03 45 88	 add	 eax, DWORD PTR _index2$3[ebp]
  00848	8a 4d 87	 mov	 cl, BYTE PTR _temp$2[ebp]
  0084b	88 08		 mov	 BYTE PTR [eax], cl

; 3193 :             ++index1;

  0084d	8b 55 8c	 mov	 edx, DWORD PTR _index1$4[ebp]
  00850	83 c2 01	 add	 edx, 1
  00853	89 55 8c	 mov	 DWORD PTR _index1$4[ebp], edx

; 3194 :             ++index2;

  00856	8b 45 88	 mov	 eax, DWORD PTR _index2$3[ebp]
  00859	83 c0 01	 add	 eax, 1
  0085c	89 45 88	 mov	 DWORD PTR _index2$3[ebp], eax

; 3195 :          }

  0085f	eb b7		 jmp	 SHORT $LN18@tga_load
$LN19@tga_load:

; 3196 :       }

  00861	e9 71 ff ff ff	 jmp	 $LN15@tga_load
$LN49@tga_load:

; 3197 :    }
; 3198 :    //   clear my palette, if I had one
; 3199 :    if ( tga_palette != NULL )

  00866	83 7d c4 00	 cmp	 DWORD PTR _tga_palette$[ebp], 0
  0086a	74 16		 je	 SHORT $LN50@tga_load

; 3200 :    {
; 3201 :       free( tga_palette );

  0086c	8b f4		 mov	 esi, esp
  0086e	8b 4d c4	 mov	 ecx, DWORD PTR _tga_palette$[ebp]
  00871	51		 push	 ecx
  00872	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00878	83 c4 04	 add	 esp, 4
  0087b	3b f4		 cmp	 esi, esp
  0087d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN50@tga_load:

; 3202 :    }
; 3203 :    //   the things I do to get rid of an error message, and yet keep
; 3204 :    //   Microsoft's C compilers happy... [8^(
; 3205 :    tga_palette_start = tga_palette_len = tga_palette_bits =

  00882	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _tga_y_origin$[ebp], 0
  00889	8b 55 dc	 mov	 edx, DWORD PTR _tga_y_origin$[ebp]
  0088c	89 55 e0	 mov	 DWORD PTR _tga_x_origin$[ebp], edx
  0088f	8b 45 e0	 mov	 eax, DWORD PTR _tga_x_origin$[ebp]
  00892	89 45 e4	 mov	 DWORD PTR _tga_palette_bits$[ebp], eax
  00895	8b 4d e4	 mov	 ecx, DWORD PTR _tga_palette_bits$[ebp]
  00898	89 4d e8	 mov	 DWORD PTR _tga_palette_len$[ebp], ecx
  0089b	8b 55 e8	 mov	 edx, DWORD PTR _tga_palette_len$[ebp]
  0089e	89 55 ec	 mov	 DWORD PTR _tga_palette_start$[ebp], edx

; 3206 :          tga_x_origin = tga_y_origin = 0;
; 3207 :    //   OK, done
; 3208 :    return tga_data;

  008a1	8b 45 c8	 mov	 eax, DWORD PTR _tga_data$[ebp]
$LN51@tga_load:

; 3209 : }

  008a4	52		 push	 edx
  008a5	8b cd		 mov	 ecx, ebp
  008a7	50		 push	 eax
  008a8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN64@tga_load
  008ae	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  008b3	58		 pop	 eax
  008b4	5a		 pop	 edx
  008b5	5f		 pop	 edi
  008b6	5e		 pop	 esi
  008b7	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  008bd	3b ec		 cmp	 ebp, esp
  008bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008c4	8b e5		 mov	 esp, ebp
  008c6	5d		 pop	 ebp
  008c7	c3		 ret	 0
$LN64@tga_load:
  008c8	02 00 00 00	 DD	 2
  008cc	00 00 00 00	 DD	 $LN63@tga_load
$LN63@tga_load:
  008d0	b4 ff ff ff	 DD	 -76			; ffffffb4H
  008d4	04 00 00 00	 DD	 4
  008d8	00 00 00 00	 DD	 $LN61@tga_load
  008dc	a8 ff ff ff	 DD	 -88			; ffffffa8H
  008e0	04 00 00 00	 DD	 4
  008e4	00 00 00 00	 DD	 $LN62@tga_load
$LN62@tga_load:
  008e8	74		 DB	 116			; 00000074H
  008e9	72		 DB	 114			; 00000072H
  008ea	61		 DB	 97			; 00000061H
  008eb	6e		 DB	 110			; 0000006eH
  008ec	73		 DB	 115			; 00000073H
  008ed	5f		 DB	 95			; 0000005fH
  008ee	64		 DB	 100			; 00000064H
  008ef	61		 DB	 97			; 00000061H
  008f0	74		 DB	 116			; 00000074H
  008f1	61		 DB	 97			; 00000061H
  008f2	00		 DB	 0
$LN61@tga_load:
  008f3	72		 DB	 114			; 00000072H
  008f4	61		 DB	 97			; 00000061H
  008f5	77		 DB	 119			; 00000077H
  008f6	5f		 DB	 95			; 0000005fH
  008f7	64		 DB	 100			; 00000064H
  008f8	61		 DB	 97			; 00000061H
  008f9	74		 DB	 116			; 00000074H
  008fa	61		 DB	 97			; 00000061H
  008fb	00		 DB	 0
$LN65@tga_load:
  008fc	00 00 00 00	 DD	 $LN41@tga_load
  00900	00 00 00 00	 DD	 $LN42@tga_load
  00904	00 00 00 00	 DD	 $LN43@tga_load
  00908	00 00 00 00	 DD	 $LN44@tga_load
  0090c	00 00 00 00	 DD	 $LN11@tga_load
$LN60@tga_load:
  00910	00		 DB	 0
  00911	04		 DB	 4
  00912	04		 DB	 4
  00913	04		 DB	 4
  00914	04		 DB	 4
  00915	04		 DB	 4
  00916	04		 DB	 4
  00917	04		 DB	 4
  00918	01		 DB	 1
  00919	04		 DB	 4
  0091a	04		 DB	 4
  0091b	04		 DB	 4
  0091c	04		 DB	 4
  0091d	04		 DB	 4
  0091e	04		 DB	 4
  0091f	04		 DB	 4
  00920	02		 DB	 2
  00921	04		 DB	 4
  00922	04		 DB	 4
  00923	04		 DB	 4
  00924	04		 DB	 4
  00925	04		 DB	 4
  00926	04		 DB	 4
  00927	04		 DB	 4
  00928	03		 DB	 3
  00929	0f 1f 00	 npad	 3
$LN66@tga_load:
  0092c	00 00 00 00	 DD	 $LN45@tga_load
  00930	00 00 00 00	 DD	 $LN46@tga_load
  00934	00 00 00 00	 DD	 $LN47@tga_load
  00938	00 00 00 00	 DD	 $LN48@tga_load
?tga_load@@YAPAEPAUstbi@@PAH11H@Z ENDP			; tga_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_tga_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_tga_load

; 3212 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3213 :    return tga_load(s,x,y,comp,req_comp);

  00003	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?tga_load@@YAPAEPAUstbi@@PAH11H@Z ; tga_load
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 3214 : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?stbi_tga_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_tga_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
?psd_test@@YAHPAUstbi@@@Z PROC				; psd_test

; 3221 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3222 :    if (get32(s) != 0x38425053) return 0;   // "8BPS"

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  0000c	83 c4 04	 add	 esp, 4
  0000f	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00014	74 06		 je	 SHORT $LN2@psd_test
  00016	33 c0		 xor	 eax, eax
  00018	eb 07		 jmp	 SHORT $LN1@psd_test
  0001a	eb 05		 jmp	 SHORT $LN1@psd_test
$LN2@psd_test:

; 3223 :    else return 1;

  0001c	b8 01 00 00 00	 mov	 eax, 1
$LN1@psd_test:

; 3224 : }

  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?psd_test@@YAHPAUstbi@@@Z ENDP				; psd_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_psd_test@@YAHPAUstbi@@@Z PROC			; stbi_psd_test

; 3227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3228 :    int r = psd_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?psd_test@@YAHPAUstbi@@@Z ; psd_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 3229 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 3230 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 3231 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_psd_test@@YAHPAUstbi@@@Z ENDP			; stbi_psd_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv213 = -88						; size = 4
tv182 = -84						; size = 4
tv168 = -80						; size = 4
tv156 = -76						; size = 4
tv137 = -72						; size = 4
tv130 = -68						; size = 4
tv87 = -64						; size = 4
tv77 = -60						; size = 4
tv70 = -56						; size = 4
_p$1 = -52						; size = 4
_val$2 = -45						; size = 1
_p$3 = -44						; size = 4
_out$ = -40						; size = 4
_h$ = -36						; size = 4
_w$ = -32						; size = 4
_len$ = -28						; size = 4
_count$ = -24						; size = 4
_i$ = -20						; size = 4
_channel$ = -16						; size = 4
_compression$ = -12					; size = 4
_channelCount$ = -8					; size = 4
_pixelCount$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?psd_load@@YAPAEPAUstbi@@PAH11H@Z PROC			; psd_load

; 3234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000b	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 3235 :    int   pixelCount;
; 3236 :    int channelCount, compression;
; 3237 :    int channel, i, count, len;
; 3238 :    int w,h;
; 3239 :    uint8 *out;
; 3240 : 
; 3241 :    // Check identifier
; 3242 :    if (get32(s) != 0x38425053)   // "8BPS"

  00017	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00020	83 c4 04	 add	 esp, 4
  00023	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00028	74 29		 je	 SHORT $LN23@psd_load

; 3243 :       return epuc("not PSD", "Corrupt PSD image");

  0002a	68 00 00 00 00	 push	 OFFSET $SG4294820144
  0002f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00034	83 c4 04	 add	 esp, 4
  00037	85 c0		 test	 eax, eax
  00039	74 09		 je	 SHORT $LN46@psd_load
  0003b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00042	eb 07		 jmp	 SHORT $LN47@psd_load
$LN46@psd_load:
  00044	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN47@psd_load:
  0004b	8b 45 c8	 mov	 eax, DWORD PTR tv70[ebp]
  0004e	e9 76 04 00 00	 jmp	 $LN1@psd_load
$LN23@psd_load:

; 3244 : 
; 3245 :    // Check file type version.
; 3246 :    if (get16(s) != 1)

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0005c	83 c4 04	 add	 esp, 4
  0005f	83 f8 01	 cmp	 eax, 1
  00062	74 29		 je	 SHORT $LN24@psd_load

; 3247 :       return epuc("wrong version", "Unsupported version of PSD image");

  00064	68 00 00 00 00	 push	 OFFSET $SG4294820143
  00069	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006e	83 c4 04	 add	 esp, 4
  00071	85 c0		 test	 eax, eax
  00073	74 09		 je	 SHORT $LN48@psd_load
  00075	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  0007c	eb 07		 jmp	 SHORT $LN49@psd_load
$LN48@psd_load:
  0007e	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN49@psd_load:
  00085	8b 45 c4	 mov	 eax, DWORD PTR tv77[ebp]
  00088	e9 3c 04 00 00	 jmp	 $LN1@psd_load
$LN24@psd_load:

; 3248 : 
; 3249 :    // Skip 6 reserved bytes.
; 3250 :    skip(s, 6 );

  0008d	6a 06		 push	 6
  0008f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00098	83 c4 08	 add	 esp, 8

; 3251 : 
; 3252 :    // Read the number of channels (R, G, B, A, etc).
; 3253 :    channelCount = get16(s);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000a4	83 c4 04	 add	 esp, 4
  000a7	89 45 f8	 mov	 DWORD PTR _channelCount$[ebp], eax

; 3254 :    if (channelCount < 0 || channelCount > 16)

  000aa	83 7d f8 00	 cmp	 DWORD PTR _channelCount$[ebp], 0
  000ae	7c 06		 jl	 SHORT $LN26@psd_load
  000b0	83 7d f8 10	 cmp	 DWORD PTR _channelCount$[ebp], 16 ; 00000010H
  000b4	7e 29		 jle	 SHORT $LN25@psd_load
$LN26@psd_load:

; 3255 :       return epuc("wrong channel count", "Unsupported number of channels in PSD image");

  000b6	68 00 00 00 00	 push	 OFFSET $SG4294820142
  000bb	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000c0	83 c4 04	 add	 esp, 4
  000c3	85 c0		 test	 eax, eax
  000c5	74 09		 je	 SHORT $LN50@psd_load
  000c7	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  000ce	eb 07		 jmp	 SHORT $LN51@psd_load
$LN50@psd_load:
  000d0	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN51@psd_load:
  000d7	8b 45 c0	 mov	 eax, DWORD PTR tv87[ebp]
  000da	e9 ea 03 00 00	 jmp	 $LN1@psd_load
$LN25@psd_load:

; 3256 : 
; 3257 :    // Read the rows and columns of the image.
; 3258 :    h = get32(s);

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  000e8	83 c4 04	 add	 esp, 4
  000eb	89 45 dc	 mov	 DWORD PTR _h$[ebp], eax

; 3259 :    w = get32(s);

  000ee	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000f1	52		 push	 edx
  000f2	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  000f7	83 c4 04	 add	 esp, 4
  000fa	89 45 e0	 mov	 DWORD PTR _w$[ebp], eax

; 3260 :    
; 3261 :    // Make sure the depth is 8 bits.
; 3262 :    if (get16(s) != 8)

  000fd	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00106	83 c4 04	 add	 esp, 4
  00109	83 f8 08	 cmp	 eax, 8
  0010c	74 29		 je	 SHORT $LN27@psd_load

; 3263 :       return epuc("unsupported bit depth", "PSD bit depth is not 8 bit");

  0010e	68 00 00 00 00	 push	 OFFSET $SG4294820141
  00113	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00118	83 c4 04	 add	 esp, 4
  0011b	85 c0		 test	 eax, eax
  0011d	74 09		 je	 SHORT $LN52@psd_load
  0011f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
  00126	eb 07		 jmp	 SHORT $LN53@psd_load
$LN52@psd_load:
  00128	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN53@psd_load:
  0012f	8b 45 bc	 mov	 eax, DWORD PTR tv130[ebp]
  00132	e9 92 03 00 00	 jmp	 $LN1@psd_load
$LN27@psd_load:

; 3264 : 
; 3265 :    // Make sure the color mode is RGB.
; 3266 :    // Valid options are:
; 3267 :    //   0: Bitmap
; 3268 :    //   1: Grayscale
; 3269 :    //   2: Indexed color
; 3270 :    //   3: RGB color
; 3271 :    //   4: CMYK color
; 3272 :    //   7: Multichannel
; 3273 :    //   8: Duotone
; 3274 :    //   9: Lab color
; 3275 :    if (get16(s) != 3)

  00137	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00140	83 c4 04	 add	 esp, 4
  00143	83 f8 03	 cmp	 eax, 3
  00146	74 29		 je	 SHORT $LN28@psd_load

; 3276 :       return epuc("wrong color format", "PSD is not in RGB color format");

  00148	68 00 00 00 00	 push	 OFFSET $SG4294820140
  0014d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00152	83 c4 04	 add	 esp, 4
  00155	85 c0		 test	 eax, eax
  00157	74 09		 je	 SHORT $LN54@psd_load
  00159	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  00160	eb 07		 jmp	 SHORT $LN55@psd_load
$LN54@psd_load:
  00162	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
$LN55@psd_load:
  00169	8b 45 b8	 mov	 eax, DWORD PTR tv137[ebp]
  0016c	e9 58 03 00 00	 jmp	 $LN1@psd_load
$LN28@psd_load:

; 3277 : 
; 3278 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 3279 :    skip(s,get32(s) );

  00171	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  0017a	83 c4 04	 add	 esp, 4
  0017d	50		 push	 eax
  0017e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00187	83 c4 08	 add	 esp, 8

; 3280 : 
; 3281 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 3282 :    skip(s, get32(s) );

  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00193	83 c4 04	 add	 esp, 4
  00196	50		 push	 eax
  00197	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0019a	52		 push	 edx
  0019b	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  001a0	83 c4 08	 add	 esp, 8

; 3283 : 
; 3284 :    // Skip the reserved data.
; 3285 :    skip(s, get32(s) );

  001a3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  001b9	83 c4 08	 add	 esp, 8

; 3286 : 
; 3287 :    // Find out if the data is compressed.
; 3288 :    // Known values:
; 3289 :    //   0: no compression
; 3290 :    //   1: RLE compressed
; 3291 :    compression = get16(s);

  001bc	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  001bf	52		 push	 edx
  001c0	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  001c5	83 c4 04	 add	 esp, 4
  001c8	89 45 f4	 mov	 DWORD PTR _compression$[ebp], eax

; 3292 :    if (compression > 1)

  001cb	83 7d f4 01	 cmp	 DWORD PTR _compression$[ebp], 1
  001cf	7e 29		 jle	 SHORT $LN29@psd_load

; 3293 :       return epuc("bad compression", "PSD has an unknown compression format");

  001d1	68 00 00 00 00	 push	 OFFSET $SG4294820139
  001d6	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001db	83 c4 04	 add	 esp, 4
  001de	85 c0		 test	 eax, eax
  001e0	74 09		 je	 SHORT $LN56@psd_load
  001e2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
  001e9	eb 07		 jmp	 SHORT $LN57@psd_load
$LN56@psd_load:
  001eb	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
$LN57@psd_load:
  001f2	8b 45 b4	 mov	 eax, DWORD PTR tv156[ebp]
  001f5	e9 cf 02 00 00	 jmp	 $LN1@psd_load
$LN29@psd_load:

; 3294 : 
; 3295 :    // Create the destination image.
; 3296 :    out = (stbi_uc *) malloc(4 * w*h);

  001fa	8b 45 e0	 mov	 eax, DWORD PTR _w$[ebp]
  001fd	c1 e0 02	 shl	 eax, 2
  00200	0f af 45 dc	 imul	 eax, DWORD PTR _h$[ebp]
  00204	8b f4		 mov	 esi, esp
  00206	50		 push	 eax
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0020d	83 c4 04	 add	 esp, 4
  00210	3b f4		 cmp	 esi, esp
  00212	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00217	89 45 d8	 mov	 DWORD PTR _out$[ebp], eax

; 3297 :    if (!out) return epuc("outofmem", "Out of memory");

  0021a	83 7d d8 00	 cmp	 DWORD PTR _out$[ebp], 0
  0021e	75 29		 jne	 SHORT $LN30@psd_load
  00220	68 00 00 00 00	 push	 OFFSET $SG4294820138
  00225	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0022a	83 c4 04	 add	 esp, 4
  0022d	85 c0		 test	 eax, eax
  0022f	74 09		 je	 SHORT $LN58@psd_load
  00231	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  00238	eb 07		 jmp	 SHORT $LN59@psd_load
$LN58@psd_load:
  0023a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
$LN59@psd_load:
  00241	8b 45 b0	 mov	 eax, DWORD PTR tv168[ebp]
  00244	e9 80 02 00 00	 jmp	 $LN1@psd_load
$LN30@psd_load:

; 3298 :    pixelCount = w*h;

  00249	8b 4d e0	 mov	 ecx, DWORD PTR _w$[ebp]
  0024c	0f af 4d dc	 imul	 ecx, DWORD PTR _h$[ebp]
  00250	89 4d fc	 mov	 DWORD PTR _pixelCount$[ebp], ecx

; 3299 : 
; 3300 :    // Initialize the data to zero.
; 3301 :    //memset( out, 0, pixelCount * 4 );
; 3302 :    
; 3303 :    // Finally, the image data.
; 3304 :    if (compression) {

  00253	83 7d f4 00	 cmp	 DWORD PTR _compression$[ebp], 0
  00257	0f 84 6a 01 00
	00		 je	 $LN31@psd_load

; 3305 :       // RLE as used by .PSD and .TIFF
; 3306 :       // Loop until you get the number of unpacked bytes you are expecting:
; 3307 :       //     Read the next source byte into n.
; 3308 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 3309 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 3310 :       //     Else if n is 128, noop.
; 3311 :       // Endloop
; 3312 : 
; 3313 :       // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
; 3314 :       // which we're going to just skip.
; 3315 :       skip(s, h * channelCount * 2 );

  0025d	8b 55 dc	 mov	 edx, DWORD PTR _h$[ebp]
  00260	0f af 55 f8	 imul	 edx, DWORD PTR _channelCount$[ebp]
  00264	d1 e2		 shl	 edx, 1
  00266	52		 push	 edx
  00267	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00270	83 c4 08	 add	 esp, 8

; 3316 : 
; 3317 :       // Read the RLE data by channel.
; 3318 :       for (channel = 0; channel < 4; channel++) {

  00273	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _channel$[ebp], 0
  0027a	eb 09		 jmp	 SHORT $LN4@psd_load
$LN2@psd_load:
  0027c	8b 4d f0	 mov	 ecx, DWORD PTR _channel$[ebp]
  0027f	83 c1 01	 add	 ecx, 1
  00282	89 4d f0	 mov	 DWORD PTR _channel$[ebp], ecx
$LN4@psd_load:
  00285	83 7d f0 04	 cmp	 DWORD PTR _channel$[ebp], 4
  00289	0f 8d 33 01 00
	00		 jge	 $LN3@psd_load

; 3319 :          uint8 *p;
; 3320 :          
; 3321 :          p = out+channel;

  0028f	8b 55 d8	 mov	 edx, DWORD PTR _out$[ebp]
  00292	03 55 f0	 add	 edx, DWORD PTR _channel$[ebp]
  00295	89 55 d4	 mov	 DWORD PTR _p$3[ebp], edx

; 3322 :          if (channel >= channelCount) {

  00298	8b 45 f0	 mov	 eax, DWORD PTR _channel$[ebp]
  0029b	3b 45 f8	 cmp	 eax, DWORD PTR _channelCount$[ebp]
  0029e	7c 48		 jl	 SHORT $LN33@psd_load

; 3323 :             // Fill this channel with default data.
; 3324 :             for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;

  002a0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002a7	eb 09		 jmp	 SHORT $LN7@psd_load
$LN5@psd_load:
  002a9	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  002ac	83 c1 01	 add	 ecx, 1
  002af	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$LN7@psd_load:
  002b2	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  002b5	3b 55 fc	 cmp	 edx, DWORD PTR _pixelCount$[ebp]
  002b8	7d 29		 jge	 SHORT $LN6@psd_load
  002ba	83 7d f0 03	 cmp	 DWORD PTR _channel$[ebp], 3
  002be	75 09		 jne	 SHORT $LN60@psd_load
  002c0	c7 45 ac ff 00
	00 00		 mov	 DWORD PTR tv182[ebp], 255 ; 000000ffH
  002c7	eb 07		 jmp	 SHORT $LN61@psd_load
$LN60@psd_load:
  002c9	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
$LN61@psd_load:
  002d0	8b 45 d4	 mov	 eax, DWORD PTR _p$3[ebp]
  002d3	8a 4d ac	 mov	 cl, BYTE PTR tv182[ebp]
  002d6	88 08		 mov	 BYTE PTR [eax], cl
  002d8	8b 55 d4	 mov	 edx, DWORD PTR _p$3[ebp]
  002db	83 c2 04	 add	 edx, 4
  002de	89 55 d4	 mov	 DWORD PTR _p$3[ebp], edx
  002e1	eb c6		 jmp	 SHORT $LN5@psd_load
$LN6@psd_load:

; 3325 :          } else {

  002e3	e9 d5 00 00 00	 jmp	 $LN34@psd_load
$LN33@psd_load:

; 3326 :             // Read the RLE data.
; 3327 :             count = 0;

  002e8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN8@psd_load:

; 3328 :             while (count < pixelCount) {

  002ef	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]
  002f2	3b 45 fc	 cmp	 eax, DWORD PTR _pixelCount$[ebp]
  002f5	0f 8d c2 00 00
	00		 jge	 $LN34@psd_load

; 3329 :                len = get8(s);

  002fb	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  002fe	51		 push	 ecx
  002ff	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00304	83 c4 04	 add	 esp, 4
  00307	89 45 e4	 mov	 DWORD PTR _len$[ebp], eax

; 3330 :                if (len == 128) {

  0030a	81 7d e4 80 00
	00 00		 cmp	 DWORD PTR _len$[ebp], 128 ; 00000080H
  00311	75 05		 jne	 SHORT $LN35@psd_load
  00313	e9 a0 00 00 00	 jmp	 $LN36@psd_load
$LN35@psd_load:

; 3331 :                   // No-op.
; 3332 :                } else if (len < 128) {

  00318	81 7d e4 80 00
	00 00		 cmp	 DWORD PTR _len$[ebp], 128 ; 00000080H
  0031f	7d 3f		 jge	 SHORT $LN37@psd_load

; 3333 :                   // Copy next len+1 bytes literally.
; 3334 :                   len++;

  00321	8b 55 e4	 mov	 edx, DWORD PTR _len$[ebp]
  00324	83 c2 01	 add	 edx, 1
  00327	89 55 e4	 mov	 DWORD PTR _len$[ebp], edx

; 3335 :                   count += len;

  0032a	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]
  0032d	03 45 e4	 add	 eax, DWORD PTR _len$[ebp]
  00330	89 45 e8	 mov	 DWORD PTR _count$[ebp], eax
$LN10@psd_load:

; 3336 :                   while (len) {

  00333	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00337	74 25		 je	 SHORT $LN11@psd_load

; 3337 :                      *p = get8u(s);

  00339	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0033c	51		 push	 ecx
  0033d	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00342	83 c4 04	 add	 esp, 4
  00345	8b 55 d4	 mov	 edx, DWORD PTR _p$3[ebp]
  00348	88 02		 mov	 BYTE PTR [edx], al

; 3338 :                      p += 4;

  0034a	8b 45 d4	 mov	 eax, DWORD PTR _p$3[ebp]
  0034d	83 c0 04	 add	 eax, 4
  00350	89 45 d4	 mov	 DWORD PTR _p$3[ebp], eax

; 3339 :                      len--;

  00353	8b 4d e4	 mov	 ecx, DWORD PTR _len$[ebp]
  00356	83 e9 01	 sub	 ecx, 1
  00359	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx

; 3340 :                   }

  0035c	eb d5		 jmp	 SHORT $LN10@psd_load
$LN11@psd_load:

; 3341 :                } else if (len > 128) {

  0035e	eb 58		 jmp	 SHORT $LN36@psd_load
$LN37@psd_load:
  00360	81 7d e4 80 00
	00 00		 cmp	 DWORD PTR _len$[ebp], 128 ; 00000080H
  00367	7e 4f		 jle	 SHORT $LN36@psd_load

; 3342 :                   uint8   val;
; 3343 :                   // Next -len+1 bytes in the dest are replicated from next source byte.
; 3344 :                   // (Interpret len as a negative 8-bit int.)
; 3345 :                   len ^= 0x0FF;

  00369	8b 55 e4	 mov	 edx, DWORD PTR _len$[ebp]
  0036c	81 f2 ff 00 00
	00		 xor	 edx, 255		; 000000ffH
  00372	89 55 e4	 mov	 DWORD PTR _len$[ebp], edx

; 3346 :                   len += 2;

  00375	8b 45 e4	 mov	 eax, DWORD PTR _len$[ebp]
  00378	83 c0 02	 add	 eax, 2
  0037b	89 45 e4	 mov	 DWORD PTR _len$[ebp], eax

; 3347 :                   val = get8u(s);

  0037e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00381	51		 push	 ecx
  00382	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00387	83 c4 04	 add	 esp, 4
  0038a	88 45 d3	 mov	 BYTE PTR _val$2[ebp], al

; 3348 :                   count += len;

  0038d	8b 55 e8	 mov	 edx, DWORD PTR _count$[ebp]
  00390	03 55 e4	 add	 edx, DWORD PTR _len$[ebp]
  00393	89 55 e8	 mov	 DWORD PTR _count$[ebp], edx
$LN12@psd_load:

; 3349 :                   while (len) {

  00396	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  0039a	74 1c		 je	 SHORT $LN36@psd_load

; 3350 :                      *p = val;

  0039c	8b 45 d4	 mov	 eax, DWORD PTR _p$3[ebp]
  0039f	8a 4d d3	 mov	 cl, BYTE PTR _val$2[ebp]
  003a2	88 08		 mov	 BYTE PTR [eax], cl

; 3351 :                      p += 4;

  003a4	8b 55 d4	 mov	 edx, DWORD PTR _p$3[ebp]
  003a7	83 c2 04	 add	 edx, 4
  003aa	89 55 d4	 mov	 DWORD PTR _p$3[ebp], edx

; 3352 :                      len--;

  003ad	8b 45 e4	 mov	 eax, DWORD PTR _len$[ebp]
  003b0	83 e8 01	 sub	 eax, 1
  003b3	89 45 e4	 mov	 DWORD PTR _len$[ebp], eax

; 3353 :                   }

  003b6	eb de		 jmp	 SHORT $LN12@psd_load
$LN36@psd_load:

; 3354 :                }
; 3355 :             }

  003b8	e9 32 ff ff ff	 jmp	 $LN8@psd_load
$LN34@psd_load:

; 3356 :          }
; 3357 :       }

  003bd	e9 ba fe ff ff	 jmp	 $LN2@psd_load
$LN3@psd_load:

; 3358 :       
; 3359 :    } else {

  003c2	e9 ad 00 00 00	 jmp	 $LN32@psd_load
$LN31@psd_load:

; 3360 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 3361 :       // where each channel consists of an 8-bit value for each pixel in the image.
; 3362 :       
; 3363 :       // Read the data by channel.
; 3364 :       for (channel = 0; channel < 4; channel++) {

  003c7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _channel$[ebp], 0
  003ce	eb 09		 jmp	 SHORT $LN16@psd_load
$LN14@psd_load:
  003d0	8b 4d f0	 mov	 ecx, DWORD PTR _channel$[ebp]
  003d3	83 c1 01	 add	 ecx, 1
  003d6	89 4d f0	 mov	 DWORD PTR _channel$[ebp], ecx
$LN16@psd_load:
  003d9	83 7d f0 04	 cmp	 DWORD PTR _channel$[ebp], 4
  003dd	0f 8d 91 00 00
	00		 jge	 $LN32@psd_load

; 3365 :          uint8 *p;
; 3366 :          
; 3367 :          p = out + channel;

  003e3	8b 55 d8	 mov	 edx, DWORD PTR _out$[ebp]
  003e6	03 55 f0	 add	 edx, DWORD PTR _channel$[ebp]
  003e9	89 55 cc	 mov	 DWORD PTR _p$1[ebp], edx

; 3368 :          if (channel > channelCount) {

  003ec	8b 45 f0	 mov	 eax, DWORD PTR _channel$[ebp]
  003ef	3b 45 f8	 cmp	 eax, DWORD PTR _channelCount$[ebp]
  003f2	7e 45		 jle	 SHORT $LN40@psd_load

; 3369 :             // Fill this channel with default data.
; 3370 :             for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;

  003f4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003fb	eb 09		 jmp	 SHORT $LN19@psd_load
$LN17@psd_load:
  003fd	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00400	83 c1 01	 add	 ecx, 1
  00403	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$LN19@psd_load:
  00406	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  00409	3b 55 fc	 cmp	 edx, DWORD PTR _pixelCount$[ebp]
  0040c	7d 29		 jge	 SHORT $LN18@psd_load
  0040e	83 7d f0 03	 cmp	 DWORD PTR _channel$[ebp], 3
  00412	75 09		 jne	 SHORT $LN62@psd_load
  00414	c7 45 a8 ff 00
	00 00		 mov	 DWORD PTR tv213[ebp], 255 ; 000000ffH
  0041b	eb 07		 jmp	 SHORT $LN63@psd_load
$LN62@psd_load:
  0041d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
$LN63@psd_load:
  00424	8b 45 cc	 mov	 eax, DWORD PTR _p$1[ebp]
  00427	8a 4d a8	 mov	 cl, BYTE PTR tv213[ebp]
  0042a	88 08		 mov	 BYTE PTR [eax], cl
  0042c	8b 55 cc	 mov	 edx, DWORD PTR _p$1[ebp]
  0042f	83 c2 04	 add	 edx, 4
  00432	89 55 cc	 mov	 DWORD PTR _p$1[ebp], edx
  00435	eb c6		 jmp	 SHORT $LN17@psd_load
$LN18@psd_load:

; 3371 :          } else {

  00437	eb 36		 jmp	 SHORT $LN41@psd_load
$LN40@psd_load:

; 3372 :             // Read the data.
; 3373 :             for (i = 0; i < pixelCount; i++)

  00439	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00440	eb 09		 jmp	 SHORT $LN22@psd_load
$LN20@psd_load:
  00442	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00445	83 c0 01	 add	 eax, 1
  00448	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN22@psd_load:
  0044b	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0044e	3b 4d fc	 cmp	 ecx, DWORD PTR _pixelCount$[ebp]
  00451	7d 1c		 jge	 SHORT $LN41@psd_load

; 3374 :                *p = get8u(s), p += 4;

  00453	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00456	52		 push	 edx
  00457	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0045c	83 c4 04	 add	 esp, 4
  0045f	8b 4d cc	 mov	 ecx, DWORD PTR _p$1[ebp]
  00462	88 01		 mov	 BYTE PTR [ecx], al
  00464	8b 55 cc	 mov	 edx, DWORD PTR _p$1[ebp]
  00467	83 c2 04	 add	 edx, 4
  0046a	89 55 cc	 mov	 DWORD PTR _p$1[ebp], edx
  0046d	eb d3		 jmp	 SHORT $LN20@psd_load
$LN41@psd_load:

; 3375 :          }
; 3376 :       }

  0046f	e9 5c ff ff ff	 jmp	 $LN14@psd_load
$LN32@psd_load:

; 3377 :    }
; 3378 : 
; 3379 :    if (req_comp && req_comp != 4) {

  00474	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  00478	74 2e		 je	 SHORT $LN42@psd_load
  0047a	83 7d 18 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  0047e	74 28		 je	 SHORT $LN42@psd_load

; 3380 :       out = convert_format(out, 4, req_comp, w, h);

  00480	8b 45 dc	 mov	 eax, DWORD PTR _h$[ebp]
  00483	50		 push	 eax
  00484	8b 4d e0	 mov	 ecx, DWORD PTR _w$[ebp]
  00487	51		 push	 ecx
  00488	8b 55 18	 mov	 edx, DWORD PTR _req_comp$[ebp]
  0048b	52		 push	 edx
  0048c	6a 04		 push	 4
  0048e	8b 45 d8	 mov	 eax, DWORD PTR _out$[ebp]
  00491	50		 push	 eax
  00492	e8 00 00 00 00	 call	 ?convert_format@@YAPAEPAEHHII@Z ; convert_format
  00497	83 c4 14	 add	 esp, 20			; 00000014H
  0049a	89 45 d8	 mov	 DWORD PTR _out$[ebp], eax

; 3381 :       if (out == NULL) return out; // convert_format frees input on failure

  0049d	83 7d d8 00	 cmp	 DWORD PTR _out$[ebp], 0
  004a1	75 05		 jne	 SHORT $LN42@psd_load
  004a3	8b 45 d8	 mov	 eax, DWORD PTR _out$[ebp]
  004a6	eb 21		 jmp	 SHORT $LN1@psd_load
$LN42@psd_load:

; 3382 :    }
; 3383 : 
; 3384 :    if (comp) *comp = channelCount;

  004a8	83 7d 14 00	 cmp	 DWORD PTR _comp$[ebp], 0
  004ac	74 08		 je	 SHORT $LN44@psd_load
  004ae	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  004b1	8b 55 f8	 mov	 edx, DWORD PTR _channelCount$[ebp]
  004b4	89 11		 mov	 DWORD PTR [ecx], edx
$LN44@psd_load:

; 3385 :    *y = h;

  004b6	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  004b9	8b 4d dc	 mov	 ecx, DWORD PTR _h$[ebp]
  004bc	89 08		 mov	 DWORD PTR [eax], ecx

; 3386 :    *x = w;

  004be	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  004c1	8b 45 e0	 mov	 eax, DWORD PTR _w$[ebp]
  004c4	89 02		 mov	 DWORD PTR [edx], eax

; 3387 :    
; 3388 :    return out;

  004c6	8b 45 d8	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@psd_load:

; 3389 : }

  004c9	5f		 pop	 edi
  004ca	5e		 pop	 esi
  004cb	83 c4 58	 add	 esp, 88			; 00000058H
  004ce	3b ec		 cmp	 ebp, esp
  004d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004d5	8b e5		 mov	 esp, ebp
  004d7	5d		 pop	 ebp
  004d8	c3		 ret	 0
?psd_load@@YAPAEPAUstbi@@PAH11H@Z ENDP			; psd_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_psd_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_psd_load

; 3392 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3393 :    return psd_load(s,x,y,comp,req_comp);

  00003	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?psd_load@@YAPAEPAUstbi@@PAH11H@Z ; psd_load
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 3394 : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?stbi_psd_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_psd_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_str$ = 12						; size = 4
?pic_is4@@YAHPAUstbi@@PBD@Z PROC			; pic_is4

; 3404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3405 :    int i;
; 3406 :    for (i=0; i<4; ++i)

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00012	eb 09		 jmp	 SHORT $LN4@pic_is4
$LN2@pic_is4:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@pic_is4:
  0001d	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00021	7d 1f		 jge	 SHORT $LN3@pic_is4

; 3407 :       if (get8(s) != (stbi_uc)str[i])

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00032	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00035	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  00038	3b c1		 cmp	 eax, ecx
  0003a	74 04		 je	 SHORT $LN5@pic_is4

; 3408 :          return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 07		 jmp	 SHORT $LN1@pic_is4
$LN5@pic_is4:

; 3409 : 
; 3410 :    return 1;

  00040	eb d2		 jmp	 SHORT $LN2@pic_is4
$LN3@pic_is4:
  00042	b8 01 00 00 00	 mov	 eax, 1
$LN1@pic_is4:

; 3411 : }

  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?pic_is4@@YAHPAUstbi@@PBD@Z ENDP			; pic_is4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_s$ = 8							; size = 4
?pic_test@@YAHPAUstbi@@@Z PROC				; pic_test

; 3414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3415 :    int i;
; 3416 : 
; 3417 :    if (!pic_is4(s,"\x53\x80\xF6\x34"))

  0000b	68 00 00 00 00	 push	 OFFSET $SG4294820137
  00010	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?pic_is4@@YAHPAUstbi@@PBD@Z ; pic_is4
  00019	83 c4 08	 add	 esp, 8
  0001c	85 c0		 test	 eax, eax
  0001e	75 04		 jne	 SHORT $LN5@pic_test

; 3418 :       return 0;

  00020	33 c0		 xor	 eax, eax
  00022	eb 44		 jmp	 SHORT $LN1@pic_test
$LN5@pic_test:

; 3419 : 
; 3420 :    for(i=0;i<84;++i)

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@pic_test
$LN2@pic_test:
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@pic_test:
  00036	83 7d fc 54	 cmp	 DWORD PTR _i$[ebp], 84	; 00000054H
  0003a	7d 0e		 jge	 SHORT $LN3@pic_test

; 3421 :       get8(s);

  0003c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00045	83 c4 04	 add	 esp, 4
  00048	eb e3		 jmp	 SHORT $LN2@pic_test
$LN3@pic_test:

; 3422 : 
; 3423 :    if (!pic_is4(s,"PICT"))

  0004a	68 00 00 00 00	 push	 OFFSET $SG4294820136
  0004f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?pic_is4@@YAHPAUstbi@@PBD@Z ; pic_is4
  00058	83 c4 08	 add	 esp, 8
  0005b	85 c0		 test	 eax, eax
  0005d	75 04		 jne	 SHORT $LN6@pic_test

; 3424 :       return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 05		 jmp	 SHORT $LN1@pic_test
$LN6@pic_test:

; 3425 : 
; 3426 :    return 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@pic_test:

; 3427 : }

  00068	83 c4 04	 add	 esp, 4
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?pic_test@@YAHPAUstbi@@@Z ENDP				; pic_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv75 = -12						; size = 4
_i$ = -8						; size = 4
_mask$ = -4						; size = 4
_s$ = 8							; size = 4
_channel$ = 12						; size = 4
_dest$ = 16						; size = 4
?pic_readval@@YAPAEPAUstbi@@HPAE@Z PROC			; pic_readval

; 3435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3436 :    int mask=0x80, i;

  0001b	c7 45 fc 80 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 128 ; 00000080H

; 3437 : 
; 3438 :    for (i=0; i<4; ++i, mask>>=1) {

  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00029	eb 11		 jmp	 SHORT $LN4@pic_readva
$LN2@pic_readva:
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _mask$[ebp]
  00037	d1 f9		 sar	 ecx, 1
  00039	89 4d fc	 mov	 DWORD PTR _mask$[ebp], ecx
$LN4@pic_readva:
  0003c	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00040	7d 54		 jge	 SHORT $LN3@pic_readva

; 3439 :       if (channel & mask) {

  00042	8b 55 0c	 mov	 edx, DWORD PTR _channel$[ebp]
  00045	23 55 fc	 and	 edx, DWORD PTR _mask$[ebp]
  00048	74 4a		 je	 SHORT $LN5@pic_readva

; 3440 :          if (at_eof(s)) return epuc("bad file","PIC file too short");

  0004a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  00053	83 c4 04	 add	 esp, 4
  00056	85 c0		 test	 eax, eax
  00058	74 26		 je	 SHORT $LN6@pic_readva
  0005a	68 00 00 00 00	 push	 OFFSET $SG4294820135
  0005f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00064	83 c4 04	 add	 esp, 4
  00067	85 c0		 test	 eax, eax
  00069	74 09		 je	 SHORT $LN8@pic_readva
  0006b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  00072	eb 07		 jmp	 SHORT $LN9@pic_readva
$LN8@pic_readva:
  00074	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN9@pic_readva:
  0007b	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0007e	eb 19		 jmp	 SHORT $LN1@pic_readva
$LN6@pic_readva:

; 3441 :          dest[i]=get8u(s);

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00089	83 c4 04	 add	 esp, 4
  0008c	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  0008f	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00092	88 02		 mov	 BYTE PTR [edx], al
$LN5@pic_readva:

; 3442 :       }
; 3443 :    }

  00094	eb 95		 jmp	 SHORT $LN2@pic_readva
$LN3@pic_readva:

; 3444 : 
; 3445 :    return dest;

  00096	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
$LN1@pic_readva:

; 3446 : }

  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?pic_readval@@YAPAEPAUstbi@@HPAE@Z ENDP			; pic_readval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mask$ = -4						; size = 4
_channel$ = 8						; size = 4
_dest$ = 12						; size = 4
_src$ = 16						; size = 4
?pic_copyval@@YAXHPAEPBE@Z PROC				; pic_copyval

; 3449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3450 :    int mask=0x80,i;

  00014	c7 45 fc 80 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 128 ; 00000080H

; 3451 : 
; 3452 :    for (i=0;i<4; ++i, mask>>=1)

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 11		 jmp	 SHORT $LN4@pic_copyva
$LN2@pic_copyva:
  00024	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _mask$[ebp]
  00030	d1 f9		 sar	 ecx, 1
  00032	89 4d fc	 mov	 DWORD PTR _mask$[ebp], ecx
$LN4@pic_copyva:
  00035	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00039	7d 1a		 jge	 SHORT $LN1@pic_copyva

; 3453 :       if (channel&mask)

  0003b	8b 55 08	 mov	 edx, DWORD PTR _channel$[ebp]
  0003e	23 55 fc	 and	 edx, DWORD PTR _mask$[ebp]
  00041	74 10		 je	 SHORT $LN5@pic_copyva

; 3454 :          dest[i]=src[i];

  00043	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00046	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00049	8b 4d 10	 mov	 ecx, DWORD PTR _src$[ebp]
  0004c	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  0004f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00051	88 10		 mov	 BYTE PTR [eax], dl
$LN5@pic_copyva:

; 3455 : }

  00053	eb cf		 jmp	 SHORT $LN2@pic_copyva
$LN1@pic_copyva:
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?pic_copyval@@YAXHPAEPBE@Z ENDP				; pic_copyval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv232 = -172						; size = 4
tv211 = -168						; size = 4
tv201 = -164						; size = 4
tv171 = -160						; size = 4
tv151 = -156						; size = 4
tv147 = -152						; size = 4
tv135 = -148						; size = 4
tv131 = -144						; size = 4
tv92 = -140						; size = 4
tv68 = -136						; size = 4
_i$1 = -132						; size = 4
_value$2 = -124						; size = 4
_i$3 = -116						; size = 4
_count$4 = -112						; size = 4
_left$5 = -108						; size = 4
_value$6 = -100						; size = 4
_count$7 = -89						; size = 1
_i$8 = -88						; size = 4
_left$9 = -84						; size = 4
_x$10 = -80						; size = 4
_dest$11 = -76						; size = 4
_packet$12 = -72					; size = 4
_packet_idx$13 = -68					; size = 4
_packet$14 = -64					; size = 4
_packets$ = -56						; size = 30
_chained$ = -20						; size = 4
_y$ = -16						; size = 4
_num_packets$ = -12					; size = 4
_act_comp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_comp$ = 20						; size = 4
_result$ = 24						; size = 4
?pic_load2@@YAPAEPAUstbi@@HHPAHPAE@Z PROC		; pic_load2

; 3458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	57		 push	 edi
  0000a	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00010	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3459 :    int act_comp=0,num_packets=0,y,chained;

  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _act_comp$[ebp], 0
  0002d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _num_packets$[ebp], 0
$LN4@pic_load2:

; 3460 :    pic_packet_t packets[10];
; 3461 : 
; 3462 :    // this will (should...) cater for even some bizarre stuff like having data
; 3463 :     // for the same channel in multiple packets.
; 3464 :    do {
; 3465 :       pic_packet_t *packet;
; 3466 : 
; 3467 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))

  00034	83 7d f4 0a	 cmp	 DWORD PTR _num_packets$[ebp], 10 ; 0000000aH
  00038	75 32		 jne	 SHORT $LN29@pic_load2

; 3468 :          return epuc("bad format","too many packets");

  0003a	68 00 00 00 00	 push	 OFFSET $SG4294820134
  0003f	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00044	83 c4 04	 add	 esp, 4
  00047	85 c0		 test	 eax, eax
  00049	74 0c		 je	 SHORT $LN50@pic_load2
  0004b	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00055	eb 0a		 jmp	 SHORT $LN51@pic_load2
$LN50@pic_load2:
  00057	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN51@pic_load2:
  00061	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  00067	e9 df 04 00 00	 jmp	 $LN1@pic_load2
$LN29@pic_load2:

; 3469 : 
; 3470 :       packet = &packets[num_packets++];

  0006c	6b 45 f4 03	 imul	 eax, DWORD PTR _num_packets$[ebp], 3
  00070	8d 4c 05 c8	 lea	 ecx, DWORD PTR _packets$[ebp+eax]
  00074	89 4d c0	 mov	 DWORD PTR _packet$14[ebp], ecx
  00077	8b 55 f4	 mov	 edx, DWORD PTR _num_packets$[ebp]
  0007a	83 c2 01	 add	 edx, 1
  0007d	89 55 f4	 mov	 DWORD PTR _num_packets$[ebp], edx

; 3471 : 
; 3472 :       chained = get8(s);

  00080	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00089	83 c4 04	 add	 esp, 4
  0008c	89 45 ec	 mov	 DWORD PTR _chained$[ebp], eax

; 3473 :       packet->size    = get8u(s);

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00098	83 c4 04	 add	 esp, 4
  0009b	8b 55 c0	 mov	 edx, DWORD PTR _packet$14[ebp]
  0009e	88 02		 mov	 BYTE PTR [edx], al

; 3474 :       packet->type    = get8u(s);

  000a0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000a9	83 c4 04	 add	 esp, 4
  000ac	8b 4d c0	 mov	 ecx, DWORD PTR _packet$14[ebp]
  000af	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 3475 :       packet->channel = get8u(s);

  000b2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000bb	83 c4 04	 add	 esp, 4
  000be	8b 4d c0	 mov	 ecx, DWORD PTR _packet$14[ebp]
  000c1	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 3476 : 
; 3477 :       act_comp |= packet->channel;

  000c4	8b 55 c0	 mov	 edx, DWORD PTR _packet$14[ebp]
  000c7	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000cb	0b 45 f8	 or	 eax, DWORD PTR _act_comp$[ebp]
  000ce	89 45 f8	 mov	 DWORD PTR _act_comp$[ebp], eax

; 3478 : 
; 3479 :       if (at_eof(s))          return epuc("bad file","file too short (reading packets)");

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  000da	83 c4 04	 add	 esp, 4
  000dd	85 c0		 test	 eax, eax
  000df	74 32		 je	 SHORT $LN30@pic_load2
  000e1	68 00 00 00 00	 push	 OFFSET $SG4294820133
  000e6	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000eb	83 c4 04	 add	 esp, 4
  000ee	85 c0		 test	 eax, eax
  000f0	74 0c		 je	 SHORT $LN52@pic_load2
  000f2	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
  000fc	eb 0a		 jmp	 SHORT $LN53@pic_load2
$LN52@pic_load2:
  000fe	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN53@pic_load2:
  00108	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv92[ebp]
  0010e	e9 38 04 00 00	 jmp	 $LN1@pic_load2
$LN30@pic_load2:

; 3480 :       if (packet->size != 8)  return epuc("bad format","packet isn't 8bpp");

  00113	8b 55 c0	 mov	 edx, DWORD PTR _packet$14[ebp]
  00116	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00119	83 f8 08	 cmp	 eax, 8
  0011c	74 32		 je	 SHORT $LN2@pic_load2
  0011e	68 00 00 00 00	 push	 OFFSET $SG4294820132
  00123	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00128	83 c4 04	 add	 esp, 4
  0012b	85 c0		 test	 eax, eax
  0012d	74 0c		 je	 SHORT $LN54@pic_load2
  0012f	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
  00139	eb 0a		 jmp	 SHORT $LN55@pic_load2
$LN54@pic_load2:
  0013b	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
$LN55@pic_load2:
  00145	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv131[ebp]
  0014b	e9 fb 03 00 00	 jmp	 $LN1@pic_load2
$LN2@pic_load2:

; 3481 :    } while (chained);

  00150	83 7d ec 00	 cmp	 DWORD PTR _chained$[ebp], 0
  00154	0f 85 da fe ff
	ff		 jne	 $LN4@pic_load2

; 3482 : 
; 3483 :    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

  0015a	8b 4d f8	 mov	 ecx, DWORD PTR _act_comp$[ebp]
  0015d	83 e1 10	 and	 ecx, 16			; 00000010H
  00160	74 0c		 je	 SHORT $LN56@pic_load2
  00162	c7 85 6c ff ff
	ff 04 00 00 00	 mov	 DWORD PTR tv135[ebp], 4
  0016c	eb 0a		 jmp	 SHORT $LN57@pic_load2
$LN56@pic_load2:
  0016e	c7 85 6c ff ff
	ff 03 00 00 00	 mov	 DWORD PTR tv135[ebp], 3
$LN57@pic_load2:
  00178	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0017b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  00181	89 02		 mov	 DWORD PTR [edx], eax

; 3484 : 
; 3485 :    for(y=0; y<height; ++y) {

  00183	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0018a	eb 09		 jmp	 SHORT $LN7@pic_load2
$LN5@pic_load2:
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  0018f	83 c1 01	 add	 ecx, 1
  00192	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx
$LN7@pic_load2:
  00195	8b 55 f0	 mov	 edx, DWORD PTR _y$[ebp]
  00198	3b 55 10	 cmp	 edx, DWORD PTR _height$[ebp]
  0019b	0f 8d a7 03 00
	00		 jge	 $LN6@pic_load2

; 3486 :       int packet_idx;
; 3487 : 
; 3488 :       for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

  001a1	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _packet_idx$13[ebp], 0
  001a8	eb 09		 jmp	 SHORT $LN10@pic_load2
$LN8@pic_load2:
  001aa	8b 45 bc	 mov	 eax, DWORD PTR _packet_idx$13[ebp]
  001ad	83 c0 01	 add	 eax, 1
  001b0	89 45 bc	 mov	 DWORD PTR _packet_idx$13[ebp], eax
$LN10@pic_load2:
  001b3	8b 4d bc	 mov	 ecx, DWORD PTR _packet_idx$13[ebp]
  001b6	3b 4d f4	 cmp	 ecx, DWORD PTR _num_packets$[ebp]
  001b9	0f 8d 84 03 00
	00		 jge	 $LN9@pic_load2

; 3489 :          pic_packet_t *packet = &packets[packet_idx];

  001bf	6b 55 bc 03	 imul	 edx, DWORD PTR _packet_idx$13[ebp], 3
  001c3	8d 44 15 c8	 lea	 eax, DWORD PTR _packets$[ebp+edx]
  001c7	89 45 b8	 mov	 DWORD PTR _packet$12[ebp], eax

; 3490 :          stbi_uc *dest = result+y*width*4;

  001ca	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  001cd	0f af 4d 0c	 imul	 ecx, DWORD PTR _width$[ebp]
  001d1	8b 55 18	 mov	 edx, DWORD PTR _result$[ebp]
  001d4	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001d7	89 45 b4	 mov	 DWORD PTR _dest$11[ebp], eax

; 3491 : 
; 3492 :          switch (packet->type) {

  001da	8b 4d b8	 mov	 ecx, DWORD PTR _packet$12[ebp]
  001dd	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  001e0	88 95 68 ff ff
	ff		 mov	 BYTE PTR tv147[ebp], dl
  001e6	80 bd 68 ff ff
	ff 00		 cmp	 BYTE PTR tv147[ebp], 0
  001ed	74 4c		 je	 SHORT $LN33@pic_load2
  001ef	80 bd 68 ff ff
	ff 01		 cmp	 BYTE PTR tv147[ebp], 1
  001f6	0f 84 8c 00 00
	00		 je	 $LN35@pic_load2
  001fc	80 bd 68 ff ff
	ff 02		 cmp	 BYTE PTR tv147[ebp], 2
  00203	0f 84 66 01 00
	00		 je	 $LN39@pic_load2

; 3493 :             default:
; 3494 :                return epuc("bad format","packet has bad compression type");

  00209	68 00 00 00 00	 push	 OFFSET $SG4294820131
  0020e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	74 0c		 je	 SHORT $LN58@pic_load2
  0021a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
  00224	eb 0a		 jmp	 SHORT $LN59@pic_load2
$LN58@pic_load2:
  00226	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
$LN59@pic_load2:
  00230	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv151[ebp]
  00236	e9 10 03 00 00	 jmp	 $LN1@pic_load2
$LN33@pic_load2:

; 3495 : 
; 3496 :             case 0: {//uncompressed
; 3497 :                int x;
; 3498 : 
; 3499 :                for(x=0;x<width;++x, dest+=4)

  0023b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _x$10[ebp], 0
  00242	eb 12		 jmp	 SHORT $LN15@pic_load2
$LN13@pic_load2:
  00244	8b 45 b0	 mov	 eax, DWORD PTR _x$10[ebp]
  00247	83 c0 01	 add	 eax, 1
  0024a	89 45 b0	 mov	 DWORD PTR _x$10[ebp], eax
  0024d	8b 4d b4	 mov	 ecx, DWORD PTR _dest$11[ebp]
  00250	83 c1 04	 add	 ecx, 4
  00253	89 4d b4	 mov	 DWORD PTR _dest$11[ebp], ecx
$LN15@pic_load2:
  00256	8b 55 b0	 mov	 edx, DWORD PTR _x$10[ebp]
  00259	3b 55 0c	 cmp	 edx, DWORD PTR _width$[ebp]
  0025c	7d 25		 jge	 SHORT $LN14@pic_load2

; 3500 :                   if (!pic_readval(s,packet->channel,dest))

  0025e	8b 45 b4	 mov	 eax, DWORD PTR _dest$11[ebp]
  00261	50		 push	 eax
  00262	8b 4d b8	 mov	 ecx, DWORD PTR _packet$12[ebp]
  00265	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00269	52		 push	 edx
  0026a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?pic_readval@@YAPAEPAUstbi@@HPAE@Z ; pic_readval
  00273	83 c4 0c	 add	 esp, 12			; 0000000cH
  00276	85 c0		 test	 eax, eax
  00278	75 07		 jne	 SHORT $LN34@pic_load2

; 3501 :                      return 0;

  0027a	33 c0		 xor	 eax, eax
  0027c	e9 ca 02 00 00	 jmp	 $LN1@pic_load2
$LN34@pic_load2:

; 3502 :                break;

  00281	eb c1		 jmp	 SHORT $LN13@pic_load2
$LN14@pic_load2:
  00283	e9 b6 02 00 00	 jmp	 $LN11@pic_load2
$LN35@pic_load2:

; 3503 :             }
; 3504 : 
; 3505 :             case 1://Pure RLE
; 3506 :                {
; 3507 :                   int left=width, i;

  00288	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  0028b	89 4d ac	 mov	 DWORD PTR _left$9[ebp], ecx
$LN16@pic_load2:

; 3508 : 
; 3509 :                   while (left>0) {

  0028e	83 7d ac 00	 cmp	 DWORD PTR _left$9[ebp], 0
  00292	0f 8e d2 00 00
	00		 jle	 $LN17@pic_load2

; 3510 :                      stbi_uc count,value[4];
; 3511 : 
; 3512 :                      count=get8u(s);

  00298	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0029b	52		 push	 edx
  0029c	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  002a1	83 c4 04	 add	 esp, 4
  002a4	88 45 a7	 mov	 BYTE PTR _count$7[ebp], al

; 3513 :                      if (at_eof(s))   return epuc("bad file","file too short (pure read count)");

  002a7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  002aa	50		 push	 eax
  002ab	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  002b0	83 c4 04	 add	 esp, 4
  002b3	85 c0		 test	 eax, eax
  002b5	74 32		 je	 SHORT $LN36@pic_load2
  002b7	68 00 00 00 00	 push	 OFFSET $SG4294820130
  002bc	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002c1	83 c4 04	 add	 esp, 4
  002c4	85 c0		 test	 eax, eax
  002c6	74 0c		 je	 SHORT $LN60@pic_load2
  002c8	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp], 0
  002d2	eb 0a		 jmp	 SHORT $LN61@pic_load2
$LN60@pic_load2:
  002d4	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp], 0
$LN61@pic_load2:
  002de	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv171[ebp]
  002e4	e9 62 02 00 00	 jmp	 $LN1@pic_load2
$LN36@pic_load2:

; 3514 : 
; 3515 :                      if (count > left)

  002e9	0f b6 4d a7	 movzx	 ecx, BYTE PTR _count$7[ebp]
  002ed	3b 4d ac	 cmp	 ecx, DWORD PTR _left$9[ebp]
  002f0	7e 06		 jle	 SHORT $LN37@pic_load2

; 3516 :                         count = (uint8) left;

  002f2	8a 55 ac	 mov	 dl, BYTE PTR _left$9[ebp]
  002f5	88 55 a7	 mov	 BYTE PTR _count$7[ebp], dl
$LN37@pic_load2:

; 3517 : 
; 3518 :                      if (!pic_readval(s,packet->channel,value))  return 0;

  002f8	8d 45 9c	 lea	 eax, DWORD PTR _value$6[ebp]
  002fb	50		 push	 eax
  002fc	8b 4d b8	 mov	 ecx, DWORD PTR _packet$12[ebp]
  002ff	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00303	52		 push	 edx
  00304	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00307	50		 push	 eax
  00308	e8 00 00 00 00	 call	 ?pic_readval@@YAPAEPAUstbi@@HPAE@Z ; pic_readval
  0030d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00310	85 c0		 test	 eax, eax
  00312	75 07		 jne	 SHORT $LN38@pic_load2
  00314	33 c0		 xor	 eax, eax
  00316	e9 30 02 00 00	 jmp	 $LN1@pic_load2
$LN38@pic_load2:

; 3519 : 
; 3520 :                      for(i=0; i<count; ++i,dest+=4)

  0031b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00322	eb 12		 jmp	 SHORT $LN20@pic_load2
$LN18@pic_load2:
  00324	8b 4d a8	 mov	 ecx, DWORD PTR _i$8[ebp]
  00327	83 c1 01	 add	 ecx, 1
  0032a	89 4d a8	 mov	 DWORD PTR _i$8[ebp], ecx
  0032d	8b 55 b4	 mov	 edx, DWORD PTR _dest$11[ebp]
  00330	83 c2 04	 add	 edx, 4
  00333	89 55 b4	 mov	 DWORD PTR _dest$11[ebp], edx
$LN20@pic_load2:
  00336	0f b6 45 a7	 movzx	 eax, BYTE PTR _count$7[ebp]
  0033a	39 45 a8	 cmp	 DWORD PTR _i$8[ebp], eax
  0033d	7d 1a		 jge	 SHORT $LN19@pic_load2

; 3521 :                         pic_copyval(packet->channel,dest,value);

  0033f	8d 4d 9c	 lea	 ecx, DWORD PTR _value$6[ebp]
  00342	51		 push	 ecx
  00343	8b 55 b4	 mov	 edx, DWORD PTR _dest$11[ebp]
  00346	52		 push	 edx
  00347	8b 45 b8	 mov	 eax, DWORD PTR _packet$12[ebp]
  0034a	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0034e	51		 push	 ecx
  0034f	e8 00 00 00 00	 call	 ?pic_copyval@@YAXHPAEPBE@Z ; pic_copyval
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	eb cb		 jmp	 SHORT $LN18@pic_load2
$LN19@pic_load2:

; 3522 :                      left -= count;

  00359	0f b6 55 a7	 movzx	 edx, BYTE PTR _count$7[ebp]
  0035d	8b 45 ac	 mov	 eax, DWORD PTR _left$9[ebp]
  00360	2b c2		 sub	 eax, edx
  00362	89 45 ac	 mov	 DWORD PTR _left$9[ebp], eax

; 3523 :                   }

  00365	e9 24 ff ff ff	 jmp	 $LN16@pic_load2
$LN17@pic_load2:

; 3524 :                }
; 3525 :                break;

  0036a	e9 cf 01 00 00	 jmp	 $LN11@pic_load2
$LN39@pic_load2:

; 3526 : 
; 3527 :             case 2: {//Mixed RLE
; 3528 :                int left=width;

  0036f	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00372	89 4d 94	 mov	 DWORD PTR _left$5[ebp], ecx
$LN21@pic_load2:

; 3529 :                while (left>0) {

  00375	83 7d 94 00	 cmp	 DWORD PTR _left$5[ebp], 0
  00379	0f 8e bf 01 00
	00		 jle	 $LN11@pic_load2

; 3530 :                   int count = get8(s), i;

  0037f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00382	52		 push	 edx
  00383	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00388	83 c4 04	 add	 esp, 4
  0038b	89 45 90	 mov	 DWORD PTR _count$4[ebp], eax

; 3531 :                   if (at_eof(s))  return epuc("bad file","file too short (mixed read count)");

  0038e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  00397	83 c4 04	 add	 esp, 4
  0039a	85 c0		 test	 eax, eax
  0039c	74 32		 je	 SHORT $LN40@pic_load2
  0039e	68 00 00 00 00	 push	 OFFSET $SG4294820129
  003a3	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  003a8	83 c4 04	 add	 esp, 4
  003ab	85 c0		 test	 eax, eax
  003ad	74 0c		 je	 SHORT $LN62@pic_load2
  003af	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
  003b9	eb 0a		 jmp	 SHORT $LN63@pic_load2
$LN62@pic_load2:
  003bb	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN63@pic_load2:
  003c5	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv201[ebp]
  003cb	e9 7b 01 00 00	 jmp	 $LN1@pic_load2
$LN40@pic_load2:

; 3532 : 
; 3533 :                   if (count >= 128) { // Repeated

  003d0	81 7d 90 80 00
	00 00		 cmp	 DWORD PTR _count$4[ebp], 128 ; 00000080H
  003d7	0f 8c ce 00 00
	00		 jl	 $LN41@pic_load2

; 3534 :                      stbi_uc value[4];
; 3535 :                      int i;
; 3536 : 
; 3537 :                      if (count==128)

  003dd	81 7d 90 80 00
	00 00		 cmp	 DWORD PTR _count$4[ebp], 128 ; 00000080H
  003e4	75 11		 jne	 SHORT $LN43@pic_load2

; 3538 :                         count = get16(s);

  003e6	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  003ef	83 c4 04	 add	 esp, 4
  003f2	89 45 90	 mov	 DWORD PTR _count$4[ebp], eax

; 3539 :                      else

  003f5	eb 09		 jmp	 SHORT $LN44@pic_load2
$LN43@pic_load2:

; 3540 :                         count -= 127;

  003f7	8b 55 90	 mov	 edx, DWORD PTR _count$4[ebp]
  003fa	83 ea 7f	 sub	 edx, 127		; 0000007fH
  003fd	89 55 90	 mov	 DWORD PTR _count$4[ebp], edx
$LN44@pic_load2:

; 3541 :                      if (count > left)

  00400	8b 45 90	 mov	 eax, DWORD PTR _count$4[ebp]
  00403	3b 45 94	 cmp	 eax, DWORD PTR _left$5[ebp]
  00406	7e 32		 jle	 SHORT $LN45@pic_load2

; 3542 :                         return epuc("bad file","scanline overrun");

  00408	68 00 00 00 00	 push	 OFFSET $SG4294820128
  0040d	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00412	83 c4 04	 add	 esp, 4
  00415	85 c0		 test	 eax, eax
  00417	74 0c		 je	 SHORT $LN64@pic_load2
  00419	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv211[ebp], 0
  00423	eb 0a		 jmp	 SHORT $LN65@pic_load2
$LN64@pic_load2:
  00425	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv211[ebp], 0
$LN65@pic_load2:
  0042f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv211[ebp]
  00435	e9 11 01 00 00	 jmp	 $LN1@pic_load2
$LN45@pic_load2:

; 3543 : 
; 3544 :                      if (!pic_readval(s,packet->channel,value))

  0043a	8d 4d 84	 lea	 ecx, DWORD PTR _value$2[ebp]
  0043d	51		 push	 ecx
  0043e	8b 55 b8	 mov	 edx, DWORD PTR _packet$12[ebp]
  00441	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00445	50		 push	 eax
  00446	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00449	51		 push	 ecx
  0044a	e8 00 00 00 00	 call	 ?pic_readval@@YAPAEPAUstbi@@HPAE@Z ; pic_readval
  0044f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00452	85 c0		 test	 eax, eax
  00454	75 07		 jne	 SHORT $LN46@pic_load2

; 3545 :                         return 0;

  00456	33 c0		 xor	 eax, eax
  00458	e9 ee 00 00 00	 jmp	 $LN1@pic_load2
$LN46@pic_load2:

; 3546 : 
; 3547 :                      for(i=0;i<count;++i, dest += 4)

  0045d	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  00467	eb 18		 jmp	 SHORT $LN25@pic_load2
$LN23@pic_load2:
  00469	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  0046f	83 c2 01	 add	 edx, 1
  00472	89 95 7c ff ff
	ff		 mov	 DWORD PTR _i$1[ebp], edx
  00478	8b 45 b4	 mov	 eax, DWORD PTR _dest$11[ebp]
  0047b	83 c0 04	 add	 eax, 4
  0047e	89 45 b4	 mov	 DWORD PTR _dest$11[ebp], eax
$LN25@pic_load2:
  00481	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  00487	3b 4d 90	 cmp	 ecx, DWORD PTR _count$4[ebp]
  0048a	7d 1a		 jge	 SHORT $LN24@pic_load2

; 3548 :                         pic_copyval(packet->channel,dest,value);

  0048c	8d 55 84	 lea	 edx, DWORD PTR _value$2[ebp]
  0048f	52		 push	 edx
  00490	8b 45 b4	 mov	 eax, DWORD PTR _dest$11[ebp]
  00493	50		 push	 eax
  00494	8b 4d b8	 mov	 ecx, DWORD PTR _packet$12[ebp]
  00497	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  0049b	52		 push	 edx
  0049c	e8 00 00 00 00	 call	 ?pic_copyval@@YAXHPAEPBE@Z ; pic_copyval
  004a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a4	eb c3		 jmp	 SHORT $LN23@pic_load2
$LN24@pic_load2:

; 3549 :                   } else { // Raw

  004a6	e9 85 00 00 00	 jmp	 $LN42@pic_load2
$LN41@pic_load2:

; 3550 :                      ++count;

  004ab	8b 45 90	 mov	 eax, DWORD PTR _count$4[ebp]
  004ae	83 c0 01	 add	 eax, 1
  004b1	89 45 90	 mov	 DWORD PTR _count$4[ebp], eax

; 3551 :                      if (count>left) return epuc("bad file","scanline overrun");

  004b4	8b 4d 90	 mov	 ecx, DWORD PTR _count$4[ebp]
  004b7	3b 4d 94	 cmp	 ecx, DWORD PTR _left$5[ebp]
  004ba	7e 2f		 jle	 SHORT $LN47@pic_load2
  004bc	68 00 00 00 00	 push	 OFFSET $SG4294820127
  004c1	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  004c6	83 c4 04	 add	 esp, 4
  004c9	85 c0		 test	 eax, eax
  004cb	74 0c		 je	 SHORT $LN66@pic_load2
  004cd	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
  004d7	eb 0a		 jmp	 SHORT $LN67@pic_load2
$LN66@pic_load2:
  004d9	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], 0
$LN67@pic_load2:
  004e3	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv232[ebp]
  004e9	eb 60		 jmp	 SHORT $LN1@pic_load2
$LN47@pic_load2:

; 3552 : 
; 3553 :                      for(i=0;i<count;++i, dest+=4)

  004eb	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  004f2	eb 12		 jmp	 SHORT $LN28@pic_load2
$LN26@pic_load2:
  004f4	8b 55 8c	 mov	 edx, DWORD PTR _i$3[ebp]
  004f7	83 c2 01	 add	 edx, 1
  004fa	89 55 8c	 mov	 DWORD PTR _i$3[ebp], edx
  004fd	8b 45 b4	 mov	 eax, DWORD PTR _dest$11[ebp]
  00500	83 c0 04	 add	 eax, 4
  00503	89 45 b4	 mov	 DWORD PTR _dest$11[ebp], eax
$LN28@pic_load2:
  00506	8b 4d 8c	 mov	 ecx, DWORD PTR _i$3[ebp]
  00509	3b 4d 90	 cmp	 ecx, DWORD PTR _count$4[ebp]
  0050c	7d 22		 jge	 SHORT $LN42@pic_load2

; 3554 :                         if (!pic_readval(s,packet->channel,dest))

  0050e	8b 55 b4	 mov	 edx, DWORD PTR _dest$11[ebp]
  00511	52		 push	 edx
  00512	8b 45 b8	 mov	 eax, DWORD PTR _packet$12[ebp]
  00515	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00519	51		 push	 ecx
  0051a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0051d	52		 push	 edx
  0051e	e8 00 00 00 00	 call	 ?pic_readval@@YAPAEPAUstbi@@HPAE@Z ; pic_readval
  00523	83 c4 0c	 add	 esp, 12			; 0000000cH
  00526	85 c0		 test	 eax, eax
  00528	75 04		 jne	 SHORT $LN48@pic_load2

; 3555 :                            return 0;

  0052a	33 c0		 xor	 eax, eax
  0052c	eb 1d		 jmp	 SHORT $LN1@pic_load2
$LN48@pic_load2:

; 3556 :                   }

  0052e	eb c4		 jmp	 SHORT $LN26@pic_load2
$LN42@pic_load2:

; 3557 :                   left-=count;

  00530	8b 45 94	 mov	 eax, DWORD PTR _left$5[ebp]
  00533	2b 45 90	 sub	 eax, DWORD PTR _count$4[ebp]
  00536	89 45 94	 mov	 DWORD PTR _left$5[ebp], eax

; 3558 :                }

  00539	e9 37 fe ff ff	 jmp	 $LN21@pic_load2
$LN11@pic_load2:

; 3559 :                break;
; 3560 :             }
; 3561 :          }
; 3562 :       }

  0053e	e9 67 fc ff ff	 jmp	 $LN8@pic_load2
$LN9@pic_load2:

; 3563 :    }

  00543	e9 44 fc ff ff	 jmp	 $LN5@pic_load2
$LN6@pic_load2:

; 3564 : 
; 3565 :    return result;

  00548	8b 45 18	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@pic_load2:

; 3566 : }

  0054b	52		 push	 edx
  0054c	8b cd		 mov	 ecx, ebp
  0054e	50		 push	 eax
  0054f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN72@pic_load2
  00555	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0055a	58		 pop	 eax
  0055b	5a		 pop	 edx
  0055c	5f		 pop	 edi
  0055d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00560	33 cd		 xor	 ecx, ebp
  00562	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00567	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0056d	3b ec		 cmp	 ebp, esp
  0056f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00574	8b e5		 mov	 esp, ebp
  00576	5d		 pop	 ebp
  00577	c3		 ret	 0
$LN72@pic_load2:
  00578	03 00 00 00	 DD	 3
  0057c	00 00 00 00	 DD	 $LN71@pic_load2
$LN71@pic_load2:
  00580	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00584	1e 00 00 00	 DD	 30			; 0000001eH
  00588	00 00 00 00	 DD	 $LN68@pic_load2
  0058c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00590	04 00 00 00	 DD	 4
  00594	00 00 00 00	 DD	 $LN69@pic_load2
  00598	84 ff ff ff	 DD	 -124			; ffffff84H
  0059c	04 00 00 00	 DD	 4
  005a0	00 00 00 00	 DD	 $LN70@pic_load2
$LN70@pic_load2:
  005a4	76		 DB	 118			; 00000076H
  005a5	61		 DB	 97			; 00000061H
  005a6	6c		 DB	 108			; 0000006cH
  005a7	75		 DB	 117			; 00000075H
  005a8	65		 DB	 101			; 00000065H
  005a9	00		 DB	 0
$LN69@pic_load2:
  005aa	76		 DB	 118			; 00000076H
  005ab	61		 DB	 97			; 00000061H
  005ac	6c		 DB	 108			; 0000006cH
  005ad	75		 DB	 117			; 00000075H
  005ae	65		 DB	 101			; 00000065H
  005af	00		 DB	 0
$LN68@pic_load2:
  005b0	70		 DB	 112			; 00000070H
  005b1	61		 DB	 97			; 00000061H
  005b2	63		 DB	 99			; 00000063H
  005b3	6b		 DB	 107			; 0000006bH
  005b4	65		 DB	 101			; 00000065H
  005b5	74		 DB	 116			; 00000074H
  005b6	73		 DB	 115			; 00000073H
  005b7	00		 DB	 0
?pic_load2@@YAPAEPAUstbi@@HHPAHPAE@Z ENDP		; pic_load2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv83 = -24						; size = 4
tv77 = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_result$ = -4						; size = 4
_s$ = 8							; size = 4
_px$ = 12						; size = 4
_py$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?pic_load@@YAPAEPAUstbi@@PAH11H@Z PROC			; pic_load

; 3569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 3570 :    stbi_uc *result;
; 3571 :    int i, x,y;
; 3572 : 
; 3573 :    for (i=0; i<92; ++i)

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@pic_load
$LN2@pic_load:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@pic_load:
  00030	83 7d f8 5c	 cmp	 DWORD PTR _i$[ebp], 92	; 0000005cH
  00034	7d 0e		 jge	 SHORT $LN3@pic_load

; 3574 :       get8(s);

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0003f	83 c4 04	 add	 esp, 4
  00042	eb e3		 jmp	 SHORT $LN2@pic_load
$LN3@pic_load:

; 3575 : 
; 3576 :    x = get16(s);

  00044	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0004d	83 c4 04	 add	 esp, 4
  00050	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax

; 3577 :    y = get16(s);

  00053	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax

; 3578 :    if (at_eof(s))  return epuc("bad file","file too short (pic header)");

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 29		 je	 SHORT $LN5@pic_load
  00072	68 00 00 00 00	 push	 OFFSET $SG4294820126
  00077	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 c0		 test	 eax, eax
  00081	74 09		 je	 SHORT $LN10@pic_load
  00083	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  0008a	eb 07		 jmp	 SHORT $LN11@pic_load
$LN10@pic_load:
  0008c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN11@pic_load:
  00093	8b 45 ec	 mov	 eax, DWORD PTR tv77[ebp]
  00096	e9 1c 01 00 00	 jmp	 $LN1@pic_load
$LN5@pic_load:

; 3579 :    if ((1 << 28) / x < y) return epuc("too large", "Image too large to decode");

  0009b	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  000a0	99		 cdq
  000a1	f7 7d f4	 idiv	 DWORD PTR _x$[ebp]
  000a4	3b 45 f0	 cmp	 eax, DWORD PTR _y$[ebp]
  000a7	7d 29		 jge	 SHORT $LN6@pic_load
  000a9	68 00 00 00 00	 push	 OFFSET $SG4294820125
  000ae	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000b3	83 c4 04	 add	 esp, 4
  000b6	85 c0		 test	 eax, eax
  000b8	74 09		 je	 SHORT $LN12@pic_load
  000ba	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  000c1	eb 07		 jmp	 SHORT $LN13@pic_load
$LN12@pic_load:
  000c3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN13@pic_load:
  000ca	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  000cd	e9 e5 00 00 00	 jmp	 $LN1@pic_load
$LN6@pic_load:

; 3580 : 
; 3581 :    get32(s); //skip `ratio'

  000d2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  000db	83 c4 04	 add	 esp, 4

; 3582 :    get16(s); //skip `fields'

  000de	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000e7	83 c4 04	 add	 esp, 4

; 3583 :    get16(s); //skip `pad'

  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000f3	83 c4 04	 add	 esp, 4

; 3584 : 
; 3585 :    // intermediate buffer is RGBA
; 3586 :    result = (stbi_uc *) malloc(x*y*4);

  000f6	8b 55 f4	 mov	 edx, DWORD PTR _x$[ebp]
  000f9	0f af 55 f0	 imul	 edx, DWORD PTR _y$[ebp]
  000fd	c1 e2 02	 shl	 edx, 2
  00100	8b f4		 mov	 esi, esp
  00102	52		 push	 edx
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00109	83 c4 04	 add	 esp, 4
  0010c	3b f4		 cmp	 esi, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00113	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 3587 :    memset(result, 0xff, x*y*4);

  00116	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00119	0f af 45 f0	 imul	 eax, DWORD PTR _y$[ebp]
  0011d	c1 e0 02	 shl	 eax, 2
  00120	8b f4		 mov	 esi, esp
  00122	50		 push	 eax
  00123	68 ff 00 00 00	 push	 255			; 000000ffH
  00128	8b 4d fc	 mov	 ecx, DWORD PTR _result$[ebp]
  0012b	51		 push	 ecx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memset
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
  00135	3b f4		 cmp	 esi, esp
  00137	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3588 : 
; 3589 :    if (!pic_load2(s,x,y,comp, result)) {

  0013c	8b 55 fc	 mov	 edx, DWORD PTR _result$[ebp]
  0013f	52		 push	 edx
  00140	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00143	50		 push	 eax
  00144	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00147	51		 push	 ecx
  00148	8b 55 f4	 mov	 edx, DWORD PTR _x$[ebp]
  0014b	52		 push	 edx
  0014c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ?pic_load2@@YAPAEPAUstbi@@HHPAHPAE@Z ; pic_load2
  00155	83 c4 14	 add	 esp, 20			; 00000014H
  00158	85 c0		 test	 eax, eax
  0015a	75 1d		 jne	 SHORT $LN7@pic_load

; 3590 :       free(result);

  0015c	8b f4		 mov	 esi, esp
  0015e	8b 4d fc	 mov	 ecx, DWORD PTR _result$[ebp]
  00161	51		 push	 ecx
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00168	83 c4 04	 add	 esp, 4
  0016b	3b f4		 cmp	 esi, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3591 :       result=0;

  00172	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN7@pic_load:

; 3592 :    }
; 3593 :    *px = x;

  00179	8b 55 0c	 mov	 edx, DWORD PTR _px$[ebp]
  0017c	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0017f	89 02		 mov	 DWORD PTR [edx], eax

; 3594 :    *py = y;

  00181	8b 4d 10	 mov	 ecx, DWORD PTR _py$[ebp]
  00184	8b 55 f0	 mov	 edx, DWORD PTR _y$[ebp]
  00187	89 11		 mov	 DWORD PTR [ecx], edx

; 3595 :    if (req_comp == 0) req_comp = *comp;

  00189	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  0018d	75 08		 jne	 SHORT $LN8@pic_load
  0018f	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00192	8b 08		 mov	 ecx, DWORD PTR [eax]
  00194	89 4d 18	 mov	 DWORD PTR _req_comp$[ebp], ecx
$LN8@pic_load:

; 3596 :    result=convert_format(result,4,req_comp,x,y);

  00197	8b 55 f0	 mov	 edx, DWORD PTR _y$[ebp]
  0019a	52		 push	 edx
  0019b	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  001a2	51		 push	 ecx
  001a3	6a 04		 push	 4
  001a5	8b 55 fc	 mov	 edx, DWORD PTR _result$[ebp]
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 ?convert_format@@YAPAEPAEHHII@Z ; convert_format
  001ae	83 c4 14	 add	 esp, 20			; 00000014H
  001b1	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 3597 : 
; 3598 :    return result;

  001b4	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@pic_load:

; 3599 : }

  001b7	5e		 pop	 esi
  001b8	83 c4 18	 add	 esp, 24			; 00000018H
  001bb	3b ec		 cmp	 ebp, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
?pic_load@@YAPAEPAUstbi@@PAH11H@Z ENDP			; pic_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_pic_test@@YAHPAUstbi@@@Z PROC			; stbi_pic_test

; 3602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3603 :    int r = pic_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?pic_test@@YAHPAUstbi@@@Z ; pic_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 3604 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 3605 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 3606 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_pic_test@@YAHPAUstbi@@@Z ENDP			; stbi_pic_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_pic_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_pic_load

; 3609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3610 :    return pic_load(s,x,y,comp,req_comp);

  00003	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?pic_load@@YAPAEPAUstbi@@PAH11H@Z ; pic_load
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 3611 : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?stbi_pic_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_pic_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_sz$ = -4						; size = 4
_s$ = 8							; size = 4
?gif_test@@YAHPAUstbi@@@Z PROC				; gif_test

; 3639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3640 :    int sz;
; 3641 :    if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8') return 0;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 47	 cmp	 eax, 71			; 00000047H
  0001a	75 33		 jne	 SHORT $LN3@gif_test
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00025	83 c4 04	 add	 esp, 4
  00028	83 f8 49	 cmp	 eax, 73			; 00000049H
  0002b	75 22		 jne	 SHORT $LN3@gif_test
  0002d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00036	83 c4 04	 add	 esp, 4
  00039	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003c	75 11		 jne	 SHORT $LN3@gif_test
  0003e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00047	83 c4 04	 add	 esp, 4
  0004a	83 f8 38	 cmp	 eax, 56			; 00000038H
  0004d	74 04		 je	 SHORT $LN2@gif_test
$LN3@gif_test:
  0004f	33 c0		 xor	 eax, eax
  00051	eb 39		 jmp	 SHORT $LN1@gif_test
$LN2@gif_test:

; 3642 :    sz = get8(s);

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 fc	 mov	 DWORD PTR _sz$[ebp], eax

; 3643 :    if (sz != '9' && sz != '7') return 0;

  00062	83 7d fc 39	 cmp	 DWORD PTR _sz$[ebp], 57	; 00000039H
  00066	74 0a		 je	 SHORT $LN4@gif_test
  00068	83 7d fc 37	 cmp	 DWORD PTR _sz$[ebp], 55	; 00000037H
  0006c	74 04		 je	 SHORT $LN4@gif_test
  0006e	33 c0		 xor	 eax, eax
  00070	eb 1a		 jmp	 SHORT $LN1@gif_test
$LN4@gif_test:

; 3644 :    if (get8(s) != 'a') return 0;

  00072	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0007b	83 c4 04	 add	 esp, 4
  0007e	83 f8 61	 cmp	 eax, 97			; 00000061H
  00081	74 04		 je	 SHORT $LN5@gif_test
  00083	33 c0		 xor	 eax, eax
  00085	eb 05		 jmp	 SHORT $LN1@gif_test
$LN5@gif_test:

; 3645 :    return 1;

  00087	b8 01 00 00 00	 mov	 eax, 1
$LN1@gif_test:

; 3646 : }

  0008c	83 c4 04	 add	 esp, 4
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?gif_test@@YAHPAUstbi@@@Z ENDP				; gif_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_gif_test@@YAHPAUstbi@@@Z PROC			; stbi_gif_test

; 3649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3650 :    int r = gif_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?gif_test@@YAHPAUstbi@@@Z ; gif_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 3651 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 3652 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 3653 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_gif_test@@YAHPAUstbi@@@Z ENDP			; stbi_gif_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv89 = -8						; size = 4
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_pal$ = 12						; size = 4
_num_entries$ = 16					; size = 4
_transp$ = 20						; size = 4
?stbi_gif_parse_colortable@@YAXPAUstbi@@QAY03EHH@Z PROC	; stbi_gif_parse_colortable

; 3656 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3657 :    int i;
; 3658 :    for (i=0; i < num_entries; ++i) {

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001b	eb 09		 jmp	 SHORT $LN4@stbi_gif_p
$LN2@stbi_gif_p:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbi_gif_p:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00029	3b 4d 10	 cmp	 ecx, DWORD PTR _num_entries$[ebp]
  0002c	0f 8d 91 00 00
	00		 jge	 $LN1@stbi_gif_p

; 3659 :       pal[i][2] = get8u(s);

  00032	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0003b	83 c4 04	 add	 esp, 4
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00041	8b 55 0c	 mov	 edx, DWORD PTR _pal$[ebp]
  00044	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00047	ba 01 00 00 00	 mov	 edx, 1
  0004c	d1 e2		 shl	 edx, 1
  0004e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3660 :       pal[i][1] = get8u(s);

  00051	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0005a	83 c4 04	 add	 esp, 4
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00060	8b 55 0c	 mov	 edx, DWORD PTR _pal$[ebp]
  00063	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	c1 e2 00	 shl	 edx, 0
  0006e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3661 :       pal[i][0] = get8u(s);

  00071	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0007a	83 c4 04	 add	 esp, 4
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00080	8b 55 0c	 mov	 edx, DWORD PTR _pal$[ebp]
  00083	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00086	ba 01 00 00 00	 mov	 edx, 1
  0008b	6b d2 00	 imul	 edx, edx, 0
  0008e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3662 :       pal[i][3] = transp ? 0 : 255;

  00091	83 7d 14 00	 cmp	 DWORD PTR _transp$[ebp], 0
  00095	74 09		 je	 SHORT $LN6@stbi_gif_p
  00097	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  0009e	eb 07		 jmp	 SHORT $LN7@stbi_gif_p
$LN6@stbi_gif_p:
  000a0	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR tv89[ebp], 255 ; 000000ffH
$LN7@stbi_gif_p:
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pal$[ebp]
  000ad	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	6b c8 03	 imul	 ecx, eax, 3
  000b8	8a 45 f8	 mov	 al, BYTE PTR tv89[ebp]
  000bb	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3663 :    }   

  000be	e9 5a ff ff ff	 jmp	 $LN2@stbi_gif_p
$LN1@stbi_gif_p:

; 3664 : }

  000c3	83 c4 08	 add	 esp, 8
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?stbi_gif_parse_colortable@@YAXPAUstbi@@QAY03EHH@Z ENDP	; stbi_gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_version$ = -1						; size = 1
_s$ = 8							; size = 4
_g$ = 12						; size = 4
_comp$ = 16						; size = 4
_is_info$ = 20						; size = 4
?stbi_gif_header@@YAHPAUstbi@@PAUstbi_gif_struct@@PAHH@Z PROC ; stbi_gif_header

; 3667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3668 :    uint8 version;
; 3669 :    if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8')

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 47	 cmp	 eax, 71			; 00000047H
  0001a	75 33		 jne	 SHORT $LN3@stbi_gif_h
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00025	83 c4 04	 add	 esp, 4
  00028	83 f8 49	 cmp	 eax, 73			; 00000049H
  0002b	75 22		 jne	 SHORT $LN3@stbi_gif_h
  0002d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00036	83 c4 04	 add	 esp, 4
  00039	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003c	75 11		 jne	 SHORT $LN3@stbi_gif_h
  0003e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00047	83 c4 04	 add	 esp, 4
  0004a	83 f8 38	 cmp	 eax, 56			; 00000038H
  0004d	74 12		 je	 SHORT $LN2@stbi_gif_h
$LN3@stbi_gif_h:

; 3670 :       return e("not GIF", "Corrupt GIF");

  0004f	68 00 00 00 00	 push	 OFFSET $SG4294820124
  00054	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00059	83 c4 04	 add	 esp, 4
  0005c	e9 18 01 00 00	 jmp	 $LN1@stbi_gif_h
$LN2@stbi_gif_h:

; 3671 : 
; 3672 :    version = get8u(s);

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0006a	83 c4 04	 add	 esp, 4
  0006d	88 45 ff	 mov	 BYTE PTR _version$[ebp], al

; 3673 :    if (version != '7' && version != '9')    return e("not GIF", "Corrupt GIF");

  00070	0f b6 55 ff	 movzx	 edx, BYTE PTR _version$[ebp]
  00074	83 fa 37	 cmp	 edx, 55			; 00000037H
  00077	74 1b		 je	 SHORT $LN4@stbi_gif_h
  00079	0f b6 45 ff	 movzx	 eax, BYTE PTR _version$[ebp]
  0007d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00080	74 12		 je	 SHORT $LN4@stbi_gif_h
  00082	68 00 00 00 00	 push	 OFFSET $SG4294820123
  00087	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0008c	83 c4 04	 add	 esp, 4
  0008f	e9 e5 00 00 00	 jmp	 $LN1@stbi_gif_h
$LN4@stbi_gif_h:

; 3674 :    if (get8(s) != 'a')                      return e("not GIF", "Corrupt GIF");

  00094	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0009d	83 c4 04	 add	 esp, 4
  000a0	83 f8 61	 cmp	 eax, 97			; 00000061H
  000a3	74 12		 je	 SHORT $LN5@stbi_gif_h
  000a5	68 00 00 00 00	 push	 OFFSET $SG4294820122
  000aa	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  000af	83 c4 04	 add	 esp, 4
  000b2	e9 c2 00 00 00	 jmp	 $LN1@stbi_gif_h
$LN5@stbi_gif_h:

; 3675 :  
; 3676 :    failure_reason = "";

  000b7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?failure_reason@@3PBDB, OFFSET $SG4294820121

; 3677 :    g->w = get16le(s);

  000c1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000ca	83 c4 04	 add	 esp, 4
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000d0	89 01		 mov	 DWORD PTR [ecx], eax

; 3678 :    g->h = get16le(s);

  000d2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000db	83 c4 04	 add	 esp, 4
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000e1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3679 :    g->flags = get8(s);

  000e4	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000ed	83 c4 04	 add	 esp, 4
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000f3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 3680 :    g->bgindex = get8(s);

  000f6	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000ff	83 c4 04	 add	 esp, 4
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00105	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3681 :    g->ratio = get8(s);

  00108	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00111	83 c4 04	 add	 esp, 4
  00114	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00117	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 3682 :    g->transparent = -1;

  0011a	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0011d	c7 42 18 ff ff
	ff ff		 mov	 DWORD PTR [edx+24], -1

; 3683 : 
; 3684 :    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

  00124	83 7d 10 00	 cmp	 DWORD PTR _comp$[ebp], 0
  00128	74 09		 je	 SHORT $LN6@stbi_gif_h
  0012a	8b 45 10	 mov	 eax, DWORD PTR _comp$[ebp]
  0012d	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4
$LN6@stbi_gif_h:

; 3685 : 
; 3686 :    if (is_info) return 1;

  00133	83 7d 14 00	 cmp	 DWORD PTR _is_info$[ebp], 0
  00137	74 07		 je	 SHORT $LN7@stbi_gif_h
  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	eb 39		 jmp	 SHORT $LN1@stbi_gif_h
$LN7@stbi_gif_h:

; 3687 : 
; 3688 :    if (g->flags & 0x80)

  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00143	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00146	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0014c	74 26		 je	 SHORT $LN8@stbi_gif_h

; 3689 :       stbi_gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

  0014e	6a ff		 push	 -1
  00150	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00153	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00156	83 e1 07	 and	 ecx, 7
  00159	ba 02 00 00 00	 mov	 edx, 2
  0015e	d3 e2		 shl	 edx, cl
  00160	52		 push	 edx
  00161	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00164	83 c0 20	 add	 eax, 32			; 00000020H
  00167	50		 push	 eax
  00168	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 ?stbi_gif_parse_colortable@@YAXPAUstbi@@QAY03EHH@Z ; stbi_gif_parse_colortable
  00171	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@stbi_gif_h:

; 3690 : 
; 3691 :    return 1;

  00174	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_gif_h:

; 3692 : }

  00179	83 c4 04	 add	 esp, 4
  0017c	3b ec		 cmp	 ebp, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?stbi_gif_header@@YAHPAUstbi@@PAUstbi_gif_struct@@PAHH@Z ENDP ; stbi_gif_header
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_g$ = -18516						; size = 18508
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_gif_info_raw@@YAHPAUstbi@@PAH11@Z PROC		; stbi_gif_info_raw

; 3695 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 58 48 00 00	 mov	 eax, 18520		; 00004858H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd a8 b7 ff
	ff		 lea	 edi, DWORD PTR [ebp-18520]
  00014	b9 16 12 00 00	 mov	 ecx, 4630		; 00001216H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3696 :    stbi_gif g;   
; 3697 :    if (!stbi_gif_header(s, &g, comp, 1)) {

  0002a	6a 01		 push	 1
  0002c	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  0002f	50		 push	 eax
  00030	8d 8d ac b7 ff
	ff		 lea	 ecx, DWORD PTR _g$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?stbi_gif_header@@YAHPAUstbi@@PAUstbi_gif_struct@@PAHH@Z ; stbi_gif_header
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	85 c0		 test	 eax, eax
  00045	75 10		 jne	 SHORT $LN2@stbi_gif_i

; 3698 :       stbi_rewind( s );

  00047	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00050	83 c4 04	 add	 esp, 4

; 3699 :       return 0;

  00053	33 c0		 xor	 eax, eax
  00055	eb 27		 jmp	 SHORT $LN1@stbi_gif_i
$LN2@stbi_gif_i:

; 3700 :    }
; 3701 :    if (x) *x = g.w;

  00057	83 7d 0c 00	 cmp	 DWORD PTR _x$[ebp], 0
  0005b	74 0b		 je	 SHORT $LN3@stbi_gif_i
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00060	8b 95 ac b7 ff
	ff		 mov	 edx, DWORD PTR _g$[ebp]
  00066	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@stbi_gif_i:

; 3702 :    if (y) *y = g.h;

  00068	83 7d 10 00	 cmp	 DWORD PTR _y$[ebp], 0
  0006c	74 0b		 je	 SHORT $LN4@stbi_gif_i
  0006e	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00071	8b 8d b0 b7 ff
	ff		 mov	 ecx, DWORD PTR _g$[ebp+4]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@stbi_gif_i:

; 3703 :    return 1;

  00079	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_gif_i:

; 3704 : }

  0007e	52		 push	 edx
  0007f	8b cd		 mov	 ecx, ebp
  00081	50		 push	 eax
  00082	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@stbi_gif_i
  00088	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008d	58		 pop	 eax
  0008e	5a		 pop	 edx
  0008f	5f		 pop	 edi
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	81 c4 58 48 00
	00		 add	 esp, 18520		; 00004858H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
  000ab	90		 npad	 1
$LN8@stbi_gif_i:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN7@stbi_gif_i
$LN7@stbi_gif_i:
  000b4	ac b7 ff ff	 DD	 -18516			; ffffb7acH
  000b8	4c 48 00 00	 DD	 18508			; 0000484cH
  000bc	00 00 00 00	 DD	 $LN6@stbi_gif_i
$LN6@stbi_gif_i:
  000c0	67		 DB	 103			; 00000067H
  000c1	00		 DB	 0
?stbi_gif_info_raw@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_gif_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_c$ = -8						; size = 4
_p$ = -4						; size = 4
_g$ = 8							; size = 4
_code$ = 12						; size = 2
?stbi_out_gif_code@@YAXPAUstbi_gif_struct@@G@Z PROC	; stbi_out_gif_code

; 3707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3708 :    uint8 *p, *c;
; 3709 : 
; 3710 :    // recurse to decode the prefixes, since the linked-list is backwards,
; 3711 :    // and working backwards through an interleaved image would be nasty
; 3712 :    if (g->codes[code].prefix >= 0)

  00015	0f b7 45 0c	 movzx	 eax, WORD PTR _code$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0001c	0f bf 94 81 20
	08 00 00	 movsx	 edx, WORD PTR [ecx+eax*4+2080]
  00024	85 d2		 test	 edx, edx
  00026	7c 1c		 jl	 SHORT $LN4@stbi_out_g

; 3713 :       stbi_out_gif_code(g, g->codes[code].prefix);

  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _code$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0002f	0f b7 94 81 20
	08 00 00	 movzx	 edx, WORD PTR [ecx+eax*4+2080]
  00037	52		 push	 edx
  00038	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?stbi_out_gif_code@@YAXPAUstbi_gif_struct@@G@Z ; stbi_out_gif_code
  00041	83 c4 08	 add	 esp, 8
$LN4@stbi_out_g:

; 3714 : 
; 3715 :    if (g->cur_y >= g->max_y) return;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  00047	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  0004a	8b 81 44 48 00
	00		 mov	 eax, DWORD PTR [ecx+18500]
  00050	3b 82 3c 48 00
	00		 cmp	 eax, DWORD PTR [edx+18492]
  00056	7c 05		 jl	 SHORT $LN5@stbi_out_g
  00058	e9 91 01 00 00	 jmp	 $LN1@stbi_out_g
$LN5@stbi_out_g:

; 3716 :   
; 3717 :    p = &g->out[g->cur_x + g->cur_y];

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  00060	8b 91 40 48 00
	00		 mov	 edx, DWORD PTR [ecx+18496]
  00066	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  00069	03 90 44 48 00
	00		 add	 edx, DWORD PTR [eax+18500]
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  00072	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00075	03 c2		 add	 eax, edx
  00077	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 3718 :    c = &g->color_table[g->codes[code].suffix * 4];

  0007a	0f b7 4d 0c	 movzx	 ecx, WORD PTR _code$[ebp]
  0007e	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00081	0f b6 84 8a 23
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+2083]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0008c	8b 91 20 48 00
	00		 mov	 edx, DWORD PTR [ecx+18464]
  00092	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  00095	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 3719 : 
; 3720 :    if (c[3] >= 128) {

  00098	b9 01 00 00 00	 mov	 ecx, 1
  0009d	6b d1 03	 imul	 edx, ecx, 3
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000a3	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000a7	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000ad	7c 6e		 jl	 SHORT $LN6@stbi_out_g

; 3721 :       p[0] = c[2];

  000af	ba 01 00 00 00	 mov	 edx, 1
  000b4	d1 e2		 shl	 edx, 1
  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	6b c8 00	 imul	 ecx, eax, 0
  000be	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000c1	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  000c4	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000c7	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3722 :       p[1] = c[1];

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	c1 e0 00	 shl	 eax, 0
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	c1 e1 00	 shl	 ecx, 0
  000da	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000dd	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  000e0	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  000e3	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3723 :       p[2] = c[0];

  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	6b d1 00	 imul	 edx, ecx, 0
  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	d1 e0		 shl	 eax, 1
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000f8	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  000fb	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000fe	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 3724 :       p[3] = c[3];

  00101	b8 01 00 00 00	 mov	 eax, 1
  00106	6b c8 03	 imul	 ecx, eax, 3
  00109	ba 01 00 00 00	 mov	 edx, 1
  0010e	6b c2 03	 imul	 eax, edx, 3
  00111	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00114	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  00117	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  0011a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
$LN6@stbi_out_g:

; 3725 :    }
; 3726 :    g->cur_x += 4;

  0011d	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00120	8b 82 40 48 00
	00		 mov	 eax, DWORD PTR [edx+18496]
  00126	83 c0 04	 add	 eax, 4
  00129	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0012c	89 81 40 48 00
	00		 mov	 DWORD PTR [ecx+18496], eax

; 3727 : 
; 3728 :    if (g->cur_x >= g->max_x) {

  00132	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00135	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  00138	8b 8a 40 48 00
	00		 mov	 ecx, DWORD PTR [edx+18496]
  0013e	3b 88 38 48 00
	00		 cmp	 ecx, DWORD PTR [eax+18488]
  00144	0f 8c a4 00 00
	00		 jl	 $LN1@stbi_out_g

; 3729 :       g->cur_x = g->start_x;

  0014a	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  0014d	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  00150	8b 88 30 48 00
	00		 mov	 ecx, DWORD PTR [eax+18480]
  00156	89 8a 40 48 00
	00		 mov	 DWORD PTR [edx+18496], ecx

; 3730 :       g->cur_y += g->step;

  0015c	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  0015f	8b 82 44 48 00
	00		 mov	 eax, DWORD PTR [edx+18500]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  00168	03 81 28 48 00
	00		 add	 eax, DWORD PTR [ecx+18472]
  0016e	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00171	89 82 44 48 00
	00		 mov	 DWORD PTR [edx+18500], eax
$LN2@stbi_out_g:

; 3731 : 
; 3732 :       while (g->cur_y >= g->max_y && g->parse > 0) {

  00177	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  0017a	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0017d	8b 90 44 48 00
	00		 mov	 edx, DWORD PTR [eax+18500]
  00183	3b 91 3c 48 00
	00		 cmp	 edx, DWORD PTR [ecx+18492]
  00189	7c 63		 jl	 SHORT $LN1@stbi_out_g
  0018b	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  0018e	83 b8 24 48 00
	00 00		 cmp	 DWORD PTR [eax+18468], 0
  00195	7e 57		 jle	 SHORT $LN1@stbi_out_g

; 3733 :          g->step = (1 << g->parse) * g->line_size;

  00197	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  0019a	ba 01 00 00 00	 mov	 edx, 1
  0019f	8b 89 24 48 00
	00		 mov	 ecx, DWORD PTR [ecx+18468]
  001a5	d3 e2		 shl	 edx, cl
  001a7	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  001aa	0f af 90 48 48
	00 00		 imul	 edx, DWORD PTR [eax+18504]
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  001b4	89 91 28 48 00
	00		 mov	 DWORD PTR [ecx+18472], edx

; 3734 :          g->cur_y = g->start_y + (g->step >> 1);

  001ba	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  001bd	8b 82 28 48 00
	00		 mov	 eax, DWORD PTR [edx+18472]
  001c3	d1 f8		 sar	 eax, 1
  001c5	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  001c8	03 81 34 48 00
	00		 add	 eax, DWORD PTR [ecx+18484]
  001ce	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  001d1	89 82 44 48 00
	00		 mov	 DWORD PTR [edx+18500], eax

; 3735 :          --g->parse;

  001d7	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  001da	8b 88 24 48 00
	00		 mov	 ecx, DWORD PTR [eax+18468]
  001e0	83 e9 01	 sub	 ecx, 1
  001e3	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  001e6	89 8a 24 48 00
	00		 mov	 DWORD PTR [edx+18468], ecx

; 3736 :       }

  001ec	eb 89		 jmp	 SHORT $LN2@stbi_out_g
$LN1@stbi_out_g:

; 3737 :    }
; 3738 : }

  001ee	5e		 pop	 esi
  001ef	83 c4 08	 add	 esp, 8
  001f2	3b ec		 cmp	 ebp, esp
  001f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
?stbi_out_gif_code@@YAXPAUstbi_gif_struct@@G@Z ENDP	; stbi_out_gif_code
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv196 = -72						; size = 4
tv184 = -68						; size = 4
tv179 = -61						; size = 1
tv165 = -60						; size = 4
tv155 = -56						; size = 4
_code$1 = -52						; size = 4
_p$ = -48						; size = 4
_clear$ = -44						; size = 4
_valid_bits$ = -40					; size = 4
_bits$ = -36						; size = 4
_oldcode$ = -32						; size = 4
_avail$ = -28						; size = 4
_codemask$ = -24					; size = 4
_codesize$ = -20					; size = 4
_first$ = -16						; size = 4
_code$ = -12						; size = 4
_len$ = -8						; size = 4
_lzw_cs$ = -1						; size = 1
_s$ = 8							; size = 4
_g$ = 12						; size = 4
?stbi_process_gif_raster@@YAPAEPAUstbi@@PAUstbi_gif_struct@@@Z PROC ; stbi_process_gif_raster

; 3741 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	57		 push	 edi
  00007	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  0000a	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd

; 3742 :    uint8 lzw_cs;
; 3743 :    int32 len, code;
; 3744 :    uint32 first;
; 3745 :    int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 3746 :    stbi_gif_lzw *p;
; 3747 : 
; 3748 :    lzw_cs = get8u(s);

  00016	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0001f	83 c4 04	 add	 esp, 4
  00022	88 45 ff	 mov	 BYTE PTR _lzw_cs$[ebp], al

; 3749 :    clear = 1 << lzw_cs;

  00025	0f b6 4d ff	 movzx	 ecx, BYTE PTR _lzw_cs$[ebp]
  00029	ba 01 00 00 00	 mov	 edx, 1
  0002e	d3 e2		 shl	 edx, cl
  00030	89 55 d4	 mov	 DWORD PTR _clear$[ebp], edx

; 3750 :    first = 1;

  00033	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1

; 3751 :    codesize = lzw_cs + 1;

  0003a	0f b6 45 ff	 movzx	 eax, BYTE PTR _lzw_cs$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 ec	 mov	 DWORD PTR _codesize$[ebp], eax

; 3752 :    codemask = (1 << codesize) - 1;

  00044	ba 01 00 00 00	 mov	 edx, 1
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _codesize$[ebp]
  0004c	d3 e2		 shl	 edx, cl
  0004e	83 ea 01	 sub	 edx, 1
  00051	89 55 e8	 mov	 DWORD PTR _codemask$[ebp], edx

; 3753 :    bits = 0;

  00054	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 3754 :    valid_bits = 0;

  0005b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _valid_bits$[ebp], 0

; 3755 :    for (code = 0; code < clear; code++) {

  00062	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _code$[ebp], 0
  00069	eb 09		 jmp	 SHORT $LN4@stbi_proce
$LN2@stbi_proce:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _code$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f4	 mov	 DWORD PTR _code$[ebp], eax
$LN4@stbi_proce:
  00074	8b 4d f4	 mov	 ecx, DWORD PTR _code$[ebp]
  00077	3b 4d d4	 cmp	 ecx, DWORD PTR _clear$[ebp]
  0007a	7d 33		 jge	 SHORT $LN3@stbi_proce

; 3756 :       g->codes[code].prefix = -1;

  0007c	83 ca ff	 or	 edx, -1
  0007f	8b 45 f4	 mov	 eax, DWORD PTR _code$[ebp]
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00085	66 89 94 81 20
	08 00 00	 mov	 WORD PTR [ecx+eax*4+2080], dx

; 3757 :       g->codes[code].first = (uint8) code;

  0008d	8b 55 f4	 mov	 edx, DWORD PTR _code$[ebp]
  00090	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00093	8a 4d f4	 mov	 cl, BYTE PTR _code$[ebp]
  00096	88 8c 90 22 08
	00 00		 mov	 BYTE PTR [eax+edx*4+2082], cl

; 3758 :       g->codes[code].suffix = (uint8) code;

  0009d	8b 55 f4	 mov	 edx, DWORD PTR _code$[ebp]
  000a0	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  000a3	8a 4d f4	 mov	 cl, BYTE PTR _code$[ebp]
  000a6	88 8c 90 23 08
	00 00		 mov	 BYTE PTR [eax+edx*4+2083], cl

; 3759 :    }

  000ad	eb bc		 jmp	 SHORT $LN2@stbi_proce
$LN3@stbi_proce:

; 3760 : 
; 3761 :    // support no starting clear code
; 3762 :    avail = clear+2;

  000af	8b 55 d4	 mov	 edx, DWORD PTR _clear$[ebp]
  000b2	83 c2 02	 add	 edx, 2
  000b5	89 55 e4	 mov	 DWORD PTR _avail$[ebp], edx

; 3763 :    oldcode = -1;

  000b8	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _oldcode$[ebp], -1

; 3764 : 
; 3765 :    len = 0;

  000bf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN7@stbi_proce:

; 3766 :    for(;;) {
; 3767 :       if (valid_bits < codesize) {

  000c6	8b 45 d8	 mov	 eax, DWORD PTR _valid_bits$[ebp]
  000c9	3b 45 ec	 cmp	 eax, DWORD PTR _codesize$[ebp]
  000cc	7d 54		 jge	 SHORT $LN10@stbi_proce

; 3768 :          if (len == 0) {

  000ce	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  000d2	75 20		 jne	 SHORT $LN12@stbi_proce

; 3769 :             len = get8(s); // start new block

  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000dd	83 c4 04	 add	 esp, 4
  000e0	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 3770 :             if (len == 0) 

  000e3	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  000e7	75 0b		 jne	 SHORT $LN12@stbi_proce

; 3771 :                return g->out;

  000e9	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  000ec	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ef	e9 52 02 00 00	 jmp	 $LN1@stbi_proce
$LN12@stbi_proce:

; 3772 :          }
; 3773 :          --len;

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000f7	83 e8 01	 sub	 eax, 1
  000fa	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 3774 :          bits |= (int32) get8(s) << valid_bits;

  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00106	83 c4 04	 add	 esp, 4
  00109	8b 4d d8	 mov	 ecx, DWORD PTR _valid_bits$[ebp]
  0010c	d3 e0		 shl	 eax, cl
  0010e	0b 45 dc	 or	 eax, DWORD PTR _bits$[ebp]
  00111	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax

; 3775 :          valid_bits += 8;

  00114	8b 55 d8	 mov	 edx, DWORD PTR _valid_bits$[ebp]
  00117	83 c2 08	 add	 edx, 8
  0011a	89 55 d8	 mov	 DWORD PTR _valid_bits$[ebp], edx

; 3776 :       } else {

  0011d	e9 1f 02 00 00	 jmp	 $LN11@stbi_proce
$LN10@stbi_proce:

; 3777 :          int32 code = bits & codemask;

  00122	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  00125	23 45 e8	 and	 eax, DWORD PTR _codemask$[ebp]
  00128	89 45 cc	 mov	 DWORD PTR _code$1[ebp], eax

; 3778 :          bits >>= codesize;

  0012b	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0012e	8b 4d ec	 mov	 ecx, DWORD PTR _codesize$[ebp]
  00131	d3 fa		 sar	 edx, cl
  00133	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx

; 3779 :          valid_bits -= codesize;

  00136	8b 45 d8	 mov	 eax, DWORD PTR _valid_bits$[ebp]
  00139	2b 45 ec	 sub	 eax, DWORD PTR _codesize$[ebp]
  0013c	89 45 d8	 mov	 DWORD PTR _valid_bits$[ebp], eax

; 3780 :          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 3781 :          if (code == clear) {  // clear code

  0013f	8b 4d cc	 mov	 ecx, DWORD PTR _code$1[ebp]
  00142	3b 4d d4	 cmp	 ecx, DWORD PTR _clear$[ebp]
  00145	75 36		 jne	 SHORT $LN14@stbi_proce

; 3782 :             codesize = lzw_cs + 1;

  00147	0f b6 55 ff	 movzx	 edx, BYTE PTR _lzw_cs$[ebp]
  0014b	83 c2 01	 add	 edx, 1
  0014e	89 55 ec	 mov	 DWORD PTR _codesize$[ebp], edx

; 3783 :             codemask = (1 << codesize) - 1;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	8b 4d ec	 mov	 ecx, DWORD PTR _codesize$[ebp]
  00159	d3 e0		 shl	 eax, cl
  0015b	83 e8 01	 sub	 eax, 1
  0015e	89 45 e8	 mov	 DWORD PTR _codemask$[ebp], eax

; 3784 :             avail = clear + 2;

  00161	8b 4d d4	 mov	 ecx, DWORD PTR _clear$[ebp]
  00164	83 c1 02	 add	 ecx, 2
  00167	89 4d e4	 mov	 DWORD PTR _avail$[ebp], ecx

; 3785 :             oldcode = -1;

  0016a	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _oldcode$[ebp], -1

; 3786 :             first = 0;

  00171	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
  00178	e9 c4 01 00 00	 jmp	 $LN11@stbi_proce
$LN14@stbi_proce:

; 3787 :          } else if (code == clear + 1) { // end of stream code

  0017d	8b 55 d4	 mov	 edx, DWORD PTR _clear$[ebp]
  00180	83 c2 01	 add	 edx, 1
  00183	39 55 cc	 cmp	 DWORD PTR _code$1[ebp], edx
  00186	75 47		 jne	 SHORT $LN16@stbi_proce

; 3788 :             skip(s, len);

  00188	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00195	83 c4 08	 add	 esp, 8
$LN8@stbi_proce:

; 3789 :             while ((len = get8(s)) > 0)

  00198	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  001a1	83 c4 04	 add	 esp, 4
  001a4	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
  001a7	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  001ab	7e 12		 jle	 SHORT $LN9@stbi_proce

; 3790 :                skip(s,len);

  001ad	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  001ba	83 c4 08	 add	 esp, 8
  001bd	eb d9		 jmp	 SHORT $LN8@stbi_proce
$LN9@stbi_proce:

; 3791 :             return g->out;

  001bf	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  001c2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001c5	e9 7c 01 00 00	 jmp	 $LN1@stbi_proce
  001ca	e9 72 01 00 00	 jmp	 $LN11@stbi_proce
$LN16@stbi_proce:

; 3792 :          } else if (code <= avail) {

  001cf	8b 45 cc	 mov	 eax, DWORD PTR _code$1[ebp]
  001d2	3b 45 e4	 cmp	 eax, DWORD PTR _avail$[ebp]
  001d5	0f 8f 40 01 00
	00		 jg	 $LN18@stbi_proce

; 3793 :             if (first) return epuc("no clear code", "Corrupt GIF");

  001db	83 7d f0 00	 cmp	 DWORD PTR _first$[ebp], 0
  001df	74 29		 je	 SHORT $LN20@stbi_proce
  001e1	68 00 00 00 00	 push	 OFFSET $SG4294820120
  001e6	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001eb	83 c4 04	 add	 esp, 4
  001ee	85 c0		 test	 eax, eax
  001f0	74 09		 je	 SHORT $LN27@stbi_proce
  001f2	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
  001f9	eb 07		 jmp	 SHORT $LN28@stbi_proce
$LN27@stbi_proce:
  001fb	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
$LN28@stbi_proce:
  00202	8b 45 c8	 mov	 eax, DWORD PTR tv155[ebp]
  00205	e9 3c 01 00 00	 jmp	 $LN1@stbi_proce
$LN20@stbi_proce:

; 3794 : 
; 3795 :             if (oldcode >= 0) {

  0020a	83 7d e0 00	 cmp	 DWORD PTR _oldcode$[ebp], 0
  0020e	0f 8c 96 00 00
	00		 jl	 $LN21@stbi_proce

; 3796 :                p = &g->codes[avail++];

  00214	8b 4d e4	 mov	 ecx, DWORD PTR _avail$[ebp]
  00217	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0021a	8d 84 8a 20 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+2080]
  00221	89 45 d0	 mov	 DWORD PTR _p$[ebp], eax
  00224	8b 4d e4	 mov	 ecx, DWORD PTR _avail$[ebp]
  00227	83 c1 01	 add	 ecx, 1
  0022a	89 4d e4	 mov	 DWORD PTR _avail$[ebp], ecx

; 3797 :                if (avail > 4096)        return epuc("too many codes", "Corrupt GIF");

  0022d	81 7d e4 00 10
	00 00		 cmp	 DWORD PTR _avail$[ebp], 4096 ; 00001000H
  00234	7e 29		 jle	 SHORT $LN23@stbi_proce
  00236	68 00 00 00 00	 push	 OFFSET $SG4294820119
  0023b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00240	83 c4 04	 add	 esp, 4
  00243	85 c0		 test	 eax, eax
  00245	74 09		 je	 SHORT $LN29@stbi_proce
  00247	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
  0024e	eb 07		 jmp	 SHORT $LN30@stbi_proce
$LN29@stbi_proce:
  00250	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
$LN30@stbi_proce:
  00257	8b 45 c4	 mov	 eax, DWORD PTR tv165[ebp]
  0025a	e9 e7 00 00 00	 jmp	 $LN1@stbi_proce
$LN23@stbi_proce:

; 3798 :                p->prefix = (int16) oldcode;

  0025f	8b 55 d0	 mov	 edx, DWORD PTR _p$[ebp]
  00262	66 8b 45 e0	 mov	 ax, WORD PTR _oldcode$[ebp]
  00266	66 89 02	 mov	 WORD PTR [edx], ax

; 3799 :                p->first = g->codes[oldcode].first;

  00269	8b 4d d0	 mov	 ecx, DWORD PTR _p$[ebp]
  0026c	8b 55 e0	 mov	 edx, DWORD PTR _oldcode$[ebp]
  0026f	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00272	8a 94 90 22 08
	00 00		 mov	 dl, BYTE PTR [eax+edx*4+2082]
  00279	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 3800 :                p->suffix = (code == avail) ? p->first : g->codes[code].first;

  0027c	8b 45 cc	 mov	 eax, DWORD PTR _code$1[ebp]
  0027f	3b 45 e4	 cmp	 eax, DWORD PTR _avail$[ebp]
  00282	75 0b		 jne	 SHORT $LN31@stbi_proce
  00284	8b 4d d0	 mov	 ecx, DWORD PTR _p$[ebp]
  00287	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0028a	88 55 c3	 mov	 BYTE PTR tv179[ebp], dl
  0028d	eb 10		 jmp	 SHORT $LN32@stbi_proce
$LN31@stbi_proce:
  0028f	8b 45 cc	 mov	 eax, DWORD PTR _code$1[ebp]
  00292	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00295	8a 94 81 22 08
	00 00		 mov	 dl, BYTE PTR [ecx+eax*4+2082]
  0029c	88 55 c3	 mov	 BYTE PTR tv179[ebp], dl
$LN32@stbi_proce:
  0029f	8b 45 d0	 mov	 eax, DWORD PTR _p$[ebp]
  002a2	8a 4d c3	 mov	 cl, BYTE PTR tv179[ebp]
  002a5	88 48 03	 mov	 BYTE PTR [eax+3], cl
  002a8	eb 2e		 jmp	 SHORT $LN22@stbi_proce
$LN21@stbi_proce:

; 3801 :             } else if (code == avail)

  002aa	8b 55 cc	 mov	 edx, DWORD PTR _code$1[ebp]
  002ad	3b 55 e4	 cmp	 edx, DWORD PTR _avail$[ebp]
  002b0	75 26		 jne	 SHORT $LN22@stbi_proce

; 3802 :                return epuc("illegal code in raster", "Corrupt GIF");

  002b2	68 00 00 00 00	 push	 OFFSET $SG4294820118
  002b7	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  002bc	83 c4 04	 add	 esp, 4
  002bf	85 c0		 test	 eax, eax
  002c1	74 09		 je	 SHORT $LN33@stbi_proce
  002c3	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
  002ca	eb 07		 jmp	 SHORT $LN34@stbi_proce
$LN33@stbi_proce:
  002cc	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
$LN34@stbi_proce:
  002d3	8b 45 bc	 mov	 eax, DWORD PTR tv184[ebp]
  002d6	eb 6e		 jmp	 SHORT $LN1@stbi_proce
$LN22@stbi_proce:

; 3803 : 
; 3804 :             stbi_out_gif_code(g, (uint16) code);

  002d8	0f b7 45 cc	 movzx	 eax, WORD PTR _code$1[ebp]
  002dc	50		 push	 eax
  002dd	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  002e0	51		 push	 ecx
  002e1	e8 00 00 00 00	 call	 ?stbi_out_gif_code@@YAXPAUstbi_gif_struct@@G@Z ; stbi_out_gif_code
  002e6	83 c4 08	 add	 esp, 8

; 3805 : 
; 3806 :             if ((avail & codemask) == 0 && avail <= 0x0FFF) {

  002e9	8b 55 e4	 mov	 edx, DWORD PTR _avail$[ebp]
  002ec	23 55 e8	 and	 edx, DWORD PTR _codemask$[ebp]
  002ef	75 22		 jne	 SHORT $LN25@stbi_proce
  002f1	81 7d e4 ff 0f
	00 00		 cmp	 DWORD PTR _avail$[ebp], 4095 ; 00000fffH
  002f8	7f 19		 jg	 SHORT $LN25@stbi_proce

; 3807 :                codesize++;

  002fa	8b 45 ec	 mov	 eax, DWORD PTR _codesize$[ebp]
  002fd	83 c0 01	 add	 eax, 1
  00300	89 45 ec	 mov	 DWORD PTR _codesize$[ebp], eax

; 3808 :                codemask = (1 << codesize) - 1;

  00303	ba 01 00 00 00	 mov	 edx, 1
  00308	8b 4d ec	 mov	 ecx, DWORD PTR _codesize$[ebp]
  0030b	d3 e2		 shl	 edx, cl
  0030d	83 ea 01	 sub	 edx, 1
  00310	89 55 e8	 mov	 DWORD PTR _codemask$[ebp], edx
$LN25@stbi_proce:

; 3809 :             }
; 3810 : 
; 3811 :             oldcode = code;

  00313	8b 45 cc	 mov	 eax, DWORD PTR _code$1[ebp]
  00316	89 45 e0	 mov	 DWORD PTR _oldcode$[ebp], eax

; 3812 :          } else {

  00319	eb 26		 jmp	 SHORT $LN11@stbi_proce
$LN18@stbi_proce:

; 3813 :             return epuc("illegal code in raster", "Corrupt GIF");

  0031b	68 00 00 00 00	 push	 OFFSET $SG4294820117
  00320	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00325	83 c4 04	 add	 esp, 4
  00328	85 c0		 test	 eax, eax
  0032a	74 09		 je	 SHORT $LN35@stbi_proce
  0032c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], 0
  00333	eb 07		 jmp	 SHORT $LN36@stbi_proce
$LN35@stbi_proce:
  00335	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], 0
$LN36@stbi_proce:
  0033c	8b 45 b8	 mov	 eax, DWORD PTR tv196[ebp]
  0033f	eb 05		 jmp	 SHORT $LN1@stbi_proce
$LN11@stbi_proce:

; 3814 :          }
; 3815 :       } 
; 3816 :    }

  00341	e9 80 fd ff ff	 jmp	 $LN7@stbi_proce
$LN1@stbi_proce:

; 3817 : }

  00346	5f		 pop	 edi
  00347	83 c4 48	 add	 esp, 72			; 00000048H
  0034a	3b ec		 cmp	 ebp, esp
  0034c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00351	8b e5		 mov	 esp, ebp
  00353	5d		 pop	 ebp
  00354	c3		 ret	 0
?stbi_process_gif_raster@@YAPAEPAUstbi@@PAUstbi_gif_struct@@@Z ENDP ; stbi_process_gif_raster
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_p$1 = -12						; size = 4
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_g$ = 8							; size = 4
?stbi_fill_gif_background@@YAXPAUstbi_gif_struct@@@Z PROC ; stbi_fill_gif_background

; 3820 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3821 :    int i;
; 3822 :    uint8 *c = g->pal[g->bgindex];

  0001c	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  0001f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00022	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00025	8d 44 8a 20	 lea	 eax, DWORD PTR [edx+ecx*4+32]
  00029	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 3823 :    // @OPTIMIZE: write a dword at a time
; 3824 :    for (i = 0; i < g->w * g->h * 4; i += 4) {

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00033	eb 09		 jmp	 SHORT $LN4@stbi_fill_
$LN2@stbi_fill_:
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00038	83 c1 04	 add	 ecx, 4
  0003b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@stbi_fill_:
  0003e	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00041	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  00044	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00046	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  0004a	c1 e1 02	 shl	 ecx, 2
  0004d	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  00050	7d 7f		 jge	 SHORT $LN1@stbi_fill_

; 3825 :       uint8 *p  = &g->out[i];

  00052	8b 55 08	 mov	 edx, DWORD PTR _g$[ebp]
  00055	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00058	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0005b	89 45 f4	 mov	 DWORD PTR _p$1[ebp], eax

; 3826 :       p[0] = c[2];

  0005e	b9 01 00 00 00	 mov	 ecx, 1
  00063	d1 e1		 shl	 ecx, 1
  00065	ba 01 00 00 00	 mov	 edx, 1
  0006a	6b c2 00	 imul	 eax, edx, 0
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _p$1[ebp]
  00070	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  00073	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00076	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 3827 :       p[1] = c[1];

  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	c1 e2 00	 shl	 edx, 0
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	c1 e0 00	 shl	 eax, 0
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _p$1[ebp]
  0008c	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  0008f	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00092	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 3828 :       p[2] = c[0];

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	6b c8 00	 imul	 ecx, eax, 0
  0009d	ba 01 00 00 00	 mov	 edx, 1
  000a2	d1 e2		 shl	 edx, 1
  000a4	8b 45 f4	 mov	 eax, DWORD PTR _p$1[ebp]
  000a7	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  000aa	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  000ad	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 3829 :       p[3] = c[3];

  000b0	ba 01 00 00 00	 mov	 edx, 1
  000b5	6b c2 03	 imul	 eax, edx, 3
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	6b d1 03	 imul	 edx, ecx, 3
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _p$1[ebp]
  000c3	8b 75 f8	 mov	 esi, DWORD PTR _c$[ebp]
  000c6	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  000c9	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3830 :    }

  000cc	e9 64 ff ff ff	 jmp	 $LN2@stbi_fill_
$LN1@stbi_fill_:

; 3831 : }

  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?stbi_fill_gif_background@@YAXPAUstbi_gif_struct@@@Z ENDP ; stbi_fill_gif_background
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv287 = -60						; size = 4
tv249 = -56						; size = 4
tv212 = -52						; size = 4
tv170 = -48						; size = 4
tv152 = -44						; size = 4
tv141 = -40						; size = 4
tv87 = -36						; size = 4
_len$1 = -32						; size = 4
_o$2 = -28						; size = 4
_h$3 = -24						; size = 4
_w$4 = -20						; size = 4
_y$5 = -16						; size = 4
_x$6 = -12						; size = 4
_old_out$ = -8						; size = 4
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_g$ = 12						; size = 4
_comp$ = 16						; size = 4
_req_comp$ = 20						; size = 4
?stbi_gif_load_next@@YAPAEPAUstbi@@PAUstbi_gif_struct@@PAHH@Z PROC ; stbi_gif_load_next

; 3835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 3836 :    int i;
; 3837 :    uint8 *old_out = 0;

  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _old_out$[ebp], 0

; 3838 : 
; 3839 :    if (g->out == 0) {

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00021	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00025	0f 85 8c 00 00
	00		 jne	 $LN12@stbi_gif_l

; 3840 :       if (!stbi_gif_header(s, g, comp,0))     return 0; // failure_reason set by stbi_gif_header

  0002b	6a 00		 push	 0
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _comp$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?stbi_gif_header@@YAHPAUstbi@@PAUstbi_gif_struct@@PAHH@Z ; stbi_gif_header
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	85 c0		 test	 eax, eax
  00043	75 07		 jne	 SHORT $LN14@stbi_gif_l
  00045	33 c0		 xor	 eax, eax
  00047	e9 ec 04 00 00	 jmp	 $LN1@stbi_gif_l
$LN14@stbi_gif_l:

; 3841 :       g->out = (uint8 *) malloc(4 * g->w * g->h);

  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	c1 e2 02	 shl	 edx, 2
  00054	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00057	0f af 50 04	 imul	 edx, DWORD PTR [eax+4]
  0005b	8b f4		 mov	 esi, esp
  0005d	52		 push	 edx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00064	83 c4 04	 add	 esp, 4
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00071	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3842 :       if (g->out == 0)                      return epuc("outofmem", "Out of memory");

  00074	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00077	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0007b	75 29		 jne	 SHORT $LN15@stbi_gif_l
  0007d	68 00 00 00 00	 push	 OFFSET $SG4294820116
  00082	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00087	83 c4 04	 add	 esp, 4
  0008a	85 c0		 test	 eax, eax
  0008c	74 09		 je	 SHORT $LN37@stbi_gif_l
  0008e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  00095	eb 07		 jmp	 SHORT $LN38@stbi_gif_l
$LN37@stbi_gif_l:
  00097	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN38@stbi_gif_l:
  0009e	8b 45 dc	 mov	 eax, DWORD PTR tv87[ebp]
  000a1	e9 92 04 00 00	 jmp	 $LN1@stbi_gif_l
$LN15@stbi_gif_l:

; 3843 :       stbi_fill_gif_background(g);

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?stbi_fill_gif_background@@YAXPAUstbi_gif_struct@@@Z ; stbi_fill_gif_background
  000af	83 c4 04	 add	 esp, 4

; 3844 :    } else {

  000b2	e9 a5 00 00 00	 jmp	 $LN4@stbi_gif_l
$LN12@stbi_gif_l:

; 3845 :       // animated-gif-only path
; 3846 :       if (((g->eflags & 0x1C) >> 2) == 3) {

  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000ba	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000bd	83 e2 1c	 and	 edx, 28			; 0000001cH
  000c0	c1 fa 02	 sar	 edx, 2
  000c3	83 fa 03	 cmp	 edx, 3
  000c6	0f 85 90 00 00
	00		 jne	 $LN4@stbi_gif_l

; 3847 :          old_out = g->out;

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  000cf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d2	89 4d f8	 mov	 DWORD PTR _old_out$[ebp], ecx

; 3848 :          g->out = (uint8 *) malloc(4 * g->w * g->h);

  000d5	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  000d8	8b 02		 mov	 eax, DWORD PTR [edx]
  000da	c1 e0 02	 shl	 eax, 2
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  000e0	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  000e4	8b f4		 mov	 esi, esp
  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000ed	83 c4 04	 add	 esp, 4
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  000fa	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 3849 :          if (g->out == 0)                   return epuc("outofmem", "Out of memory");

  000fd	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00100	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00104	75 29		 jne	 SHORT $LN17@stbi_gif_l
  00106	68 00 00 00 00	 push	 OFFSET $SG4294820115
  0010b	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00110	83 c4 04	 add	 esp, 4
  00113	85 c0		 test	 eax, eax
  00115	74 09		 je	 SHORT $LN39@stbi_gif_l
  00117	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  0011e	eb 07		 jmp	 SHORT $LN40@stbi_gif_l
$LN39@stbi_gif_l:
  00120	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$LN40@stbi_gif_l:
  00127	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  0012a	e9 09 04 00 00	 jmp	 $LN1@stbi_gif_l
$LN17@stbi_gif_l:

; 3850 :          memcpy(g->out, old_out, g->w*g->h*4);

  0012f	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00132	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00135	8b 01		 mov	 eax, DWORD PTR [ecx]
  00137	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  0013b	c1 e0 02	 shl	 eax, 2
  0013e	8b f4		 mov	 esi, esp
  00140	50		 push	 eax
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _old_out$[ebp]
  00144	51		 push	 ecx
  00145	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00148	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	3b f4		 cmp	 esi, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@stbi_gif_l:

; 3851 :       }
; 3852 :    }
; 3853 :     
; 3854 :    for (;;) {
; 3855 :       switch (get8(s)) {

  0015c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00165	83 c4 04	 add	 esp, 4
  00168	89 45 d4	 mov	 DWORD PTR tv152[ebp], eax
  0016b	83 7d d4 21	 cmp	 DWORD PTR tv152[ebp], 33 ; 00000021H
  0016f	0f 84 fc 02 00
	00		 je	 $LN30@stbi_gif_l
  00175	83 7d d4 2c	 cmp	 DWORD PTR tv152[ebp], 44 ; 0000002cH
  00179	74 0f		 je	 SHORT $LN18@stbi_gif_l
  0017b	83 7d d4 3b	 cmp	 DWORD PTR tv152[ebp], 59 ; 0000003bH
  0017f	0f 84 81 03 00
	00		 je	 $LN34@stbi_gif_l
  00185	e9 83 03 00 00	 jmp	 $LN35@stbi_gif_l
$LN18@stbi_gif_l:

; 3856 :          case 0x2C: /* Image Descriptor */
; 3857 :          {
; 3858 :             int32 x, y, w, h;
; 3859 :             uint8 *o;
; 3860 : 
; 3861 :             x = get16le(s);

  0018a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0018d	52		 push	 edx
  0018e	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00193	83 c4 04	 add	 esp, 4
  00196	89 45 f4	 mov	 DWORD PTR _x$6[ebp], eax

; 3862 :             y = get16le(s);

  00199	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  001a2	83 c4 04	 add	 esp, 4
  001a5	89 45 f0	 mov	 DWORD PTR _y$5[ebp], eax

; 3863 :             w = get16le(s);

  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  001b1	83 c4 04	 add	 esp, 4
  001b4	89 45 ec	 mov	 DWORD PTR _w$4[ebp], eax

; 3864 :             h = get16le(s);

  001b7	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  001c0	83 c4 04	 add	 esp, 4
  001c3	89 45 e8	 mov	 DWORD PTR _h$3[ebp], eax

; 3865 :             if (((x + w) > (g->w)) || ((y + h) > (g->h)))

  001c6	8b 45 f4	 mov	 eax, DWORD PTR _x$6[ebp]
  001c9	03 45 ec	 add	 eax, DWORD PTR _w$4[ebp]
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  001cf	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001d1	7f 0e		 jg	 SHORT $LN20@stbi_gif_l
  001d3	8b 55 f0	 mov	 edx, DWORD PTR _y$5[ebp]
  001d6	03 55 e8	 add	 edx, DWORD PTR _h$3[ebp]
  001d9	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  001dc	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  001df	7e 29		 jle	 SHORT $LN19@stbi_gif_l
$LN20@stbi_gif_l:

; 3866 :                return epuc("bad Image Descriptor", "Corrupt GIF");

  001e1	68 00 00 00 00	 push	 OFFSET $SG4294820114
  001e6	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  001eb	83 c4 04	 add	 esp, 4
  001ee	85 c0		 test	 eax, eax
  001f0	74 09		 je	 SHORT $LN41@stbi_gif_l
  001f2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
  001f9	eb 07		 jmp	 SHORT $LN42@stbi_gif_l
$LN41@stbi_gif_l:
  001fb	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
$LN42@stbi_gif_l:
  00202	8b 45 d0	 mov	 eax, DWORD PTR tv170[ebp]
  00205	e9 2e 03 00 00	 jmp	 $LN1@stbi_gif_l
$LN19@stbi_gif_l:

; 3867 : 
; 3868 :             g->line_size = g->w * 4;

  0020a	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  0020d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0020f	c1 e2 02	 shl	 edx, 2
  00212	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00215	89 90 48 48 00
	00		 mov	 DWORD PTR [eax+18504], edx

; 3869 :             g->start_x = x * 4;

  0021b	8b 4d f4	 mov	 ecx, DWORD PTR _x$6[ebp]
  0021e	c1 e1 02	 shl	 ecx, 2
  00221	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00224	89 8a 30 48 00
	00		 mov	 DWORD PTR [edx+18480], ecx

; 3870 :             g->start_y = y * g->line_size;

  0022a	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0022d	8b 4d f0	 mov	 ecx, DWORD PTR _y$5[ebp]
  00230	0f af 88 48 48
	00 00		 imul	 ecx, DWORD PTR [eax+18504]
  00237	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0023a	89 8a 34 48 00
	00		 mov	 DWORD PTR [edx+18484], ecx

; 3871 :             g->max_x   = g->start_x + w * 4;

  00240	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00243	8b 88 30 48 00
	00		 mov	 ecx, DWORD PTR [eax+18480]
  00249	8b 55 ec	 mov	 edx, DWORD PTR _w$4[ebp]
  0024c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0024f	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00252	89 81 38 48 00
	00		 mov	 DWORD PTR [ecx+18488], eax

; 3872 :             g->max_y   = g->start_y + h * g->line_size;

  00258	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0025b	8b 45 e8	 mov	 eax, DWORD PTR _h$3[ebp]
  0025e	0f af 82 48 48
	00 00		 imul	 eax, DWORD PTR [edx+18504]
  00265	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00268	03 81 34 48 00
	00		 add	 eax, DWORD PTR [ecx+18484]
  0026e	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00271	89 82 3c 48 00
	00		 mov	 DWORD PTR [edx+18492], eax

; 3873 :             g->cur_x   = g->start_x;

  00277	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0027a	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  0027d	8b 91 30 48 00
	00		 mov	 edx, DWORD PTR [ecx+18480]
  00283	89 90 40 48 00
	00		 mov	 DWORD PTR [eax+18496], edx

; 3874 :             g->cur_y   = g->start_y;

  00289	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0028c	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  0028f	8b 91 34 48 00
	00		 mov	 edx, DWORD PTR [ecx+18484]
  00295	89 90 44 48 00
	00		 mov	 DWORD PTR [eax+18500], edx

; 3875 : 
; 3876 :             g->lflags = get8(s);

  0029b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  002a4	83 c4 04	 add	 esp, 4
  002a7	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  002aa	89 81 2c 48 00
	00		 mov	 DWORD PTR [ecx+18476], eax

; 3877 : 
; 3878 :             if (g->lflags & 0x40) {

  002b0	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  002b3	8b 82 2c 48 00
	00		 mov	 eax, DWORD PTR [edx+18476]
  002b9	83 e0 40	 and	 eax, 64			; 00000040H
  002bc	74 24		 je	 SHORT $LN21@stbi_gif_l

; 3879 :                g->step = 8 * g->line_size; // first interlaced spacing

  002be	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  002c1	8b 91 48 48 00
	00		 mov	 edx, DWORD PTR [ecx+18504]
  002c7	c1 e2 03	 shl	 edx, 3
  002ca	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  002cd	89 90 28 48 00
	00		 mov	 DWORD PTR [eax+18472], edx

; 3880 :                g->parse = 3;

  002d3	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  002d6	c7 81 24 48 00
	00 03 00 00 00	 mov	 DWORD PTR [ecx+18468], 3

; 3881 :             } else {

  002e0	eb 1f		 jmp	 SHORT $LN22@stbi_gif_l
$LN21@stbi_gif_l:

; 3882 :                g->step = g->line_size;

  002e2	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  002e5	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  002e8	8b 88 48 48 00
	00		 mov	 ecx, DWORD PTR [eax+18504]
  002ee	89 8a 28 48 00
	00		 mov	 DWORD PTR [edx+18472], ecx

; 3883 :                g->parse = 0;

  002f4	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  002f7	c7 82 24 48 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+18468], 0
$LN22@stbi_gif_l:

; 3884 :             }
; 3885 : 
; 3886 :             if (g->lflags & 0x80) {

  00301	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00304	8b 88 2c 48 00
	00		 mov	 ecx, DWORD PTR [eax+18476]
  0030a	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00310	74 61		 je	 SHORT $LN23@stbi_gif_l

; 3887 :                stbi_gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

  00312	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  00315	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00318	83 e0 01	 and	 eax, 1
  0031b	74 0b		 je	 SHORT $LN43@stbi_gif_l
  0031d	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00320	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00323	89 55 cc	 mov	 DWORD PTR tv212[ebp], edx
  00326	eb 07		 jmp	 SHORT $LN44@stbi_gif_l
$LN43@stbi_gif_l:
  00328	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR tv212[ebp], -1
$LN44@stbi_gif_l:
  0032f	8b 45 cc	 mov	 eax, DWORD PTR tv212[ebp]
  00332	50		 push	 eax
  00333	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00336	8b 89 2c 48 00
	00		 mov	 ecx, DWORD PTR [ecx+18476]
  0033c	83 e1 07	 and	 ecx, 7
  0033f	ba 02 00 00 00	 mov	 edx, 2
  00344	d3 e2		 shl	 edx, cl
  00346	52		 push	 edx
  00347	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  0034a	05 20 04 00 00	 add	 eax, 1056		; 00000420H
  0034f	50		 push	 eax
  00350	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00353	51		 push	 ecx
  00354	e8 00 00 00 00	 call	 ?stbi_gif_parse_colortable@@YAXPAUstbi@@QAY03EHH@Z ; stbi_gif_parse_colortable
  00359	83 c4 10	 add	 esp, 16			; 00000010H

; 3888 :                g->color_table = (uint8 *) g->lpal;       

  0035c	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0035f	81 c2 20 04 00
	00		 add	 edx, 1056		; 00000420H
  00365	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00368	89 90 20 48 00
	00		 mov	 DWORD PTR [eax+18464], edx
  0036e	e9 a8 00 00 00	 jmp	 $LN24@stbi_gif_l
$LN23@stbi_gif_l:

; 3889 :             } else if (g->flags & 0x80) {

  00373	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  00376	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00379	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0037f	74 71		 je	 SHORT $LN25@stbi_gif_l

; 3890 :                for (i=0; i < 256; ++i)  // @OPTIMIZE: reset only the previous transparent

  00381	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00388	eb 09		 jmp	 SHORT $LN9@stbi_gif_l
$LN7@stbi_gif_l:
  0038a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0038d	83 c0 01	 add	 eax, 1
  00390	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN9@stbi_gif_l:
  00393	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  0039a	7d 18		 jge	 SHORT $LN8@stbi_gif_l

; 3891 :                   g->pal[i][3] = 255; 

  0039c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0039f	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  003a2	8d 44 8a 20	 lea	 eax, DWORD PTR [edx+ecx*4+32]
  003a6	b9 01 00 00 00	 mov	 ecx, 1
  003ab	6b d1 03	 imul	 edx, ecx, 3
  003ae	c6 04 10 ff	 mov	 BYTE PTR [eax+edx], 255	; 000000ffH
  003b2	eb d6		 jmp	 SHORT $LN7@stbi_gif_l
$LN8@stbi_gif_l:

; 3892 :                if (g->transparent >= 0 && (g->eflags & 0x01))

  003b4	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  003b7	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  003bb	7c 24		 jl	 SHORT $LN27@stbi_gif_l
  003bd	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  003c0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003c3	83 e2 01	 and	 edx, 1
  003c6	74 19		 je	 SHORT $LN27@stbi_gif_l

; 3893 :                   g->pal[g->transparent][3] = 0;

  003c8	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  003cb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003ce	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  003d1	8d 44 8a 20	 lea	 eax, DWORD PTR [edx+ecx*4+32]
  003d5	b9 01 00 00 00	 mov	 ecx, 1
  003da	6b d1 03	 imul	 edx, ecx, 3
  003dd	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
$LN27@stbi_gif_l:

; 3894 :                g->color_table = (uint8 *) g->pal;

  003e1	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  003e4	83 c0 20	 add	 eax, 32			; 00000020H
  003e7	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  003ea	89 81 20 48 00
	00		 mov	 DWORD PTR [ecx+18464], eax

; 3895 :             } else

  003f0	eb 29		 jmp	 SHORT $LN24@stbi_gif_l
$LN25@stbi_gif_l:

; 3896 :                return epuc("missing color table", "Corrupt GIF");

  003f2	68 00 00 00 00	 push	 OFFSET $SG4294820113
  003f7	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  003fc	83 c4 04	 add	 esp, 4
  003ff	85 c0		 test	 eax, eax
  00401	74 09		 je	 SHORT $LN45@stbi_gif_l
  00403	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv249[ebp], 0
  0040a	eb 07		 jmp	 SHORT $LN46@stbi_gif_l
$LN45@stbi_gif_l:
  0040c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv249[ebp], 0
$LN46@stbi_gif_l:
  00413	8b 45 c8	 mov	 eax, DWORD PTR tv249[ebp]
  00416	e9 1d 01 00 00	 jmp	 $LN1@stbi_gif_l
$LN24@stbi_gif_l:

; 3897 :    
; 3898 :             o = stbi_process_gif_raster(s, g);

  0041b	8b 55 0c	 mov	 edx, DWORD PTR _g$[ebp]
  0041e	52		 push	 edx
  0041f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00422	50		 push	 eax
  00423	e8 00 00 00 00	 call	 ?stbi_process_gif_raster@@YAPAEPAUstbi@@PAUstbi_gif_struct@@@Z ; stbi_process_gif_raster
  00428	83 c4 08	 add	 esp, 8
  0042b	89 45 e4	 mov	 DWORD PTR _o$2[ebp], eax

; 3899 :             if (o == NULL) return NULL;

  0042e	83 7d e4 00	 cmp	 DWORD PTR _o$2[ebp], 0
  00432	75 07		 jne	 SHORT $LN28@stbi_gif_l
  00434	33 c0		 xor	 eax, eax
  00436	e9 fd 00 00 00	 jmp	 $LN1@stbi_gif_l
$LN28@stbi_gif_l:

; 3900 : 
; 3901 :             if (req_comp && req_comp != 4)

  0043b	83 7d 14 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  0043f	74 28		 je	 SHORT $LN29@stbi_gif_l
  00441	83 7d 14 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  00445	74 22		 je	 SHORT $LN29@stbi_gif_l

; 3902 :                o = convert_format(o, 4, req_comp, g->w, g->h);

  00447	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  0044a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0044d	52		 push	 edx
  0044e	8b 45 0c	 mov	 eax, DWORD PTR _g$[ebp]
  00451	8b 08		 mov	 ecx, DWORD PTR [eax]
  00453	51		 push	 ecx
  00454	8b 55 14	 mov	 edx, DWORD PTR _req_comp$[ebp]
  00457	52		 push	 edx
  00458	6a 04		 push	 4
  0045a	8b 45 e4	 mov	 eax, DWORD PTR _o$2[ebp]
  0045d	50		 push	 eax
  0045e	e8 00 00 00 00	 call	 ?convert_format@@YAPAEPAEHHII@Z ; convert_format
  00463	83 c4 14	 add	 esp, 20			; 00000014H
  00466	89 45 e4	 mov	 DWORD PTR _o$2[ebp], eax
$LN29@stbi_gif_l:

; 3903 :             return o;

  00469	8b 45 e4	 mov	 eax, DWORD PTR _o$2[ebp]
  0046c	e9 c7 00 00 00	 jmp	 $LN1@stbi_gif_l
$LN30@stbi_gif_l:

; 3904 :          }
; 3905 : 
; 3906 :          case 0x21: // Comment Extension.
; 3907 :          {
; 3908 :             int len;
; 3909 :             if (get8(s) == 0xF9) { // Graphic Control Extension.

  00471	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00474	51		 push	 ecx
  00475	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0047a	83 c4 04	 add	 esp, 4
  0047d	3d f9 00 00 00	 cmp	 eax, 249		; 000000f9H
  00482	75 59		 jne	 SHORT $LN10@stbi_gif_l

; 3910 :                len = get8(s);

  00484	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00487	52		 push	 edx
  00488	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0048d	83 c4 04	 add	 esp, 4
  00490	89 45 e0	 mov	 DWORD PTR _len$1[ebp], eax

; 3911 :                if (len == 4) {

  00493	83 7d e0 04	 cmp	 DWORD PTR _len$1[ebp], 4
  00497	75 32		 jne	 SHORT $LN32@stbi_gif_l

; 3912 :                   g->eflags = get8(s);

  00499	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0049c	50		 push	 eax
  0049d	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  004a2	83 c4 04	 add	 esp, 4
  004a5	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  004a8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 3913 :                   get16le(s); // delay

  004ab	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  004ae	52		 push	 edx
  004af	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  004b4	83 c4 04	 add	 esp, 4

; 3914 :                   g->transparent = get8(s);

  004b7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  004c0	83 c4 04	 add	 esp, 4
  004c3	8b 4d 0c	 mov	 ecx, DWORD PTR _g$[ebp]
  004c6	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 3915 :                } else {

  004c9	eb 12		 jmp	 SHORT $LN10@stbi_gif_l
$LN32@stbi_gif_l:

; 3916 :                   skip(s, len);

  004cb	8b 55 e0	 mov	 edx, DWORD PTR _len$1[ebp]
  004ce	52		 push	 edx
  004cf	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  004d2	50		 push	 eax
  004d3	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  004d8	83 c4 08	 add	 esp, 8

; 3917 :                   break;

  004db	eb 56		 jmp	 SHORT $LN5@stbi_gif_l
$LN10@stbi_gif_l:

; 3918 :                }
; 3919 :             }
; 3920 :             while ((len = get8(s)) != 0)

  004dd	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  004e0	51		 push	 ecx
  004e1	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  004e6	83 c4 04	 add	 esp, 4
  004e9	89 45 e0	 mov	 DWORD PTR _len$1[ebp], eax
  004ec	83 7d e0 00	 cmp	 DWORD PTR _len$1[ebp], 0
  004f0	74 12		 je	 SHORT $LN11@stbi_gif_l

; 3921 :                skip(s, len);

  004f2	8b 55 e0	 mov	 edx, DWORD PTR _len$1[ebp]
  004f5	52		 push	 edx
  004f6	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  004ff	83 c4 08	 add	 esp, 8
  00502	eb d9		 jmp	 SHORT $LN10@stbi_gif_l
$LN11@stbi_gif_l:

; 3922 :             break;

  00504	eb 2d		 jmp	 SHORT $LN5@stbi_gif_l
$LN34@stbi_gif_l:

; 3923 :          }
; 3924 : 
; 3925 :          case 0x3B: // gif stream termination code
; 3926 :             return (uint8 *) 1;

  00506	b8 01 00 00 00	 mov	 eax, 1
  0050b	eb 2b		 jmp	 SHORT $LN1@stbi_gif_l
$LN35@stbi_gif_l:

; 3927 : 
; 3928 :          default:
; 3929 :             return epuc("unknown code", "Corrupt GIF");

  0050d	68 00 00 00 00	 push	 OFFSET $SG4294820112
  00512	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00517	83 c4 04	 add	 esp, 4
  0051a	85 c0		 test	 eax, eax
  0051c	74 09		 je	 SHORT $LN47@stbi_gif_l
  0051e	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv287[ebp], 0
  00525	eb 07		 jmp	 SHORT $LN48@stbi_gif_l
$LN47@stbi_gif_l:
  00527	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv287[ebp], 0
$LN48@stbi_gif_l:
  0052e	8b 45 c4	 mov	 eax, DWORD PTR tv287[ebp]
  00531	eb 05		 jmp	 SHORT $LN1@stbi_gif_l
$LN5@stbi_gif_l:

; 3930 :       }
; 3931 :    }

  00533	e9 24 fc ff ff	 jmp	 $LN4@stbi_gif_l
$LN1@stbi_gif_l:

; 3932 : }

  00538	5f		 pop	 edi
  00539	5e		 pop	 esi
  0053a	83 c4 3c	 add	 esp, 60			; 0000003cH
  0053d	3b ec		 cmp	 ebp, esp
  0053f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00544	8b e5		 mov	 esp, ebp
  00546	5d		 pop	 ebp
  00547	c3		 ret	 0
?stbi_gif_load_next@@YAPAEPAUstbi@@PAUstbi_gif_struct@@PAHH@Z ENDP ; stbi_gif_load_next
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_g$ = -18520						; size = 18508
_u$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_gif_load@@YAPAEPAUstbi@@PAH11H@Z PROC		; stbi_gif_load

; 3935 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 5c 48 00 00	 mov	 eax, 18524		; 0000485cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	57		 push	 edi
  0000e	8d bd a4 b7 ff
	ff		 lea	 edi, DWORD PTR [ebp-18524]
  00014	b9 17 12 00 00	 mov	 ecx, 4631		; 00001217H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3936 :    uint8 *u = 0;

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _u$[ebp], 0

; 3937 :    stbi_gif g={0};

  00031	c7 85 a8 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _g$[ebp], 0
  0003b	68 48 48 00 00	 push	 18504			; 00004848H
  00040	6a 00		 push	 0
  00042	8d 85 ac b7 ff
	ff		 lea	 eax, DWORD PTR _g$[ebp+4]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _memset
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3938 : 
; 3939 :    u = stbi_gif_load_next(s, &g, comp, req_comp);

  00051	8b 4d 18	 mov	 ecx, DWORD PTR _req_comp$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00058	52		 push	 edx
  00059	8d 85 a8 b7 ff
	ff		 lea	 eax, DWORD PTR _g$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?stbi_gif_load_next@@YAPAEPAUstbi@@PAUstbi_gif_struct@@PAHH@Z ; stbi_gif_load_next
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	89 45 f8	 mov	 DWORD PTR _u$[ebp], eax

; 3940 :    if (u == (void *) 1) u = 0;  // end of animated gif marker

  0006f	83 7d f8 01	 cmp	 DWORD PTR _u$[ebp], 1
  00073	75 07		 jne	 SHORT $LN2@stbi_gif_l
  00075	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _u$[ebp], 0
$LN2@stbi_gif_l:

; 3941 :    if (u) {

  0007c	83 7d f8 00	 cmp	 DWORD PTR _u$[ebp], 0
  00080	74 16		 je	 SHORT $LN3@stbi_gif_l

; 3942 :       *x = g.w;

  00082	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00085	8b 85 a8 b7 ff
	ff		 mov	 eax, DWORD PTR _g$[ebp]
  0008b	89 02		 mov	 DWORD PTR [edx], eax

; 3943 :       *y = g.h;

  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00090	8b 95 ac b7 ff
	ff		 mov	 edx, DWORD PTR _g$[ebp+4]
  00096	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@stbi_gif_l:

; 3944 :    }
; 3945 : 
; 3946 :    return u;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _u$[ebp]

; 3947 : }

  0009b	52		 push	 edx
  0009c	8b cd		 mov	 ecx, ebp
  0009e	50		 push	 eax
  0009f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@stbi_gif_l
  000a5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000aa	58		 pop	 eax
  000ab	5a		 pop	 edx
  000ac	5f		 pop	 edi
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	81 c4 5c 48 00
	00		 add	 esp, 18524		; 0000485cH
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN7@stbi_gif_l:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN6@stbi_gif_l
$LN6@stbi_gif_l:
  000d0	a8 b7 ff ff	 DD	 -18520			; ffffb7a8H
  000d4	4c 48 00 00	 DD	 18508			; 0000484cH
  000d8	00 00 00 00	 DD	 $LN5@stbi_gif_l
$LN5@stbi_gif_l:
  000dc	67		 DB	 103			; 00000067H
  000dd	00		 DB	 0
?stbi_gif_load@@YAPAEPAUstbi@@PAH11H@Z ENDP		; stbi_gif_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_gif_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_gif_info

; 3950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3951 :    return stbi_gif_info_raw(s,x,y,comp);

  00003	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?stbi_gif_info_raw@@YAHPAUstbi@@PAH11@Z ; stbi_gif_info_raw
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 3952 : }

  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?stbi_gif_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_gif_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_signature$ = -4					; size = 4
_s$ = 8							; size = 4
?hdr_test@@YAHPAUstbi@@@Z PROC				; hdr_test

; 3960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3961 :    const char *signature = "#?RADIANCE\n";

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _signature$[ebp], OFFSET $SG4294820111

; 3962 :    int i;
; 3963 :    for (i=0; signature[i]; ++i)

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@hdr_test
$LN2@hdr_test:
  00024	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@hdr_test:
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _signature$[ebp]
  00030	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00033	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00036	85 d2		 test	 edx, edx
  00038	74 1f		 je	 SHORT $LN3@hdr_test

; 3964 :       if (get8(s) != signature[i])

  0003a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00043	83 c4 04	 add	 esp, 4
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _signature$[ebp]
  00049	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  0004c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0004f	3b c2		 cmp	 eax, edx
  00051	74 04		 je	 SHORT $LN5@hdr_test

; 3965 :          return 0;

  00053	33 c0		 xor	 eax, eax
  00055	eb 07		 jmp	 SHORT $LN1@hdr_test
$LN5@hdr_test:

; 3966 :    return 1;

  00057	eb cb		 jmp	 SHORT $LN2@hdr_test
$LN3@hdr_test:
  00059	b8 01 00 00 00	 mov	 eax, 1
$LN1@hdr_test:

; 3967 : }

  0005e	83 c4 08	 add	 esp, 8
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?hdr_test@@YAHPAUstbi@@@Z ENDP				; hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_r$ = -4						; size = 4
_s$ = 8							; size = 4
?stbi_hdr_test@@YAHPAUstbi@@@Z PROC			; stbi_hdr_test

; 3970 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3971 :    int r = hdr_test(s);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?hdr_test@@YAHPAUstbi@@@Z ; hdr_test
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 3972 :    stbi_rewind(s);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00023	83 c4 04	 add	 esp, 4

; 3973 :    return r;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 3974 : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?stbi_hdr_test@@YAHPAUstbi@@@Z ENDP			; stbi_hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_c$ = -5						; size = 1
_len$ = -4						; size = 4
_z$ = 8							; size = 4
_buffer$ = 12						; size = 4
?hdr_gettoken@@YAPADPAUstbi@@PAD@Z PROC			; hdr_gettoken

; 3978 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3979 :    int len=0;

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 3980 :    char c = '\0';

  0001b	c6 45 fb 00	 mov	 BYTE PTR _c$[ebp], 0

; 3981 : 
; 3982 :    c = (char) get8(z);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00028	83 c4 04	 add	 esp, 4
  0002b	88 45 fb	 mov	 BYTE PTR _c$[ebp], al
$LN2@hdr_gettok:

; 3983 : 
; 3984 :    while (!at_eof(z) && c != '\n') {

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  00037	83 c4 04	 add	 esp, 4
  0003a	85 c0		 test	 eax, eax
  0003c	75 5c		 jne	 SHORT $LN3@hdr_gettok
  0003e	0f be 55 fb	 movsx	 edx, BYTE PTR _c$[ebp]
  00042	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00045	74 53		 je	 SHORT $LN3@hdr_gettok

; 3985 :       buffer[len++] = c;

  00047	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0004a	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  0004d	8a 4d fb	 mov	 cl, BYTE PTR _c$[ebp]
  00050	88 08		 mov	 BYTE PTR [eax], cl
  00052	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00055	83 c2 01	 add	 edx, 1
  00058	89 55 fc	 mov	 DWORD PTR _len$[ebp], edx

; 3986 :       if (len == HDR_BUFLEN-1) {

  0005b	81 7d fc ff 03
	00 00		 cmp	 DWORD PTR _len$[ebp], 1023 ; 000003ffH
  00062	75 25		 jne	 SHORT $LN6@hdr_gettok
$LN4@hdr_gettok:

; 3987 :          // flush to end of line
; 3988 :          while (!at_eof(z) && get8(z) != '\n')

  00064	8b 45 08	 mov	 eax, DWORD PTR _z$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  0006d	83 c4 04	 add	 esp, 4
  00070	85 c0		 test	 eax, eax
  00072	75 13		 jne	 SHORT $LN5@hdr_gettok
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _z$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  0007d	83 c4 04	 add	 esp, 4
  00080	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00083	74 02		 je	 SHORT $LN5@hdr_gettok

; 3989 :             ;

  00085	eb dd		 jmp	 SHORT $LN4@hdr_gettok
$LN5@hdr_gettok:

; 3990 :          break;

  00087	eb 11		 jmp	 SHORT $LN3@hdr_gettok
$LN6@hdr_gettok:

; 3991 :       }
; 3992 :       c = (char) get8(z);

  00089	8b 55 08	 mov	 edx, DWORD PTR _z$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00092	83 c4 04	 add	 esp, 4
  00095	88 45 fb	 mov	 BYTE PTR _c$[ebp], al

; 3993 :    }

  00098	eb 94		 jmp	 SHORT $LN2@hdr_gettok
$LN3@hdr_gettok:

; 3994 : 
; 3995 :    buffer[len] = 0;

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0009d	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  000a0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3996 :    return buffer;

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]

; 3997 : }

  000a6	83 c4 08	 add	 esp, 8
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ENDP			; hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv152 = -8						; size = 4
_f1$1 = -4						; size = 4
_output$ = 8						; size = 4
_input$ = 12						; size = 4
_req_comp$ = 16						; size = 4
?hdr_convert@@YAXPAMPAEH@Z PROC				; hdr_convert

; 4000 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 4001 :    if ( input[3] != 0 ) {

  00015	b8 01 00 00 00	 mov	 eax, 1
  0001a	6b c8 03	 imul	 ecx, eax, 3
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00020	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00024	85 c0		 test	 eax, eax
  00026	0f 84 4b 01 00
	00		 je	 $LN4@hdr_conver

; 4002 :       float f1;
; 4003 :       // Exponent
; 4004 :       f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));

  0002c	b9 01 00 00 00	 mov	 ecx, 1
  00031	6b d1 03	 imul	 edx, ecx, 3
  00034	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  00037	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0003b	81 e9 88 00 00
	00		 sub	 ecx, 136		; 00000088H
  00041	8b f4		 mov	 esi, esp
  00043	51		 push	 ecx
  00044	83 ec 08	 sub	 esp, 8
  00047	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0004f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ldexp
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	d9 5d fc	 fstp	 DWORD PTR _f1$1[ebp]

; 4005 :       if (req_comp <= 2)

  00067	83 7d 10 02	 cmp	 DWORD PTR _req_comp$[ebp], 2
  0006b	7f 53		 jg	 SHORT $LN6@hdr_conver

; 4006 :          output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

  0006d	ba 01 00 00 00	 mov	 edx, 1
  00072	6b c2 00	 imul	 eax, edx, 0
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  00078	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	c1 e0 00	 shl	 eax, 0
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  0008b	03 d0		 add	 edx, eax
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	d1 e1		 shl	 ecx, 1
  00094	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  00097	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0009b	03 d1		 add	 edx, ecx
  0009d	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000a1	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _f1$1[ebp]
  000a6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  000ae	ba 04 00 00 00	 mov	 edx, 4
  000b3	6b c2 00	 imul	 eax, edx, 0
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  000b9	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 4007 :       else {

  000be	eb 76		 jmp	 SHORT $LN7@hdr_conver
$LN6@hdr_conver:

; 4008 :          output[0] = input[0] * f1;

  000c0	ba 01 00 00 00	 mov	 edx, 1
  000c5	6b c2 00	 imul	 eax, edx, 0
  000c8	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  000cb	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000cf	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000d3	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _f1$1[ebp]
  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	6b c8 00	 imul	 ecx, eax, 0
  000e0	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  000e3	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 4009 :          output[1] = input[1] * f1;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	c1 e0 00	 shl	 eax, 0
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  000f3	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000f7	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000fb	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _f1$1[ebp]
  00100	b8 04 00 00 00	 mov	 eax, 4
  00105	c1 e0 00	 shl	 eax, 0
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  0010b	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 4010 :          output[2] = input[2] * f1;

  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	d1 e2		 shl	 edx, 1
  00117	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  0011a	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0011e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00122	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _f1$1[ebp]
  00127	ba 04 00 00 00	 mov	 edx, 4
  0012c	d1 e2		 shl	 edx, 1
  0012e	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  00131	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
$LN7@hdr_conver:

; 4011 :       }
; 4012 :       if (req_comp == 2) output[1] = 1;

  00136	83 7d 10 02	 cmp	 DWORD PTR _req_comp$[ebp], 2
  0013a	75 18		 jne	 SHORT $LN8@hdr_conver
  0013c	b9 04 00 00 00	 mov	 ecx, 4
  00141	c1 e1 00	 shl	 ecx, 0
  00144	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00147	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0014f	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
$LN8@hdr_conver:

; 4013 :       if (req_comp == 4) output[3] = 1;

  00154	83 7d 10 04	 cmp	 DWORD PTR _req_comp$[ebp], 4
  00158	75 18		 jne	 SHORT $LN9@hdr_conver
  0015a	b8 04 00 00 00	 mov	 eax, 4
  0015f	6b c8 03	 imul	 ecx, eax, 3
  00162	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00165	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016d	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
$LN9@hdr_conver:

; 4014 :    } else {

  00172	e9 b4 00 00 00	 jmp	 $LN2@hdr_conver
$LN4@hdr_conver:

; 4015 :       switch (req_comp) {

  00177	8b 45 10	 mov	 eax, DWORD PTR _req_comp$[ebp]
  0017a	89 45 f8	 mov	 DWORD PTR tv152[ebp], eax
  0017d	8b 4d f8	 mov	 ecx, DWORD PTR tv152[ebp]
  00180	83 e9 01	 sub	 ecx, 1
  00183	89 4d f8	 mov	 DWORD PTR tv152[ebp], ecx
  00186	83 7d f8 03	 cmp	 DWORD PTR tv152[ebp], 3
  0018a	0f 87 9b 00 00
	00		 ja	 $LN2@hdr_conver
  00190	8b 55 f8	 mov	 edx, DWORD PTR tv152[ebp]
  00193	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN15@hdr_conver[edx*4]
$LN10@hdr_conver:

; 4016 :          case 4: output[3] = 1; /* fallthrough */

  0019a	b8 04 00 00 00	 mov	 eax, 4
  0019f	6b c8 03	 imul	 ecx, eax, 3
  001a2	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  001a5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ad	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
$LN11@hdr_conver:

; 4017 :          case 3: output[0] = output[1] = output[2] = 0;

  001b2	b8 04 00 00 00	 mov	 eax, 4
  001b7	d1 e0		 shl	 eax, 1
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  001bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001c4	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  001c9	ba 04 00 00 00	 mov	 edx, 4
  001ce	c1 e2 00	 shl	 edx, 0
  001d1	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  001d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001dc	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  001e1	b9 04 00 00 00	 mov	 ecx, 4
  001e6	6b d1 00	 imul	 edx, ecx, 0
  001e9	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  001ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  001f4	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 4018 :                  break;

  001f9	eb 30		 jmp	 SHORT $LN2@hdr_conver
$LN12@hdr_conver:

; 4019 :          case 2: output[1] = 1; /* fallthrough */

  001fb	b9 04 00 00 00	 mov	 ecx, 4
  00200	c1 e1 00	 shl	 ecx, 0
  00203	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020e	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
$LN13@hdr_conver:

; 4020 :          case 1: output[0] = 0;

  00213	b8 04 00 00 00	 mov	 eax, 4
  00218	6b c8 00	 imul	 ecx, eax, 0
  0021b	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  00226	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
$LN2@hdr_conver:

; 4021 :                  break;
; 4022 :       }
; 4023 :    }
; 4024 : }

  0022b	5e		 pop	 esi
  0022c	83 c4 08	 add	 esp, 8
  0022f	3b ec		 cmp	 ebp, esp
  00231	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c3		 ret	 0
  0023a	66 90		 npad	 2
$LN15@hdr_conver:
  0023c	00 00 00 00	 DD	 $LN13@hdr_conver
  00240	00 00 00 00	 DD	 $LN12@hdr_conver
  00244	00 00 00 00	 DD	 $LN11@hdr_conver
  00248	00 00 00 00	 DD	 $LN10@hdr_conver
?hdr_convert@@YAXPAMPAEH@Z ENDP				; hdr_convert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv221 = -1144						; size = 4
tv151 = -1140						; size = 4
tv134 = -1136						; size = 4
tv90 = -1132						; size = 4
tv74 = -1128						; size = 4
_rgbe$1 = -1120						; size = 4
_rgbe$2 = -1108						; size = 4
_z$ = -1100						; size = 4
_c2$ = -1096						; size = 4
_c1$ = -1092						; size = 4
_k$ = -1088						; size = 4
_j$ = -1084						; size = 4
_i$ = -1080						; size = 4
_value$ = -1074						; size = 1
_count$ = -1073						; size = 1
_len$ = -1072						; size = 4
_hdr_data$ = -1068					; size = 4
_scanline$ = -1064					; size = 4
_height$ = -1060					; size = 4
_width$ = -1056						; size = 4
_valid$ = -1052						; size = 4
_token$ = -1044						; size = 4
_buffer$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?hdr_load@@YAPAMPAUstbi@@PAH11H@Z PROC			; hdr_load

; 4027 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 04 00
	00		 sub	 esp, 1144		; 00000478H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 88 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1144]
  00011	b9 1e 01 00 00	 mov	 ecx, 286		; 0000011eH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4028 :    char buffer[HDR_BUFLEN];
; 4029 :    char *token;
; 4030 :    int valid = 0;

  00027	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _valid$[ebp], 0

; 4031 :    int width, height;
; 4032 :    stbi_uc *scanline;
; 4033 :    float *hdr_data;
; 4034 :    int len;
; 4035 :    unsigned char count, value;
; 4036 :    int i, j, k, c1,c2, z;
; 4037 : 
; 4038 : 
; 4039 :    // Check identifier
; 4040 :    if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0)

  00031	8b f4		 mov	 esi, esp
  00033	68 00 00 00 00	 push	 OFFSET $SG4294820110
  00038	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  00048	83 c4 08	 add	 esp, 8
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcmp
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	85 c0		 test	 eax, eax
  0005e	74 32		 je	 SHORT $LN4@hdr_load

; 4041 :       return epf("not HDR", "Corrupt HDR image");

  00060	68 00 00 00 00	 push	 OFFSET $SG4294820109
  00065	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0006a	83 c4 04	 add	 esp, 4
  0006d	85 c0		 test	 eax, eax
  0006f	74 0c		 je	 SHORT $LN47@hdr_load
  00071	c7 85 98 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
  0007b	eb 0a		 jmp	 SHORT $LN48@hdr_load
$LN47@hdr_load:
  0007d	c7 85 98 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN48@hdr_load:
  00087	8b 85 98 fb ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  0008d	e9 dd 06 00 00	 jmp	 $LN1@hdr_load
$LN4@hdr_load:

; 4042 :    
; 4043 :    // Parse header
; 4044 :    for(;;) {
; 4045 :       token = hdr_gettoken(s,buffer);

  00092	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00098	52		 push	 edx
  00099	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  000a2	83 c4 08	 add	 esp, 8
  000a5	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4046 :       if (token[0] == 0) break;

  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	6b d1 00	 imul	 edx, ecx, 0
  000b3	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  000b9	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  000bd	85 c9		 test	 ecx, ecx
  000bf	75 02		 jne	 SHORT $LN31@hdr_load
  000c1	eb 2e		 jmp	 SHORT $LN3@hdr_load
$LN31@hdr_load:

; 4047 :       if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000c3	8b f4		 mov	 esi, esp
  000c5	68 00 00 00 00	 push	 OFFSET $SG4294820108
  000ca	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  000d0	52		 push	 edx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcmp
  000d7	83 c4 08	 add	 esp, 8
  000da	3b f4		 cmp	 esi, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	85 c0		 test	 eax, eax
  000e3	75 0a		 jne	 SHORT $LN32@hdr_load
  000e5	c7 85 e4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _valid$[ebp], 1
$LN32@hdr_load:

; 4048 :    }

  000ef	eb a1		 jmp	 SHORT $LN4@hdr_load
$LN3@hdr_load:

; 4049 : 
; 4050 :    if (!valid)    return epf("unsupported format", "Unsupported HDR format");

  000f1	83 bd e4 fb ff
	ff 00		 cmp	 DWORD PTR _valid$[ebp], 0
  000f8	75 32		 jne	 SHORT $LN33@hdr_load
  000fa	68 00 00 00 00	 push	 OFFSET $SG4294820107
  000ff	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00104	83 c4 04	 add	 esp, 4
  00107	85 c0		 test	 eax, eax
  00109	74 0c		 je	 SHORT $LN49@hdr_load
  0010b	c7 85 94 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
  00115	eb 0a		 jmp	 SHORT $LN50@hdr_load
$LN49@hdr_load:
  00117	c7 85 94 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$LN50@hdr_load:
  00121	8b 85 94 fb ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
  00127	e9 43 06 00 00	 jmp	 $LN1@hdr_load
$LN33@hdr_load:

; 4051 : 
; 4052 :    // Parse width and height
; 4053 :    // can't use sscanf() if we're not using stdio!
; 4054 :    token = hdr_gettoken(s,buffer);

  0012c	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00132	50		 push	 eax
  00133	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  0013c	83 c4 08	 add	 esp, 8
  0013f	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4055 :    if (strncmp(token, "-Y ", 3))  return epf("unsupported data layout", "Unsupported HDR format");

  00145	8b f4		 mov	 esi, esp
  00147	6a 03		 push	 3
  00149	68 00 00 00 00	 push	 OFFSET $SG4294820106
  0014e	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  00154	52		 push	 edx
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	3b f4		 cmp	 esi, esp
  00160	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00165	85 c0		 test	 eax, eax
  00167	74 32		 je	 SHORT $LN34@hdr_load
  00169	68 00 00 00 00	 push	 OFFSET $SG4294820105
  0016e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00173	83 c4 04	 add	 esp, 4
  00176	85 c0		 test	 eax, eax
  00178	74 0c		 je	 SHORT $LN51@hdr_load
  0017a	c7 85 90 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
  00184	eb 0a		 jmp	 SHORT $LN52@hdr_load
$LN51@hdr_load:
  00186	c7 85 90 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
$LN52@hdr_load:
  00190	8b 85 90 fb ff
	ff		 mov	 eax, DWORD PTR tv134[ebp]
  00196	e9 d4 05 00 00	 jmp	 $LN1@hdr_load
$LN34@hdr_load:

; 4056 :    token += 3;

  0019b	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  001a1	83 c0 03	 add	 eax, 3
  001a4	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4057 :    height = strtol(token, &token, 10);

  001aa	8b f4		 mov	 esi, esp
  001ac	6a 0a		 push	 10			; 0000000aH
  001ae	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  001b4	51		 push	 ecx
  001b5	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  001bb	52		 push	 edx
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	3b f4		 cmp	 esi, esp
  001c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cc	89 85 dc fb ff
	ff		 mov	 DWORD PTR _height$[ebp], eax
$LN5@hdr_load:

; 4058 :    while (*token == ' ') ++token;

  001d2	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  001d8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001db	83 f9 20	 cmp	 ecx, 32			; 00000020H
  001de	75 11		 jne	 SHORT $LN6@hdr_load
  001e0	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  001e6	83 c2 01	 add	 edx, 1
  001e9	89 95 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], edx
  001ef	eb e1		 jmp	 SHORT $LN5@hdr_load
$LN6@hdr_load:

; 4059 :    if (strncmp(token, "+X ", 3))  return epf("unsupported data layout", "Unsupported HDR format");

  001f1	8b f4		 mov	 esi, esp
  001f3	6a 03		 push	 3
  001f5	68 00 00 00 00	 push	 OFFSET $SG4294820104
  001fa	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  00200	50		 push	 eax
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020a	3b f4		 cmp	 esi, esp
  0020c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00211	85 c0		 test	 eax, eax
  00213	74 32		 je	 SHORT $LN35@hdr_load
  00215	68 00 00 00 00	 push	 OFFSET $SG4294820103
  0021a	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  0021f	83 c4 04	 add	 esp, 4
  00222	85 c0		 test	 eax, eax
  00224	74 0c		 je	 SHORT $LN53@hdr_load
  00226	c7 85 8c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
  00230	eb 0a		 jmp	 SHORT $LN54@hdr_load
$LN53@hdr_load:
  00232	c7 85 8c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
$LN54@hdr_load:
  0023c	8b 85 8c fb ff
	ff		 mov	 eax, DWORD PTR tv151[ebp]
  00242	e9 28 05 00 00	 jmp	 $LN1@hdr_load
$LN35@hdr_load:

; 4060 :    token += 3;

  00247	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _token$[ebp]
  0024d	83 c1 03	 add	 ecx, 3
  00250	89 8d ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], ecx

; 4061 :    width = strtol(token, NULL, 10);

  00256	8b f4		 mov	 esi, esp
  00258	6a 0a		 push	 10			; 0000000aH
  0025a	6a 00		 push	 0
  0025c	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  00262	52		 push	 edx
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	3b f4		 cmp	 esi, esp
  0026e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00273	89 85 e0 fb ff
	ff		 mov	 DWORD PTR _width$[ebp], eax

; 4062 : 
; 4063 :    *x = width;

  00279	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0027c	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _width$[ebp]
  00282	89 08		 mov	 DWORD PTR [eax], ecx

; 4064 :    *y = height;

  00284	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00287	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _height$[ebp]
  0028d	89 02		 mov	 DWORD PTR [edx], eax

; 4065 : 
; 4066 :    *comp = 3;

  0028f	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00292	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 4067 :    if (req_comp == 0) req_comp = 3;

  00298	83 7d 18 00	 cmp	 DWORD PTR _req_comp$[ebp], 0
  0029c	75 07		 jne	 SHORT $LN36@hdr_load
  0029e	c7 45 18 03 00
	00 00		 mov	 DWORD PTR _req_comp$[ebp], 3
$LN36@hdr_load:

; 4068 : 
; 4069 :    // Read data
; 4070 :    hdr_data = (float *) malloc(height * width * req_comp * sizeof(float));

  002a5	8b 95 dc fb ff
	ff		 mov	 edx, DWORD PTR _height$[ebp]
  002ab	0f af 95 e0 fb
	ff ff		 imul	 edx, DWORD PTR _width$[ebp]
  002b2	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  002b6	c1 e2 02	 shl	 edx, 2
  002b9	8b f4		 mov	 esi, esp
  002bb	52		 push	 edx
  002bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  002c2	83 c4 04	 add	 esp, 4
  002c5	3b f4		 cmp	 esi, esp
  002c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002cc	89 85 d4 fb ff
	ff		 mov	 DWORD PTR _hdr_data$[ebp], eax

; 4071 : 
; 4072 :    // Load image data
; 4073 :    // image data is stored as some number of sca
; 4074 :    if ( width < 8 || width >= 32768) {

  002d2	83 bd e0 fb ff
	ff 08		 cmp	 DWORD PTR _width$[ebp], 8
  002d9	7c 10		 jl	 SHORT $LN39@hdr_load
  002db	81 bd e0 fb ff
	ff 00 80 00 00	 cmp	 DWORD PTR _width$[ebp], 32768 ; 00008000H
  002e5	0f 8c b2 00 00
	00		 jl	 $LN37@hdr_load
$LN39@hdr_load:

; 4075 :       // Read flat data
; 4076 :       for (j=0; j < height; ++j) {

  002eb	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  002f5	eb 0f		 jmp	 SHORT $LN9@hdr_load
$LN7@hdr_load:
  002f7	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  002fd	83 c0 01	 add	 eax, 1
  00300	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN9@hdr_load:
  00306	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  0030c	3b 8d dc fb ff
	ff		 cmp	 ecx, DWORD PTR _height$[ebp]
  00312	0f 8d 80 00 00
	00		 jge	 $LN8@hdr_load

; 4077 :          for (i=0; i < width; ++i) {

  00318	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00322	eb 0f		 jmp	 SHORT $LN12@hdr_load
$LN10@hdr_load:
  00324	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0032a	83 c2 01	 add	 edx, 1
  0032d	89 95 c8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$LN12@hdr_load:
  00333	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00339	3b 85 e0 fb ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  0033f	7d 52		 jge	 SHORT $LN11@hdr_load
$main_decode_loop$63:

; 4078 :             stbi_uc rgbe[4];
; 4079 :            main_decode_loop:
; 4080 :             getn(s, rgbe, 4);

  00341	6a 04		 push	 4
  00343	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _rgbe$2[ebp]
  00349	51		 push	 ecx
  0034a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0034d	52		 push	 edx
  0034e	e8 00 00 00 00	 call	 ?getn@@YAHPAUstbi@@PAEH@Z ; getn
  00353	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4081 :             hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

  00356	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00359	50		 push	 eax
  0035a	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _rgbe$2[ebp]
  00360	51		 push	 ecx
  00361	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00367	0f af 95 e0 fb
	ff ff		 imul	 edx, DWORD PTR _width$[ebp]
  0036e	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  00372	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _hdr_data$[ebp]
  00378	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0037b	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00381	0f af 55 18	 imul	 edx, DWORD PTR _req_comp$[ebp]
  00385	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 ?hdr_convert@@YAXPAMPAEH@Z ; hdr_convert
  0038e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4082 :          }

  00391	eb 91		 jmp	 SHORT $LN10@hdr_load
$LN11@hdr_load:

; 4083 :       }

  00393	e9 5f ff ff ff	 jmp	 $LN7@hdr_load
$LN8@hdr_load:

; 4084 :    } else {

  00398	e9 cc 03 00 00	 jmp	 $LN38@hdr_load
$LN37@hdr_load:

; 4085 :       // Read RLE-encoded data
; 4086 :       scanline = NULL;

  0039d	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _scanline$[ebp], 0

; 4087 : 
; 4088 :       for (j = 0; j < height; ++j) {

  003a7	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  003b1	eb 0f		 jmp	 SHORT $LN15@hdr_load
$LN13@hdr_load:
  003b3	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  003b9	83 c1 01	 add	 ecx, 1
  003bc	89 8d c4 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], ecx
$LN15@hdr_load:
  003c2	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  003c8	3b 95 dc fb ff
	ff		 cmp	 edx, DWORD PTR _height$[ebp]
  003ce	0f 8d 7c 03 00
	00		 jge	 $LN14@hdr_load

; 4089 :          c1 = get8(s);

  003d4	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003d7	50		 push	 eax
  003d8	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  003dd	83 c4 04	 add	 esp, 4
  003e0	89 85 bc fb ff
	ff		 mov	 DWORD PTR _c1$[ebp], eax

; 4090 :          c2 = get8(s);

  003e6	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  003ef	83 c4 04	 add	 esp, 4
  003f2	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _c2$[ebp], eax

; 4091 :          len = get8(s);

  003f8	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  003fb	52		 push	 edx
  003fc	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00401	83 c4 04	 add	 esp, 4
  00404	89 85 d0 fb ff
	ff		 mov	 DWORD PTR _len$[ebp], eax

; 4092 :          if (c1 != 2 || c2 != 2 || (len & 0x80)) {

  0040a	83 bd bc fb ff
	ff 02		 cmp	 DWORD PTR _c1$[ebp], 2
  00411	75 1a		 jne	 SHORT $LN41@hdr_load
  00413	83 bd b8 fb ff
	ff 02		 cmp	 DWORD PTR _c2$[ebp], 2
  0041a	75 11		 jne	 SHORT $LN41@hdr_load
  0041c	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00422	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00427	0f 84 a5 00 00
	00		 je	 $LN40@hdr_load
$LN41@hdr_load:

; 4093 :             // not run-length encoded, so we have to actually use THIS data as a decoded
; 4094 :             // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 4095 :             uint8 rgbe[4];
; 4096 :             rgbe[0] = (uint8) c1;

  0042d	b9 01 00 00 00	 mov	 ecx, 1
  00432	6b d1 00	 imul	 edx, ecx, 0
  00435	8a 85 bc fb ff
	ff		 mov	 al, BYTE PTR _c1$[ebp]
  0043b	88 84 15 a0 fb
	ff ff		 mov	 BYTE PTR _rgbe$1[ebp+edx], al

; 4097 :             rgbe[1] = (uint8) c2;

  00442	b9 01 00 00 00	 mov	 ecx, 1
  00447	c1 e1 00	 shl	 ecx, 0
  0044a	8a 95 b8 fb ff
	ff		 mov	 dl, BYTE PTR _c2$[ebp]
  00450	88 94 0d a0 fb
	ff ff		 mov	 BYTE PTR _rgbe$1[ebp+ecx], dl

; 4098 :             rgbe[2] = (uint8) len;

  00457	b8 01 00 00 00	 mov	 eax, 1
  0045c	d1 e0		 shl	 eax, 1
  0045e	8a 8d d0 fb ff
	ff		 mov	 cl, BYTE PTR _len$[ebp]
  00464	88 8c 05 a0 fb
	ff ff		 mov	 BYTE PTR _rgbe$1[ebp+eax], cl

; 4099 :             rgbe[3] = (uint8) get8u(s);

  0046b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0046e	52		 push	 edx
  0046f	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00474	83 c4 04	 add	 esp, 4
  00477	b9 01 00 00 00	 mov	 ecx, 1
  0047c	6b d1 03	 imul	 edx, ecx, 3
  0047f	88 84 15 a0 fb
	ff ff		 mov	 BYTE PTR _rgbe$1[ebp+edx], al

; 4100 :             hdr_convert(hdr_data, rgbe, req_comp);

  00486	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00489	50		 push	 eax
  0048a	8d 8d a0 fb ff
	ff		 lea	 ecx, DWORD PTR _rgbe$1[ebp]
  00490	51		 push	 ecx
  00491	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _hdr_data$[ebp]
  00497	52		 push	 edx
  00498	e8 00 00 00 00	 call	 ?hdr_convert@@YAXPAMPAEH@Z ; hdr_convert
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4101 :             i = 1;

  004a0	c7 85 c8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _i$[ebp], 1

; 4102 :             j = 0;

  004aa	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0

; 4103 :             free(scanline);

  004b4	8b f4		 mov	 esi, esp
  004b6	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _scanline$[ebp]
  004bc	50		 push	 eax
  004bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  004c3	83 c4 04	 add	 esp, 4
  004c6	3b f4		 cmp	 esi, esp
  004c8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4104 :             goto main_decode_loop; // yes, this makes no sense

  004cd	e9 6f fe ff ff	 jmp	 $main_decode_loop$63
$LN40@hdr_load:

; 4105 :          }
; 4106 :          len <<= 8;

  004d2	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _len$[ebp]
  004d8	c1 e1 08	 shl	 ecx, 8
  004db	89 8d d0 fb ff
	ff		 mov	 DWORD PTR _len$[ebp], ecx

; 4107 :          len |= get8(s);

  004e1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  004e4	52		 push	 edx
  004e5	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  004ea	83 c4 04	 add	 esp, 4
  004ed	0b 85 d0 fb ff
	ff		 or	 eax, DWORD PTR _len$[ebp]
  004f3	89 85 d0 fb ff
	ff		 mov	 DWORD PTR _len$[ebp], eax

; 4108 :          if (len != width) { free(hdr_data); free(scanline); return epf("invalid decoded scanline length", "corrupt HDR"); }

  004f9	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  004ff	3b 85 e0 fb ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  00505	74 64		 je	 SHORT $LN42@hdr_load
  00507	8b f4		 mov	 esi, esp
  00509	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _hdr_data$[ebp]
  0050f	51		 push	 ecx
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00516	83 c4 04	 add	 esp, 4
  00519	3b f4		 cmp	 esi, esp
  0051b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00520	8b f4		 mov	 esi, esp
  00522	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _scanline$[ebp]
  00528	52		 push	 edx
  00529	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0052f	83 c4 04	 add	 esp, 4
  00532	3b f4		 cmp	 esi, esp
  00534	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00539	68 00 00 00 00	 push	 OFFSET $SG4294820102
  0053e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00543	83 c4 04	 add	 esp, 4
  00546	85 c0		 test	 eax, eax
  00548	74 0c		 je	 SHORT $LN55@hdr_load
  0054a	c7 85 88 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv221[ebp], 0
  00554	eb 0a		 jmp	 SHORT $LN56@hdr_load
$LN55@hdr_load:
  00556	c7 85 88 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv221[ebp], 0
$LN56@hdr_load:
  00560	8b 85 88 fb ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  00566	e9 04 02 00 00	 jmp	 $LN1@hdr_load
$LN42@hdr_load:

; 4109 :          if (scanline == NULL) scanline = (stbi_uc *) malloc(width * 4);

  0056b	83 bd d8 fb ff
	ff 00		 cmp	 DWORD PTR _scanline$[ebp], 0
  00572	75 22		 jne	 SHORT $LN43@hdr_load
  00574	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  0057a	c1 e0 02	 shl	 eax, 2
  0057d	8b f4		 mov	 esi, esp
  0057f	50		 push	 eax
  00580	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00586	83 c4 04	 add	 esp, 4
  00589	3b f4		 cmp	 esi, esp
  0058b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00590	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _scanline$[ebp], eax
$LN43@hdr_load:

; 4110 :             
; 4111 :          for (k = 0; k < 4; ++k) {

  00596	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$[ebp], 0
  005a0	eb 0f		 jmp	 SHORT $LN18@hdr_load
$LN16@hdr_load:
  005a2	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  005a8	83 c1 01	 add	 ecx, 1
  005ab	89 8d c0 fb ff
	ff		 mov	 DWORD PTR _k$[ebp], ecx
$LN18@hdr_load:
  005b1	83 bd c0 fb ff
	ff 04		 cmp	 DWORD PTR _k$[ebp], 4
  005b8	0f 8d 25 01 00
	00		 jge	 $LN17@hdr_load

; 4112 :             i = 0;

  005be	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
$LN19@hdr_load:

; 4113 :             while (i < width) {

  005c8	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  005ce	3b 95 e0 fb ff
	ff		 cmp	 edx, DWORD PTR _width$[ebp]
  005d4	0f 8d 04 01 00
	00		 jge	 $LN20@hdr_load

; 4114 :                count = get8u(s);

  005da	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  005dd	50		 push	 eax
  005de	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  005e3	83 c4 04	 add	 esp, 4
  005e6	88 85 cf fb ff
	ff		 mov	 BYTE PTR _count$[ebp], al

; 4115 :                if (count > 128) {

  005ec	0f b6 8d cf fb
	ff ff		 movzx	 ecx, BYTE PTR _count$[ebp]
  005f3	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  005f9	7e 7f		 jle	 SHORT $LN44@hdr_load

; 4116 :                   // Run
; 4117 :                   value = get8u(s);

  005fb	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  005fe	52		 push	 edx
  005ff	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  00604	83 c4 04	 add	 esp, 4
  00607	88 85 ce fb ff
	ff		 mov	 BYTE PTR _value$[ebp], al

; 4118 :                   count -= 128;

  0060d	0f b6 85 cf fb
	ff ff		 movzx	 eax, BYTE PTR _count$[ebp]
  00614	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00619	88 85 cf fb ff
	ff		 mov	 BYTE PTR _count$[ebp], al

; 4119 :                   for (z = 0; z < count; ++z)

  0061f	c7 85 b4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$[ebp], 0
  00629	eb 0f		 jmp	 SHORT $LN23@hdr_load
$LN21@hdr_load:
  0062b	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _z$[ebp]
  00631	83 c1 01	 add	 ecx, 1
  00634	89 8d b4 fb ff
	ff		 mov	 DWORD PTR _z$[ebp], ecx
$LN23@hdr_load:
  0063a	0f b6 95 cf fb
	ff ff		 movzx	 edx, BYTE PTR _count$[ebp]
  00641	39 95 b4 fb ff
	ff		 cmp	 DWORD PTR _z$[ebp], edx
  00647	7d 2f		 jge	 SHORT $LN22@hdr_load

; 4120 :                      scanline[i++ * 4 + k] = value;

  00649	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0064f	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _k$[ebp]
  00655	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00658	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _scanline$[ebp]
  0065e	8a 8d ce fb ff
	ff		 mov	 cl, BYTE PTR _value$[ebp]
  00664	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00667	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0066d	83 c2 01	 add	 edx, 1
  00670	89 95 c8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
  00676	eb b3		 jmp	 SHORT $LN21@hdr_load
$LN22@hdr_load:

; 4121 :                } else {

  00678	eb 5f		 jmp	 SHORT $LN45@hdr_load
$LN44@hdr_load:

; 4122 :                   // Dump
; 4123 :                   for (z = 0; z < count; ++z)

  0067a	c7 85 b4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$[ebp], 0
  00684	eb 0f		 jmp	 SHORT $LN26@hdr_load
$LN24@hdr_load:
  00686	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  0068c	83 c0 01	 add	 eax, 1
  0068f	89 85 b4 fb ff
	ff		 mov	 DWORD PTR _z$[ebp], eax
$LN26@hdr_load:
  00695	0f b6 8d cf fb
	ff ff		 movzx	 ecx, BYTE PTR _count$[ebp]
  0069c	39 8d b4 fb ff
	ff		 cmp	 DWORD PTR _z$[ebp], ecx
  006a2	7d 35		 jge	 SHORT $LN45@hdr_load

; 4124 :                      scanline[i++ * 4 + k] = get8u(s);

  006a4	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  006a7	52		 push	 edx
  006a8	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  006ad	83 c4 04	 add	 esp, 4
  006b0	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006b6	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _k$[ebp]
  006bc	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  006bf	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _scanline$[ebp]
  006c5	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  006c8	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  006ce	83 c0 01	 add	 eax, 1
  006d1	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  006d7	eb ad		 jmp	 SHORT $LN24@hdr_load
$LN45@hdr_load:

; 4125 :                }
; 4126 :             }

  006d9	e9 ea fe ff ff	 jmp	 $LN19@hdr_load
$LN20@hdr_load:

; 4127 :          }

  006de	e9 bf fe ff ff	 jmp	 $LN16@hdr_load
$LN17@hdr_load:

; 4128 :          for (i=0; i < width; ++i)

  006e3	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  006ed	eb 0f		 jmp	 SHORT $LN29@hdr_load
$LN27@hdr_load:
  006ef	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006f5	83 c1 01	 add	 ecx, 1
  006f8	89 8d c8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
$LN29@hdr_load:
  006fe	8b 95 c8 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00704	3b 95 e0 fb ff
	ff		 cmp	 edx, DWORD PTR _width$[ebp]
  0070a	7d 3f		 jge	 SHORT $LN28@hdr_load

; 4129 :             hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);

  0070c	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  0070f	50		 push	 eax
  00710	8b 8d c8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00716	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR _scanline$[ebp]
  0071c	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0071f	50		 push	 eax
  00720	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00726	0f af 8d e0 fb
	ff ff		 imul	 ecx, DWORD PTR _width$[ebp]
  0072d	03 8d c8 fb ff
	ff		 add	 ecx, DWORD PTR _i$[ebp]
  00733	0f af 4d 18	 imul	 ecx, DWORD PTR _req_comp$[ebp]
  00737	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _hdr_data$[ebp]
  0073d	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00740	50		 push	 eax
  00741	e8 00 00 00 00	 call	 ?hdr_convert@@YAXPAMPAEH@Z ; hdr_convert
  00746	83 c4 0c	 add	 esp, 12			; 0000000cH
  00749	eb a4		 jmp	 SHORT $LN27@hdr_load
$LN28@hdr_load:

; 4130 :       }

  0074b	e9 63 fc ff ff	 jmp	 $LN13@hdr_load
$LN14@hdr_load:

; 4131 :       free(scanline);

  00750	8b f4		 mov	 esi, esp
  00752	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR _scanline$[ebp]
  00758	51		 push	 ecx
  00759	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0075f	83 c4 04	 add	 esp, 4
  00762	3b f4		 cmp	 esi, esp
  00764	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN38@hdr_load:

; 4132 :    }
; 4133 : 
; 4134 :    return hdr_data;

  00769	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _hdr_data$[ebp]
$LN1@hdr_load:

; 4135 : }

  0076f	52		 push	 edx
  00770	8b cd		 mov	 ecx, ebp
  00772	50		 push	 eax
  00773	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN62@hdr_load
  00779	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0077e	58		 pop	 eax
  0077f	5a		 pop	 edx
  00780	5f		 pop	 edi
  00781	5e		 pop	 esi
  00782	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00785	33 cd		 xor	 ecx, ebp
  00787	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0078c	81 c4 78 04 00
	00		 add	 esp, 1144		; 00000478H
  00792	3b ec		 cmp	 ebp, esp
  00794	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00799	8b e5		 mov	 esp, ebp
  0079b	5d		 pop	 ebp
  0079c	c3		 ret	 0
  0079d	0f 1f 00	 npad	 3
$LN62@hdr_load:
  007a0	04 00 00 00	 DD	 4
  007a4	00 00 00 00	 DD	 $LN61@hdr_load
$LN61@hdr_load:
  007a8	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  007ac	00 04 00 00	 DD	 1024			; 00000400H
  007b0	00 00 00 00	 DD	 $LN57@hdr_load
  007b4	ec fb ff ff	 DD	 -1044			; fffffbecH
  007b8	04 00 00 00	 DD	 4
  007bc	00 00 00 00	 DD	 $LN58@hdr_load
  007c0	ac fb ff ff	 DD	 -1108			; fffffbacH
  007c4	04 00 00 00	 DD	 4
  007c8	00 00 00 00	 DD	 $LN59@hdr_load
  007cc	a0 fb ff ff	 DD	 -1120			; fffffba0H
  007d0	04 00 00 00	 DD	 4
  007d4	00 00 00 00	 DD	 $LN60@hdr_load
$LN60@hdr_load:
  007d8	72		 DB	 114			; 00000072H
  007d9	67		 DB	 103			; 00000067H
  007da	62		 DB	 98			; 00000062H
  007db	65		 DB	 101			; 00000065H
  007dc	00		 DB	 0
$LN59@hdr_load:
  007dd	72		 DB	 114			; 00000072H
  007de	67		 DB	 103			; 00000067H
  007df	62		 DB	 98			; 00000062H
  007e0	65		 DB	 101			; 00000065H
  007e1	00		 DB	 0
$LN58@hdr_load:
  007e2	74		 DB	 116			; 00000074H
  007e3	6f		 DB	 111			; 0000006fH
  007e4	6b		 DB	 107			; 0000006bH
  007e5	65		 DB	 101			; 00000065H
  007e6	6e		 DB	 110			; 0000006eH
  007e7	00		 DB	 0
$LN57@hdr_load:
  007e8	62		 DB	 98			; 00000062H
  007e9	75		 DB	 117			; 00000075H
  007ea	66		 DB	 102			; 00000066H
  007eb	66		 DB	 102			; 00000066H
  007ec	65		 DB	 101			; 00000065H
  007ed	72		 DB	 114			; 00000072H
  007ee	00		 DB	 0
?hdr_load@@YAPAMPAUstbi@@PAH11H@Z ENDP			; hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_req_comp$ = 24						; size = 4
?stbi_hdr_load@@YAPAMPAUstbi@@PAH11H@Z PROC		; stbi_hdr_load

; 4138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4139 :    return hdr_load(s,x,y,comp,req_comp);

  00003	8b 45 18	 mov	 eax, DWORD PTR _req_comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?hdr_load@@YAPAMPAUstbi@@PAH11H@Z ; hdr_load
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 4140 : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?stbi_hdr_load@@YAPAMPAUstbi@@PAH11H@Z ENDP		; stbi_hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_valid$ = -1052						; size = 4
_token$ = -1044						; size = 4
_buffer$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_hdr_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_hdr_info

; 4143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd e4 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1052]
  00011	b9 07 01 00 00	 mov	 ecx, 263		; 00000107H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4144 :    char buffer[HDR_BUFLEN];
; 4145 :    char *token;
; 4146 :    int valid = 0;

  00027	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _valid$[ebp], 0

; 4147 : 
; 4148 :    if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0) {

  00031	8b f4		 mov	 esi, esp
  00033	68 00 00 00 00	 push	 OFFSET $SG4294820101
  00038	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  00048	83 c4 08	 add	 esp, 8
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcmp
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	85 c0		 test	 eax, eax
  0005e	74 13		 je	 SHORT $LN4@stbi_hdr_i

; 4149 :        stbi_rewind( s );

  00060	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00069	83 c4 04	 add	 esp, 4

; 4150 :        return 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 93 01 00 00	 jmp	 $LN1@stbi_hdr_i
$LN4@stbi_hdr_i:

; 4151 :    }
; 4152 : 
; 4153 :    for(;;) {
; 4154 :       token = hdr_gettoken(s,buffer);

  00073	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  00083	83 c4 08	 add	 esp, 8
  00086	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4155 :       if (token[0] == 0) break;

  0008c	ba 01 00 00 00	 mov	 edx, 1
  00091	6b c2 00	 imul	 eax, edx, 0
  00094	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _token$[ebp]
  0009a	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0009e	85 d2		 test	 edx, edx
  000a0	75 02		 jne	 SHORT $LN8@stbi_hdr_i
  000a2	eb 2e		 jmp	 SHORT $LN3@stbi_hdr_i
$LN8@stbi_hdr_i:

; 4156 :       if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000a4	8b f4		 mov	 esi, esp
  000a6	68 00 00 00 00	 push	 OFFSET $SG4294820100
  000ab	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  000b1	50		 push	 eax
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcmp
  000b8	83 c4 08	 add	 esp, 8
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	85 c0		 test	 eax, eax
  000c4	75 0a		 jne	 SHORT $LN9@stbi_hdr_i
  000c6	c7 85 e4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _valid$[ebp], 1
$LN9@stbi_hdr_i:

; 4157 :    }

  000d0	eb a1		 jmp	 SHORT $LN4@stbi_hdr_i
$LN3@stbi_hdr_i:

; 4158 : 
; 4159 :    if (!valid) {

  000d2	83 bd e4 fb ff
	ff 00		 cmp	 DWORD PTR _valid$[ebp], 0
  000d9	75 13		 jne	 SHORT $LN10@stbi_hdr_i

; 4160 :        stbi_rewind( s );

  000db	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000e4	83 c4 04	 add	 esp, 4

; 4161 :        return 0;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 18 01 00 00	 jmp	 $LN1@stbi_hdr_i
$LN10@stbi_hdr_i:

; 4162 :    }
; 4163 :    token = hdr_gettoken(s,buffer);

  000ee	8d 95 f8 fb ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?hdr_gettoken@@YAPADPAUstbi@@PAD@Z ; hdr_gettoken
  000fe	83 c4 08	 add	 esp, 8
  00101	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4164 :    if (strncmp(token, "-Y ", 3)) {

  00107	8b f4		 mov	 esi, esp
  00109	6a 03		 push	 3
  0010b	68 00 00 00 00	 push	 OFFSET $SG4294820099
  00110	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _token$[ebp]
  00116	51		 push	 ecx
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	85 c0		 test	 eax, eax
  00129	74 13		 je	 SHORT $LN11@stbi_hdr_i

; 4165 :        stbi_rewind( s );

  0012b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00134	83 c4 04	 add	 esp, 4

; 4166 :        return 0;

  00137	33 c0		 xor	 eax, eax
  00139	e9 c8 00 00 00	 jmp	 $LN1@stbi_hdr_i
$LN11@stbi_hdr_i:

; 4167 :    }
; 4168 :    token += 3;

  0013e	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _token$[ebp]
  00144	83 c0 03	 add	 eax, 3
  00147	89 85 ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], eax

; 4169 :    *y = strtol(token, &token, 10);

  0014d	8b f4		 mov	 esi, esp
  0014f	6a 0a		 push	 10			; 0000000aH
  00151	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _token$[ebp]
  00157	51		 push	 ecx
  00158	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  0015e	52		 push	 edx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00172	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@stbi_hdr_i:

; 4170 :    while (*token == ' ') ++token;

  00174	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  0017a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0017d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00180	75 11		 jne	 SHORT $LN6@stbi_hdr_i
  00182	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _token$[ebp]
  00188	83 c1 01	 add	 ecx, 1
  0018b	89 8d ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], ecx
  00191	eb e1		 jmp	 SHORT $LN5@stbi_hdr_i
$LN6@stbi_hdr_i:

; 4171 :    if (strncmp(token, "+X ", 3)) {

  00193	8b f4		 mov	 esi, esp
  00195	6a 03		 push	 3
  00197	68 00 00 00 00	 push	 OFFSET $SG4294820098
  0019c	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  001a2	52		 push	 edx
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	3b f4		 cmp	 esi, esp
  001ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b3	85 c0		 test	 eax, eax
  001b5	74 10		 je	 SHORT $LN12@stbi_hdr_i

; 4172 :        stbi_rewind( s );

  001b7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  001c0	83 c4 04	 add	 esp, 4

; 4173 :        return 0;

  001c3	33 c0		 xor	 eax, eax
  001c5	eb 3f		 jmp	 SHORT $LN1@stbi_hdr_i
$LN12@stbi_hdr_i:

; 4174 :    }
; 4175 :    token += 3;

  001c7	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _token$[ebp]
  001cd	83 c1 03	 add	 ecx, 3
  001d0	89 8d ec fb ff
	ff		 mov	 DWORD PTR _token$[ebp], ecx

; 4176 :    *x = strtol(token, NULL, 10);

  001d6	8b f4		 mov	 esi, esp
  001d8	6a 0a		 push	 10			; 0000000aH
  001da	6a 00		 push	 0
  001dc	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _token$[ebp]
  001e2	52		 push	 edx
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ec	3b f4		 cmp	 esi, esp
  001ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f3	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  001f6	89 01		 mov	 DWORD PTR [ecx], eax

; 4177 :    *comp = 3;

  001f8	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  001fb	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3

; 4178 :    return 1;

  00201	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_hdr_i:

; 4179 : }

  00206	52		 push	 edx
  00207	8b cd		 mov	 ecx, ebp
  00209	50		 push	 eax
  0020a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@stbi_hdr_i
  00210	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00215	58		 pop	 eax
  00216	5a		 pop	 edx
  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021c	33 cd		 xor	 ecx, ebp
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  00229	3b ec		 cmp	 ebp, esp
  0022b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c3		 ret	 0
$LN17@stbi_hdr_i:
  00234	02 00 00 00	 DD	 2
  00238	00 00 00 00	 DD	 $LN16@stbi_hdr_i
$LN16@stbi_hdr_i:
  0023c	f8 fb ff ff	 DD	 -1032			; fffffbf8H
  00240	00 04 00 00	 DD	 1024			; 00000400H
  00244	00 00 00 00	 DD	 $LN14@stbi_hdr_i
  00248	ec fb ff ff	 DD	 -1044			; fffffbecH
  0024c	04 00 00 00	 DD	 4
  00250	00 00 00 00	 DD	 $LN15@stbi_hdr_i
$LN15@stbi_hdr_i:
  00254	74		 DB	 116			; 00000074H
  00255	6f		 DB	 111			; 0000006fH
  00256	6b		 DB	 107			; 0000006bH
  00257	65		 DB	 101			; 00000065H
  00258	6e		 DB	 110			; 0000006eH
  00259	00		 DB	 0
$LN14@stbi_hdr_i:
  0025a	62		 DB	 98			; 00000062H
  0025b	75		 DB	 117			; 00000075H
  0025c	66		 DB	 102			; 00000066H
  0025d	66		 DB	 102			; 00000066H
  0025e	65		 DB	 101			; 00000065H
  0025f	72		 DB	 114			; 00000072H
  00260	00		 DB	 0
?stbi_hdr_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_hdr_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_hsz$ = -4						; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_bmp_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_bmp_info

; 4183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 4184 :    int hsz;
; 4185 :    if (get8(s) != 'B' || get8(s) != 'M') {

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 42	 cmp	 eax, 66			; 00000042H
  0001a	75 11		 jne	 SHORT $LN3@stbi_bmp_i
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  00025	83 c4 04	 add	 esp, 4
  00028	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0002b	74 13		 je	 SHORT $LN2@stbi_bmp_i
$LN3@stbi_bmp_i:

; 4186 :        stbi_rewind( s );

  0002d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00036	83 c4 04	 add	 esp, 4

; 4187 :        return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 d4 00 00 00	 jmp	 $LN1@stbi_bmp_i
$LN2@stbi_bmp_i:

; 4188 :    }
; 4189 :    skip(s,12);

  00040	6a 0c		 push	 12			; 0000000cH
  00042	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  0004b	83 c4 08	 add	 esp, 8

; 4190 :    hsz = get32le(s);

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  00057	83 c4 04	 add	 esp, 4
  0005a	89 45 fc	 mov	 DWORD PTR _hsz$[ebp], eax

; 4191 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) {

  0005d	83 7d fc 0c	 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  00061	74 25		 je	 SHORT $LN4@stbi_bmp_i
  00063	83 7d fc 28	 cmp	 DWORD PTR _hsz$[ebp], 40 ; 00000028H
  00067	74 1f		 je	 SHORT $LN4@stbi_bmp_i
  00069	83 7d fc 38	 cmp	 DWORD PTR _hsz$[ebp], 56 ; 00000038H
  0006d	74 19		 je	 SHORT $LN4@stbi_bmp_i
  0006f	83 7d fc 6c	 cmp	 DWORD PTR _hsz$[ebp], 108 ; 0000006cH
  00073	74 13		 je	 SHORT $LN4@stbi_bmp_i

; 4192 :        stbi_rewind( s );

  00075	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  0007e	83 c4 04	 add	 esp, 4

; 4193 :        return 0;

  00081	33 c0		 xor	 eax, eax
  00083	e9 8c 00 00 00	 jmp	 $LN1@stbi_bmp_i
$LN4@stbi_bmp_i:

; 4194 :    }
; 4195 :    if (hsz == 12) {

  00088	83 7d fc 0c	 cmp	 DWORD PTR _hsz$[ebp], 12 ; 0000000cH
  0008c	75 24		 jne	 SHORT $LN5@stbi_bmp_i

; 4196 :       *x = get16le(s);

  0008e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  00097	83 c4 04	 add	 esp, 4
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0009d	89 01		 mov	 DWORD PTR [ecx], eax

; 4197 :       *y = get16le(s);

  0009f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000a8	83 c4 04	 add	 esp, 4
  000ab	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  000ae	89 01		 mov	 DWORD PTR [ecx], eax

; 4198 :    } else {

  000b0	eb 22		 jmp	 SHORT $LN6@stbi_bmp_i
$LN5@stbi_bmp_i:

; 4199 :       *x = get32le(s);

  000b2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  000bb	83 c4 04	 add	 esp, 4
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000c1	89 01		 mov	 DWORD PTR [ecx], eax

; 4200 :       *y = get32le(s);

  000c3	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?get32le@@YAIPAUstbi@@@Z ; get32le
  000cc	83 c4 04	 add	 esp, 4
  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  000d2	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@stbi_bmp_i:

; 4201 :    }
; 4202 :    if (get16le(s) != 1) {

  000d4	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000dd	83 c4 04	 add	 esp, 4
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	74 10		 je	 SHORT $LN7@stbi_bmp_i

; 4203 :        stbi_rewind( s );

  000e5	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000ee	83 c4 04	 add	 esp, 4

; 4204 :        return 0;

  000f1	33 c0		 xor	 eax, eax
  000f3	eb 1f		 jmp	 SHORT $LN1@stbi_bmp_i
$LN7@stbi_bmp_i:

; 4205 :    }
; 4206 :    *comp = get16le(s) / 8;

  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 ?get16le@@YAHPAUstbi@@@Z ; get16le
  000fe	83 c4 04	 add	 esp, 4
  00101	99		 cdq
  00102	83 e2 07	 and	 edx, 7
  00105	03 c2		 add	 eax, edx
  00107	c1 f8 03	 sar	 eax, 3
  0010a	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  0010d	89 02		 mov	 DWORD PTR [edx], eax

; 4207 :    return 1;

  0010f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_bmp_i:

; 4208 : }

  00114	83 c4 04	 add	 esp, 4
  00117	3b ec		 cmp	 ebp, esp
  00119	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?stbi_bmp_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_bmp_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_channelCount$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_psd_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_psd_info

; 4211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 4212 :    int channelCount;
; 4213 :    if (get32(s) != 0x38425053) {

  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00014	83 c4 04	 add	 esp, 4
  00017	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0001c	74 13		 je	 SHORT $LN2@stbi_psd_i

; 4214 :        stbi_rewind( s );

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00027	83 c4 04	 add	 esp, 4

; 4215 :        return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 cf 00 00 00	 jmp	 $LN1@stbi_psd_i
$LN2@stbi_psd_i:

; 4216 :    }
; 4217 :    if (get16(s) != 1) {

  00031	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0003a	83 c4 04	 add	 esp, 4
  0003d	83 f8 01	 cmp	 eax, 1
  00040	74 13		 je	 SHORT $LN3@stbi_psd_i

; 4218 :        stbi_rewind( s );

  00042	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  0004b	83 c4 04	 add	 esp, 4

; 4219 :        return 0;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 ab 00 00 00	 jmp	 $LN1@stbi_psd_i
$LN3@stbi_psd_i:

; 4220 :    }
; 4221 :    skip(s, 6);

  00055	6a 06		 push	 6
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00060	83 c4 08	 add	 esp, 8

; 4222 :    channelCount = get16(s);

  00063	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 45 fc	 mov	 DWORD PTR _channelCount$[ebp], eax

; 4223 :    if (channelCount < 0 || channelCount > 16) {

  00072	83 7d fc 00	 cmp	 DWORD PTR _channelCount$[ebp], 0
  00076	7c 06		 jl	 SHORT $LN5@stbi_psd_i
  00078	83 7d fc 10	 cmp	 DWORD PTR _channelCount$[ebp], 16 ; 00000010H
  0007c	7e 10		 jle	 SHORT $LN4@stbi_psd_i
$LN5@stbi_psd_i:

; 4224 :        stbi_rewind( s );

  0007e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00087	83 c4 04	 add	 esp, 4

; 4225 :        return 0;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 72		 jmp	 SHORT $LN1@stbi_psd_i
$LN4@stbi_psd_i:

; 4226 :    }
; 4227 :    *y = get32(s);

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  00097	83 c4 04	 add	 esp, 4
  0009a	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0009d	89 02		 mov	 DWORD PTR [edx], eax

; 4228 :    *x = get32(s);

  0009f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?get32@@YAIPAUstbi@@@Z	; get32
  000a8	83 c4 04	 add	 esp, 4
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000ae	89 01		 mov	 DWORD PTR [ecx], eax

; 4229 :    if (get16(s) != 8) {

  000b0	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000b9	83 c4 04	 add	 esp, 4
  000bc	83 f8 08	 cmp	 eax, 8
  000bf	74 10		 je	 SHORT $LN6@stbi_psd_i

; 4230 :        stbi_rewind( s );

  000c1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000ca	83 c4 04	 add	 esp, 4

; 4231 :        return 0;

  000cd	33 c0		 xor	 eax, eax
  000cf	eb 2f		 jmp	 SHORT $LN1@stbi_psd_i
$LN6@stbi_psd_i:

; 4232 :    }
; 4233 :    if (get16(s) != 3) {

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  000da	83 c4 04	 add	 esp, 4
  000dd	83 f8 03	 cmp	 eax, 3
  000e0	74 10		 je	 SHORT $LN7@stbi_psd_i

; 4234 :        stbi_rewind( s );

  000e2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  000eb	83 c4 04	 add	 esp, 4

; 4235 :        return 0;

  000ee	33 c0		 xor	 eax, eax
  000f0	eb 0e		 jmp	 SHORT $LN1@stbi_psd_i
$LN7@stbi_psd_i:

; 4236 :    }
; 4237 :    *comp = 4;

  000f2	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  000f5	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4

; 4238 :    return 1;

  000fb	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_psd_i:

; 4239 : }

  00100	83 c4 04	 add	 esp, 4
  00103	3b ec		 cmp	 ebp, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?stbi_psd_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_psd_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
tv140 = -64						; size = 4
_packet$1 = -60						; size = 4
_packets$ = -52						; size = 30
_chained$ = -16						; size = 4
_num_packets$ = -12					; size = 4
_act_comp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_pic_info@@YAHPAUstbi@@PAH11@Z PROC		; stbi_pic_info

; 4242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	57		 push	 edi
  00007	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0000a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4243 :    int act_comp=0,num_packets=0,chained;

  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _act_comp$[ebp], 0
  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _num_packets$[ebp], 0

; 4244 :    pic_packet_t packets[10];
; 4245 : 
; 4246 :    skip(s, 92);

  0002e	6a 5c		 push	 92			; 0000005cH
  00030	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  00039	83 c4 08	 add	 esp, 8

; 4247 : 
; 4248 :    *x = get16(s);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00045	83 c4 04	 add	 esp, 4
  00048	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0004b	89 02		 mov	 DWORD PTR [edx], eax

; 4249 :    *y = get16(s);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?get16@@YAHPAUstbi@@@Z	; get16
  00056	83 c4 04	 add	 esp, 4
  00059	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax

; 4250 :    if (at_eof(s))  return 0;

  0005e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	74 07		 je	 SHORT $LN5@stbi_pic_i
  0006e	33 c0		 xor	 eax, eax
  00070	e9 17 01 00 00	 jmp	 $LN1@stbi_pic_i
$LN5@stbi_pic_i:

; 4251 :    if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {

  00075	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00078	83 38 00	 cmp	 DWORD PTR [eax], 0
  0007b	74 25		 je	 SHORT $LN6@stbi_pic_i
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00080	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  00085	99		 cdq
  00086	f7 39		 idiv	 DWORD PTR [ecx]
  00088	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0008b	3b 02		 cmp	 eax, DWORD PTR [edx]
  0008d	7d 13		 jge	 SHORT $LN6@stbi_pic_i

; 4252 :        stbi_rewind( s );

  0008f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00098	83 c4 04	 add	 esp, 4

; 4253 :        return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 ea 00 00 00	 jmp	 $LN1@stbi_pic_i
$LN6@stbi_pic_i:

; 4254 :    }
; 4255 : 
; 4256 :    skip(s, 8);

  000a2	6a 08		 push	 8
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ?skip@@YAXPAUstbi@@H@Z	; skip
  000ad	83 c4 08	 add	 esp, 8
$LN4@stbi_pic_i:

; 4257 : 
; 4258 :    do {
; 4259 :       pic_packet_t *packet;
; 4260 : 
; 4261 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))

  000b0	83 7d f4 0a	 cmp	 DWORD PTR _num_packets$[ebp], 10 ; 0000000aH
  000b4	75 07		 jne	 SHORT $LN7@stbi_pic_i

; 4262 :          return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 cf 00 00 00	 jmp	 $LN1@stbi_pic_i
$LN7@stbi_pic_i:

; 4263 : 
; 4264 :       packet = &packets[num_packets++];

  000bd	6b 55 f4 03	 imul	 edx, DWORD PTR _num_packets$[ebp], 3
  000c1	8d 44 15 cc	 lea	 eax, DWORD PTR _packets$[ebp+edx]
  000c5	89 45 c4	 mov	 DWORD PTR _packet$1[ebp], eax
  000c8	8b 4d f4	 mov	 ecx, DWORD PTR _num_packets$[ebp]
  000cb	83 c1 01	 add	 ecx, 1
  000ce	89 4d f4	 mov	 DWORD PTR _num_packets$[ebp], ecx

; 4265 :       chained = get8(s);

  000d1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?get8@@YAHPAUstbi@@@Z	; get8
  000da	83 c4 04	 add	 esp, 4
  000dd	89 45 f0	 mov	 DWORD PTR _chained$[ebp], eax

; 4266 :       packet->size    = get8u(s);

  000e0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000e9	83 c4 04	 add	 esp, 4
  000ec	8b 4d c4	 mov	 ecx, DWORD PTR _packet$1[ebp]
  000ef	88 01		 mov	 BYTE PTR [ecx], al

; 4267 :       packet->type    = get8u(s);

  000f1	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  000fa	83 c4 04	 add	 esp, 4
  000fd	8b 4d c4	 mov	 ecx, DWORD PTR _packet$1[ebp]
  00100	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 4268 :       packet->channel = get8u(s);

  00103	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 ?get8u@@YAEPAUstbi@@@Z	; get8u
  0010c	83 c4 04	 add	 esp, 4
  0010f	8b 4d c4	 mov	 ecx, DWORD PTR _packet$1[ebp]
  00112	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 4269 :       act_comp |= packet->channel;

  00115	8b 55 c4	 mov	 edx, DWORD PTR _packet$1[ebp]
  00118	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0011c	0b 45 f8	 or	 eax, DWORD PTR _act_comp$[ebp]
  0011f	89 45 f8	 mov	 DWORD PTR _act_comp$[ebp], eax

; 4270 : 
; 4271 :       if (at_eof(s)) {

  00122	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ?at_eof@@YAHPAUstbi@@@Z	; at_eof
  0012b	83 c4 04	 add	 esp, 4
  0012e	85 c0		 test	 eax, eax
  00130	74 10		 je	 SHORT $LN8@stbi_pic_i

; 4272 :           stbi_rewind( s );

  00132	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  0013b	83 c4 04	 add	 esp, 4

; 4273 :           return 0;

  0013e	33 c0		 xor	 eax, eax
  00140	eb 4a		 jmp	 SHORT $LN1@stbi_pic_i
$LN8@stbi_pic_i:

; 4274 :       }
; 4275 :       if (packet->size != 8) {

  00142	8b 45 c4	 mov	 eax, DWORD PTR _packet$1[ebp]
  00145	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00148	83 f9 08	 cmp	 ecx, 8
  0014b	74 10		 je	 SHORT $LN2@stbi_pic_i

; 4276 :           stbi_rewind( s );

  0014d	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 ?stbi_rewind@@YAXPAUstbi@@@Z ; stbi_rewind
  00156	83 c4 04	 add	 esp, 4

; 4277 :           return 0;

  00159	33 c0		 xor	 eax, eax
  0015b	eb 2f		 jmp	 SHORT $LN1@stbi_pic_i
$LN2@stbi_pic_i:

; 4278 :       }
; 4279 :    } while (chained);

  0015d	83 7d f0 00	 cmp	 DWORD PTR _chained$[ebp], 0
  00161	0f 85 49 ff ff
	ff		 jne	 $LN4@stbi_pic_i

; 4280 : 
; 4281 :    *comp = (act_comp & 0x10 ? 4 : 3);

  00167	8b 45 f8	 mov	 eax, DWORD PTR _act_comp$[ebp]
  0016a	83 e0 10	 and	 eax, 16			; 00000010H
  0016d	74 09		 je	 SHORT $LN11@stbi_pic_i
  0016f	c7 45 c0 04 00
	00 00		 mov	 DWORD PTR tv140[ebp], 4
  00176	eb 07		 jmp	 SHORT $LN12@stbi_pic_i
$LN11@stbi_pic_i:
  00178	c7 45 c0 03 00
	00 00		 mov	 DWORD PTR tv140[ebp], 3
$LN12@stbi_pic_i:
  0017f	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00182	8b 55 c0	 mov	 edx, DWORD PTR tv140[ebp]
  00185	89 11		 mov	 DWORD PTR [ecx], edx

; 4282 : 
; 4283 :    return 1;

  00187	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi_pic_i:

; 4284 : }

  0018c	52		 push	 edx
  0018d	8b cd		 mov	 ecx, ebp
  0018f	50		 push	 eax
  00190	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@stbi_pic_i
  00196	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0019b	58		 pop	 eax
  0019c	5a		 pop	 edx
  0019d	5f		 pop	 edi
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	83 c4 40	 add	 esp, 64			; 00000040H
  001ab	3b ec		 cmp	 ebp, esp
  001ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c3		 ret	 0
  001b6	66 90		 npad	 2
$LN15@stbi_pic_i:
  001b8	01 00 00 00	 DD	 1
  001bc	00 00 00 00	 DD	 $LN14@stbi_pic_i
$LN14@stbi_pic_i:
  001c0	cc ff ff ff	 DD	 -52			; ffffffccH
  001c4	1e 00 00 00	 DD	 30			; 0000001eH
  001c8	00 00 00 00	 DD	 $LN13@stbi_pic_i
$LN13@stbi_pic_i:
  001cc	70		 DB	 112			; 00000070H
  001cd	61		 DB	 97			; 00000061H
  001ce	63		 DB	 99			; 00000063H
  001cf	6b		 DB	 107			; 0000006bH
  001d0	65		 DB	 101			; 00000065H
  001d1	74		 DB	 116			; 00000074H
  001d2	73		 DB	 115			; 00000073H
  001d3	00		 DB	 0
?stbi_pic_info@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_pic_info
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
?stbi_info_main@@YAHPAUstbi@@PAH11@Z PROC		; stbi_info_main

; 4287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4288 :    if (stbi_jpeg_info(s, x, y, comp))

  00003	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?stbi_jpeg_info@@YAHPAUstbi@@PAH11@Z ; stbi_jpeg_info
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	85 c0		 test	 eax, eax
  0001d	74 0a		 je	 SHORT $LN2@stbi_info_

; 4289 :        return 1;

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	e9 0b 01 00 00	 jmp	 $LN1@stbi_info_
$LN2@stbi_info_:

; 4290 :    if (stbi_png_info(s, x, y, comp))

  00029	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00030	52		 push	 edx
  00031	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?stbi_png_info@@YAHPAUstbi@@PAH11@Z ; stbi_png_info
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	85 c0		 test	 eax, eax
  00043	74 0a		 je	 SHORT $LN3@stbi_info_

; 4291 :        return 1;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	e9 e5 00 00 00	 jmp	 $LN1@stbi_info_
$LN3@stbi_info_:

; 4292 :    if (stbi_gif_info(s, x, y, comp))

  0004f	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  00052	52		 push	 edx
  00053	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?stbi_gif_info@@YAHPAUstbi@@PAH11@Z ; stbi_gif_info
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN4@stbi_info_

; 4293 :        return 1;

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	e9 bf 00 00 00	 jmp	 $LN1@stbi_info_
$LN4@stbi_info_:

; 4294 :    if (stbi_bmp_info(s, x, y, comp))

  00075	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00080	52		 push	 edx
  00081	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?stbi_bmp_info@@YAHPAUstbi@@PAH11@Z ; stbi_bmp_info
  0008a	83 c4 10	 add	 esp, 16			; 00000010H
  0008d	85 c0		 test	 eax, eax
  0008f	74 0a		 je	 SHORT $LN5@stbi_info_

; 4295 :        return 1;

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	e9 99 00 00 00	 jmp	 $LN1@stbi_info_
$LN5@stbi_info_:

; 4296 :    if (stbi_psd_info(s, x, y, comp))

  0009b	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ?stbi_psd_info@@YAHPAUstbi@@PAH11@Z ; stbi_psd_info
  000b0	83 c4 10	 add	 esp, 16			; 00000010H
  000b3	85 c0		 test	 eax, eax
  000b5	74 07		 je	 SHORT $LN6@stbi_info_

; 4297 :        return 1;

  000b7	b8 01 00 00 00	 mov	 eax, 1
  000bc	eb 76		 jmp	 SHORT $LN1@stbi_info_
$LN6@stbi_info_:

; 4298 :    if (stbi_pic_info(s, x, y, comp))

  000be	8b 55 14	 mov	 edx, DWORD PTR _comp$[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 ?stbi_pic_info@@YAHPAUstbi@@PAH11@Z ; stbi_pic_info
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
  000d6	85 c0		 test	 eax, eax
  000d8	74 07		 je	 SHORT $LN7@stbi_info_

; 4299 :        return 1;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	eb 53		 jmp	 SHORT $LN1@stbi_info_
$LN7@stbi_info_:

; 4300 :    #ifndef STBI_NO_HDR
; 4301 :    if (stbi_hdr_info(s, x, y, comp))

  000e1	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  000ec	52		 push	 edx
  000ed	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?stbi_hdr_info@@YAHPAUstbi@@PAH11@Z ; stbi_hdr_info
  000f6	83 c4 10	 add	 esp, 16			; 00000010H
  000f9	85 c0		 test	 eax, eax
  000fb	74 07		 je	 SHORT $LN8@stbi_info_

; 4302 :        return 1;

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	eb 30		 jmp	 SHORT $LN1@stbi_info_
$LN8@stbi_info_:

; 4303 :    #endif
; 4304 :    // test tga last because it's a crappy test!
; 4305 :    if (stbi_tga_info(s, x, y, comp))

  00104	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0010b	52		 push	 edx
  0010c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?stbi_tga_info@@YAHPAUstbi@@PAH11@Z ; stbi_tga_info
  00119	83 c4 10	 add	 esp, 16			; 00000010H
  0011c	85 c0		 test	 eax, eax
  0011e	74 07		 je	 SHORT $LN9@stbi_info_

; 4306 :        return 1;

  00120	b8 01 00 00 00	 mov	 eax, 1
  00125	eb 0d		 jmp	 SHORT $LN1@stbi_info_
$LN9@stbi_info_:

; 4307 :    return e("unknown image type", "Image not of any known type, or corrupt");

  00127	68 00 00 00 00	 push	 OFFSET $SG4294820097
  0012c	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00131	83 c4 04	 add	 esp, 4
$LN1@stbi_info_:

; 4308 : }

  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?stbi_info_main@@YAHPAUstbi@@PAH11@Z ENDP		; stbi_info_main
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_result$ = -8						; size = 4
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info PROC

; 4312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 4313 :     FILE *f = fopen(filename, "rb");

  00015	8b f4		 mov	 esi, esp
  00017	68 00 00 00 00	 push	 OFFSET $SG4294820096
  0001c	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 4314 :     int result;
; 4315 :     if (!f) return e("can't fopen", "Unable to open file");

  00033	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  00037	75 0f		 jne	 SHORT $LN2@stbi_info
  00039	68 00 00 00 00	 push	 OFFSET $SG4294820095
  0003e	e8 00 00 00 00	 call	 ?e@@YAHPBD@Z		; e
  00043	83 c4 04	 add	 esp, 4
  00046	eb 34		 jmp	 SHORT $LN1@stbi_info
$LN2@stbi_info:

; 4316 :     result = stbi_info_from_file(f, x, y, comp);

  00048	8b 4d 14	 mov	 ecx, DWORD PTR _comp$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _f$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _stbi_info_from_file
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
  00060	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 4317 :     fclose(f);

  00063	8b f4		 mov	 esi, esp
  00065	8b 55 fc	 mov	 edx, DWORD PTR _f$[ebp]
  00068	52		 push	 edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4318 :     return result;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@stbi_info:

; 4319 : }

  0007c	5e		 pop	 esi
  0007d	83 c4 08	 add	 esp, 8
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_pos$ = -200						; size = 4
_s$ = -192						; size = 180
_r$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_comp$ = 20						; size = 4
_stbi_info_from_file PROC

; 4322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00011	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4323 :    int r;
; 4324 :    stbi s;
; 4325 :    long pos = ftell(f);

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 85 38 ff ff
	ff		 mov	 DWORD PTR _pos$[ebp], eax

; 4326 :    start_file(&s, f);

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  00046	51		 push	 ecx
  00047	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?start_file@@YAXPAUstbi@@PAU_iobuf@@@Z ; start_file
  00053	83 c4 08	 add	 esp, 8

; 4327 :    r = stbi_info_main(&s,x,y,comp);

  00056	8b 45 14	 mov	 eax, DWORD PTR _comp$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00061	52		 push	 edx
  00062	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?stbi_info_main@@YAHPAUstbi@@PAH11@Z ; stbi_info_main
  0006e	83 c4 10	 add	 esp, 16			; 00000010H
  00071	89 45 f8	 mov	 DWORD PTR _r$[ebp], eax

; 4328 :    fseek(f,pos,SEEK_SET);

  00074	8b f4		 mov	 esi, esp
  00076	6a 00		 push	 0
  00078	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00082	52		 push	 edx
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4329 :    return r;

  00093	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]

; 4330 : }

  00096	52		 push	 edx
  00097	8b cd		 mov	 ecx, ebp
  00099	50		 push	 eax
  0009a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_info_
  000a0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a5	58		 pop	 eax
  000a6	5a		 pop	 edx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ac	33 cd		 xor	 ecx, ebp
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN5@stbi_info_:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN4@stbi_info_
$LN4@stbi_info_:
  000cc	40 ff ff ff	 DD	 -192			; ffffff40H
  000d0	b4 00 00 00	 DD	 180			; 000000b4H
  000d4	00 00 00 00	 DD	 $LN3@stbi_info_
$LN3@stbi_info_:
  000d8	73		 DB	 115			; 00000073H
  000d9	00		 DB	 0
_stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_memory PROC

; 4334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4335 :    stbi s;
; 4336 :    start_mem(&s,buffer,len);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_mem@@YAXPAUstbi@@PBEH@Z ; start_mem
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4337 :    return stbi_info_main(&s,x,y,comp);

  0003d	8b 45 18	 mov	 eax, DWORD PTR _comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  00048	52		 push	 edx
  00049	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?stbi_info_main@@YAHPAUstbi@@PAH11@Z ; stbi_info_main
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 4338 : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_info_
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@stbi_info_:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@stbi_info_
$LN4@stbi_info_:
  00090	44 ff ff ff	 DD	 -188			; ffffff44H
  00094	b4 00 00 00	 DD	 180			; 000000b4H
  00098	00 00 00 00	 DD	 $LN3@stbi_info_
$LN3@stbi_info_:
  0009c	73		 DB	 115			; 00000073H
  0009d	00		 DB	 0
_stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\fusion3d_work\engine\src\staticlibs\stb_image.c
_TEXT	SEGMENT
_s$ = -188						; size = 180
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_user$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_comp$ = 24						; size = 4
_stbi_info_from_callbacks PROC

; 4341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	57		 push	 edi
  0000a	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00010	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4342 :    stbi s;
; 4343 :    start_callbacks(&s, (stbi_io_callbacks *) c, user);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _user$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ?start_callbacks@@YAXPAUstbi@@PAUstbi_io_callbacks@@PAX@Z ; start_callbacks
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4344 :    return stbi_info_main(&s,x,y,comp);

  0003d	8b 45 18	 mov	 eax, DWORD PTR _comp$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  00048	52		 push	 edx
  00049	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?stbi_info_main@@YAHPAUstbi@@PAH11@Z ; stbi_info_main
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 4345 : }

  00058	52		 push	 edx
  00059	8b cd		 mov	 ecx, ebp
  0005b	50		 push	 eax
  0005c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@stbi_info_
  00062	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00067	58		 pop	 eax
  00068	5a		 pop	 edx
  00069	5f		 pop	 edi
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
  00085	0f 1f 00	 npad	 3
$LN5@stbi_info_:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@stbi_info_
$LN4@stbi_info_:
  00090	44 ff ff ff	 DD	 -188			; ffffff44H
  00094	b4 00 00 00	 DD	 180			; 000000b4H
  00098	00 00 00 00	 DD	 $LN3@stbi_info_
$LN3@stbi_info_:
  0009c	73		 DB	 115			; 00000073H
  0009d	00		 DB	 0
_stbi_info_from_callbacks ENDP
_TEXT	ENDS
END
